(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

var _core = require("@loaders.gl/core");

var _csv = require("@loaders.gl/csv");

var _nanohtml = _interopRequireDefault(require("nanohtml"));

var _templateObject, _templateObject2, _templateObject3;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

/*
* To do:
* - how to update tooltip when date is updated? 
* - definition file for datasets
* - make dataset files that only contain values, not geoid
* - implement start date and end date
* - add sample data for timeseries
* - loading spinner while data is loading
* - show selected elements as separate array
* 
* assumptions: geo id in tileset refers to data order (?)
* are there datasets that only exist at certain geolevels?
* https://deck.gl/docs/api-reference/geo-layers/mvt-layer
*/
var _deck = deck,
    DeckGL = _deck.DeckGL,
    MVTLayer = _deck.MVTLayer; //import { csv } from 'd3'

var viz;
var geoRegion;
var dataset = 'mobility';
var baseURL = window.location.href.replace('/example-data-loading/', '');
var datasetPath = "/sample-data/datasets/";
var tilesetPath = "/sample-data/tilesets/"; // sets of vector tilesets representing different geo-regions

var tilesets = [{
  label: 'gemeinden',
  // 
  id: 'gemeinden',
  // 
  url: 'gemeinden',
  numEntries: 11431
}, {
  label: 'kreise',
  id: 'kreise',
  url: 'kreise',
  numEntries: 432
}, {
  label: 'laender',
  id: 'laender',
  url: 'laender',
  numEntries: 34
}];
var datasets = [{
  label: 'Mobility by Date',
  id: 'mobility',
  url: '',
  startDate: '2021-05-23',
  endDate: '2021-08-30',
  tilesets: ['laendergeo', 'kreisegeo', 'gemeindengeo']
}];
tilesets.forEach(function (tileset, i) {
  var URL = "".concat(baseURL).concat(tilesetPath).concat(tileset.url, "/{z}/{x}/{y}.pbf?").concat(Date.now()); // @TODO: remove date now, only for resetting browser cache in dev version

  tileset.tiles = [URL];
  tileset.visibile = false;
  tileset.mobility = new Array(tileset.numEntries).fill(0).map(function (_, i) {
    return Math.random();
  });
});
var numDates = 100;
var currentDateIndex = 0;
selectGeoLevel('gemeinden'); //geoRegion = tilesets[0]

console.log('base url', tilesets, geoRegion);
var footer = (0, _nanohtml["default"])(_templateObject || (_templateObject = _taggedTemplateLiteral(["<div style=\"position:absolute;bottom:0px;right:0px;width:100%\"></div>"])));

var generateDate = function generateDate() {
  var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'hi';
  return "<div style=\"font-size:4rem;color:white;background:rgba(0, 0, 0, 0.4)\">".concat(date, "</div>");
};

var dateEl = document.createElement('div');
var geoSelect = (0, _nanohtml["default"])(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["<label for=\"geolevel\">Select map geo level</label>\n<select label=\"geolevel\" onchange=", " id=\"geolevel\">\n ", "\n</select>"])), function (e) {
  selectGeoLevel(e.target.value);
}, tilesets.map(function (tileset) {
  return (0, _nanohtml["default"])(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["<option value=\"", "\" ", ">", "</option>"])), tileset.id, tileset.id === geoRegion.id ? 'selected' : '', tileset.label);
}));
footer.appendChild(geoSelect);
footer.appendChild(dateEl); // optimizations for this: load directly as an array and do not parse into objects
// store already loaded data in some way and only load new data as necessary
// read more about deckgl / webgl performance
// show loading animation while loading

function getData() {
  return _getData.apply(this, arguments);
}

function _getData() {
  _getData = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
    var d, dateStr, newData;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            currentDateIndex++;
            if (currentDateIndex > numDates) currentDateIndex = 0;
            d = new Date();
            d.setDate(-numDates + currentDateIndex);
            dateStr = d.toLocaleDateString('en-CA'); //date.format(d, 'YYYY-MM-DD')

            dateEl.innerHTML = generateDate(dateStr);
            _context.next = 8;
            return (0, _core.load)("".concat(baseURL).concat(datasetPath).concat(dataset, "/").concat(geoRegion.id, "/values-by-date/").concat(dateStr, ".csv"), _csv.CSVLoader);

          case 8:
            newData = _context.sent;
            // console.log('loaded', newData, geoRegion)
            geoRegion.mobility = geoRegion.mobility.map(function (_, i) {
              return newData[i].mobility;
            }); //gemeinden: new Array(11431).fill(0).map((_, i) => Math.random()),
            //kreise: new Array(432).fill(0).map((_, i) => Math.random())

            render();

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _getData.apply(this, arguments);
}

getData();

function selectGeoLevel(id) {
  tilesets.forEach(function (tileset) {
    if (tileset.id === id) {
      tileset.visible = true;
      geoRegion = tileset;
    } else {
      tileset.visible = false;
    }
  });
}

function render() {
  // console.log(tilesets, 'tilesets')
  var layers = tilesets.map(function (tileset) {
    return new MVTLayer({
      // id: tileset.id,
      id: tileset.id,
      data: tileset.tiles,
      pickable: tileset.visible,
      getFillColor: function getFillColor(obj) {
        //console.log('getting mobility at', obj.id, tileset.mobility)
        var j = tileset.mobility[obj.id];
        return [j * 255, j * 255, j * 255]; //return [Math.random() * 255, Math.random() * 255, Math.random() * 255]
      },
      getLineWidth: 4,
      transitions: {
        getFillColor: 100
      },
      updateTriggers: {
        // if currentDateIndex changes, recompute getFillColor for each point
        getFillColor: [currentDateIndex]
      },
      visible: tileset.visible,
      lineWidthMinPixels: 0,
      maxZoom: 13,
      minZoom: 0
    });
  });
  viz.setProps({
    layers: layers
  });
}

viz = new DeckGL({
  initialViewState: {
    // longitude: -122.4,
    latitude: 51.66403781658121,
    longitude: 10.6460952758789,
    // latitude: 37.74,
    // longitude: 13.765869,
    //13.765869,54.117382
    zoom: 6,
    maxZoom: 20,
    pitch: 30,
    bearing: 0
  },
  controller: true,
  useDevicePixels: false,
  getTooltip: function getTooltip(_ref) {
    var object = _ref.object;

    if (object) {
      console.log(object.id, object.properties, object.properties.AGS);
      return "".concat(object.properties.GEN, " ").concat(object.properties.AGS, " mobility ").concat(geoRegion.mobility[object.id]);
    }

    return null;
  } //layers: [layer]

});
setInterval(function () {
  //  console.log(shouldUpdate)
  // fakeData.laender = fakeData.laender.map((_, i) => Math.random())
  // fakeData.kreise = fakeData.kreise.map((_, i) => Math.random())
  //fakeData[geoRegion] = fakeData[geoRegion].map((_, i) => Math.random())
  //gemeinden: new Array(11431).fill(0).map((_, i) => Math.random()),
  //kreise: new Array(432).fill(0).map((_, i) => Math.random())
  //render()
  getData(); // shouldUpdate ++
}, 2000);
document.body.appendChild(footer); //   const tileURL = `${window.location.origin}/gemeinden-z7-uncompressed/{z}/{x}/{y}.pbf`
// const DATA = [
//     tileURL
//     //'https://tiles-a.basemaps.cartocdn.com/vectortiles/carto.streets/v1/{z}/{x}/{y}.mvt'
//   ]
// function render () {
// const gemeinden = new MVTLayer({
//   id: 'gemeindengeo',
//   data: DATA,
//   pickable: true,
//   getFillColor: () => {
//    // console.log(shouldUpdate)
//    return [Math.random() * 255, Math.random() * 255, Math.random() * 255]
//   },
//   getLineColor: () => [Math.random() * 255, Math.random() * 255, Math.random() * 255],
//   getLineWidth: 4,
//   transitions: {
//     getFillColor: 100,
//   },
//   updateTriggers: {
//     // if showLibraries changes, recompute getFillColor for each point
//     getFillColor: [shouldUpdate]
//   },
//   lineWidthMinPixels: 1,
//   /* props from MVTLayer class */
//   // binary: false,
//   // highlightedFeatureId: null,
//   // loaders: ,
//   // uniqueIdProperty: '',
//   /* props inherited from TileLayer class */
//   // extent: null,
//   // getTileData: null,
//   // maxCacheByteSize: null,
//   // maxCacheSize: null,
//   // maxRequests: 6,
//   maxZoom: 13,
//   minZoom: 7,
//   // onTileError: null,
//   // onTileLoad: null,
//   // onTileUnload: null,
//   // onViewportLoad: null,
//   // refinementStrategy: 'best-available',
//   // renderSubLayers: null,
//   // tileSize: 512,
//   // zRange: null,
//   /* props inherited from Layer class */
//   // autoHighlight: false,
//   // coordinateOrigin: [0, 0, 0],
//   // coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
//   // highlightColor: [0, 0, 128, 128],
//   // modelMatrix: null,
//   // opacity: 1,
//   // pickable: false,
//   // visible: true,
//   // wrapLongitude: false,
// });

},{"@loaders.gl/core":34,"@loaders.gl/csv":70,"nanohtml":135}],2:[function(require,module,exports){
var AwaitValue = require("./AwaitValue.js");

function AsyncGenerator(gen) {
  var front, back;

  function send(key, arg) {
    return new Promise(function (resolve, reject) {
      var request = {
        key: key,
        arg: arg,
        resolve: resolve,
        reject: reject,
        next: null
      };

      if (back) {
        back = back.next = request;
      } else {
        front = back = request;
        resume(key, arg);
      }
    });
  }

  function resume(key, arg) {
    try {
      var result = gen[key](arg);
      var value = result.value;
      var wrappedAwait = value instanceof AwaitValue;
      Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {
        if (wrappedAwait) {
          resume(key === "return" ? "return" : "next", arg);
          return;
        }

        settle(result.done ? "return" : "normal", arg);
      }, function (err) {
        resume("throw", err);
      });
    } catch (err) {
      settle("throw", err);
    }
  }

  function settle(type, value) {
    switch (type) {
      case "return":
        front.resolve({
          value: value,
          done: true
        });
        break;

      case "throw":
        front.reject(value);
        break;

      default:
        front.resolve({
          value: value,
          done: false
        });
        break;
    }

    front = front.next;

    if (front) {
      resume(front.key, front.arg);
    } else {
      back = null;
    }
  }

  this._invoke = send;

  if (typeof gen["return"] !== "function") {
    this["return"] = undefined;
  }
}

AsyncGenerator.prototype[typeof Symbol === "function" && Symbol.asyncIterator || "@@asyncIterator"] = function () {
  return this;
};

AsyncGenerator.prototype.next = function (arg) {
  return this._invoke("next", arg);
};

AsyncGenerator.prototype["throw"] = function (arg) {
  return this._invoke("throw", arg);
};

AsyncGenerator.prototype["return"] = function (arg) {
  return this._invoke("return", arg);
};

module.exports = AsyncGenerator;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./AwaitValue.js":3}],3:[function(require,module,exports){
function _AwaitValue(value) {
  this.wrapped = value;
}

module.exports = _AwaitValue;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],4:[function(require,module,exports){
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],5:[function(require,module,exports){
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],6:[function(require,module,exports){
var arrayLikeToArray = require("./arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./arrayLikeToArray.js":4}],7:[function(require,module,exports){
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],8:[function(require,module,exports){
function _asyncGeneratorDelegate(inner, awaitWrap) {
  var iter = {},
      waiting = false;

  function pump(key, value) {
    waiting = true;
    value = new Promise(function (resolve) {
      resolve(inner[key](value));
    });
    return {
      done: false,
      value: awaitWrap(value)
    };
  }

  ;

  iter[typeof Symbol !== "undefined" && Symbol.iterator || "@@iterator"] = function () {
    return this;
  };

  iter.next = function (value) {
    if (waiting) {
      waiting = false;
      return value;
    }

    return pump("next", value);
  };

  if (typeof inner["throw"] === "function") {
    iter["throw"] = function (value) {
      if (waiting) {
        waiting = false;
        throw value;
      }

      return pump("throw", value);
    };
  }

  if (typeof inner["return"] === "function") {
    iter["return"] = function (value) {
      if (waiting) {
        waiting = false;
        return value;
      }

      return pump("return", value);
    };
  }

  return iter;
}

module.exports = _asyncGeneratorDelegate;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],9:[function(require,module,exports){
function _asyncIterator(iterable) {
  var method;

  if (typeof Symbol !== "undefined") {
    if (Symbol.asyncIterator) method = iterable[Symbol.asyncIterator];
    if (method == null && Symbol.iterator) method = iterable[Symbol.iterator];
  }

  if (method == null) method = iterable["@@asyncIterator"];
  if (method == null) method = iterable["@@iterator"];
  if (method == null) throw new TypeError("Object is not async iterable");
  return method.call(iterable);
}

module.exports = _asyncIterator;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],10:[function(require,module,exports){
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],11:[function(require,module,exports){
var AwaitValue = require("./AwaitValue.js");

function _awaitAsyncGenerator(value) {
  return new AwaitValue(value);
}

module.exports = _awaitAsyncGenerator;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./AwaitValue.js":3}],12:[function(require,module,exports){
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],13:[function(require,module,exports){
var setPrototypeOf = require("./setPrototypeOf.js");

var isNativeReflectConstruct = require("./isNativeReflectConstruct.js");

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./isNativeReflectConstruct.js":20,"./setPrototypeOf.js":26}],14:[function(require,module,exports){
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],15:[function(require,module,exports){
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],16:[function(require,module,exports){
function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],17:[function(require,module,exports){
var setPrototypeOf = require("./setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./setPrototypeOf.js":26}],18:[function(require,module,exports){
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],19:[function(require,module,exports){
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

module.exports = _isNativeFunction;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],20:[function(require,module,exports){
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = _isNativeReflectConstruct;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],21:[function(require,module,exports){
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

module.exports = _iterableToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],22:[function(require,module,exports){
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],23:[function(require,module,exports){
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],24:[function(require,module,exports){
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],25:[function(require,module,exports){
var _typeof = require("@babel/runtime/helpers/typeof")["default"];

var assertThisInitialized = require("./assertThisInitialized.js");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./assertThisInitialized.js":7,"@babel/runtime/helpers/typeof":29}],26:[function(require,module,exports){
function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],27:[function(require,module,exports){
var arrayWithHoles = require("./arrayWithHoles.js");

var iterableToArrayLimit = require("./iterableToArrayLimit.js");

var unsupportedIterableToArray = require("./unsupportedIterableToArray.js");

var nonIterableRest = require("./nonIterableRest.js");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./arrayWithHoles.js":5,"./iterableToArrayLimit.js":22,"./nonIterableRest.js":23,"./unsupportedIterableToArray.js":30}],28:[function(require,module,exports){
var arrayWithoutHoles = require("./arrayWithoutHoles.js");

var iterableToArray = require("./iterableToArray.js");

var unsupportedIterableToArray = require("./unsupportedIterableToArray.js");

var nonIterableSpread = require("./nonIterableSpread.js");

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./arrayWithoutHoles.js":6,"./iterableToArray.js":21,"./nonIterableSpread.js":24,"./unsupportedIterableToArray.js":30}],29:[function(require,module,exports){
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _typeof(obj);
}

module.exports = _typeof;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],30:[function(require,module,exports){
var arrayLikeToArray = require("./arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./arrayLikeToArray.js":4}],31:[function(require,module,exports){
var AsyncGenerator = require("./AsyncGenerator.js");

function _wrapAsyncGenerator(fn) {
  return function () {
    return new AsyncGenerator(fn.apply(this, arguments));
  };
}

module.exports = _wrapAsyncGenerator;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./AsyncGenerator.js":2}],32:[function(require,module,exports){
var getPrototypeOf = require("./getPrototypeOf.js");

var setPrototypeOf = require("./setPrototypeOf.js");

var isNativeFunction = require("./isNativeFunction.js");

var construct = require("./construct.js");

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return construct(Class, arguments, getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return setPrototypeOf(Wrapper, Class);
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _wrapNativeSuper(Class);
}

module.exports = _wrapNativeSuper;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./construct.js":13,"./getPrototypeOf.js":16,"./isNativeFunction.js":19,"./setPrototypeOf.js":26}],33:[function(require,module,exports){
module.exports = require("regenerator-runtime");

},{"regenerator-runtime":154}],34:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "fetchFile", {
  enumerable: true,
  get: function get() {
    return _fetchFile.fetchFile;
  }
});
Object.defineProperty(exports, "readArrayBuffer", {
  enumerable: true,
  get: function get() {
    return _readArrayBuffer.readArrayBuffer;
  }
});
Object.defineProperty(exports, "readFileSync", {
  enumerable: true,
  get: function get() {
    return _readFile.readFileSync;
  }
});
Object.defineProperty(exports, "writeFile", {
  enumerable: true,
  get: function get() {
    return _writeFile.writeFile;
  }
});
Object.defineProperty(exports, "writeFileSync", {
  enumerable: true,
  get: function get() {
    return _writeFile.writeFileSync;
  }
});
Object.defineProperty(exports, "setLoaderOptions", {
  enumerable: true,
  get: function get() {
    return _setLoaderOptions.setLoaderOptions;
  }
});
Object.defineProperty(exports, "registerLoaders", {
  enumerable: true,
  get: function get() {
    return _registerLoaders.registerLoaders;
  }
});
Object.defineProperty(exports, "_unregisterLoaders", {
  enumerable: true,
  get: function get() {
    return _registerLoaders._unregisterLoaders;
  }
});
Object.defineProperty(exports, "selectLoader", {
  enumerable: true,
  get: function get() {
    return _selectLoader.selectLoader;
  }
});
Object.defineProperty(exports, "selectLoaderSync", {
  enumerable: true,
  get: function get() {
    return _selectLoader.selectLoaderSync;
  }
});
Object.defineProperty(exports, "parse", {
  enumerable: true,
  get: function get() {
    return _parse.parse;
  }
});
Object.defineProperty(exports, "parseSync", {
  enumerable: true,
  get: function get() {
    return _parseSync.parseSync;
  }
});
Object.defineProperty(exports, "parseInBatches", {
  enumerable: true,
  get: function get() {
    return _parseInBatches.parseInBatches;
  }
});
Object.defineProperty(exports, "load", {
  enumerable: true,
  get: function get() {
    return _load.load;
  }
});
Object.defineProperty(exports, "loadInBatches", {
  enumerable: true,
  get: function get() {
    return _loadInBatches.loadInBatches;
  }
});
Object.defineProperty(exports, "encode", {
  enumerable: true,
  get: function get() {
    return _encode.encode;
  }
});
Object.defineProperty(exports, "encodeSync", {
  enumerable: true,
  get: function get() {
    return _encode.encodeSync;
  }
});
Object.defineProperty(exports, "encodeInBatches", {
  enumerable: true,
  get: function get() {
    return _encode.encodeInBatches;
  }
});
Object.defineProperty(exports, "encodeText", {
  enumerable: true,
  get: function get() {
    return _encode.encodeText;
  }
});
Object.defineProperty(exports, "encodeURLtoURL", {
  enumerable: true,
  get: function get() {
    return _encode.encodeURLtoURL;
  }
});
Object.defineProperty(exports, "save", {
  enumerable: true,
  get: function get() {
    return _save.save;
  }
});
Object.defineProperty(exports, "saveSync", {
  enumerable: true,
  get: function get() {
    return _save.saveSync;
  }
});
Object.defineProperty(exports, "setPathPrefix", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.setPathPrefix;
  }
});
Object.defineProperty(exports, "getPathPrefix", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.getPathPrefix;
  }
});
Object.defineProperty(exports, "resolvePath", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.resolvePath;
  }
});
Object.defineProperty(exports, "RequestScheduler", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.RequestScheduler;
  }
});
Object.defineProperty(exports, "JSONLoader", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.JSONLoader;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.isBrowser;
  }
});
Object.defineProperty(exports, "isWorker", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.isWorker;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.window;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.global;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.document;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.assert;
  }
});
Object.defineProperty(exports, "forEach", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.forEach;
  }
});
Object.defineProperty(exports, "concatenateArrayBuffersAsync", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.concatenateArrayBuffersAsync;
  }
});
Object.defineProperty(exports, "makeTextDecoderIterator", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.makeTextDecoderIterator;
  }
});
Object.defineProperty(exports, "makeTextEncoderIterator", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.makeTextEncoderIterator;
  }
});
Object.defineProperty(exports, "makeLineIterator", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.makeLineIterator;
  }
});
Object.defineProperty(exports, "makeNumberedLineIterator", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.makeNumberedLineIterator;
  }
});
Object.defineProperty(exports, "makeIterator", {
  enumerable: true,
  get: function get() {
    return _makeIterator.makeIterator;
  }
});
Object.defineProperty(exports, "makeStream", {
  enumerable: true,
  get: function get() {
    return _makeStream.makeStream;
  }
});
Object.defineProperty(exports, "makeDOMStream", {
  enumerable: true,
  get: function get() {
    return _makeDomStream.makeDOMStream;
  }
});
Object.defineProperty(exports, "makeNodeStream", {
  enumerable: true,
  get: function get() {
    return _makeNodeStream.default;
  }
});
Object.defineProperty(exports, "NullWorkerLoader", {
  enumerable: true,
  get: function get() {
    return _nullLoader.NullWorkerLoader;
  }
});
Object.defineProperty(exports, "NullLoader", {
  enumerable: true,
  get: function get() {
    return _nullLoader.NullLoader;
  }
});
Object.defineProperty(exports, "_fetchProgress", {
  enumerable: true,
  get: function get() {
    return _fetchProgress.default;
  }
});
Object.defineProperty(exports, "_BrowserFileSystem", {
  enumerable: true,
  get: function get() {
    return _browserFilesystem.default;
  }
});
Object.defineProperty(exports, "isPureObject", {
  enumerable: true,
  get: function get() {
    return _isType.isPureObject;
  }
});
Object.defineProperty(exports, "isPromise", {
  enumerable: true,
  get: function get() {
    return _isType.isPromise;
  }
});
Object.defineProperty(exports, "isIterable", {
  enumerable: true,
  get: function get() {
    return _isType.isIterable;
  }
});
Object.defineProperty(exports, "isAsyncIterable", {
  enumerable: true,
  get: function get() {
    return _isType.isAsyncIterable;
  }
});
Object.defineProperty(exports, "isIterator", {
  enumerable: true,
  get: function get() {
    return _isType.isIterator;
  }
});
Object.defineProperty(exports, "isResponse", {
  enumerable: true,
  get: function get() {
    return _isType.isResponse;
  }
});
Object.defineProperty(exports, "isReadableStream", {
  enumerable: true,
  get: function get() {
    return _isType.isReadableStream;
  }
});
Object.defineProperty(exports, "isWritableStream", {
  enumerable: true,
  get: function get() {
    return _isType.isWritableStream;
  }
});

var _fetchFile = require("./lib/fetch/fetch-file");

var _readArrayBuffer = require("./lib/fetch/read-array-buffer");

var _readFile = require("./lib/fetch/read-file");

var _writeFile = require("./lib/fetch/write-file");

var _setLoaderOptions = require("./lib/api/set-loader-options");

var _registerLoaders = require("./lib/api/register-loaders");

var _selectLoader = require("./lib/api/select-loader");

var _parse = require("./lib/api/parse");

var _parseSync = require("./lib/api/parse-sync");

var _parseInBatches = require("./lib/api/parse-in-batches");

var _load = require("./lib/api/load");

var _loadInBatches = require("./lib/api/load-in-batches");

var _encode = require("./lib/api/encode");

var _save = require("./lib/api/save");

var _loaderUtils = require("@loaders.gl/loader-utils");

var _makeIterator = require("./iterators/make-iterator/make-iterator");

var _makeStream = require("./iterators/make-stream/make-stream");

var _makeDomStream = require("./iterators/make-stream/make-dom-stream");

var _makeNodeStream = _interopRequireDefault(require("./iterators/make-stream/make-node-stream"));

var _nullLoader = require("./null-loader");

var _fetchProgress = _interopRequireDefault(require("./lib/progress/fetch-progress"));

var _browserFilesystem = _interopRequireDefault(require("./lib/filesystems/browser-filesystem"));

var _isType = require("./javascript-utils/is-type");

},{"./iterators/make-iterator/make-iterator":37,"./iterators/make-stream/make-dom-stream":40,"./iterators/make-stream/make-node-stream":130,"./iterators/make-stream/make-stream":41,"./javascript-utils/is-type":42,"./lib/api/encode":43,"./lib/api/load":45,"./lib/api/load-in-batches":44,"./lib/api/parse":48,"./lib/api/parse-in-batches":46,"./lib/api/parse-sync":47,"./lib/api/register-loaders":49,"./lib/api/save":50,"./lib/api/select-loader":51,"./lib/api/set-loader-options":52,"./lib/fetch/fetch-file":53,"./lib/fetch/read-array-buffer":54,"./lib/fetch/read-file":55,"./lib/fetch/write-file":56,"./lib/filesystems/browser-filesystem":57,"./lib/progress/fetch-progress":64,"./null-loader":68,"@babel/runtime/helpers/interopRequireDefault":18,"@loaders.gl/loader-utils":73}],35:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeArrayBufferIterator = makeArrayBufferIterator;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _marked = _regenerator.default.mark(makeArrayBufferIterator);

var DEFAULT_CHUNK_SIZE = 256 * 1024;

function makeArrayBufferIterator(arrayBuffer) {
  var options,
      _options$chunkSize,
      chunkSize,
      byteOffset,
      chunkByteLength,
      chunk,
      sourceArray,
      chunkArray,
      _args = arguments;

  return _regenerator.default.wrap(function makeArrayBufferIterator$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
          _options$chunkSize = options.chunkSize, chunkSize = _options$chunkSize === void 0 ? DEFAULT_CHUNK_SIZE : _options$chunkSize;
          byteOffset = 0;

        case 3:
          if (!(byteOffset < arrayBuffer.byteLength)) {
            _context.next = 14;
            break;
          }

          chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);
          chunk = new ArrayBuffer(chunkByteLength);
          sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);
          chunkArray = new Uint8Array(chunk);
          chunkArray.set(sourceArray);
          byteOffset += chunkByteLength;
          _context.next = 12;
          return chunk;

        case 12:
          _context.next = 3;
          break;

        case 14:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}

},{"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],36:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeBlobIterator = makeBlobIterator;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _awaitAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/awaitAsyncGenerator"));

var _wrapAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapAsyncGenerator"));

var DEFAULT_CHUNK_SIZE = 1024 * 1024;

function makeBlobIterator(_x, _x2) {
  return _makeBlobIterator.apply(this, arguments);
}

function _makeBlobIterator() {
  _makeBlobIterator = (0, _wrapAsyncGenerator2.default)(_regenerator.default.mark(function _callee(blob, options) {
    var chunkSize, offset, end, chunk;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE;
            offset = 0;

          case 2:
            if (!(offset < blob.size)) {
              _context.next = 12;
              break;
            }

            end = offset + chunkSize;
            _context.next = 6;
            return (0, _awaitAsyncGenerator2.default)(blob.slice(offset, end).arrayBuffer());

          case 6:
            chunk = _context.sent;
            offset = end;
            _context.next = 10;
            return chunk;

          case 10:
            _context.next = 2;
            break;

          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _makeBlobIterator.apply(this, arguments);
}

},{"@babel/runtime/helpers/awaitAsyncGenerator":11,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/wrapAsyncGenerator":31,"@babel/runtime/regenerator":33}],37:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeIterator = makeIterator;

var _makeStringIterator = require("./make-string-iterator");

var _makeArrayBufferIterator = require("./make-array-buffer-iterator");

var _makeBlobIterator = require("./make-blob-iterator");

var _makeStreamIterator = require("./make-stream-iterator");

var _isType = require("../../javascript-utils/is-type");

function makeIterator(data, options) {
  if (typeof data === 'string') {
    return (0, _makeStringIterator.makeStringIterator)(data, options);
  }

  if (data instanceof ArrayBuffer) {
    return (0, _makeArrayBufferIterator.makeArrayBufferIterator)(data, options);
  }

  if ((0, _isType.isBlob)(data)) {
    return (0, _makeBlobIterator.makeBlobIterator)(data, options);
  }

  if ((0, _isType.isReadableStream)(data)) {
    return (0, _makeStreamIterator.makeStreamIterator)(data, options);
  }

  if ((0, _isType.isResponse)(data)) {
    var response = data;
    return (0, _makeStreamIterator.makeStreamIterator)(response.body, options);
  }

  throw new Error('makeIterator');
}

},{"../../javascript-utils/is-type":42,"./make-array-buffer-iterator":35,"./make-blob-iterator":36,"./make-stream-iterator":38,"./make-string-iterator":39}],38:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeStreamIterator = makeStreamIterator;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

var _awaitAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/awaitAsyncGenerator"));

var _wrapAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapAsyncGenerator"));

var _loaderUtils = require("@loaders.gl/loader-utils");

function makeStreamIterator(stream, options) {
  return _loaderUtils.isBrowser ? makeBrowserStreamIterator(stream, options) : makeNodeStreamIterator(stream, options);
}

function makeBrowserStreamIterator(_x, _x2) {
  return _makeBrowserStreamIterator.apply(this, arguments);
}

function _makeBrowserStreamIterator() {
  _makeBrowserStreamIterator = (0, _wrapAsyncGenerator2.default)(_regenerator.default.mark(function _callee(stream, options) {
    var reader, nextBatchPromise, currentBatchPromise, _yield$_awaitAsyncGen, done, value;

    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            reader = stream.getReader();
            _context.prev = 1;

          case 2:
            if (!true) {
              _context.next = 16;
              break;
            }

            currentBatchPromise = nextBatchPromise || reader.read();

            if (options !== null && options !== void 0 && options._streamReadAhead) {
              nextBatchPromise = reader.read();
            }

            _context.next = 7;
            return (0, _awaitAsyncGenerator2.default)(currentBatchPromise);

          case 7:
            _yield$_awaitAsyncGen = _context.sent;
            done = _yield$_awaitAsyncGen.done;
            value = _yield$_awaitAsyncGen.value;

            if (!done) {
              _context.next = 12;
              break;
            }

            return _context.abrupt("return");

          case 12:
            _context.next = 14;
            return (0, _loaderUtils.toArrayBuffer)(value);

          case 14:
            _context.next = 2;
            break;

          case 16:
            _context.next = 21;
            break;

          case 18:
            _context.prev = 18;
            _context.t0 = _context["catch"](1);
            reader.releaseLock();

          case 21:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[1, 18]]);
  }));
  return _makeBrowserStreamIterator.apply(this, arguments);
}

function makeNodeStreamIterator(_x3, _x4) {
  return _makeNodeStreamIterator.apply(this, arguments);
}

function _makeNodeStreamIterator() {
  _makeNodeStreamIterator = (0, _wrapAsyncGenerator2.default)(_regenerator.default.mark(function _callee2(stream, options) {
    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk;

    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _context2.prev = 2;
            _iterator = (0, _asyncIterator2.default)(stream);

          case 4:
            _context2.next = 6;
            return (0, _awaitAsyncGenerator2.default)(_iterator.next());

          case 6:
            _step = _context2.sent;
            _iteratorNormalCompletion = _step.done;
            _context2.next = 10;
            return (0, _awaitAsyncGenerator2.default)(_step.value);

          case 10:
            _value = _context2.sent;

            if (_iteratorNormalCompletion) {
              _context2.next = 18;
              break;
            }

            chunk = _value;
            _context2.next = 15;
            return (0, _loaderUtils.toArrayBuffer)(chunk);

          case 15:
            _iteratorNormalCompletion = true;
            _context2.next = 4;
            break;

          case 18:
            _context2.next = 24;
            break;

          case 20:
            _context2.prev = 20;
            _context2.t0 = _context2["catch"](2);
            _didIteratorError = true;
            _iteratorError = _context2.t0;

          case 24:
            _context2.prev = 24;
            _context2.prev = 25;

            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
              _context2.next = 29;
              break;
            }

            _context2.next = 29;
            return (0, _awaitAsyncGenerator2.default)(_iterator.return());

          case 29:
            _context2.prev = 29;

            if (!_didIteratorError) {
              _context2.next = 32;
              break;
            }

            throw _iteratorError;

          case 32:
            return _context2.finish(29);

          case 33:
            return _context2.finish(24);

          case 34:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[2, 20, 24, 34], [25,, 29, 33]]);
  }));
  return _makeNodeStreamIterator.apply(this, arguments);
}

},{"@babel/runtime/helpers/asyncIterator":9,"@babel/runtime/helpers/awaitAsyncGenerator":11,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/wrapAsyncGenerator":31,"@babel/runtime/regenerator":33,"@loaders.gl/loader-utils":73}],39:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeStringIterator = makeStringIterator;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _marked = _regenerator.default.mark(makeStringIterator);

var DEFAULT_CHUNK_SIZE = 256 * 1024;

function makeStringIterator(string, options) {
  var chunkSize, offset, textEncoder, chunkLength, chunk;
  return _regenerator.default.wrap(function makeStringIterator$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE;
          offset = 0;
          textEncoder = new TextEncoder();

        case 3:
          if (!(offset < string.length)) {
            _context.next = 11;
            break;
          }

          chunkLength = Math.min(string.length - offset, chunkSize);
          chunk = string.slice(offset, offset + chunkLength);
          offset += chunkLength;
          _context.next = 9;
          return textEncoder.encode(chunk);

        case 9:
          _context.next = 3;
          break;

        case 11:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}

},{"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],40:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeDOMStream = makeDOMStream;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function makeDOMStream(source, options) {
  var iterator = source[Symbol.asyncIterator] ? source[Symbol.asyncIterator]() : source[Symbol.iterator]();
  return new ReadableStream({
    type: 'bytes',
    pull: function pull(controller) {
      return (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {
        var _yield$iterator$next, done, value;

        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _context.next = 3;
                return iterator.next();

              case 3:
                _yield$iterator$next = _context.sent;
                done = _yield$iterator$next.done;
                value = _yield$iterator$next.value;

                if (done) {
                  controller.close();
                } else {
                  controller.enqueue(new Uint8Array(value));
                }

                _context.next = 12;
                break;

              case 9:
                _context.prev = 9;
                _context.t0 = _context["catch"](0);
                controller.error(_context.t0);

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[0, 9]]);
      }))();
    },
    cancel: function cancel() {
      return (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2() {
        var _iterator$return;

        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return iterator === null || iterator === void 0 ? void 0 : (_iterator$return = iterator.return) === null || _iterator$return === void 0 ? void 0 : _iterator$return.call(iterator);

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }))();
    }
  }, _objectSpread({
    highWaterMark: Math.pow(2, 24)
  }, options));
}

},{"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],41:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeStream = makeStream;

var _loaderUtils = require("@loaders.gl/loader-utils");

var _makeDomStream = require("./make-dom-stream");

var _makeNodeStream = _interopRequireDefault(require("./make-node-stream"));

function makeStream(data, options) {
  return _loaderUtils.isBrowser ? (0, _makeDomStream.makeDOMStream)(data, options) : (0, _makeNodeStream.default)(data, options);
}

},{"./make-dom-stream":40,"./make-node-stream":130,"@babel/runtime/helpers/interopRequireDefault":18,"@loaders.gl/loader-utils":73}],42:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isWritableStream = exports.isReadableStream = exports.isReadableNodeStream = exports.isWritableNodeStream = exports.isBuffer = exports.isReadableDOMStream = exports.isWritableDOMStream = exports.isBlob = exports.isFile = exports.isResponse = exports.isIterator = exports.isAsyncIterable = exports.isIterable = exports.isPromise = exports.isPureObject = exports.isObject = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var isBoolean = function isBoolean(x) {
  return typeof x === 'boolean';
};

var isFunction = function isFunction(x) {
  return typeof x === 'function';
};

var isObject = function isObject(x) {
  return x !== null && (0, _typeof2.default)(x) === 'object';
};

exports.isObject = isObject;

var isPureObject = function isPureObject(x) {
  return isObject(x) && x.constructor === {}.constructor;
};

exports.isPureObject = isPureObject;

var isPromise = function isPromise(x) {
  return isObject(x) && isFunction(x.then);
};

exports.isPromise = isPromise;

var isIterable = function isIterable(x) {
  return x && typeof x[Symbol.iterator] === 'function';
};

exports.isIterable = isIterable;

var isAsyncIterable = function isAsyncIterable(x) {
  return x && typeof x[Symbol.asyncIterator] === 'function';
};

exports.isAsyncIterable = isAsyncIterable;

var isIterator = function isIterator(x) {
  return x && isFunction(x.next);
};

exports.isIterator = isIterator;

var isResponse = function isResponse(x) {
  return typeof Response !== 'undefined' && x instanceof Response || x && x.arrayBuffer && x.text && x.json;
};

exports.isResponse = isResponse;

var isFile = function isFile(x) {
  return typeof File !== 'undefined' && x instanceof File;
};

exports.isFile = isFile;

var isBlob = function isBlob(x) {
  return typeof Blob !== 'undefined' && x instanceof Blob;
};

exports.isBlob = isBlob;

var isWritableDOMStream = function isWritableDOMStream(x) {
  return isObject(x) && isFunction(x.abort) && isFunction(x.getWriter);
};

exports.isWritableDOMStream = isWritableDOMStream;

var isReadableDOMStream = function isReadableDOMStream(x) {
  return typeof ReadableStream !== 'undefined' && x instanceof ReadableStream || isObject(x) && isFunction(x.tee) && isFunction(x.cancel) && isFunction(x.getReader);
};

exports.isReadableDOMStream = isReadableDOMStream;

var isBuffer = function isBuffer(x) {
  return x && (0, _typeof2.default)(x) === 'object' && x.isBuffer;
};

exports.isBuffer = isBuffer;

var isWritableNodeStream = function isWritableNodeStream(x) {
  return isObject(x) && isFunction(x.end) && isFunction(x.write) && isBoolean(x.writable);
};

exports.isWritableNodeStream = isWritableNodeStream;

var isReadableNodeStream = function isReadableNodeStream(x) {
  return isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);
};

exports.isReadableNodeStream = isReadableNodeStream;

var isReadableStream = function isReadableStream(x) {
  return isReadableDOMStream(x) || isReadableNodeStream(x);
};

exports.isReadableStream = isReadableStream;

var isWritableStream = function isWritableStream(x) {
  return isWritableDOMStream(x) || isWritableNodeStream(x);
};

exports.isWritableStream = isWritableStream;

},{"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29}],43:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encode = encode;
exports.encodeSync = encodeSync;
exports.encodeText = encodeText;
exports.encodeInBatches = encodeInBatches;
exports.encodeURLtoURL = encodeURLtoURL;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

var _loaderUtils = require("@loaders.gl/loader-utils");

var _writeFile = require("../fetch/write-file");

var _fetchFile = require("../fetch/fetch-file");

function encode(_x, _x2, _x3) {
  return _encode.apply(this, arguments);
}

function _encode() {
  _encode = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(data, writer, options) {
    var batches, chunks, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, batch, tmpInputFilename, tmpOutputFilename, outputFilename, response;

    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!writer.encode) {
              _context.next = 4;
              break;
            }

            _context.next = 3;
            return writer.encode(data, options);

          case 3:
            return _context.abrupt("return", _context.sent);

          case 4:
            if (!writer.encodeSync) {
              _context.next = 6;
              break;
            }

            return _context.abrupt("return", writer.encodeSync(data, options));

          case 6:
            if (!writer.encodeText) {
              _context.next = 12;
              break;
            }

            _context.t0 = new TextEncoder();
            _context.next = 10;
            return writer.encodeText(data, options);

          case 10:
            _context.t1 = _context.sent;
            return _context.abrupt("return", _context.t0.encode.call(_context.t0, _context.t1));

          case 12:
            if (!writer.encodeInBatches) {
              _context.next = 49;
              break;
            }

            batches = encodeInBatches(data, writer, options);
            chunks = [];
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _context.prev = 17;
            _iterator = (0, _asyncIterator2.default)(batches);

          case 19:
            _context.next = 21;
            return _iterator.next();

          case 21:
            _step = _context.sent;
            _iteratorNormalCompletion = _step.done;
            _context.next = 25;
            return _step.value;

          case 25:
            _value = _context.sent;

            if (_iteratorNormalCompletion) {
              _context.next = 32;
              break;
            }

            batch = _value;
            chunks.push(batch);

          case 29:
            _iteratorNormalCompletion = true;
            _context.next = 19;
            break;

          case 32:
            _context.next = 38;
            break;

          case 34:
            _context.prev = 34;
            _context.t2 = _context["catch"](17);
            _didIteratorError = true;
            _iteratorError = _context.t2;

          case 38:
            _context.prev = 38;
            _context.prev = 39;

            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
              _context.next = 43;
              break;
            }

            _context.next = 43;
            return _iterator.return();

          case 43:
            _context.prev = 43;

            if (!_didIteratorError) {
              _context.next = 46;
              break;
            }

            throw _iteratorError;

          case 46:
            return _context.finish(43);

          case 47:
            return _context.finish(38);

          case 48:
            return _context.abrupt("return", _loaderUtils.concatenateArrayBuffers.apply(void 0, chunks));

          case 49:
            if (!(!_loaderUtils.isBrowser && writer.encodeURLtoURL)) {
              _context.next = 61;
              break;
            }

            tmpInputFilename = getTemporaryFilename('input');
            _context.next = 53;
            return (0, _writeFile.writeFile)(tmpInputFilename, data);

          case 53:
            tmpOutputFilename = getTemporaryFilename('output');
            _context.next = 56;
            return encodeURLtoURL(tmpInputFilename, tmpOutputFilename, writer, options);

          case 56:
            outputFilename = _context.sent;
            _context.next = 59;
            return (0, _fetchFile.fetchFile)(outputFilename);

          case 59:
            response = _context.sent;
            return _context.abrupt("return", response.arrayBuffer());

          case 61:
            throw new Error('Writer could not encode data');

          case 62:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[17, 34, 38, 48], [39,, 43, 47]]);
  }));
  return _encode.apply(this, arguments);
}

function encodeSync(data, writer, options) {
  if (writer.encodeSync) {
    return writer.encodeSync(data, options);
  }

  throw new Error('Writer could not synchronously encode data');
}

function encodeText(_x4, _x5, _x6) {
  return _encodeText.apply(this, arguments);
}

function _encodeText() {
  _encodeText = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(data, writer, options) {
    var arrayBuffer;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(writer.text && writer.encodeText)) {
              _context2.next = 4;
              break;
            }

            _context2.next = 3;
            return writer.encodeText(data, options);

          case 3:
            return _context2.abrupt("return", _context2.sent);

          case 4:
            if (!(writer.text && (writer.encode || writer.encodeInBatches))) {
              _context2.next = 9;
              break;
            }

            _context2.next = 7;
            return encode(data, writer, options);

          case 7:
            arrayBuffer = _context2.sent;
            return _context2.abrupt("return", new TextDecoder().decode(arrayBuffer));

          case 9:
            throw new Error('Writer could not encode data as text');

          case 10:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _encodeText.apply(this, arguments);
}

function encodeInBatches(data, writer, options) {
  if (writer.encodeInBatches) {
    var dataIterator = getIterator(data);
    return writer.encodeInBatches(dataIterator, options);
  }

  throw new Error('Writer could not encode data in batches');
}

function encodeURLtoURL(_x7, _x8, _x9, _x10) {
  return _encodeURLtoURL.apply(this, arguments);
}

function _encodeURLtoURL() {
  _encodeURLtoURL = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(inputUrl, outputUrl, writer, options) {
    var outputFilename;
    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            inputUrl = (0, _loaderUtils.resolvePath)(inputUrl);
            outputUrl = (0, _loaderUtils.resolvePath)(outputUrl);

            if (!(_loaderUtils.isBrowser || !writer.encodeURLtoURL)) {
              _context3.next = 4;
              break;
            }

            throw new Error();

          case 4:
            _context3.next = 6;
            return writer.encodeURLtoURL(inputUrl, outputUrl, options);

          case 6:
            outputFilename = _context3.sent;
            return _context3.abrupt("return", outputFilename);

          case 8:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _encodeURLtoURL.apply(this, arguments);
}

function getIterator(data) {
  var dataIterator = [{
    table: data,
    start: 0,
    end: data.length
  }];
  return dataIterator;
}

function getTemporaryFilename(filename) {
  return "/tmp/".concat(filename);
}

},{"../fetch/fetch-file":53,"../fetch/write-file":56,"@babel/runtime/helpers/asyncIterator":9,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33,"@loaders.gl/loader-utils":73}],44:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadInBatches = loadInBatches;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _normalizeLoader = require("../loader-utils/normalize-loader");

var _optionUtils = require("../loader-utils/option-utils");

var _parseInBatches = require("./parse-in-batches");

function loadInBatches(files, loaders, options, context) {
  if (!Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
    context = undefined;
    options = loaders;
    loaders = null;
  }

  var fetch = (0, _optionUtils.getFetchFunction)(options || {});

  if (!Array.isArray(files)) {
    return loadOneFileInBatches(files, loaders, options, fetch);
  }

  var promises = files.map(function (file) {
    return loadOneFileInBatches(file, loaders, options, fetch);
  });
  return promises;
}

function loadOneFileInBatches(_x, _x2, _x3, _x4) {
  return _loadOneFileInBatches.apply(this, arguments);
}

function _loadOneFileInBatches() {
  _loadOneFileInBatches = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(file, loaders, options, fetch) {
    var url, response;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(typeof file === 'string')) {
              _context.next = 8;
              break;
            }

            url = file;
            _context.next = 4;
            return fetch(url);

          case 4:
            response = _context.sent;
            _context.next = 7;
            return (0, _parseInBatches.parseInBatches)(response, loaders, options);

          case 7:
            return _context.abrupt("return", _context.sent);

          case 8:
            _context.next = 10;
            return (0, _parseInBatches.parseInBatches)(file, loaders, options);

          case 10:
            return _context.abrupt("return", _context.sent);

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _loadOneFileInBatches.apply(this, arguments);
}

},{"../loader-utils/normalize-loader":61,"../loader-utils/option-utils":63,"./parse-in-batches":46,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],45:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.load = load;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _isType = require("../../javascript-utils/is-type");

var _normalizeLoader = require("../loader-utils/normalize-loader");

var _optionUtils = require("../loader-utils/option-utils");

var _parse = require("./parse");

function load(_x, _x2, _x3, _x4) {
  return _load.apply(this, arguments);
}

function _load() {
  _load = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(url, loaders, options, context) {
    var fetch, data;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
              context = undefined;
              options = loaders;
              loaders = undefined;
            }

            fetch = (0, _optionUtils.getFetchFunction)(options);
            data = url;

            if (!(typeof url === 'string')) {
              _context.next = 7;
              break;
            }

            _context.next = 6;
            return fetch(url);

          case 6:
            data = _context.sent;

          case 7:
            if (!(0, _isType.isBlob)(url)) {
              _context.next = 11;
              break;
            }

            _context.next = 10;
            return fetch(url);

          case 10:
            data = _context.sent;

          case 11:
            _context.next = 13;
            return (0, _parse.parse)(data, loaders, options);

          case 13:
            return _context.abrupt("return", _context.sent);

          case 14:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _load.apply(this, arguments);
}

},{"../../javascript-utils/is-type":42,"../loader-utils/normalize-loader":61,"../loader-utils/option-utils":63,"./parse":48,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],46:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseInBatches = parseInBatches;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _wrapAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapAsyncGenerator"));

var _awaitAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/awaitAsyncGenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

var _asyncGeneratorDelegate2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncGeneratorDelegate"));

var _loaderUtils = require("@loaders.gl/loader-utils");

var _normalizeLoader = require("../loader-utils/normalize-loader");

var _optionUtils = require("../loader-utils/option-utils");

var _loaderContext = require("../loader-utils/loader-context");

var _getData = require("../loader-utils/get-data");

var _resourceUtils = require("../utils/resource-utils");

var _selectLoader = require("./select-loader");

var _parse = require("./parse");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function parseInBatches(_x2, _x3, _x4, _x5) {
  return _parseInBatches.apply(this, arguments);
}

function _parseInBatches() {
  _parseInBatches = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(data, loaders, options, context) {
    var _getResourceUrlAndTyp, url, loader;

    return _regenerator.default.wrap(function _callee2$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            (0, _loaderUtils.assert)(!context || (0, _typeof2.default)(context) === 'object');

            if (!Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
              context = undefined;
              options = loaders;
              loaders = undefined;
            }

            _context3.next = 4;
            return data;

          case 4:
            data = _context3.sent;
            options = options || {};
            _getResourceUrlAndTyp = (0, _resourceUtils.getResourceUrlAndType)(data), url = _getResourceUrlAndTyp.url;
            _context3.next = 9;
            return (0, _selectLoader.selectLoader)(data, loaders, options);

          case 9:
            loader = _context3.sent;

            if (loader) {
              _context3.next = 12;
              break;
            }

            return _context3.abrupt("return", null);

          case 12:
            options = (0, _optionUtils.normalizeOptions)(options, loader, loaders, url);
            context = (0, _loaderContext.getLoaderContext)({
              url: url,
              parseInBatches: parseInBatches,
              parse: _parse.parse,
              loaders: loaders
            }, options, context);
            _context3.next = 16;
            return parseWithLoaderInBatches(loader, data, options, context);

          case 16:
            return _context3.abrupt("return", _context3.sent);

          case 17:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee2);
  }));
  return _parseInBatches.apply(this, arguments);
}

function parseWithLoaderInBatches(loader, data, options, context) {
  var outputIterator, metadataBatch, makeMetadataBatchIterator, _makeMetadataBatchIterator;

  return _regenerator.default.async(function parseWithLoaderInBatches$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _makeMetadataBatchIterator = function _makeMetadataBatchIte2() {
            _makeMetadataBatchIterator = (0, _wrapAsyncGenerator2.default)(_regenerator.default.mark(function _callee(iterator) {
              return _regenerator.default.wrap(function _callee$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      _context2.next = 2;
                      return metadataBatch;

                    case 2:
                      return _context2.delegateYield((0, _asyncGeneratorDelegate2.default)((0, _asyncIterator2.default)(iterator), _awaitAsyncGenerator2.default), "t0", 3);

                    case 3:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee);
            }));
            return _makeMetadataBatchIterator.apply(this, arguments);
          };

          makeMetadataBatchIterator = function _makeMetadataBatchIte(_x) {
            return _makeMetadataBatchIterator.apply(this, arguments);
          };

          _context.next = 4;
          return _regenerator.default.awrap(parseToOutputIterator(loader, data, options, context));

        case 4:
          outputIterator = _context.sent;

          if (options.metadata) {
            _context.next = 7;
            break;
          }

          return _context.abrupt("return", outputIterator);

        case 7:
          metadataBatch = {
            batchType: 'metadata',
            metadata: {
              _loader: loader,
              _context: context
            },
            data: [],
            bytesUsed: 0
          };
          return _context.abrupt("return", makeMetadataBatchIterator(outputIterator));

        case 9:
        case "end":
          return _context.stop();
      }
    }
  }, null, null, null, Promise);
}

function parseToOutputIterator(_x6, _x7, _x8, _x9) {
  return _parseToOutputIterator.apply(this, arguments);
}

function _parseToOutputIterator() {
  _parseToOutputIterator = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee4(loader, data, options, context) {
    var inputIterator, transformedIterator, parseChunkInBatches, _parseChunkInBatches;

    return _regenerator.default.wrap(function _callee4$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _parseChunkInBatches = function _parseChunkInBatches3() {
              _parseChunkInBatches = (0, _wrapAsyncGenerator2.default)(_regenerator.default.mark(function _callee3() {
                var arrayBuffer, parsedData, batch;
                return _regenerator.default.wrap(function _callee3$(_context4) {
                  while (1) {
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        _context4.next = 2;
                        return (0, _awaitAsyncGenerator2.default)((0, _loaderUtils.concatenateArrayBuffersAsync)(transformedIterator));

                      case 2:
                        arrayBuffer = _context4.sent;
                        _context4.next = 5;
                        return (0, _awaitAsyncGenerator2.default)((0, _parse.parse)(arrayBuffer, loader, _objectSpread(_objectSpread({}, options), {}, {
                          mimeType: loader.mimeTypes[0]
                        }), context));

                      case 5:
                        parsedData = _context4.sent;
                        batch = {
                          mimeType: loader.mimeTypes[0],
                          shape: Array.isArray(parsedData) ? 'row-table' : 'unknown',
                          batchType: 'data',
                          data: parsedData,
                          length: Array.isArray(parsedData) ? parsedData.length : 1
                        };
                        _context4.next = 9;
                        return batch;

                      case 9:
                      case "end":
                        return _context4.stop();
                    }
                  }
                }, _callee3);
              }));
              return _parseChunkInBatches.apply(this, arguments);
            };

            parseChunkInBatches = function _parseChunkInBatches2() {
              return _parseChunkInBatches.apply(this, arguments);
            };

            _context5.next = 4;
            return (0, _getData.getAsyncIterableFromData)(data, options);

          case 4:
            inputIterator = _context5.sent;
            _context5.next = 7;
            return applyInputTransforms(inputIterator, (options === null || options === void 0 ? void 0 : options.transforms) || []);

          case 7:
            transformedIterator = _context5.sent;

            if (!loader.parseInBatches) {
              _context5.next = 10;
              break;
            }

            return _context5.abrupt("return", loader.parseInBatches(transformedIterator, options, context));

          case 10:
            return _context5.abrupt("return", parseChunkInBatches());

          case 11:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee4);
  }));
  return _parseToOutputIterator.apply(this, arguments);
}

function applyInputTransforms(_x10) {
  return _applyInputTransforms.apply(this, arguments);
}

function _applyInputTransforms() {
  _applyInputTransforms = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee5(inputIterator) {
    var transforms,
        iteratorChain,
        _iteratorNormalCompletion,
        _didIteratorError,
        _iteratorError,
        _iterator,
        _step,
        _value,
        transformBatches,
        _args6 = arguments;

    return _regenerator.default.wrap(function _callee5$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            transforms = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : [];
            iteratorChain = inputIterator;
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _context6.prev = 4;
            _iterator = (0, _asyncIterator2.default)(transforms);

          case 6:
            _context6.next = 8;
            return _iterator.next();

          case 8:
            _step = _context6.sent;
            _iteratorNormalCompletion = _step.done;
            _context6.next = 12;
            return _step.value;

          case 12:
            _value = _context6.sent;

            if (_iteratorNormalCompletion) {
              _context6.next = 19;
              break;
            }

            transformBatches = _value;
            iteratorChain = transformBatches(iteratorChain);

          case 16:
            _iteratorNormalCompletion = true;
            _context6.next = 6;
            break;

          case 19:
            _context6.next = 25;
            break;

          case 21:
            _context6.prev = 21;
            _context6.t0 = _context6["catch"](4);
            _didIteratorError = true;
            _iteratorError = _context6.t0;

          case 25:
            _context6.prev = 25;
            _context6.prev = 26;

            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
              _context6.next = 30;
              break;
            }

            _context6.next = 30;
            return _iterator.return();

          case 30:
            _context6.prev = 30;

            if (!_didIteratorError) {
              _context6.next = 33;
              break;
            }

            throw _iteratorError;

          case 33:
            return _context6.finish(30);

          case 34:
            return _context6.finish(25);

          case 35:
            return _context6.abrupt("return", iteratorChain);

          case 36:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee5, null, [[4, 21, 25, 35], [26,, 30, 34]]);
  }));
  return _applyInputTransforms.apply(this, arguments);
}

},{"../loader-utils/get-data":58,"../loader-utils/loader-context":59,"../loader-utils/normalize-loader":61,"../loader-utils/option-utils":63,"../utils/resource-utils":66,"./parse":48,"./select-loader":51,"@babel/runtime/helpers/asyncGeneratorDelegate":8,"@babel/runtime/helpers/asyncIterator":9,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/awaitAsyncGenerator":11,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"@babel/runtime/helpers/wrapAsyncGenerator":31,"@babel/runtime/regenerator":33,"@loaders.gl/loader-utils":73}],47:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseSync = parseSync;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _loaderUtils = require("@loaders.gl/loader-utils");

var _selectLoader = require("./select-loader");

var _normalizeLoader = require("../loader-utils/normalize-loader");

var _optionUtils = require("../loader-utils/option-utils");

var _getData = require("../loader-utils/get-data");

var _loaderContext = require("../loader-utils/loader-context");

var _resourceUtils = require("../utils/resource-utils");

function parseSync(data, loaders, options, context) {
  (0, _loaderUtils.assert)(!context || (0, _typeof2.default)(context) === 'object');

  if (!Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
    context = undefined;
    options = loaders;
    loaders = undefined;
  }

  options = options || {};
  var typedLoaders = loaders;
  var candidateLoaders = (0, _loaderContext.getLoadersFromContext)(typedLoaders, context);
  var loader = (0, _selectLoader.selectLoaderSync)(data, candidateLoaders, options);

  if (!loader) {
    return null;
  }

  options = (0, _optionUtils.normalizeOptions)(options, loader, candidateLoaders);

  var _getResourceUrlAndTyp = (0, _resourceUtils.getResourceUrlAndType)(data),
      url = _getResourceUrlAndTyp.url;

  var parse = function parse() {
    throw new Error('parseSync called parse');
  };

  context = (0, _loaderContext.getLoaderContext)({
    url: url,
    parseSync: parseSync,
    parse: parse,
    loaders: loaders
  }, options);
  return parseWithLoaderSync(loader, data, options, context);
}

function parseWithLoaderSync(loader, data, options, context) {
  data = (0, _getData.getArrayBufferOrStringFromDataSync)(data, loader, options);

  if (loader.parseTextSync && typeof data === 'string') {
    return loader.parseTextSync(data, options);
  }

  if (loader.parseSync && data instanceof ArrayBuffer) {
    return loader.parseSync(data, options, context);
  }

  throw new Error("".concat(loader.name, " loader: 'parseSync' not supported by this loader, use 'parse' instead. ").concat(context.url || ''));
}

},{"../loader-utils/get-data":58,"../loader-utils/loader-context":59,"../loader-utils/normalize-loader":61,"../loader-utils/option-utils":63,"../utils/resource-utils":66,"./select-loader":51,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"@loaders.gl/loader-utils":73}],48:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = parse;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _workerUtils = require("@loaders.gl/worker-utils");

var _loaderUtils = require("@loaders.gl/loader-utils");

var _normalizeLoader = require("../loader-utils/normalize-loader");

var _optionUtils = require("../loader-utils/option-utils");

var _getData = require("../loader-utils/get-data");

var _loaderContext = require("../loader-utils/loader-context");

var _resourceUtils = require("../utils/resource-utils");

var _selectLoader = require("./select-loader");

function parse(_x, _x2, _x3, _x4) {
  return _parse.apply(this, arguments);
}

function _parse() {
  _parse = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(data, loaders, options, context) {
    var _getResourceUrlAndTyp, url, typedLoaders, candidateLoaders, loader;

    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            (0, _workerUtils.assert)(!context || (0, _typeof2.default)(context) === 'object');

            if (loaders && !Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
              context = undefined;
              options = loaders;
              loaders = undefined;
            }

            _context.next = 4;
            return data;

          case 4:
            data = _context.sent;
            options = options || {};
            _getResourceUrlAndTyp = (0, _resourceUtils.getResourceUrlAndType)(data), url = _getResourceUrlAndTyp.url;
            typedLoaders = loaders;
            candidateLoaders = (0, _loaderContext.getLoadersFromContext)(typedLoaders, context);
            _context.next = 11;
            return (0, _selectLoader.selectLoader)(data, candidateLoaders, options);

          case 11:
            loader = _context.sent;

            if (loader) {
              _context.next = 14;
              break;
            }

            return _context.abrupt("return", null);

          case 14:
            options = (0, _optionUtils.normalizeOptions)(options, loader, candidateLoaders, url);
            context = (0, _loaderContext.getLoaderContext)({
              url: url,
              parse: parse,
              loaders: candidateLoaders
            }, options, context);
            _context.next = 18;
            return parseWithLoader(loader, data, options, context);

          case 18:
            return _context.abrupt("return", _context.sent);

          case 19:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _parse.apply(this, arguments);
}

function parseWithLoader(_x5, _x6, _x7, _x8) {
  return _parseWithLoader.apply(this, arguments);
}

function _parseWithLoader() {
  _parseWithLoader = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(loader, data, options, context) {
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            (0, _workerUtils.validateWorkerVersion)(loader);
            _context2.next = 3;
            return (0, _getData.getArrayBufferOrStringFromData)(data, loader, options);

          case 3:
            data = _context2.sent;

            if (!(loader.parseTextSync && typeof data === 'string')) {
              _context2.next = 7;
              break;
            }

            options.dataType = 'text';
            return _context2.abrupt("return", loader.parseTextSync(data, options, context, loader));

          case 7:
            if (!(0, _loaderUtils.canParseWithWorker)(loader, options)) {
              _context2.next = 11;
              break;
            }

            _context2.next = 10;
            return (0, _loaderUtils.parseWithWorker)(loader, data, options, context, parse);

          case 10:
            return _context2.abrupt("return", _context2.sent);

          case 11:
            if (!(loader.parseText && typeof data === 'string')) {
              _context2.next = 15;
              break;
            }

            _context2.next = 14;
            return loader.parseText(data, options, context, loader);

          case 14:
            return _context2.abrupt("return", _context2.sent);

          case 15:
            if (!loader.parse) {
              _context2.next = 19;
              break;
            }

            _context2.next = 18;
            return loader.parse(data, options, context, loader);

          case 18:
            return _context2.abrupt("return", _context2.sent);

          case 19:
            (0, _workerUtils.assert)(!loader.parseSync);
            throw new Error("".concat(loader.id, " loader - no parser found and worker is disabled"));

          case 21:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _parseWithLoader.apply(this, arguments);
}

},{"../loader-utils/get-data":58,"../loader-utils/loader-context":59,"../loader-utils/normalize-loader":61,"../loader-utils/option-utils":63,"../utils/resource-utils":66,"./select-loader":51,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"@babel/runtime/regenerator":33,"@loaders.gl/loader-utils":73,"@loaders.gl/worker-utils":108}],49:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerLoaders = registerLoaders;
exports.getRegisteredLoaders = getRegisteredLoaders;
exports._unregisterLoaders = _unregisterLoaders;

var _normalizeLoader = require("../loader-utils/normalize-loader");

var _optionUtils = require("../loader-utils/option-utils");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var getGlobalLoaderRegistry = function getGlobalLoaderRegistry() {
  var state = (0, _optionUtils.getGlobalLoaderState)();
  state.loaderRegistry = state.loaderRegistry || [];
  return state.loaderRegistry;
};

function registerLoaders(loaders) {
  var loaderRegistry = getGlobalLoaderRegistry();
  loaders = Array.isArray(loaders) ? loaders : [loaders];

  var _iterator = _createForOfIteratorHelper(loaders),
      _step;

  try {
    var _loop = function _loop() {
      var loader = _step.value;
      var normalizedLoader = (0, _normalizeLoader.normalizeLoader)(loader);

      if (!loaderRegistry.find(function (registeredLoader) {
        return normalizedLoader === registeredLoader;
      })) {
        loaderRegistry.unshift(normalizedLoader);
      }
    };

    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      _loop();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}

function getRegisteredLoaders() {
  return getGlobalLoaderRegistry();
}

function _unregisterLoaders() {
  var state = (0, _optionUtils.getGlobalLoaderState)();
  state.loaderRegistry = [];
}

},{"../loader-utils/normalize-loader":61,"../loader-utils/option-utils":63}],50:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.save = save;
exports.saveSync = saveSync;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _encode = require("./encode");

var _writeFile = require("../fetch/write-file");

function save(_x, _x2, _x3, _x4) {
  return _save.apply(this, arguments);
}

function _save() {
  _save = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(data, url, writer, options) {
    var encodedData;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return (0, _encode.encode)(data, writer, options);

          case 2:
            encodedData = _context.sent;
            _context.next = 5;
            return (0, _writeFile.writeFile)(url, encodedData);

          case 5:
            return _context.abrupt("return", _context.sent);

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _save.apply(this, arguments);
}

function saveSync(data, url, writer, options) {
  var encodedData = (0, _encode.encodeSync)(data, writer, options);
  return (0, _writeFile.writeFileSync)(url, encodedData);
}

},{"../fetch/write-file":56,"./encode":43,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],51:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.selectLoader = selectLoader;
exports.selectLoaderSync = selectLoaderSync;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _loaderUtils = require("@loaders.gl/loader-utils");

var _normalizeLoader = require("../loader-utils/normalize-loader");

var _resourceUtils = require("../utils/resource-utils");

var _registerLoaders = require("./register-loaders");

var _isType = require("../../javascript-utils/is-type");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var EXT_PATTERN = /\.([^.]+)$/;

function selectLoader(_x) {
  return _selectLoader.apply(this, arguments);
}

function _selectLoader() {
  _selectLoader = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(data) {
    var loaders,
        options,
        context,
        loader,
        _args = arguments;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            loaders = _args.length > 1 && _args[1] !== undefined ? _args[1] : [];
            options = _args.length > 2 ? _args[2] : undefined;
            context = _args.length > 3 ? _args[3] : undefined;

            if (validHTTPResponse(data)) {
              _context.next = 5;
              break;
            }

            return _context.abrupt("return", null);

          case 5:
            loader = selectLoaderSync(data, loaders, _objectSpread(_objectSpread({}, options), {}, {
              nothrow: true
            }), context);

            if (!loader) {
              _context.next = 8;
              break;
            }

            return _context.abrupt("return", loader);

          case 8:
            if (!(0, _isType.isBlob)(data)) {
              _context.next = 13;
              break;
            }

            _context.next = 11;
            return data.slice(0, 10).arrayBuffer();

          case 11:
            data = _context.sent;
            loader = selectLoaderSync(data, loaders, options, context);

          case 13:
            if (!(!loader && !(options !== null && options !== void 0 && options.nothrow))) {
              _context.next = 15;
              break;
            }

            throw new Error(getNoValidLoaderMessage(data));

          case 15:
            return _context.abrupt("return", loader);

          case 16:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _selectLoader.apply(this, arguments);
}

function selectLoaderSync(data) {
  var loaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var options = arguments.length > 2 ? arguments[2] : undefined;
  var context = arguments.length > 3 ? arguments[3] : undefined;

  if (!validHTTPResponse(data)) {
    return null;
  }

  if (loaders && !Array.isArray(loaders)) {
    return (0, _normalizeLoader.normalizeLoader)(loaders);
  }

  var candidateLoaders = [];

  if (loaders) {
    candidateLoaders = candidateLoaders.concat(loaders);
  }

  if (!(options !== null && options !== void 0 && options.ignoreRegisteredLoaders)) {
    var _candidateLoaders;

    (_candidateLoaders = candidateLoaders).push.apply(_candidateLoaders, (0, _toConsumableArray2.default)((0, _registerLoaders.getRegisteredLoaders)()));
  }

  normalizeLoaders(candidateLoaders);
  var loader = selectLoaderInternal(data, candidateLoaders, options, context);

  if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {
    throw new Error(getNoValidLoaderMessage(data));
  }

  return loader;
}

function selectLoaderInternal(data, loaders, options, context) {
  var _getResourceUrlAndTyp = (0, _resourceUtils.getResourceUrlAndType)(data),
      url = _getResourceUrlAndTyp.url,
      type = _getResourceUrlAndTyp.type;

  var testUrl = url || (context === null || context === void 0 ? void 0 : context.url);
  var loader = null;

  if (options !== null && options !== void 0 && options.mimeType) {
    loader = findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.mimeType);
  }

  loader = loader || findLoaderByUrl(loaders, testUrl);
  loader = loader || findLoaderByMIMEType(loaders, type);
  loader = loader || findLoaderByInitialBytes(loaders, data);
  loader = loader || findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.fallbackMimeType);
  return loader;
}

function validHTTPResponse(data) {
  if (data instanceof Response) {
    if (data.status === 204) {
      return false;
    }
  }

  return true;
}

function getNoValidLoaderMessage(data) {
  var _getResourceUrlAndTyp2 = (0, _resourceUtils.getResourceUrlAndType)(data),
      url = _getResourceUrlAndTyp2.url,
      type = _getResourceUrlAndTyp2.type;

  var message = 'No valid loader found';

  if (data) {
    message += " data: \"".concat(getFirstCharacters(data), "\", contentType: \"").concat(type, "\"");
  }

  if (url) {
    message += " url: ".concat(url);
  }

  return message;
}

function normalizeLoaders(loaders) {
  var _iterator = _createForOfIteratorHelper(loaders),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var loader = _step.value;
      (0, _normalizeLoader.normalizeLoader)(loader);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}

function findLoaderByUrl(loaders, url) {
  var match = url && EXT_PATTERN.exec(url);
  var extension = match && match[1];
  return extension ? findLoaderByExtension(loaders, extension) : null;
}

function findLoaderByExtension(loaders, extension) {
  extension = extension.toLowerCase();

  var _iterator2 = _createForOfIteratorHelper(loaders),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var loader = _step2.value;

      var _iterator3 = _createForOfIteratorHelper(loader.extensions),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var loaderExtension = _step3.value;

          if (loaderExtension.toLowerCase() === extension) {
            return loader;
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return null;
}

function findLoaderByMIMEType(loaders, mimeType) {
  var _iterator4 = _createForOfIteratorHelper(loaders),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var loader = _step4.value;

      if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {
        return loader;
      }

      if (mimeType === "application/x.".concat(loader.id)) {
        return loader;
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  return null;
}

function findLoaderByInitialBytes(loaders, data) {
  if (!data) {
    return null;
  }

  var _iterator5 = _createForOfIteratorHelper(loaders),
      _step5;

  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var loader = _step5.value;

      if (typeof data === 'string') {
        if (testDataAgainstText(data, loader)) {
          return loader;
        }
      } else if (ArrayBuffer.isView(data)) {
        if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {
          return loader;
        }
      } else if (data instanceof ArrayBuffer) {
        var byteOffset = 0;

        if (testDataAgainstBinary(data, byteOffset, loader)) {
          return loader;
        }
      }
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }

  return null;
}

function testDataAgainstText(data, loader) {
  if (loader.testText) {
    return loader.testText(data);
  }

  var tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some(function (test) {
    return data.startsWith(test);
  });
}

function testDataAgainstBinary(data, byteOffset, loader) {
  var tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some(function (test) {
    return testBinary(data, byteOffset, loader, test);
  });
}

function testBinary(data, byteOffset, loader, test) {
  if (test instanceof ArrayBuffer) {
    return (0, _loaderUtils.compareArrayBuffers)(test, data, test.byteLength);
  }

  switch ((0, _typeof2.default)(test)) {
    case 'function':
      return test(data, loader);

    case 'string':
      var magic = getMagicString(data, byteOffset, test.length);
      return test === magic;

    default:
      return false;
  }
}

function getFirstCharacters(data) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;

  if (typeof data === 'string') {
    return data.slice(0, length);
  } else if (ArrayBuffer.isView(data)) {
    return getMagicString(data.buffer, data.byteOffset, length);
  } else if (data instanceof ArrayBuffer) {
    var byteOffset = 0;
    return getMagicString(data, byteOffset, length);
  }

  return '';
}

function getMagicString(arrayBuffer, byteOffset, length) {
  if (arrayBuffer.byteLength < byteOffset + length) {
    return '';
  }

  var dataView = new DataView(arrayBuffer);
  var magic = '';

  for (var i = 0; i < length; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }

  return magic;
}

},{"../../javascript-utils/is-type":42,"../loader-utils/normalize-loader":61,"../utils/resource-utils":66,"./register-loaders":49,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/toConsumableArray":28,"@babel/runtime/helpers/typeof":29,"@babel/runtime/regenerator":33,"@loaders.gl/loader-utils":73}],52:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setLoaderOptions = setLoaderOptions;

var _optionUtils = require("../loader-utils/option-utils");

function setLoaderOptions(options) {
  (0, _optionUtils.setGlobalOptions)(options);
}

},{"../loader-utils/option-utils":63}],53:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchFile = fetchFile;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _loaderUtils = require("@loaders.gl/loader-utils");

var _responseUtils = require("../utils/response-utils");

function fetchFile(_x, _x2) {
  return _fetchFile.apply(this, arguments);
}

function _fetchFile() {
  _fetchFile = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(url, options) {
    var fetchOptions;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(typeof url === 'string')) {
              _context.next = 7;
              break;
            }

            url = (0, _loaderUtils.resolvePath)(url);
            fetchOptions = options;

            if (options !== null && options !== void 0 && options.fetch && typeof (options === null || options === void 0 ? void 0 : options.fetch) !== 'function') {
              fetchOptions = options.fetch;
            }

            _context.next = 6;
            return fetch(url, fetchOptions);

          case 6:
            return _context.abrupt("return", _context.sent);

          case 7:
            _context.next = 9;
            return (0, _responseUtils.makeResponse)(url);

          case 9:
            return _context.abrupt("return", _context.sent);

          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _fetchFile.apply(this, arguments);
}

},{"../utils/response-utils":67,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33,"@loaders.gl/loader-utils":73}],54:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readArrayBuffer = readArrayBuffer;
exports.readBlob = readBlob;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _loaderUtils = require("@loaders.gl/loader-utils");

function readArrayBuffer(_x, _x2, _x3) {
  return _readArrayBuffer.apply(this, arguments);
}

function _readArrayBuffer() {
  _readArrayBuffer = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(file, start, length) {
    var slice;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(typeof file === 'number')) {
              _context.next = 4;
              break;
            }

            _context.next = 3;
            return _loaderUtils.fs._readToArrayBuffer(file, start, length);

          case 3:
            return _context.abrupt("return", _context.sent);

          case 4:
            if (!(file instanceof Blob)) {
              file = new Blob([file]);
            }

            slice = file.slice(start, start + length);
            _context.next = 8;
            return readBlob(slice);

          case 8:
            return _context.abrupt("return", _context.sent);

          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _readArrayBuffer.apply(this, arguments);
}

function readBlob(_x4) {
  return _readBlob.apply(this, arguments);
}

function _readBlob() {
  _readBlob = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(blob) {
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return new Promise(function (resolve, reject) {
              var fileReader = new FileReader();

              fileReader.onload = function (event) {
                var _event$target;

                return resolve(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);
              };

              fileReader.onerror = function (error) {
                return reject(error);
              };

              fileReader.readAsArrayBuffer(blob);
            });

          case 2:
            return _context2.abrupt("return", _context2.sent);

          case 3:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _readBlob.apply(this, arguments);
}

},{"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33,"@loaders.gl/loader-utils":73}],55:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readFileSync = readFileSync;

var _loaderUtils = require("@loaders.gl/loader-utils");

function readFileSync(url) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  url = (0, _loaderUtils.resolvePath)(url);

  if (!_loaderUtils.isBrowser) {
    var buffer = _loaderUtils.fs.readFileSync(url, options);

    return typeof buffer !== 'string' ? (0, _loaderUtils.toArrayBuffer)(buffer) : buffer;
  }

  if (!options.nothrow) {
    (0, _loaderUtils.assert)(false);
  }

  return null;
}

},{"@loaders.gl/loader-utils":73}],56:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.writeFile = writeFile;
exports.writeFileSync = writeFileSync;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _loaderUtils = require("@loaders.gl/loader-utils");

function writeFile(_x, _x2, _x3) {
  return _writeFile.apply(this, arguments);
}

function _writeFile() {
  _writeFile = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(filePath, arrayBufferOrString, options) {
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            filePath = (0, _loaderUtils.resolvePath)(filePath);

            if (_loaderUtils.isBrowser) {
              _context.next = 4;
              break;
            }

            _context.next = 4;
            return _loaderUtils.fs.writeFile(filePath, (0, _loaderUtils.toBuffer)(arrayBufferOrString), {
              flag: 'w'
            });

          case 4:
            (0, _loaderUtils.assert)(false);

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _writeFile.apply(this, arguments);
}

function writeFileSync(filePath, arrayBufferOrString, options) {
  filePath = (0, _loaderUtils.resolvePath)(filePath);

  if (!_loaderUtils.isBrowser) {
    _loaderUtils.fs.writeFileSync(filePath, (0, _loaderUtils.toBuffer)(arrayBufferOrString), {
      flag: 'w'
    });
  }

  (0, _loaderUtils.assert)(false);
}

},{"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33,"@loaders.gl/loader-utils":73}],57:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var BrowserFileSystem = function () {
  function BrowserFileSystem(files, options) {
    (0, _classCallCheck2.default)(this, BrowserFileSystem);
    (0, _defineProperty2.default)(this, "_fetch", void 0);
    (0, _defineProperty2.default)(this, "files", {});
    (0, _defineProperty2.default)(this, "lowerCaseFiles", {});
    (0, _defineProperty2.default)(this, "usedFiles", {});
    this._fetch = (options === null || options === void 0 ? void 0 : options.fetch) || fetch;

    for (var i = 0; i < files.length; ++i) {
      var file = files[i];
      this.files[file.name] = file;
      this.lowerCaseFiles[file.name.toLowerCase()] = file;
      this.usedFiles[file.name] = false;
    }

    this.fetch = this.fetch.bind(this);
  }

  (0, _createClass2.default)(BrowserFileSystem, [{
    key: "fetch",
    value: function () {
      var _fetch = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(path, options) {
        var file, headers, range, bytes, start, end, data, _response, response;

        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!path.includes('://')) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return", this._fetch(path, options));

              case 2:
                file = this.files[path];

                if (file) {
                  _context.next = 5;
                  break;
                }

                return _context.abrupt("return", new Response(path, {
                  status: 400,
                  statusText: 'NOT FOUND'
                }));

              case 5:
                headers = new Headers(options === null || options === void 0 ? void 0 : options.headers);
                range = headers.get('Range');
                bytes = range && /bytes=($1)-($2)/.exec(range);

                if (!bytes) {
                  _context.next = 17;
                  break;
                }

                start = parseInt(bytes[1]);
                end = parseInt(bytes[2]);
                _context.next = 13;
                return file.slice(start, end).arrayBuffer();

              case 13:
                data = _context.sent;
                _response = new Response(data);
                Object.defineProperty(_response, 'url', {
                  value: path
                });
                return _context.abrupt("return", _response);

              case 17:
                response = new Response(file);
                Object.defineProperty(response, 'url', {
                  value: path
                });
                return _context.abrupt("return", response);

              case 20:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function fetch(_x, _x2) {
        return _fetch.apply(this, arguments);
      }

      return fetch;
    }()
  }, {
    key: "readdir",
    value: function () {
      var _readdir = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(dirname) {
        var files, path;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                files = [];

                for (path in this.files) {
                  files.push(path);
                }

                return _context2.abrupt("return", files);

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function readdir(_x3) {
        return _readdir.apply(this, arguments);
      }

      return readdir;
    }()
  }, {
    key: "stat",
    value: function () {
      var _stat = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(path, options) {
        var file;
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                file = this.files[path];

                if (file) {
                  _context3.next = 3;
                  break;
                }

                throw new Error(path);

              case 3:
                return _context3.abrupt("return", {
                  size: file.size
                });

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function stat(_x4, _x5) {
        return _stat.apply(this, arguments);
      }

      return stat;
    }()
  }, {
    key: "unlink",
    value: function () {
      var _unlink = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee4(path) {
        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                delete this.files[path];
                delete this.lowerCaseFiles[path];
                this.usedFiles[path] = true;

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function unlink(_x6) {
        return _unlink.apply(this, arguments);
      }

      return unlink;
    }()
  }, {
    key: "open",
    value: function () {
      var _open = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee5(pathname, flags, mode) {
        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                return _context5.abrupt("return", this.files[pathname]);

              case 1:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function open(_x7, _x8, _x9) {
        return _open.apply(this, arguments);
      }

      return open;
    }()
  }, {
    key: "read",
    value: function () {
      var _read = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee6(fd, buffer) {
        var offset,
            length,
            position,
            file,
            startPosition,
            arrayBuffer,
            _args6 = arguments;
        return _regenerator.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                offset = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : 0;
                length = _args6.length > 3 && _args6[3] !== undefined ? _args6[3] : buffer.byteLength;
                position = _args6.length > 4 && _args6[4] !== undefined ? _args6[4] : null;
                file = fd;
                startPosition = 0;
                _context6.next = 7;
                return file.slice(startPosition, startPosition + length).arrayBuffer();

              case 7:
                arrayBuffer = _context6.sent;
                return _context6.abrupt("return", {
                  bytesRead: length,
                  buffer: arrayBuffer
                });

              case 9:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));

      function read(_x10, _x11) {
        return _read.apply(this, arguments);
      }

      return read;
    }()
  }, {
    key: "close",
    value: function () {
      var _close = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee7(fd) {
        return _regenerator.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));

      function close(_x12) {
        return _close.apply(this, arguments);
      }

      return close;
    }()
  }, {
    key: "_getFile",
    value: function _getFile(path, used) {
      var file = this.files[path] || this.lowerCaseFiles[path];

      if (file && used) {
        this.usedFiles[path] = true;
      }

      return file;
    }
  }]);
  return BrowserFileSystem;
}();

exports.default = BrowserFileSystem;

},{"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],58:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getArrayBufferOrStringFromDataSync = getArrayBufferOrStringFromDataSync;
exports.getArrayBufferOrStringFromData = getArrayBufferOrStringFromData;
exports.getAsyncIterableFromData = getAsyncIterableFromData;
exports.getReadableStream = getReadableStream;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _loaderUtils = require("@loaders.gl/loader-utils");

var _isType = require("../../javascript-utils/is-type");

var _makeIterator = require("../../iterators/make-iterator/make-iterator");

var _responseUtils = require("../utils/response-utils");

var ERR_DATA = 'Cannot convert supplied data type';

function getArrayBufferOrStringFromDataSync(data, loader, options) {
  if (loader.text && typeof data === 'string') {
    return data;
  }

  if ((0, _isType.isBuffer)(data)) {
    data = data.buffer;
  }

  if (data instanceof ArrayBuffer) {
    var arrayBuffer = data;

    if (loader.text && !loader.binary) {
      var textDecoder = new TextDecoder('utf8');
      return textDecoder.decode(arrayBuffer);
    }

    return arrayBuffer;
  }

  if (ArrayBuffer.isView(data)) {
    if (loader.text && !loader.binary) {
      var _textDecoder = new TextDecoder('utf8');

      return _textDecoder.decode(data);
    }

    var _arrayBuffer = data.buffer;
    var byteLength = data.byteLength || data.length;

    if (data.byteOffset !== 0 || byteLength !== _arrayBuffer.byteLength) {
      _arrayBuffer = _arrayBuffer.slice(data.byteOffset, data.byteOffset + byteLength);
    }

    return _arrayBuffer;
  }

  throw new Error(ERR_DATA);
}

function getArrayBufferOrStringFromData(_x, _x2, _x3) {
  return _getArrayBufferOrStringFromData.apply(this, arguments);
}

function _getArrayBufferOrStringFromData() {
  _getArrayBufferOrStringFromData = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(data, loader, options) {
    var isArrayBuffer, response;
    return _regenerator.default.wrap(function _callee$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);

            if (!(typeof data === 'string' || isArrayBuffer)) {
              _context3.next = 3;
              break;
            }

            return _context3.abrupt("return", getArrayBufferOrStringFromDataSync(data, loader, options));

          case 3:
            if (!(0, _isType.isBlob)(data)) {
              _context3.next = 7;
              break;
            }

            _context3.next = 6;
            return (0, _responseUtils.makeResponse)(data);

          case 6:
            data = _context3.sent;

          case 7:
            if (!(0, _isType.isResponse)(data)) {
              _context3.next = 21;
              break;
            }

            response = data;
            _context3.next = 11;
            return (0, _responseUtils.checkResponse)(response);

          case 11:
            if (!loader.binary) {
              _context3.next = 17;
              break;
            }

            _context3.next = 14;
            return response.arrayBuffer();

          case 14:
            _context3.t0 = _context3.sent;
            _context3.next = 20;
            break;

          case 17:
            _context3.next = 19;
            return response.text();

          case 19:
            _context3.t0 = _context3.sent;

          case 20:
            return _context3.abrupt("return", _context3.t0);

          case 21:
            if ((0, _isType.isReadableStream)(data)) {
              data = (0, _makeIterator.makeIterator)(data, options);
            }

            if (!((0, _isType.isIterable)(data) || (0, _isType.isAsyncIterable)(data))) {
              _context3.next = 24;
              break;
            }

            return _context3.abrupt("return", (0, _loaderUtils.concatenateArrayBuffersAsync)(data));

          case 24:
            throw new Error(ERR_DATA);

          case 25:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee);
  }));
  return _getArrayBufferOrStringFromData.apply(this, arguments);
}

function getAsyncIterableFromData(_x4, _x5) {
  return _getAsyncIterableFromData.apply(this, arguments);
}

function _getAsyncIterableFromData() {
  _getAsyncIterableFromData = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(data, options) {
    var response, body;
    return _regenerator.default.wrap(function _callee2$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (!(0, _isType.isIterator)(data)) {
              _context4.next = 2;
              break;
            }

            return _context4.abrupt("return", data);

          case 2:
            if (!(0, _isType.isResponse)(data)) {
              _context4.next = 10;
              break;
            }

            response = data;
            _context4.next = 6;
            return (0, _responseUtils.checkResponse)(response);

          case 6:
            _context4.next = 8;
            return response.body;

          case 8:
            body = _context4.sent;
            return _context4.abrupt("return", (0, _makeIterator.makeIterator)(body, options));

          case 10:
            if (!((0, _isType.isBlob)(data) || (0, _isType.isReadableStream)(data))) {
              _context4.next = 12;
              break;
            }

            return _context4.abrupt("return", (0, _makeIterator.makeIterator)(data, options));

          case 12:
            if (!(0, _isType.isAsyncIterable)(data)) {
              _context4.next = 14;
              break;
            }

            return _context4.abrupt("return", data[Symbol.asyncIterator]());

          case 14:
            return _context4.abrupt("return", getIterableFromData(data));

          case 15:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee2);
  }));
  return _getAsyncIterableFromData.apply(this, arguments);
}

function getReadableStream(_x6) {
  return _getReadableStream.apply(this, arguments);
}

function _getReadableStream() {
  _getReadableStream = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(data) {
    var response;
    return _regenerator.default.wrap(function _callee3$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            if (!(0, _isType.isReadableStream)(data)) {
              _context5.next = 2;
              break;
            }

            return _context5.abrupt("return", data);

          case 2:
            if (!(0, _isType.isResponse)(data)) {
              _context5.next = 4;
              break;
            }

            return _context5.abrupt("return", data.body);

          case 4:
            _context5.next = 6;
            return (0, _responseUtils.makeResponse)(data);

          case 6:
            response = _context5.sent;
            return _context5.abrupt("return", response.body);

          case 8:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee3);
  }));
  return _getReadableStream.apply(this, arguments);
}

function getIterableFromData(data) {
  if (ArrayBuffer.isView(data)) {
    return _regenerator.default.mark(function oneChunk() {
      return _regenerator.default.wrap(function oneChunk$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return data.buffer;

            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, oneChunk);
    })();
  }

  if (data instanceof ArrayBuffer) {
    return _regenerator.default.mark(function oneChunk() {
      return _regenerator.default.wrap(function oneChunk$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return data;

            case 2:
            case "end":
              return _context2.stop();
          }
        }
      }, oneChunk);
    })();
  }

  if ((0, _isType.isIterator)(data)) {
    return data;
  }

  if ((0, _isType.isIterable)(data)) {
    return data[Symbol.iterator]();
  }

  throw new Error(ERR_DATA);
}

},{"../../iterators/make-iterator/make-iterator":37,"../../javascript-utils/is-type":42,"../utils/response-utils":67,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33,"@loaders.gl/loader-utils":73}],59:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLoaderContext = getLoaderContext;
exports.getLoadersFromContext = getLoadersFromContext;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _optionUtils = require("./option-utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function getLoaderContext(context, options) {
  var previousContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  if (previousContext) {
    return previousContext;
  }

  var resolvedContext = _objectSpread({
    fetch: (0, _optionUtils.getFetchFunction)(options, context)
  }, context);

  if (!Array.isArray(resolvedContext.loaders)) {
    resolvedContext.loaders = null;
  }

  return resolvedContext;
}

function getLoadersFromContext(loaders, context) {
  if (!context && loaders && !Array.isArray(loaders)) {
    return loaders;
  }

  var candidateLoaders;

  if (loaders) {
    candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];
  }

  if (context && context.loaders) {
    var contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];
    candidateLoaders = candidateLoaders ? [].concat((0, _toConsumableArray2.default)(candidateLoaders), (0, _toConsumableArray2.default)(contextLoaders)) : contextLoaders;
  }

  return candidateLoaders && candidateLoaders.length ? candidateLoaders : null;
}

},{"./option-utils":63,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/toConsumableArray":28}],60:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConsoleLog = exports.NullLog = exports.probeLog = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _probe = require("probe.gl");

var probeLog = new _probe.Log({
  id: 'loaders.gl'
});
exports.probeLog = probeLog;

var NullLog = function () {
  function NullLog() {
    (0, _classCallCheck2.default)(this, NullLog);
  }

  (0, _createClass2.default)(NullLog, [{
    key: "log",
    value: function log() {
      return function () {};
    }
  }, {
    key: "info",
    value: function info() {
      return function () {};
    }
  }, {
    key: "warn",
    value: function warn() {
      return function () {};
    }
  }, {
    key: "error",
    value: function error() {
      return function () {};
    }
  }]);
  return NullLog;
}();

exports.NullLog = NullLog;

var ConsoleLog = function () {
  function ConsoleLog() {
    (0, _classCallCheck2.default)(this, ConsoleLog);
    (0, _defineProperty2.default)(this, "console", void 0);
    this.console = console;
  }

  (0, _createClass2.default)(ConsoleLog, [{
    key: "log",
    value: function log() {
      var _this$console$log;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return (_this$console$log = this.console.log).bind.apply(_this$console$log, [this.console].concat(args));
    }
  }, {
    key: "info",
    value: function info() {
      var _this$console$info;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return (_this$console$info = this.console.info).bind.apply(_this$console$info, [this.console].concat(args));
    }
  }, {
    key: "warn",
    value: function warn() {
      var _this$console$warn;

      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return (_this$console$warn = this.console.warn).bind.apply(_this$console$warn, [this.console].concat(args));
    }
  }, {
    key: "error",
    value: function error() {
      var _this$console$error;

      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return (_this$console$error = this.console.error).bind.apply(_this$console$error, [this.console].concat(args));
    }
  }]);
  return ConsoleLog;
}();

exports.ConsoleLog = ConsoleLog;

},{"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"probe.gl":143}],61:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isLoaderObject = isLoaderObject;
exports.normalizeLoader = normalizeLoader;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _loaderUtils = require("@loaders.gl/loader-utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function isLoaderObject(loader) {
  var _loader;

  if (!loader) {
    return false;
  }

  if (Array.isArray(loader)) {
    loader = loader[0];
  }

  var hasExtensions = Array.isArray((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.extensions);
  return hasExtensions;
}

function normalizeLoader(loader) {
  var _loader2, _loader3;

  (0, _loaderUtils.assert)(loader, 'null loader');
  (0, _loaderUtils.assert)(isLoaderObject(loader), 'invalid loader');
  var options;

  if (Array.isArray(loader)) {
    options = loader[1];
    loader = loader[0];
    loader = _objectSpread(_objectSpread({}, loader), {}, {
      options: _objectSpread(_objectSpread({}, loader.options), options)
    });
  }

  if ((_loader2 = loader) !== null && _loader2 !== void 0 && _loader2.parseTextSync || (_loader3 = loader) !== null && _loader3 !== void 0 && _loader3.parseText) {
    loader.text = true;
  }

  if (!loader.text) {
    loader.binary = true;
  }

  return loader;
}

},{"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@loaders.gl/loader-utils":73}],62:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.REMOVED_LOADER_OPTIONS = exports.DEFAULT_LOADER_OPTIONS = void 0;

var _loggers = require("./loggers");

var DEFAULT_LOADER_OPTIONS = {
  fetch: null,
  mimeType: undefined,
  nothrow: false,
  log: new _loggers.ConsoleLog(),
  CDN: 'https://unpkg.com/@loaders.gl',
  worker: true,
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: true,
  _workerType: '',
  limit: 0,
  _limitMB: 0,
  batchSize: 'auto',
  batchDebounceMs: 0,
  metadata: false,
  transforms: []
};
exports.DEFAULT_LOADER_OPTIONS = DEFAULT_LOADER_OPTIONS;
var REMOVED_LOADER_OPTIONS = {
  throws: 'nothrow',
  dataType: '(no longer used)',
  uri: 'baseUri',
  method: 'fetch.method',
  headers: 'fetch.headers',
  body: 'fetch.body',
  mode: 'fetch.mode',
  credentials: 'fetch.credentials',
  cache: 'fetch.cache',
  redirect: 'fetch.redirect',
  referrer: 'fetch.referrer',
  referrerPolicy: 'fetch.referrerPolicy',
  integrity: 'fetch.integrity',
  keepalive: 'fetch.keepalive',
  signal: 'fetch.signal'
};
exports.REMOVED_LOADER_OPTIONS = REMOVED_LOADER_OPTIONS;

},{"./loggers":60}],63:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getGlobalLoaderState = getGlobalLoaderState;
exports.setGlobalOptions = setGlobalOptions;
exports.normalizeOptions = normalizeOptions;
exports.getFetchFunction = getFetchFunction;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _loaderUtils = require("@loaders.gl/loader-utils");

var _isType = require("../../javascript-utils/is-type");

var _fetchFile = require("../fetch/fetch-file");

var _loggers = require("./loggers");

var _optionDefaults = require("./option-defaults");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function getGlobalLoaderState() {
  _loaderUtils.global.loaders = _loaderUtils.global.loaders || {};
  var loaders = _loaderUtils.global.loaders;
  loaders._state = loaders._state || {};
  return loaders._state;
}

var getGlobalLoaderOptions = function getGlobalLoaderOptions() {
  var state = getGlobalLoaderState();
  state.globalOptions = state.globalOptions || _objectSpread({}, _optionDefaults.DEFAULT_LOADER_OPTIONS);
  return state.globalOptions;
};

function setGlobalOptions(options) {
  var state = getGlobalLoaderState();
  var globalOptions = getGlobalLoaderOptions();
  state.globalOptions = normalizeOptionsInternal(globalOptions, options);
}

function normalizeOptions(options, loader, loaders, url) {
  loaders = loaders || [];
  loaders = Array.isArray(loaders) ? loaders : [loaders];
  validateOptions(options, loaders);
  return normalizeOptionsInternal(loader, options, url);
}

function getFetchFunction(options, context) {
  var globalOptions = getGlobalLoaderOptions();
  var fetchOptions = options || globalOptions;

  if (typeof fetchOptions.fetch === 'function') {
    return fetchOptions.fetch;
  }

  if ((0, _isType.isObject)(fetchOptions.fetch)) {
    return function (url) {
      return (0, _fetchFile.fetchFile)(url, fetchOptions);
    };
  }

  if (context !== null && context !== void 0 && context.fetch) {
    return context === null || context === void 0 ? void 0 : context.fetch;
  }

  return _fetchFile.fetchFile;
}

function validateOptions(options, loaders) {
  validateOptionsObject(options, null, _optionDefaults.DEFAULT_LOADER_OPTIONS, _optionDefaults.REMOVED_LOADER_OPTIONS, loaders);

  var _iterator = _createForOfIteratorHelper(loaders),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var loader = _step.value;
      var idOptions = options && options[loader.id] || {};
      var loaderOptions = loader.options && loader.options[loader.id] || {};
      var deprecatedOptions = loader.deprecatedOptions && loader.deprecatedOptions[loader.id] || {};
      validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}

function validateOptionsObject(options, id, defaultOptions, deprecatedOptions, loaders) {
  var loaderName = id || 'Top level';
  var prefix = id ? "".concat(id, ".") : '';

  for (var _key in options) {
    var isSubOptions = !id && (0, _isType.isObject)(options[_key]);
    var isBaseUriOption = _key === 'baseUri' && !id;
    var isWorkerUrlOption = _key === 'workerUrl' && id;

    if (!(_key in defaultOptions) && !isBaseUriOption && !isWorkerUrlOption) {
      if (_key in deprecatedOptions) {
        _loggers.probeLog.warn("".concat(loaderName, " loader option '").concat(prefix).concat(_key, "' no longer supported, use '").concat(deprecatedOptions[_key], "'"))();
      } else if (!isSubOptions) {
        var suggestion = findSimilarOption(_key, loaders);

        _loggers.probeLog.warn("".concat(loaderName, " loader option '").concat(prefix).concat(_key, "' not recognized. ").concat(suggestion))();
      }
    }
  }
}

function findSimilarOption(optionKey, loaders) {
  var lowerCaseOptionKey = optionKey.toLowerCase();
  var bestSuggestion = '';

  var _iterator2 = _createForOfIteratorHelper(loaders),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var loader = _step2.value;

      for (var _key2 in loader.options) {
        if (optionKey === _key2) {
          return "Did you mean '".concat(loader.id, ".").concat(_key2, "'?");
        }

        var lowerCaseKey = _key2.toLowerCase();

        var isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);

        if (isPartialMatch) {
          bestSuggestion = bestSuggestion || "Did you mean '".concat(loader.id, ".").concat(_key2, "'?");
        }
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return bestSuggestion;
}

function normalizeOptionsInternal(loader, options, url) {
  var loaderDefaultOptions = loader.options || {};

  var mergedOptions = _objectSpread({}, loaderDefaultOptions);

  addUrlOptions(mergedOptions, url);

  if (mergedOptions.log === null) {
    mergedOptions.log = new _loggers.NullLog();
  }

  mergeNestedFields(mergedOptions, getGlobalLoaderOptions());
  mergeNestedFields(mergedOptions, options);
  return mergedOptions;
}

function mergeNestedFields(mergedOptions, options) {
  for (var _key3 in options) {
    if (_key3 in options) {
      var value = options[_key3];

      if ((0, _isType.isPureObject)(value) && (0, _isType.isPureObject)(mergedOptions[_key3])) {
        mergedOptions[_key3] = _objectSpread(_objectSpread({}, mergedOptions[_key3]), options[_key3]);
      } else {
        mergedOptions[_key3] = options[_key3];
      }
    }
  }
}

function addUrlOptions(options, url) {
  if (url && !('baseUri' in options)) {
    options.baseUri = url;
  }
}

},{"../../javascript-utils/is-type":42,"../fetch/fetch-file":53,"./loggers":60,"./option-defaults":62,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@loaders.gl/loader-utils":73}],64:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fetchProgress;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

function fetchProgress(_x, _x2) {
  return _fetchProgress.apply(this, arguments);
}

function _fetchProgress() {
  _fetchProgress = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(response, onProgress) {
    var onDone,
        onError,
        body,
        contentLength,
        totalBytes,
        progressStream,
        _args2 = arguments;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            onDone = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : function () {};
            onError = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : function () {};
            _context2.next = 4;
            return response;

          case 4:
            response = _context2.sent;

            if (response.ok) {
              _context2.next = 7;
              break;
            }

            return _context2.abrupt("return", response);

          case 7:
            body = response.body;

            if (body) {
              _context2.next = 10;
              break;
            }

            return _context2.abrupt("return", response);

          case 10:
            contentLength = response.headers.get('content-length') || 0;
            totalBytes = contentLength && parseInt(contentLength);

            if (contentLength > 0) {
              _context2.next = 14;
              break;
            }

            return _context2.abrupt("return", response);

          case 14:
            if (!(typeof ReadableStream === 'undefined' || !body.getReader)) {
              _context2.next = 16;
              break;
            }

            return _context2.abrupt("return", response);

          case 16:
            progressStream = new ReadableStream({
              start: function start(controller) {
                return (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {
                  var reader;
                  return _regenerator.default.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          reader = body.getReader();
                          _context.next = 3;
                          return read(controller, reader, 0, totalBytes, onProgress, onDone, onError);

                        case 3:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee);
                }))();
              }
            });
            return _context2.abrupt("return", new Response(progressStream));

          case 18:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _fetchProgress.apply(this, arguments);
}

function read(_x3, _x4, _x5, _x6, _x7, _x8, _x9) {
  return _read.apply(this, arguments);
}

function _read() {
  _read = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError) {
    var _yield$reader$read, done, value, percent;

    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.prev = 0;
            _context3.next = 3;
            return reader.read();

          case 3:
            _yield$reader$read = _context3.sent;
            done = _yield$reader$read.done;
            value = _yield$reader$read.value;

            if (!done) {
              _context3.next = 10;
              break;
            }

            onDone();
            controller.close();
            return _context3.abrupt("return");

          case 10:
            loadedBytes += value.byteLength;
            percent = Math.round(loadedBytes / totalBytes * 100);
            onProgress(percent, {
              loadedBytes: loadedBytes,
              totalBytes: totalBytes
            });
            controller.enqueue(value);
            _context3.next = 16;
            return read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError);

          case 16:
            _context3.next = 22;
            break;

          case 18:
            _context3.prev = 18;
            _context3.t0 = _context3["catch"](0);
            controller.error(_context3.t0);
            onError(_context3.t0);

          case 22:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[0, 18]]);
  }));
  return _read.apply(this, arguments);
}

},{"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],65:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseMIMEType = parseMIMEType;
exports.parseMIMETypeFromURL = parseMIMETypeFromURL;
var DATA_URL_PATTERN = /^data:([-\w.]+\/[-\w.+]+)(;|,)/;
var MIME_TYPE_PATTERN = /^([-\w.]+\/[-\w.+]+)/;

function parseMIMEType(mimeString) {
  var matches = MIME_TYPE_PATTERN.exec(mimeString);

  if (matches) {
    return matches[1];
  }

  return mimeString;
}

function parseMIMETypeFromURL(url) {
  var matches = DATA_URL_PATTERN.exec(url);

  if (matches) {
    return matches[1];
  }

  return '';
}

},{}],66:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getResourceUrlAndType = getResourceUrlAndType;
exports.getResourceContentLength = getResourceContentLength;

var _isType = require("../../javascript-utils/is-type");

var _mimeTypeUtils = require("./mime-type-utils");

var QUERY_STRING_PATTERN = /\?.*/;

function getResourceUrlAndType(resource) {
  if ((0, _isType.isResponse)(resource)) {
    var url = stripQueryString(resource.url || '');
    var contentTypeHeader = resource.headers.get('content-type') || '';
    return {
      url: url,
      type: (0, _mimeTypeUtils.parseMIMEType)(contentTypeHeader) || (0, _mimeTypeUtils.parseMIMETypeFromURL)(url)
    };
  }

  if ((0, _isType.isBlob)(resource)) {
    return {
      url: stripQueryString(resource.name || ''),
      type: resource.type || ''
    };
  }

  if (typeof resource === 'string') {
    return {
      url: stripQueryString(resource),
      type: (0, _mimeTypeUtils.parseMIMETypeFromURL)(resource)
    };
  }

  return {
    url: '',
    type: ''
  };
}

function getResourceContentLength(resource) {
  if ((0, _isType.isResponse)(resource)) {
    return resource.headers['content-length'] || -1;
  }

  if ((0, _isType.isBlob)(resource)) {
    return resource.size;
  }

  if (typeof resource === 'string') {
    return resource.length;
  }

  if (resource instanceof ArrayBuffer) {
    return resource.byteLength;
  }

  if (ArrayBuffer.isView(resource)) {
    return resource.byteLength;
  }

  return -1;
}

function stripQueryString(url) {
  return url.replace(QUERY_STRING_PATTERN, '');
}

},{"../../javascript-utils/is-type":42,"./mime-type-utils":65}],67:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeResponse = makeResponse;
exports.checkResponse = checkResponse;
exports.checkResponseSync = checkResponseSync;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _isType = require("../../javascript-utils/is-type");

var _resourceUtils = require("./resource-utils");

function makeResponse(_x) {
  return _makeResponse.apply(this, arguments);
}

function _makeResponse() {
  _makeResponse = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(resource) {
    var headers, contentLength, _getResourceUrlAndTyp, url, type, initialDataUrl, response;

    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(0, _isType.isResponse)(resource)) {
              _context.next = 2;
              break;
            }

            return _context.abrupt("return", resource);

          case 2:
            headers = {};
            contentLength = (0, _resourceUtils.getResourceContentLength)(resource);

            if (contentLength >= 0) {
              headers['content-length'] = String(contentLength);
            }

            _getResourceUrlAndTyp = (0, _resourceUtils.getResourceUrlAndType)(resource), url = _getResourceUrlAndTyp.url, type = _getResourceUrlAndTyp.type;

            if (type) {
              headers['content-type'] = type;
            }

            _context.next = 9;
            return getInitialDataUrl(resource);

          case 9:
            initialDataUrl = _context.sent;

            if (initialDataUrl) {
              headers['x-first-bytes'] = initialDataUrl;
            }

            if (typeof resource === 'string') {
              resource = new TextEncoder().encode(resource);
            }

            response = new Response(resource, {
              headers: headers
            });
            Object.defineProperty(response, 'url', {
              value: url
            });
            return _context.abrupt("return", response);

          case 15:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _makeResponse.apply(this, arguments);
}

function checkResponse(_x2) {
  return _checkResponse.apply(this, arguments);
}

function _checkResponse() {
  _checkResponse = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(response) {
    var message;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (response.ok) {
              _context2.next = 5;
              break;
            }

            _context2.next = 3;
            return getResponseError(response);

          case 3:
            message = _context2.sent;
            throw new Error(message);

          case 5:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _checkResponse.apply(this, arguments);
}

function checkResponseSync(response) {
  if (!response.ok) {
    var message = "".concat(response.status, " ").concat(response.statusText);
    message = message.length > 60 ? "".concat(message.slice(60), "...") : message;
    throw new Error(message);
  }
}

function getResponseError(_x3) {
  return _getResponseError.apply(this, arguments);
}

function _getResponseError() {
  _getResponseError = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(response) {
    var message, contentType, text;
    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            message = "Failed to fetch resource ".concat(response.url, " (").concat(response.status, "): ");
            _context3.prev = 1;
            contentType = response.headers.get('Content-Type');
            text = response.statusText;

            if (!contentType.includes('application/json')) {
              _context3.next = 11;
              break;
            }

            _context3.t0 = text;
            _context3.t1 = " ";
            _context3.next = 9;
            return response.text();

          case 9:
            _context3.t2 = _context3.sent;
            text = _context3.t0 += _context3.t1.concat.call(_context3.t1, _context3.t2);

          case 11:
            message += text;
            message = message.length > 60 ? "".concat(message.slice(60), "...") : message;
            _context3.next = 17;
            break;

          case 15:
            _context3.prev = 15;
            _context3.t3 = _context3["catch"](1);

          case 17:
            return _context3.abrupt("return", message);

          case 18:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[1, 15]]);
  }));
  return _getResponseError.apply(this, arguments);
}

function getInitialDataUrl(_x4) {
  return _getInitialDataUrl.apply(this, arguments);
}

function _getInitialDataUrl() {
  _getInitialDataUrl = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee4(resource) {
    var INITIAL_DATA_LENGTH, blobSlice, slice, base64;
    return _regenerator.default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            INITIAL_DATA_LENGTH = 5;

            if (!(typeof resource === 'string')) {
              _context4.next = 3;
              break;
            }

            return _context4.abrupt("return", "data:,".concat(resource.slice(0, INITIAL_DATA_LENGTH)));

          case 3:
            if (!(resource instanceof Blob)) {
              _context4.next = 8;
              break;
            }

            blobSlice = resource.slice(0, 5);
            _context4.next = 7;
            return new Promise(function (resolve) {
              var reader = new FileReader();

              reader.onload = function (event) {
                var _event$target;

                return resolve(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);
              };

              reader.readAsDataURL(blobSlice);
            });

          case 7:
            return _context4.abrupt("return", _context4.sent);

          case 8:
            if (!(resource instanceof ArrayBuffer)) {
              _context4.next = 12;
              break;
            }

            slice = resource.slice(0, INITIAL_DATA_LENGTH);
            base64 = arrayBufferToBase64(slice);
            return _context4.abrupt("return", "data:base64,".concat(base64));

          case 12:
            return _context4.abrupt("return", null);

          case 13:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _getInitialDataUrl.apply(this, arguments);
}

function arrayBufferToBase64(buffer) {
  var binary = '';
  var bytes = new Uint8Array(buffer);

  for (var i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }

  return btoa(binary);
}

},{"../../javascript-utils/is-type":42,"./resource-utils":66,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],68:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NullLoader = exports.NullWorkerLoader = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _awaitAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/awaitAsyncGenerator"));

var _wrapAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapAsyncGenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

var VERSION = typeof "3.0.9" !== 'undefined' ? "3.0.9" : 'latest';
var NullWorkerLoader = {
  name: 'Null loader',
  id: 'null',
  module: 'core',
  version: VERSION,
  worker: true,
  mimeTypes: ['application/x.empty'],
  extensions: ['null'],
  tests: [function () {
    return false;
  }],
  options: {
    null: {}
  }
};
exports.NullWorkerLoader = NullWorkerLoader;
var NullLoader = {
  name: 'Null loader',
  id: 'null',
  module: 'core',
  version: VERSION,
  mimeTypes: ['application/x.empty'],
  extensions: ['null'],
  parse: function () {
    var _parse = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(arrayBuffer) {
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", arrayBuffer);

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function parse(_x2) {
      return _parse.apply(this, arguments);
    }

    return parse;
  }(),
  parseSync: function parseSync(arrayBuffer) {
    return arrayBuffer;
  },
  parseInBatches: function () {
    var _generator = (0, _wrapAsyncGenerator2.default)(_regenerator.default.mark(function _callee2(asyncIterator) {
      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, batch;

      return _regenerator.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _context2.prev = 2;
              _iterator = (0, _asyncIterator2.default)(asyncIterator);

            case 4:
              _context2.next = 6;
              return (0, _awaitAsyncGenerator2.default)(_iterator.next());

            case 6:
              _step = _context2.sent;
              _iteratorNormalCompletion = _step.done;
              _context2.next = 10;
              return (0, _awaitAsyncGenerator2.default)(_step.value);

            case 10:
              _value = _context2.sent;

              if (_iteratorNormalCompletion) {
                _context2.next = 18;
                break;
              }

              batch = _value;
              _context2.next = 15;
              return batch;

            case 15:
              _iteratorNormalCompletion = true;
              _context2.next = 4;
              break;

            case 18:
              _context2.next = 24;
              break;

            case 20:
              _context2.prev = 20;
              _context2.t0 = _context2["catch"](2);
              _didIteratorError = true;
              _iteratorError = _context2.t0;

            case 24:
              _context2.prev = 24;
              _context2.prev = 25;

              if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
                _context2.next = 29;
                break;
              }

              _context2.next = 29;
              return (0, _awaitAsyncGenerator2.default)(_iterator.return());

            case 29:
              _context2.prev = 29;

              if (!_didIteratorError) {
                _context2.next = 32;
                break;
              }

              throw _iteratorError;

            case 32:
              return _context2.finish(29);

            case 33:
              return _context2.finish(24);

            case 34:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[2, 20, 24, 34], [25,, 29, 33]]);
    }));

    function generator(_x) {
      return _generator.apply(this, arguments);
    }

    return generator;
  }(),
  tests: [function () {
    return false;
  }],
  options: {
    null: {}
  }
};
exports.NullLoader = NullLoader;

},{"@babel/runtime/helpers/asyncIterator":9,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/awaitAsyncGenerator":11,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/wrapAsyncGenerator":31,"@babel/runtime/regenerator":33}],69:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._typecheckCSVLoader = exports.CSVLoader = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _schema = require("@loaders.gl/schema");

var _papaparse = _interopRequireDefault(require("./libs/papaparse"));

var _asyncIteratorStreamer = _interopRequireDefault(require("./lib/async-iterator-streamer"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var VERSION = typeof "3.0.9" !== 'undefined' ? "3.0.9" : 'latest';
var DEFAULT_CSV_LOADER_OPTIONS = {
  csv: {
    shape: 'object-row-table',
    optimizeMemoryUsage: false,
    header: 'auto',
    columnPrefix: 'column',
    quoteChar: '"',
    escapeChar: '"',
    dynamicTyping: true,
    comments: false,
    skipEmptyLines: true,
    delimitersToGuess: [',', '\t', '|', ';']
  }
};
var CSVLoader = {
  id: 'csv',
  module: 'csv',
  name: 'CSV',
  version: VERSION,
  extensions: ['csv'],
  mimeTypes: ['text/csv'],
  category: 'table',
  parse: function () {
    var _parse = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(arrayBuffer, options) {
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", parseCSV(new TextDecoder().decode(arrayBuffer), options));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function parse(_x, _x2) {
      return _parse.apply(this, arguments);
    }

    return parse;
  }(),
  parseText: function parseText(text, options) {
    return parseCSV(text, options);
  },
  parseInBatches: parseCSVInBatches,
  options: DEFAULT_CSV_LOADER_OPTIONS
};
exports.CSVLoader = CSVLoader;

function parseCSV(_x3, _x4) {
  return _parseCSV.apply(this, arguments);
}

function _parseCSV() {
  _parseCSV = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(csvText, options) {
    var csvOptions, firstRow, header, parseWithHeader, papaparseConfig, result, rows, headerRow;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            csvOptions = _objectSpread(_objectSpread({}, DEFAULT_CSV_LOADER_OPTIONS.csv), options === null || options === void 0 ? void 0 : options.csv);
            firstRow = readFirstRow(csvText);
            header = csvOptions.header === 'auto' ? isHeaderRow(firstRow) : Boolean(csvOptions.header);
            parseWithHeader = header;
            papaparseConfig = _objectSpread(_objectSpread({}, csvOptions), {}, {
              header: parseWithHeader,
              download: false,
              transformHeader: parseWithHeader ? duplicateColumnTransformer() : undefined,
              error: function error(e) {
                throw new Error(e);
              }
            });
            result = _papaparse.default.parse(csvText, papaparseConfig);
            rows = result.data;
            headerRow = result.meta.fields || generateHeader(csvOptions.columnPrefix, firstRow.length);
            _context2.t0 = csvOptions.shape;
            _context2.next = _context2.t0 === 'object-row-table' ? 11 : _context2.t0 === 'array-row-table' ? 13 : 15;
            break;

          case 11:
            rows = rows.map(function (row) {
              return Array.isArray(row) ? (0, _schema.convertToObjectRow)(row, headerRow) : row;
            });
            return _context2.abrupt("break", 15);

          case 13:
            rows = rows.map(function (row) {
              return Array.isArray(row) ? row : (0, _schema.convertToArrayRow)(row, headerRow);
            });
            return _context2.abrupt("break", 15);

          case 15:
            return _context2.abrupt("return", rows);

          case 16:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _parseCSV.apply(this, arguments);
}

function parseCSVInBatches(asyncIterator, options) {
  var _options;

  options = _objectSpread({}, options);

  if (options.batchSize === 'auto') {
    options.batchSize = 4000;
  }

  var csvOptions = _objectSpread(_objectSpread({}, DEFAULT_CSV_LOADER_OPTIONS.csv), (_options = options) === null || _options === void 0 ? void 0 : _options.csv);

  var asyncQueue = new _schema.AsyncQueue();
  var isFirstRow = true;
  var headerRow = null;
  var tableBatchBuilder = null;
  var schema = null;

  var config = _objectSpread(_objectSpread({}, csvOptions), {}, {
    header: false,
    download: false,
    chunkSize: 1024 * 1024 * 5,
    skipEmptyLines: false,
    step: function step(results) {
      var row = results.data;

      if (csvOptions.skipEmptyLines) {
        var collapsedRow = row.flat().join('').trim();

        if (collapsedRow === '') {
          return;
        }
      }

      var bytesUsed = results.meta.cursor;

      if (isFirstRow && !headerRow) {
        var header = csvOptions.header === 'auto' ? isHeaderRow(row) : Boolean(csvOptions.header);

        if (header) {
          headerRow = row.map(duplicateColumnTransformer());
          return;
        }
      }

      if (isFirstRow) {
        isFirstRow = false;

        if (!headerRow) {
          headerRow = generateHeader(csvOptions.columnPrefix, row.length);
        }

        schema = deduceSchema(row, headerRow);
      }

      if (csvOptions.optimizeMemoryUsage) {
        row = JSON.parse(JSON.stringify(row));
      }

      tableBatchBuilder = tableBatchBuilder || new _schema.TableBatchBuilder(schema, _objectSpread({
        shape: csvOptions.shape || 'array-row-table'
      }, options));

      try {
        tableBatchBuilder.addRow(row);
        var batch = tableBatchBuilder && tableBatchBuilder.getFullBatch({
          bytesUsed: bytesUsed
        });

        if (batch) {
          asyncQueue.enqueue(batch);
        }
      } catch (error) {
        asyncQueue.enqueue(error);
      }
    },
    complete: function complete(results) {
      try {
        var bytesUsed = results.meta.cursor;
        var batch = tableBatchBuilder && tableBatchBuilder.getFinalBatch({
          bytesUsed: bytesUsed
        });

        if (batch) {
          asyncQueue.enqueue(batch);
        }
      } catch (error) {
        asyncQueue.enqueue(error);
      }

      asyncQueue.close();
    }
  });

  _papaparse.default.parse(asyncIterator, config, _asyncIteratorStreamer.default);

  return asyncQueue;
}

function isHeaderRow(row) {
  return row && row.every(function (value) {
    return typeof value === 'string';
  });
}

function readFirstRow(csvText) {
  var result = _papaparse.default.parse(csvText, {
    download: false,
    dynamicTyping: true,
    preview: 1
  });

  return result.data[0];
}

function duplicateColumnTransformer() {
  var observedColumns = new Set();
  return function (col) {
    var colName = col;
    var counter = 1;

    while (observedColumns.has(colName)) {
      colName = "".concat(col, ".").concat(counter);
      counter++;
    }

    observedColumns.add(colName);
    return colName;
  };
}

function generateHeader(columnPrefix) {
  var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var headers = [];

  for (var i = 0; i < count; i++) {
    headers.push("".concat(columnPrefix).concat(i + 1));
  }

  return headers;
}

function deduceSchema(row, headerRow) {
  var schema = headerRow ? {} : [];

  for (var i = 0; i < row.length; i++) {
    var columnName = headerRow && headerRow[i] || i;
    var value = row[i];

    switch ((0, _typeof2.default)(value)) {
      case 'number':
      case 'boolean':
        schema[columnName] = {
          name: String(columnName),
          index: i,
          type: Float32Array
        };
        break;

      case 'string':
      default:
        schema[columnName] = {
          name: String(columnName),
          index: i,
          type: Array
        };
    }
  }

  return schema;
}

var _typecheckCSVLoader = CSVLoader;
exports._typecheckCSVLoader = _typecheckCSVLoader;

},{"./lib/async-iterator-streamer":71,"./libs/papaparse":72,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"@babel/runtime/regenerator":33,"@loaders.gl/schema":92}],70:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "CSVLoader", {
  enumerable: true,
  get: function get() {
    return _csvLoader.CSVLoader;
  }
});

var _csvLoader = require("./csv-loader");

},{"./csv-loader":69}],71:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = AsyncIteratorStreamer;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

var _papaparse = _interopRequireDefault(require("../libs/papaparse"));

var ChunkStreamer = _papaparse.default.ChunkStreamer;

function AsyncIteratorStreamer(config) {
  config = config || {};
  ChunkStreamer.call(this, config);
  this.textDecoder = new TextDecoder(this._config.encoding);

  this.stream = function () {
    var _ref = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(asyncIterator) {
      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk;

      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              this._input = asyncIterator;
              _context.prev = 1;
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _context.prev = 4;
              _iterator = (0, _asyncIterator2.default)(asyncIterator);

            case 6:
              _context.next = 8;
              return _iterator.next();

            case 8:
              _step = _context.sent;
              _iteratorNormalCompletion = _step.done;
              _context.next = 12;
              return _step.value;

            case 12:
              _value = _context.sent;

              if (_iteratorNormalCompletion) {
                _context.next = 19;
                break;
              }

              chunk = _value;
              this.parseChunk(this.getStringChunk(chunk));

            case 16:
              _iteratorNormalCompletion = true;
              _context.next = 6;
              break;

            case 19:
              _context.next = 25;
              break;

            case 21:
              _context.prev = 21;
              _context.t0 = _context["catch"](4);
              _didIteratorError = true;
              _iteratorError = _context.t0;

            case 25:
              _context.prev = 25;
              _context.prev = 26;

              if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
                _context.next = 30;
                break;
              }

              _context.next = 30;
              return _iterator.return();

            case 30:
              _context.prev = 30;

              if (!_didIteratorError) {
                _context.next = 33;
                break;
              }

              throw _iteratorError;

            case 33:
              return _context.finish(30);

            case 34:
              return _context.finish(25);

            case 35:
              this._finished = true;
              this.parseChunk('');
              _context.next = 42;
              break;

            case 39:
              _context.prev = 39;
              _context.t1 = _context["catch"](1);

              this._sendError(_context.t1);

            case 42:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[1, 39], [4, 21, 25, 35], [26,, 30, 34]]);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }();

  this._nextChunk = function nextChunk() {};

  this.getStringChunk = function (chunk) {
    return typeof chunk === 'string' ? chunk : this.textDecoder.decode(chunk, {
      stream: true
    });
  };
}

AsyncIteratorStreamer.prototype = Object.create(ChunkStreamer.prototype);
AsyncIteratorStreamer.prototype.constructor = AsyncIteratorStreamer;

},{"../libs/papaparse":72,"@babel/runtime/helpers/asyncIterator":9,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],72:[function(require,module,exports){
// This is a fork of papaparse
// https://github.com/mholt/PapaParse
/* @license
Papa Parse
v5.0.0-beta.0
https://github.com/mholt/PapaParse
License: MIT
*/
// FORK SUMMARY:
// - Adopt ES6 exports
// - Implement new AsyncIteratorStreamer
// - Remove non Async Iterator streamers (can all be handled by new streamer)
// - Remove unused Worker support (loaders.gl worker system used instead)
// - Remove unused jQuery plugin support

/* eslint-disable */
// @ts-nocheck
var global = (function() {
  // alternative method, similar to `Function('return this')()`
  // but without using `eval` (which is disabled when
  // using Content Security Policy).

  if (typeof self !== 'undefined') {
    return self;
  }
  if (typeof window !== 'undefined') {
    return window;
  }
  if (typeof global !== 'undefined') {
    return global;
  }

  // When running tests none of the above have been defined
  return {};
})();

var IS_PAPA_WORKER = false;

var Papa = {};
module.exports = Papa;
Papa.parse = CsvToJson;
Papa.unparse = JsonToCsv;

Papa.RECORD_SEP = String.fromCharCode(30);
Papa.UNIT_SEP = String.fromCharCode(31);
Papa.BYTE_ORDER_MARK = '\ufeff';
Papa.BAD_DELIMITERS = ['\r', '\n', '"', Papa.BYTE_ORDER_MARK];
Papa.WORKERS_SUPPORTED = false; // !IS_WORKER && !!global.Worker;
Papa.NODE_STREAM_INPUT = 1;

// Configurable chunk sizes for local and remote files, respectively
Papa.LocalChunkSize = 1024 * 1024 * 10; // 10 MB
Papa.RemoteChunkSize = 1024 * 1024 * 5; // 5 MB
Papa.DefaultDelimiter = ','; // Used if not specified and detection fails

// Exposed for testing and development only
Papa.Parser = Parser;
Papa.ParserHandle = ParserHandle;

// BEGIN FORK
Papa.ChunkStreamer = ChunkStreamer;
Papa.StringStreamer = StringStreamer;
/*
Papa.NetworkStreamer = NetworkStreamer;
Papa.FileStreamer = FileStreamer;
Papa.ReadableStreamStreamer = ReadableStreamStreamer;
if (typeof PAPA_BROWSER_CONTEXT === 'undefined') {
  Papa.DuplexStreamStreamer = DuplexStreamStreamer;
}
*/
// END FORK

// BEGIN FORK
// Adds an argument to papa.parse
// function CsvToJson(_input, _config)
function CsvToJson(
  _input,
  _config,
  UserDefinedStreamer // BEGIN FORK
) {
  _config = _config || {};
  var dynamicTyping = _config.dynamicTyping || false;
  if (isFunction(dynamicTyping)) {
    _config.dynamicTypingFunction = dynamicTyping;
    // Will be filled on first row call
    dynamicTyping = {};
  }
  _config.dynamicTyping = dynamicTyping;

  _config.transform = isFunction(_config.transform) ? _config.transform : false;

  if (_config.worker && Papa.WORKERS_SUPPORTED) {
    var w = newWorker();

    w.userStep = _config.step;
    w.userChunk = _config.chunk;
    w.userComplete = _config.complete;
    w.userError = _config.error;

    _config.step = isFunction(_config.step);
    _config.chunk = isFunction(_config.chunk);
    _config.complete = isFunction(_config.complete);
    _config.error = isFunction(_config.error);
    delete _config.worker; // prevent infinite loop

    w.postMessage({
      input: _input,
      config: _config,
      workerId: w.id
    });

    return;
  }

  var streamer = null;
  /*
  if (_input === Papa.NODE_STREAM_INPUT && typeof PAPA_BROWSER_CONTEXT === 'undefined') {
    // create a node Duplex stream for use
    // with .pipe
    streamer = new DuplexStreamStreamer(_config);
    return streamer.getStream();
  } else
  */
  if (typeof _input === 'string') {
    // if (_config.download) streamer = new NetworkStreamer(_config);
    // else
    streamer = new StringStreamer(_config);
  }
  /*
  else if (_input.readable === true && isFunction(_input.read) && isFunction(_input.on)) {
    streamer = new ReadableStreamStreamer(_config);
  } else if ((global.File && _input instanceof File) || _input instanceof Object)
    // ...Safari. (see issue #106)
    streamer = new FileStreamer(_config);
  */

  // BEGIN FORK
  if (!streamer) {
    streamer = new UserDefinedStreamer(_config);
  }
  // END FORK

  return streamer.stream(_input);
}

function JsonToCsv(_input, _config) {
  // Default configuration

  /** whether to surround every datum with quotes */
  var _quotes = false;

  /** whether to write headers */
  var _writeHeader = true;

  /** delimiting character(s) */
  var _delimiter = ',';

  /** newline character(s) */
  var _newline = '\r\n';

  /** quote character */
  var _quoteChar = '"';

  /** escaped quote character, either "" or <config.escapeChar>" */
  var _escapedQuote = _quoteChar + _quoteChar;

  /** whether to skip empty lines */
  var _skipEmptyLines = false;

  /** the columns (keys) we expect when we unparse objects */
  var _columns = null;

  unpackConfig();

  var quoteCharRegex = new RegExp(escapeRegExp(_quoteChar), 'g');

  if (typeof _input === 'string') _input = JSON.parse(_input);

  if (Array.isArray(_input)) {
    if (!_input.length || Array.isArray(_input[0])) return serialize(null, _input, _skipEmptyLines);
    else if (typeof _input[0] === 'object')
      return serialize(_columns || objectKeys(_input[0]), _input, _skipEmptyLines);
  } else if (typeof _input === 'object') {
    if (typeof _input.data === 'string') _input.data = JSON.parse(_input.data);

    if (Array.isArray(_input.data)) {
      if (!_input.fields) _input.fields = _input.meta && _input.meta.fields;

      if (!_input.fields)
        _input.fields = Array.isArray(_input.data[0]) ? _input.fields : objectKeys(_input.data[0]);

      if (!Array.isArray(_input.data[0]) && typeof _input.data[0] !== 'object')
        _input.data = [_input.data]; // handles input like [1,2,3] or ['asdf']
    }

    return serialize(_input.fields || [], _input.data || [], _skipEmptyLines);
  }

  // Default (any valid paths should return before this)
  throw new Error('Unable to serialize unrecognized input');

  function unpackConfig() {
    if (typeof _config !== 'object') return;

    if (
      typeof _config.delimiter === 'string' &&
      !Papa.BAD_DELIMITERS.filter(function(value) {
        return _config.delimiter.indexOf(value) !== -1;
      }).length
    ) {
      _delimiter = _config.delimiter;
    }

    if (typeof _config.quotes === 'boolean' || Array.isArray(_config.quotes))
      _quotes = _config.quotes;

    if (typeof _config.skipEmptyLines === 'boolean' || typeof _config.skipEmptyLines === 'string')
      _skipEmptyLines = _config.skipEmptyLines;

    if (typeof _config.newline === 'string') _newline = _config.newline;

    if (typeof _config.quoteChar === 'string') _quoteChar = _config.quoteChar;

    if (typeof _config.header === 'boolean') _writeHeader = _config.header;

    if (Array.isArray(_config.columns)) {
      if (_config.columns.length === 0) throw new Error('Option columns is empty');

      _columns = _config.columns;
    }

    if (_config.escapeChar !== undefined) {
      _escapedQuote = _config.escapeChar + _quoteChar;
    }
  }

  /** Turns an object's keys into an array */
  function objectKeys(obj) {
    if (typeof obj !== 'object') return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    return keys;
  }

  /** The double for loop that iterates the data and writes out a CSV string including header row */
  function serialize(fields, data, skipEmptyLines) {
    var csv = '';

    if (typeof fields === 'string') fields = JSON.parse(fields);
    if (typeof data === 'string') data = JSON.parse(data);

    var hasHeader = Array.isArray(fields) && fields.length > 0;
    var dataKeyedByField = !Array.isArray(data[0]);

    // If there a header row, write it first
    if (hasHeader && _writeHeader) {
      for (var i = 0; i < fields.length; i++) {
        if (i > 0) csv += _delimiter;
        csv += safe(fields[i], i);
      }
      if (data.length > 0) csv += _newline;
    }

    // Then write out the data
    for (var row = 0; row < data.length; row++) {
      var maxCol = hasHeader ? fields.length : data[row].length;

      var emptyLine = false;
      var nullLine = hasHeader ? Object.keys(data[row]).length === 0 : data[row].length === 0;
      if (skipEmptyLines && !hasHeader) {
        emptyLine =
          skipEmptyLines === 'greedy'
            ? data[row].join('').trim() === ''
            : data[row].length === 1 && data[row][0].length === 0;
      }
      if (skipEmptyLines === 'greedy' && hasHeader) {
        var line = [];
        for (var c = 0; c < maxCol; c++) {
          var cx = dataKeyedByField ? fields[c] : c;
          line.push(data[row][cx]);
        }
        emptyLine = line.join('').trim() === '';
      }
      if (!emptyLine) {
        for (var col = 0; col < maxCol; col++) {
          if (col > 0 && !nullLine) csv += _delimiter;
          var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;
          csv += safe(data[row][colIdx], col);
        }
        if (row < data.length - 1 && (!skipEmptyLines || (maxCol > 0 && !nullLine))) {
          csv += _newline;
        }
      }
    }
    return csv;
  }

  /** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */
  function safe(str, col) {
    if (typeof str === 'undefined' || str === null) return '';

    if (str.constructor === Date) return JSON.stringify(str).slice(1, 25);

    str = str.toString().replace(quoteCharRegex, _escapedQuote);

    var needsQuotes =
      (typeof _quotes === 'boolean' && _quotes) ||
      (Array.isArray(_quotes) && _quotes[col]) ||
      hasAny(str, Papa.BAD_DELIMITERS) ||
      str.indexOf(_delimiter) > -1 ||
      str.charAt(0) === ' ' ||
      str.charAt(str.length - 1) === ' ';

    return needsQuotes ? _quoteChar + str + _quoteChar : str;
  }

  function hasAny(str, substrings) {
    for (var i = 0; i < substrings.length; i++) if (str.indexOf(substrings[i]) > -1) return true;
    return false;
  }
}

/** ChunkStreamer is the base prototype for various streamer implementations. */
function ChunkStreamer(config) {
  this._handle = null;
  this._finished = false;
  this._completed = false;
  this._input = null;
  this._baseIndex = 0;
  this._partialLine = '';
  this._rowCount = 0;
  this._start = 0;
  this._nextChunk = null;
  this.isFirstChunk = true;
  this._completeResults = {
    data: [],
    errors: [],
    meta: {}
  };
  replaceConfig.call(this, config);

  this.parseChunk = function(chunk, isFakeChunk) {
    // First chunk pre-processing
    if (this.isFirstChunk && isFunction(this._config.beforeFirstChunk)) {
      var modifiedChunk = this._config.beforeFirstChunk(chunk);
      if (modifiedChunk !== undefined) chunk = modifiedChunk;
    }
    this.isFirstChunk = false;

    // Rejoin the line we likely just split in two by chunking the file
    var aggregate = this._partialLine + chunk;
    this._partialLine = '';

    var results = this._handle.parse(aggregate, this._baseIndex, !this._finished);

    if (this._handle.paused() || this._handle.aborted()) return;

    var lastIndex = results.meta.cursor;

    if (!this._finished) {
      this._partialLine = aggregate.substring(lastIndex - this._baseIndex);
      this._baseIndex = lastIndex;
    }

    if (results && results.data) this._rowCount += results.data.length;

    var finishedIncludingPreview =
      this._finished || (this._config.preview && this._rowCount >= this._config.preview);

    if (IS_PAPA_WORKER) {
      global.postMessage({
        results: results,
        workerId: Papa.WORKER_ID,
        finished: finishedIncludingPreview
      });
    } else if (isFunction(this._config.chunk) && !isFakeChunk) {
      this._config.chunk(results, this._handle);
      if (this._handle.paused() || this._handle.aborted()) return;
      results = undefined;
      this._completeResults = undefined;
    }

    if (!this._config.step && !this._config.chunk) {
      this._completeResults.data = this._completeResults.data.concat(results.data);
      this._completeResults.errors = this._completeResults.errors.concat(results.errors);
      this._completeResults.meta = results.meta;
    }

    if (
      !this._completed &&
      finishedIncludingPreview &&
      isFunction(this._config.complete) &&
      (!results || !results.meta.aborted)
    ) {
      this._config.complete(this._completeResults, this._input);
      this._completed = true;
    }

    if (!finishedIncludingPreview && (!results || !results.meta.paused)) this._nextChunk();

    return results;
  };

  this._sendError = function(error) {
    if (isFunction(this._config.error)) this._config.error(error);
    else if (IS_PAPA_WORKER && this._config.error) {
      global.postMessage({
        workerId: Papa.WORKER_ID,
        error: error,
        finished: false
      });
    }
  };

  function replaceConfig(config) {
    // Deep-copy the config so we can edit it
    var configCopy = copy(config);
    configCopy.chunkSize = parseInt(configCopy.chunkSize); // parseInt VERY important so we don't concatenate strings!
    if (!config.step && !config.chunk) configCopy.chunkSize = null; // disable Range header if not streaming; bad values break IIS - see issue #196
    this._handle = new ParserHandle(configCopy);
    this._handle.streamer = this;
    this._config = configCopy; // persist the copy to the caller
  }
}
function StringStreamer(config) {
  config = config || {};
  ChunkStreamer.call(this, config);

  var remaining;
  this.stream = function(s) {
    remaining = s;
    return this._nextChunk();
  };
  this._nextChunk = function() {
    if (this._finished) return;
    var size = this._config.chunkSize;
    var chunk = size ? remaining.substr(0, size) : remaining;
    remaining = size ? remaining.substr(size) : '';
    this._finished = !remaining;
    return this.parseChunk(chunk);
  };
}
StringStreamer.prototype = Object.create(StringStreamer.prototype);
StringStreamer.prototype.constructor = StringStreamer;

// Use one ParserHandle per entire CSV file or string
function ParserHandle(_config) {
  // One goal is to minimize the use of regular expressions...
  var FLOAT = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i;
  var ISO_DATE = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/;

  var self = this;
  var _stepCounter = 0; // Number of times step was called (number of rows parsed)
  var _rowCounter = 0; // Number of rows that have been parsed so far
  var _input; // The input being parsed
  var _parser; // The core parser being used
  var _paused = false; // Whether we are paused or not
  var _aborted = false; // Whether the parser has aborted or not
  var _delimiterError; // Temporary state between delimiter detection and processing results
  var _fields = []; // Fields are from the header row of the input, if there is one
  var _results = {
    // The last results returned from the parser
    data: [],
    errors: [],
    meta: {}
  };

  if (isFunction(_config.step)) {
    var userStep = _config.step;
    _config.step = function(results) {
      _results = results;

      if (needsHeaderRow()) processResults();
      // only call user's step function after header row
      else {
        processResults();

        // It's possbile that this line was empty and there's no row here after all
        if (!_results.data || _results.data.length === 0) return;

        _stepCounter += results.data.length;
        if (_config.preview && _stepCounter > _config.preview) _parser.abort();
        else userStep(_results, self);
      }
    };
  }

  /**
   * Parses input. Most users won't need, and shouldn't mess with, the baseIndex
   * and ignoreLastRow parameters. They are used by streamers (wrapper functions)
   * when an input comes in multiple chunks, like from a file.
   */
  this.parse = function(input, baseIndex, ignoreLastRow) {
    var quoteChar = _config.quoteChar || '"';
    if (!_config.newline) _config.newline = guessLineEndings(input, quoteChar);

    _delimiterError = false;
    if (!_config.delimiter) {
      var delimGuess = guessDelimiter(
        input,
        _config.newline,
        _config.skipEmptyLines,
        _config.comments,
        _config.delimitersToGuess
      );
      if (delimGuess.successful) _config.delimiter = delimGuess.bestDelimiter;
      else {
        _delimiterError = true; // add error after parsing (otherwise it would be overwritten)
        _config.delimiter = Papa.DefaultDelimiter;
      }
      _results.meta.delimiter = _config.delimiter;
    } else if (isFunction(_config.delimiter)) {
      _config.delimiter = _config.delimiter(input);
      _results.meta.delimiter = _config.delimiter;
    }

    var parserConfig = copy(_config);
    if (_config.preview && _config.header) parserConfig.preview++; // to compensate for header row

    _input = input;
    _parser = new Parser(parserConfig);
    _results = _parser.parse(_input, baseIndex, ignoreLastRow);
    processResults();
    return _paused ? {meta: {paused: true}} : _results || {meta: {paused: false}};
  };

  this.paused = function() {
    return _paused;
  };

  this.pause = function() {
    _paused = true;
    _parser.abort();
    _input = _input.substr(_parser.getCharIndex());
  };

  this.resume = function() {
    _paused = false;
    self.streamer.parseChunk(_input, true);
  };

  this.aborted = function() {
    return _aborted;
  };

  this.abort = function() {
    _aborted = true;
    _parser.abort();
    _results.meta.aborted = true;
    if (isFunction(_config.complete)) _config.complete(_results);
    _input = '';
  };

  function testEmptyLine(s) {
    return _config.skipEmptyLines === 'greedy'
      ? s.join('').trim() === ''
      : s.length === 1 && s[0].length === 0;
  }

  function processResults() {
    if (_results && _delimiterError) {
      addError(
        'Delimiter',
        'UndetectableDelimiter',
        "Unable to auto-detect delimiting character; defaulted to '" + Papa.DefaultDelimiter + "'"
      );
      _delimiterError = false;
    }

    if (_config.skipEmptyLines) {
      for (var i = 0; i < _results.data.length; i++)
        if (testEmptyLine(_results.data[i])) _results.data.splice(i--, 1);
    }

    if (needsHeaderRow()) fillHeaderFields();

    return applyHeaderAndDynamicTypingAndTransformation();
  }

  function needsHeaderRow() {
    return _config.header && _fields.length === 0;
  }

  function fillHeaderFields() {
    if (!_results) return;

    function addHeder(header) {
      if (isFunction(_config.transformHeader)) header = _config.transformHeader(header);

      _fields.push(header);
    }

    if (Array.isArray(_results.data[0])) {
      for (var i = 0; needsHeaderRow() && i < _results.data.length; i++)
        _results.data[i].forEach(addHeder);

      _results.data.splice(0, 1);
    }
    // if _results.data[0] is not an array, we are in a step where _results.data is the row.
    else _results.data.forEach(addHeder);
  }

  function shouldApplyDynamicTyping(field) {
    // Cache function values to avoid calling it for each row
    if (_config.dynamicTypingFunction && _config.dynamicTyping[field] === undefined) {
      _config.dynamicTyping[field] = _config.dynamicTypingFunction(field);
    }
    return (_config.dynamicTyping[field] || _config.dynamicTyping) === true;
  }

  function parseDynamic(field, value) {
    if (shouldApplyDynamicTyping(field)) {
      if (value === 'true' || value === 'TRUE') return true;
      else if (value === 'false' || value === 'FALSE') return false;
      else if (FLOAT.test(value)) return parseFloat(value);
      else if (ISO_DATE.test(value)) return new Date(value);
      else return value === '' ? null : value;
    }
    return value;
  }

  function applyHeaderAndDynamicTypingAndTransformation() {
    if (!_results || !_results.data || (!_config.header && !_config.dynamicTyping && !_config.transform))
      return _results;

    function processRow(rowSource, i) {
      var row = _config.header ? {} : [];

      var j;
      for (j = 0; j < rowSource.length; j++) {
        var field = j;
        var value = rowSource[j];

        if (_config.header) field = j >= _fields.length ? '__parsed_extra' : _fields[j];

        if (_config.transform) value = _config.transform(value, field);

        value = parseDynamic(field, value);

        if (field === '__parsed_extra') {
          row[field] = row[field] || [];
          row[field].push(value);
        } else row[field] = value;
      }

      if (_config.header) {
        if (j > _fields.length)
          addError(
            'FieldMismatch',
            'TooManyFields',
            'Too many fields: expected ' + _fields.length + ' fields but parsed ' + j,
            _rowCounter + i
          );
        else if (j < _fields.length)
          addError(
            'FieldMismatch',
            'TooFewFields',
            'Too few fields: expected ' + _fields.length + ' fields but parsed ' + j,
            _rowCounter + i
          );
      }

      return row;
    }

    var incrementBy = 1;
    if (!_results.data[0] || Array.isArray(_results.data[0])) {
      _results.data = _results.data.map(processRow);
      incrementBy = _results.data.length;
    } else _results.data = processRow(_results.data, 0);

    if (_config.header && _results.meta) _results.meta.fields = _fields;

    _rowCounter += incrementBy;
    return _results;
  }

  function guessDelimiter(input, newline, skipEmptyLines, comments, delimitersToGuess) {
    var bestDelim, bestDelta, fieldCountPrevRow;

    delimitersToGuess = delimitersToGuess || [',', '\t', '|', ';', Papa.RECORD_SEP, Papa.UNIT_SEP];

    for (var i = 0; i < delimitersToGuess.length; i++) {
      var delim = delimitersToGuess[i];
      var delta = 0,
        avgFieldCount = 0,
        emptyLinesCount = 0;
      fieldCountPrevRow = undefined;

      var preview = new Parser({
        comments: comments,
        delimiter: delim,
        newline: newline,
        preview: 10
      }).parse(input);

      for (var j = 0; j < preview.data.length; j++) {
        if (skipEmptyLines && testEmptyLine(preview.data[j])) {
          emptyLinesCount++;
          continue;
        }
        var fieldCount = preview.data[j].length;
        avgFieldCount += fieldCount;

        if (typeof fieldCountPrevRow === 'undefined') {
          fieldCountPrevRow = 0;
          continue;
        } else if (fieldCount > 1) {
          delta += Math.abs(fieldCount - fieldCountPrevRow);
          fieldCountPrevRow = fieldCount;
        }
      }

      if (preview.data.length > 0) avgFieldCount /= preview.data.length - emptyLinesCount;

      if ((typeof bestDelta === 'undefined' || delta > bestDelta) && avgFieldCount > 1.99) {
        bestDelta = delta;
        bestDelim = delim;
      }
    }

    _config.delimiter = bestDelim;

    return {
      successful: !!bestDelim,
      bestDelimiter: bestDelim
    };
  }

  function guessLineEndings(input, quoteChar) {
    input = input.substr(0, 1024 * 1024); // max length 1 MB
    // Replace all the text inside quotes
    var re = new RegExp(escapeRegExp(quoteChar) + '([^]*?)' + escapeRegExp(quoteChar), 'gm');
    input = input.replace(re, '');

    var r = input.split('\r');

    var n = input.split('\n');

    var nAppearsFirst = n.length > 1 && n[0].length < r[0].length;

    if (r.length === 1 || nAppearsFirst) return '\n';

    var numWithN = 0;
    for (var i = 0; i < r.length; i++) {
      if (r[i][0] === '\n') numWithN++;
    }

    return numWithN >= r.length / 2 ? '\r\n' : '\r';
  }

  function addError(type, code, msg, row) {
    _results.errors.push({
      type: type,
      code: code,
      message: msg,
      row: row
    });
  }
}

/** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions */
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
}

/** The core parser implements speedy and correct CSV parsing */
function Parser(config) {
  // Unpack the config object
  config = config || {};
  var delim = config.delimiter;
  var newline = config.newline;
  var comments = config.comments;
  var step = config.step;
  var preview = config.preview;
  var fastMode = config.fastMode;
  var quoteChar;
  /** Allows for no quoteChar by setting quoteChar to undefined in config */
  if (config.quoteChar === undefined) {
    quoteChar = '"';
  } else {
    quoteChar = config.quoteChar;
  }
  var escapeChar = quoteChar;
  if (config.escapeChar !== undefined) {
    escapeChar = config.escapeChar;
  }

  // Delimiter must be valid
  if (typeof delim !== 'string' || Papa.BAD_DELIMITERS.indexOf(delim) > -1) delim = ',';

  // Comment character must be valid
  if (comments === delim) throw new Error('Comment character same as delimiter');
  else if (comments === true) comments = '#';
  else if (typeof comments !== 'string' || Papa.BAD_DELIMITERS.indexOf(comments) > -1)
    comments = false;

  // Newline must be valid: \r, \n, or \r\n
  if (newline !== '\n' && newline !== '\r' && newline !== '\r\n') newline = '\n';

  // We're gonna need these at the Parser scope
  var cursor = 0;
  var aborted = false;

  this.parse = function(input, baseIndex, ignoreLastRow) {
    // For some reason, in Chrome, this speeds things up (!?)
    if (typeof input !== 'string') throw new Error('Input must be a string');

    // We don't need to compute some of these every time parse() is called,
    // but having them in a more local scope seems to perform better
    var inputLen = input.length,
      delimLen = delim.length,
      newlineLen = newline.length,
      commentsLen = comments.length;
    var stepIsFunction = isFunction(step);

    // Establish starting state
    cursor = 0;
    var data = [],
      errors = [],
      row = [],
      lastCursor = 0;

    if (!input) return returnable();

    if (fastMode || (fastMode !== false && input.indexOf(quoteChar) === -1)) {
      var rows = input.split(newline);
      for (var i = 0; i < rows.length; i++) {
        row = rows[i];
        cursor += row.length;
        if (i !== rows.length - 1) cursor += newline.length;
        else if (ignoreLastRow) return returnable();
        if (comments && row.substr(0, commentsLen) === comments) continue;
        if (stepIsFunction) {
          data = [];
          pushRow(row.split(delim));
          doStep();
          if (aborted) return returnable();
        } else pushRow(row.split(delim));
        if (preview && i >= preview) {
          data = data.slice(0, preview);
          return returnable(true);
        }
      }
      return returnable();
    }

    var nextDelim = input.indexOf(delim, cursor);
    var nextNewline = input.indexOf(newline, cursor);
    var quoteCharRegex = new RegExp(escapeRegExp(escapeChar) + escapeRegExp(quoteChar), 'g');
    var quoteSearch;

    // Parser loop
    for (;;) {
      // Field has opening quote
      if (input[cursor] === quoteChar) {
        // Start our search for the closing quote where the cursor is
        quoteSearch = cursor;

        // Skip the opening quote
        cursor++;

        for (;;) {
          // Find closing quote
          quoteSearch = input.indexOf(quoteChar, quoteSearch + 1);

          //No other quotes are found - no other delimiters
          if (quoteSearch === -1) {
            if (!ignoreLastRow) {
              // No closing quote... what a pity
              errors.push({
                type: 'Quotes',
                code: 'MissingQuotes',
                message: 'Quoted field unterminated',
                row: data.length, // row has yet to be inserted
                index: cursor
              });
            }
            return finish();
          }

          // Closing quote at EOF
          if (quoteSearch === inputLen - 1) {
            var value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);
            return finish(value);
          }

          // If this quote is escaped, it's part of the data; skip it
          // If the quote character is the escape character, then check if the next character is the escape character
          if (quoteChar === escapeChar && input[quoteSearch + 1] === escapeChar) {
            quoteSearch++;
            continue;
          }

          // If the quote character is not the escape character, then check if the previous character was the escape character
          if (
            quoteChar !== escapeChar &&
            quoteSearch !== 0 &&
            input[quoteSearch - 1] === escapeChar
          ) {
            continue;
          }

          // Check up to nextDelim or nextNewline, whichever is closest
          var checkUpTo = nextNewline === -1 ? nextDelim : Math.min(nextDelim, nextNewline);
          var spacesBetweenQuoteAndDelimiter = extraSpaces(checkUpTo);

          // Closing quote followed by delimiter or 'unnecessary spaces + delimiter'
          if (input[quoteSearch + 1 + spacesBetweenQuoteAndDelimiter] === delim) {
            row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));
            cursor = quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen;
            nextDelim = input.indexOf(delim, cursor);
            nextNewline = input.indexOf(newline, cursor);

            if (stepIsFunction) {
              doStep();
              if (aborted) return returnable();
            }

            if (preview && data.length >= preview) return returnable(true);

            break;
          }

          var spacesBetweenQuoteAndNewLine = extraSpaces(nextNewline);

          // Closing quote followed by newline or 'unnecessary spaces + newLine'
          if (
            input.substr(quoteSearch + 1 + spacesBetweenQuoteAndNewLine, newlineLen) === newline
          ) {
            row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));
            saveRow(quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen);
            nextDelim = input.indexOf(delim, cursor); // because we may have skipped the nextDelim in the quoted field

            if (stepIsFunction) {
              doStep();
              if (aborted) return returnable();
            }

            if (preview && data.length >= preview) return returnable(true);

            break;
          }

          // Checks for valid closing quotes are complete (escaped quotes or quote followed by EOF/delimiter/newline) -- assume these quotes are part of an invalid text string
          errors.push({
            type: 'Quotes',
            code: 'InvalidQuotes',
            message: 'Trailing quote on quoted field is malformed',
            row: data.length, // row has yet to be inserted
            index: cursor
          });

          quoteSearch++;
          continue;
        }

        if (stepIsFunction) {
          doStep();
          if (aborted) return returnable();
        }

        if (preview && data.length >= preview) return returnable(true);
        continue;
      }

      // Comment found at start of new line
      if (comments && row.length === 0 && input.substr(cursor, commentsLen) === comments) {
        if (nextNewline === -1)
          // Comment ends at EOF
          return returnable();
        cursor = nextNewline + newlineLen;
        nextNewline = input.indexOf(newline, cursor);
        nextDelim = input.indexOf(delim, cursor);
        continue;
      }

      // Next delimiter comes before next newline, so we've reached end of field
      if (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1)) {
        row.push(input.substring(cursor, nextDelim));
        cursor = nextDelim + delimLen;
        nextDelim = input.indexOf(delim, cursor);
        continue;
      }

      // End of row
      if (nextNewline !== -1) {
        row.push(input.substring(cursor, nextNewline));
        saveRow(nextNewline + newlineLen);

        if (stepIsFunction) {
          doStep();
          if (aborted) return returnable();
        }

        if (preview && data.length >= preview) return returnable(true);

        continue;
      }

      break;
    }

    return finish();

    function pushRow(row) {
      data.push(row);
      lastCursor = cursor;
    }

    /**
     * checks if there are extra spaces after closing quote and given index without any text
     * if Yes, returns the number of spaces
     */
    function extraSpaces(index) {
      var spaceLength = 0;
      if (index !== -1) {
        var textBetweenClosingQuoteAndIndex = input.substring(quoteSearch + 1, index);
        if (textBetweenClosingQuoteAndIndex && textBetweenClosingQuoteAndIndex.trim() === '') {
          spaceLength = textBetweenClosingQuoteAndIndex.length;
        }
      }
      return spaceLength;
    }

    /**
     * Appends the remaining input from cursor to the end into
     * row, saves the row, calls step, and returns the results.
     */
    function finish(value) {
      if (ignoreLastRow) return returnable();
      if (typeof value === 'undefined') value = input.substr(cursor);
      row.push(value);
      cursor = inputLen; // important in case parsing is paused
      pushRow(row);
      if (stepIsFunction) doStep();
      return returnable();
    }

    /**
     * Appends the current row to the results. It sets the cursor
     * to newCursor and finds the nextNewline. The caller should
     * take care to execute user's step function and check for
     * preview and end parsing if necessary.
     */
    function saveRow(newCursor) {
      cursor = newCursor;
      pushRow(row);
      row = [];
      nextNewline = input.indexOf(newline, cursor);
    }

    /** Returns an object with the results, errors, and meta. */
    function returnable(stopped, step) {
      var isStep = step || false;
      return {
        data: isStep ? data[0] : data,
        errors: errors,
        meta: {
          delimiter: delim,
          linebreak: newline,
          aborted: aborted,
          truncated: !!stopped,
          cursor: lastCursor + (baseIndex || 0)
        }
      };
    }

    /** Executes the user's step function and resets data & errors. */
    function doStep() {
      step(returnable(undefined, true));
      data = [];
      errors = [];
    }
  };

  /** Sets the abort flag */
  this.abort = function() {
    aborted = true;
  };

  /** Gets the cursor position */
  this.getCharIndex = function() {
    return cursor;
  };
}

function notImplemented() {
  throw new Error('Not implemented.');
}

/** Makes a deep copy of an array or object (mostly) */
function copy(obj) {
  if (typeof obj !== 'object' || obj === null) return obj;
  var cpy = Array.isArray(obj) ? [] : {};
  for (var key in obj) cpy[key] = copy(obj[key]);
  return cpy;
}

function isFunction(func) {
  return typeof func === 'function';
}

},{}],73:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function get() {
    return _assert.assert;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function get() {
    return _globals.isBrowser;
  }
});
Object.defineProperty(exports, "isWorker", {
  enumerable: true,
  get: function get() {
    return _globals.isWorker;
  }
});
Object.defineProperty(exports, "nodeVersion", {
  enumerable: true,
  get: function get() {
    return _globals.nodeVersion;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function get() {
    return _globals.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function get() {
    return _globals.window;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function get() {
    return _globals.global;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function get() {
    return _globals.document;
  }
});
Object.defineProperty(exports, "createLoaderWorker", {
  enumerable: true,
  get: function get() {
    return _createLoaderWorker.createLoaderWorker;
  }
});
Object.defineProperty(exports, "parseWithWorker", {
  enumerable: true,
  get: function get() {
    return _parseWithWorker.parseWithWorker;
  }
});
Object.defineProperty(exports, "canParseWithWorker", {
  enumerable: true,
  get: function get() {
    return _parseWithWorker.canParseWithWorker;
  }
});
Object.defineProperty(exports, "parseJSON", {
  enumerable: true,
  get: function get() {
    return _parseJson.parseJSON;
  }
});
Object.defineProperty(exports, "toArrayBuffer", {
  enumerable: true,
  get: function get() {
    return _arrayBufferUtils.toArrayBuffer;
  }
});
Object.defineProperty(exports, "sliceArrayBuffer", {
  enumerable: true,
  get: function get() {
    return _arrayBufferUtils.sliceArrayBuffer;
  }
});
Object.defineProperty(exports, "concatenateArrayBuffers", {
  enumerable: true,
  get: function get() {
    return _arrayBufferUtils.concatenateArrayBuffers;
  }
});
Object.defineProperty(exports, "concatenateTypedArrays", {
  enumerable: true,
  get: function get() {
    return _arrayBufferUtils.concatenateTypedArrays;
  }
});
Object.defineProperty(exports, "compareArrayBuffers", {
  enumerable: true,
  get: function get() {
    return _arrayBufferUtils.compareArrayBuffers;
  }
});
Object.defineProperty(exports, "padToNBytes", {
  enumerable: true,
  get: function get() {
    return _memoryCopyUtils.padToNBytes;
  }
});
Object.defineProperty(exports, "copyToArray", {
  enumerable: true,
  get: function get() {
    return _memoryCopyUtils.copyToArray;
  }
});
Object.defineProperty(exports, "copyArrayBuffer", {
  enumerable: true,
  get: function get() {
    return _memoryCopyUtils.copyArrayBuffer;
  }
});
Object.defineProperty(exports, "copyPaddedArrayBufferToDataView", {
  enumerable: true,
  get: function get() {
    return _binaryCopyUtils.copyPaddedArrayBufferToDataView;
  }
});
Object.defineProperty(exports, "copyPaddedStringToDataView", {
  enumerable: true,
  get: function get() {
    return _binaryCopyUtils.copyPaddedStringToDataView;
  }
});
Object.defineProperty(exports, "padStringToByteAlignment", {
  enumerable: true,
  get: function get() {
    return _encodeUtils.padStringToByteAlignment;
  }
});
Object.defineProperty(exports, "copyStringToDataView", {
  enumerable: true,
  get: function get() {
    return _encodeUtils.copyStringToDataView;
  }
});
Object.defineProperty(exports, "copyBinaryToDataView", {
  enumerable: true,
  get: function get() {
    return _encodeUtils.copyBinaryToDataView;
  }
});
Object.defineProperty(exports, "getFirstCharacters", {
  enumerable: true,
  get: function get() {
    return _getFirstCharacters.getFirstCharacters;
  }
});
Object.defineProperty(exports, "getMagicString", {
  enumerable: true,
  get: function get() {
    return _getFirstCharacters.getMagicString;
  }
});
Object.defineProperty(exports, "makeTextEncoderIterator", {
  enumerable: true,
  get: function get() {
    return _textIterators.makeTextEncoderIterator;
  }
});
Object.defineProperty(exports, "makeTextDecoderIterator", {
  enumerable: true,
  get: function get() {
    return _textIterators.makeTextDecoderIterator;
  }
});
Object.defineProperty(exports, "makeLineIterator", {
  enumerable: true,
  get: function get() {
    return _textIterators.makeLineIterator;
  }
});
Object.defineProperty(exports, "makeNumberedLineIterator", {
  enumerable: true,
  get: function get() {
    return _textIterators.makeNumberedLineIterator;
  }
});
Object.defineProperty(exports, "forEach", {
  enumerable: true,
  get: function get() {
    return _asyncIteration.forEach;
  }
});
Object.defineProperty(exports, "concatenateArrayBuffersAsync", {
  enumerable: true,
  get: function get() {
    return _asyncIteration.concatenateArrayBuffersAsync;
  }
});
Object.defineProperty(exports, "RequestScheduler", {
  enumerable: true,
  get: function get() {
    return _requestScheduler.default;
  }
});
Object.defineProperty(exports, "setPathPrefix", {
  enumerable: true,
  get: function get() {
    return _fileAliases.setPathPrefix;
  }
});
Object.defineProperty(exports, "getPathPrefix", {
  enumerable: true,
  get: function get() {
    return _fileAliases.getPathPrefix;
  }
});
Object.defineProperty(exports, "resolvePath", {
  enumerable: true,
  get: function get() {
    return _fileAliases.resolvePath;
  }
});
Object.defineProperty(exports, "_addAliases", {
  enumerable: true,
  get: function get() {
    return _fileAliases.addAliases;
  }
});
Object.defineProperty(exports, "isBuffer", {
  enumerable: true,
  get: function get() {
    return _bufferUtils.isBuffer;
  }
});
Object.defineProperty(exports, "toBuffer", {
  enumerable: true,
  get: function get() {
    return _bufferUtils.toBuffer;
  }
});
Object.defineProperty(exports, "bufferToArrayBuffer", {
  enumerable: true,
  get: function get() {
    return _bufferUtils.bufferToArrayBuffer;
  }
});
Object.defineProperty(exports, "JSONLoader", {
  enumerable: true,
  get: function get() {
    return _jsonLoader.JSONLoader;
  }
});
exports.fs = exports.path = void 0;

var _assert = require("./lib/env-utils/assert");

var _globals = require("./lib/env-utils/globals");

var _createLoaderWorker = require("./lib/worker-loader-utils/create-loader-worker");

var _parseWithWorker = require("./lib/worker-loader-utils/parse-with-worker");

var _parseJson = require("./lib/parser-utils/parse-json");

var _arrayBufferUtils = require("./lib/binary-utils/array-buffer-utils");

var _memoryCopyUtils = require("./lib/binary-utils/memory-copy-utils");

var _binaryCopyUtils = require("./lib/binary-utils/binary-copy-utils");

var _encodeUtils = require("./lib/binary-utils/encode-utils");

var _getFirstCharacters = require("./lib/binary-utils/get-first-characters");

var _textIterators = require("./lib/iterators/text-iterators");

var _asyncIteration = require("./lib/iterators/async-iteration");

var _requestScheduler = _interopRequireDefault(require("./lib/request-utils/request-scheduler"));

var path = _interopRequireWildcard(require("./lib/path-utils/path"));

exports.path = path;

var _fileAliases = require("./lib/path-utils/file-aliases");

var fs = _interopRequireWildcard(require("./lib/node/fs"));

exports.fs = fs;

var _bufferUtils = require("./lib/binary-utils/buffer-utils");

var _jsonLoader = require("./json-loader");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

},{"./json-loader":74,"./lib/binary-utils/array-buffer-utils":75,"./lib/binary-utils/binary-copy-utils":76,"./lib/binary-utils/buffer-utils":77,"./lib/binary-utils/encode-utils":78,"./lib/binary-utils/get-first-characters":79,"./lib/binary-utils/memory-copy-utils":80,"./lib/env-utils/assert":81,"./lib/env-utils/globals":82,"./lib/iterators/async-iteration":83,"./lib/iterators/text-iterators":84,"./lib/node/fs":130,"./lib/parser-utils/parse-json":85,"./lib/path-utils/file-aliases":86,"./lib/path-utils/path":87,"./lib/request-utils/request-scheduler":88,"./lib/worker-loader-utils/create-loader-worker":89,"./lib/worker-loader-utils/parse-with-worker":90,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29}],74:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._typecheckJSONLoader = exports.JSONLoader = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var VERSION = typeof "3.0.9" !== 'undefined' ? "3.0.9" : 'latest';
var JSONLoader = {
  name: 'JSON',
  id: 'json',
  module: 'json',
  version: VERSION,
  extensions: ['json', 'geojson'],
  mimeTypes: ['application/json'],
  category: 'json',
  text: true,
  parseTextSync: parseTextSync,
  parse: function () {
    var _parse = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(arrayBuffer) {
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", parseTextSync(new TextDecoder().decode(arrayBuffer)));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function parse(_x) {
      return _parse.apply(this, arguments);
    }

    return parse;
  }(),
  options: {}
};
exports.JSONLoader = JSONLoader;

function parseTextSync(text) {
  return JSON.parse(text);
}

var _typecheckJSONLoader = JSONLoader;
exports._typecheckJSONLoader = _typecheckJSONLoader;

},{"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],75:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof3 = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toArrayBuffer = toArrayBuffer;
exports.compareArrayBuffers = compareArrayBuffers;
exports.concatenateArrayBuffers = concatenateArrayBuffers;
exports.concatenateTypedArrays = concatenateTypedArrays;
exports.sliceArrayBuffer = sliceArrayBuffer;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var node = _interopRequireWildcard(require("../node/buffer-utils.node"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof3(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function toArrayBuffer(data) {
  if (node.toArrayBuffer) {
    data = node.toArrayBuffer(data);
  }

  if (data instanceof ArrayBuffer) {
    return data;
  }

  if (ArrayBuffer.isView(data)) {
    return data.buffer;
  }

  if (typeof data === 'string') {
    var text = data;
    var uint8Array = new TextEncoder().encode(text);
    return uint8Array.buffer;
  }

  if (data && (0, _typeof2.default)(data) === 'object' && data._toArrayBuffer) {
    return data._toArrayBuffer();
  }

  throw new Error('toArrayBuffer');
}

function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {
  byteLength = byteLength || arrayBuffer1.byteLength;

  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {
    return false;
  }

  var array1 = new Uint8Array(arrayBuffer1);
  var array2 = new Uint8Array(arrayBuffer2);

  for (var i = 0; i < array1.length; ++i) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }

  return true;
}

function concatenateArrayBuffers() {
  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
    sources[_key] = arguments[_key];
  }

  var sourceArrays = sources.map(function (source2) {
    return source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2;
  });
  var byteLength = sourceArrays.reduce(function (length, typedArray) {
    return length + typedArray.byteLength;
  }, 0);
  var result = new Uint8Array(byteLength);
  var offset = 0;

  var _iterator = _createForOfIteratorHelper(sourceArrays),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var sourceArray = _step.value;
      result.set(sourceArray, offset);
      offset += sourceArray.byteLength;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return result.buffer;
}

function concatenateTypedArrays() {
  for (var _len2 = arguments.length, typedArrays = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    typedArrays[_key2] = arguments[_key2];
  }

  var arrays = typedArrays;
  var TypedArrayConstructor = arrays && arrays.length > 1 && arrays[0].constructor || null;

  if (!TypedArrayConstructor) {
    throw new Error('"concatenateTypedArrays" - incorrect quantity of arguments or arguments have incompatible data types');
  }

  var sumLength = arrays.reduce(function (acc, value) {
    return acc + value.length;
  }, 0);
  var result = new TypedArrayConstructor(sumLength);
  var offset = 0;

  for (var _i = 0, _arrays = arrays; _i < _arrays.length; _i++) {
    var array = _arrays[_i];
    result.set(array, offset);
    offset += array.length;
  }

  return result;
}

function sliceArrayBuffer(arrayBuffer, byteOffset, byteLength) {
  var subArray = byteLength !== undefined ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer).subarray(byteOffset);
  var arrayCopy = new Uint8Array(subArray);
  return arrayCopy.buffer;
}

},{"../node/buffer-utils.node":130,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29}],76:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.copyPaddedArrayBufferToDataView = copyPaddedArrayBufferToDataView;
exports.copyPaddedStringToDataView = copyPaddedStringToDataView;

var _memoryCopyUtils = require("./memory-copy-utils");

function copyPaddedArrayBufferToDataView(dataView, byteOffset, sourceBuffer, padding) {
  var paddedLength = (0, _memoryCopyUtils.padToNBytes)(sourceBuffer.byteLength, padding);
  var padLength = paddedLength - sourceBuffer.byteLength;

  if (dataView) {
    var targetArray = new Uint8Array(dataView.buffer, dataView.byteOffset + byteOffset, sourceBuffer.byteLength);
    var sourceArray = new Uint8Array(sourceBuffer);
    targetArray.set(sourceArray);

    for (var i = 0; i < padLength; ++i) {
      dataView.setUint8(byteOffset + sourceBuffer.byteLength + i, 0x20);
    }
  }

  byteOffset += paddedLength;
  return byteOffset;
}

function copyPaddedStringToDataView(dataView, byteOffset, string, padding) {
  var textEncoder = new TextEncoder();
  var stringBuffer = textEncoder.encode(string);
  byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, stringBuffer, padding);
  return byteOffset;
}

},{"./memory-copy-utils":80}],77:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof3 = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isBuffer = isBuffer;
exports.toBuffer = toBuffer;
exports.bufferToArrayBuffer = bufferToArrayBuffer;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var node = _interopRequireWildcard(require("../node/buffer-utils.node"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof3(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function isBuffer(value) {
  return value && (0, _typeof2.default)(value) === 'object' && value.isBuffer;
}

function toBuffer(data) {
  return node.toBuffer ? node.toBuffer(data) : data;
}

function bufferToArrayBuffer(data) {
  if (node.toArrayBuffer) {
    return node.toArrayBuffer(data);
  }

  return data;
}

},{"../node/buffer-utils.node":130,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29}],78:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.padStringToByteAlignment = padStringToByteAlignment;
exports.copyStringToDataView = copyStringToDataView;
exports.copyBinaryToDataView = copyBinaryToDataView;

function padStringToByteAlignment(string, byteAlignment) {
  var length = string.length;
  var paddedLength = Math.ceil(length / byteAlignment) * byteAlignment;
  var padding = paddedLength - length;
  var whitespace = '';

  for (var i = 0; i < padding; ++i) {
    whitespace += ' ';
  }

  return string + whitespace;
}

function copyStringToDataView(dataView, byteOffset, string, byteLength) {
  if (dataView) {
    for (var i = 0; i < byteLength; i++) {
      dataView.setUint8(byteOffset + i, string.charCodeAt(i));
    }
  }

  return byteOffset + byteLength;
}

function copyBinaryToDataView(dataView, byteOffset, binary, byteLength) {
  if (dataView) {
    for (var i = 0; i < byteLength; i++) {
      dataView.setUint8(byteOffset + i, binary[i]);
    }
  }

  return byteOffset + byteLength;
}

},{}],79:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFirstCharacters = getFirstCharacters;
exports.getMagicString = getMagicString;

function getFirstCharacters(data) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;

  if (typeof data === 'string') {
    return data.slice(0, length);
  } else if (ArrayBuffer.isView(data)) {
    return getMagicString(data.buffer, data.byteOffset, length);
  } else if (data instanceof ArrayBuffer) {
    var byteOffset = 0;
    return getMagicString(data, byteOffset, length);
  }

  return '';
}

function getMagicString(arrayBuffer, byteOffset, length) {
  if (arrayBuffer.byteLength <= byteOffset + length) {
    return '';
  }

  var dataView = new DataView(arrayBuffer);
  var magic = '';

  for (var i = 0; i < length; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }

  return magic;
}

},{}],80:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.padToNBytes = padToNBytes;
exports.copyArrayBuffer = copyArrayBuffer;
exports.copyToArray = copyToArray;

var _assert = require("../env-utils/assert");

function padToNBytes(byteLength, padding) {
  (0, _assert.assert)(byteLength >= 0);
  (0, _assert.assert)(padding > 0);
  return byteLength + (padding - 1) & ~(padding - 1);
}

function copyArrayBuffer(targetBuffer, sourceBuffer, byteOffset) {
  var byteLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : sourceBuffer.byteLength;
  var targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);
  var sourceArray = new Uint8Array(sourceBuffer);
  targetArray.set(sourceArray);
  return targetBuffer;
}

function copyToArray(source, target, targetOffset) {
  var sourceArray;

  if (source instanceof ArrayBuffer) {
    sourceArray = new Uint8Array(source);
  } else {
    var srcByteOffset = source.byteOffset;
    var srcByteLength = source.byteLength;
    sourceArray = new Uint8Array(source.buffer || source.arrayBuffer, srcByteOffset, srcByteLength);
  }

  target.set(sourceArray, targetOffset);
  return targetOffset + padToNBytes(sourceArray.byteLength, 4);
}

},{"../env-utils/assert":81}],81:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assert = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'loader assertion failed.');
  }
}

},{}],82:[function(require,module,exports){
(function (process,global){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nodeVersion = exports.isWorker = exports.isBrowser = exports.document = exports.global = exports.window = exports.self = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};
var self_ = globals.self || globals.window || globals.global || {};
exports.self = self_;
var window_ = globals.window || globals.self || globals.global || {};
exports.window = window_;
var global_ = globals.global || globals.self || globals.window || {};
exports.global = global_;
var document_ = globals.document || {};
exports.document = document_;
var isBrowser = (typeof process === "undefined" ? "undefined" : (0, _typeof2.default)(process)) !== 'object' || String(process) !== '[object process]' || process.browser;
exports.isBrowser = isBrowser;
var isWorker = typeof importScripts === 'function';
exports.isWorker = isWorker;
var matches = typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);
var nodeVersion = matches && parseFloat(matches[1]) || 0;
exports.nodeVersion = nodeVersion;

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"_process":153}],83:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.forEach = forEach;
exports.concatenateArrayBuffersAsync = concatenateArrayBuffersAsync;
exports.concatenateStringsAsync = concatenateStringsAsync;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

var _arrayBufferUtils = require("../binary-utils/array-buffer-utils");

function forEach(_x, _x2) {
  return _forEach.apply(this, arguments);
}

function _forEach() {
  _forEach = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(iterator, visitor) {
    var _yield$iterator$next, done, value, cancel;

    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!true) {
              _context.next = 14;
              break;
            }

            _context.next = 3;
            return iterator.next();

          case 3:
            _yield$iterator$next = _context.sent;
            done = _yield$iterator$next.done;
            value = _yield$iterator$next.value;

            if (!done) {
              _context.next = 9;
              break;
            }

            iterator.return();
            return _context.abrupt("return");

          case 9:
            cancel = visitor(value);

            if (!cancel) {
              _context.next = 12;
              break;
            }

            return _context.abrupt("return");

          case 12:
            _context.next = 0;
            break;

          case 14:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _forEach.apply(this, arguments);
}

function concatenateArrayBuffersAsync(_x3) {
  return _concatenateArrayBuffersAsync.apply(this, arguments);
}

function _concatenateArrayBuffersAsync() {
  _concatenateArrayBuffersAsync = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(asyncIterator) {
    var arrayBuffers, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk;

    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            arrayBuffers = [];
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _context2.prev = 3;
            _iterator = (0, _asyncIterator2.default)(asyncIterator);

          case 5:
            _context2.next = 7;
            return _iterator.next();

          case 7:
            _step = _context2.sent;
            _iteratorNormalCompletion = _step.done;
            _context2.next = 11;
            return _step.value;

          case 11:
            _value = _context2.sent;

            if (_iteratorNormalCompletion) {
              _context2.next = 18;
              break;
            }

            chunk = _value;
            arrayBuffers.push(chunk);

          case 15:
            _iteratorNormalCompletion = true;
            _context2.next = 5;
            break;

          case 18:
            _context2.next = 24;
            break;

          case 20:
            _context2.prev = 20;
            _context2.t0 = _context2["catch"](3);
            _didIteratorError = true;
            _iteratorError = _context2.t0;

          case 24:
            _context2.prev = 24;
            _context2.prev = 25;

            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
              _context2.next = 29;
              break;
            }

            _context2.next = 29;
            return _iterator.return();

          case 29:
            _context2.prev = 29;

            if (!_didIteratorError) {
              _context2.next = 32;
              break;
            }

            throw _iteratorError;

          case 32:
            return _context2.finish(29);

          case 33:
            return _context2.finish(24);

          case 34:
            return _context2.abrupt("return", _arrayBufferUtils.concatenateArrayBuffers.apply(void 0, arrayBuffers));

          case 35:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[3, 20, 24, 34], [25,, 29, 33]]);
  }));
  return _concatenateArrayBuffersAsync.apply(this, arguments);
}

function concatenateStringsAsync(_x4) {
  return _concatenateStringsAsync.apply(this, arguments);
}

function _concatenateStringsAsync() {
  _concatenateStringsAsync = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(asyncIterator) {
    var strings, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, chunk;

    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            strings = [];
            _iteratorNormalCompletion2 = true;
            _didIteratorError2 = false;
            _context3.prev = 3;
            _iterator2 = (0, _asyncIterator2.default)(asyncIterator);

          case 5:
            _context3.next = 7;
            return _iterator2.next();

          case 7:
            _step2 = _context3.sent;
            _iteratorNormalCompletion2 = _step2.done;
            _context3.next = 11;
            return _step2.value;

          case 11:
            _value2 = _context3.sent;

            if (_iteratorNormalCompletion2) {
              _context3.next = 18;
              break;
            }

            chunk = _value2;
            strings.push(chunk);

          case 15:
            _iteratorNormalCompletion2 = true;
            _context3.next = 5;
            break;

          case 18:
            _context3.next = 24;
            break;

          case 20:
            _context3.prev = 20;
            _context3.t0 = _context3["catch"](3);
            _didIteratorError2 = true;
            _iteratorError2 = _context3.t0;

          case 24:
            _context3.prev = 24;
            _context3.prev = 25;

            if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {
              _context3.next = 29;
              break;
            }

            _context3.next = 29;
            return _iterator2.return();

          case 29:
            _context3.prev = 29;

            if (!_didIteratorError2) {
              _context3.next = 32;
              break;
            }

            throw _iteratorError2;

          case 32:
            return _context3.finish(29);

          case 33:
            return _context3.finish(24);

          case 34:
            return _context3.abrupt("return", strings.join(''));

          case 35:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[3, 20, 24, 34], [25,, 29, 33]]);
  }));
  return _concatenateStringsAsync.apply(this, arguments);
}

},{"../binary-utils/array-buffer-utils":75,"@babel/runtime/helpers/asyncIterator":9,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],84:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeTextDecoderIterator = makeTextDecoderIterator;
exports.makeTextEncoderIterator = makeTextEncoderIterator;
exports.makeLineIterator = makeLineIterator;
exports.makeNumberedLineIterator = makeNumberedLineIterator;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _awaitAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/awaitAsyncGenerator"));

var _wrapAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapAsyncGenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

function makeTextDecoderIterator(_x) {
  return _makeTextDecoderIterator.apply(this, arguments);
}

function _makeTextDecoderIterator() {
  _makeTextDecoderIterator = (0, _wrapAsyncGenerator2.default)(_regenerator.default.mark(function _callee(arrayBufferIterator) {
    var options,
        textDecoder,
        _iteratorNormalCompletion,
        _didIteratorError,
        _iteratorError,
        _iterator,
        _step,
        _value,
        arrayBuffer,
        _args = arguments;

    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
            textDecoder = new TextDecoder(undefined, options);
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _context.prev = 4;
            _iterator = (0, _asyncIterator2.default)(arrayBufferIterator);

          case 6:
            _context.next = 8;
            return (0, _awaitAsyncGenerator2.default)(_iterator.next());

          case 8:
            _step = _context.sent;
            _iteratorNormalCompletion = _step.done;
            _context.next = 12;
            return (0, _awaitAsyncGenerator2.default)(_step.value);

          case 12:
            _value = _context.sent;

            if (_iteratorNormalCompletion) {
              _context.next = 20;
              break;
            }

            arrayBuffer = _value;
            _context.next = 17;
            return typeof arrayBuffer === 'string' ? arrayBuffer : textDecoder.decode(arrayBuffer, {
              stream: true
            });

          case 17:
            _iteratorNormalCompletion = true;
            _context.next = 6;
            break;

          case 20:
            _context.next = 26;
            break;

          case 22:
            _context.prev = 22;
            _context.t0 = _context["catch"](4);
            _didIteratorError = true;
            _iteratorError = _context.t0;

          case 26:
            _context.prev = 26;
            _context.prev = 27;

            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
              _context.next = 31;
              break;
            }

            _context.next = 31;
            return (0, _awaitAsyncGenerator2.default)(_iterator.return());

          case 31:
            _context.prev = 31;

            if (!_didIteratorError) {
              _context.next = 34;
              break;
            }

            throw _iteratorError;

          case 34:
            return _context.finish(31);

          case 35:
            return _context.finish(26);

          case 36:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[4, 22, 26, 36], [27,, 31, 35]]);
  }));
  return _makeTextDecoderIterator.apply(this, arguments);
}

function makeTextEncoderIterator(_x2) {
  return _makeTextEncoderIterator.apply(this, arguments);
}

function _makeTextEncoderIterator() {
  _makeTextEncoderIterator = (0, _wrapAsyncGenerator2.default)(_regenerator.default.mark(function _callee2(textIterator) {
    var textEncoder, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, text;

    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            textEncoder = new TextEncoder();
            _iteratorNormalCompletion2 = true;
            _didIteratorError2 = false;
            _context2.prev = 3;
            _iterator2 = (0, _asyncIterator2.default)(textIterator);

          case 5:
            _context2.next = 7;
            return (0, _awaitAsyncGenerator2.default)(_iterator2.next());

          case 7:
            _step2 = _context2.sent;
            _iteratorNormalCompletion2 = _step2.done;
            _context2.next = 11;
            return (0, _awaitAsyncGenerator2.default)(_step2.value);

          case 11:
            _value2 = _context2.sent;

            if (_iteratorNormalCompletion2) {
              _context2.next = 19;
              break;
            }

            text = _value2;
            _context2.next = 16;
            return typeof text === 'string' ? textEncoder.encode(text) : text;

          case 16:
            _iteratorNormalCompletion2 = true;
            _context2.next = 5;
            break;

          case 19:
            _context2.next = 25;
            break;

          case 21:
            _context2.prev = 21;
            _context2.t0 = _context2["catch"](3);
            _didIteratorError2 = true;
            _iteratorError2 = _context2.t0;

          case 25:
            _context2.prev = 25;
            _context2.prev = 26;

            if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {
              _context2.next = 30;
              break;
            }

            _context2.next = 30;
            return (0, _awaitAsyncGenerator2.default)(_iterator2.return());

          case 30:
            _context2.prev = 30;

            if (!_didIteratorError2) {
              _context2.next = 33;
              break;
            }

            throw _iteratorError2;

          case 33:
            return _context2.finish(30);

          case 34:
            return _context2.finish(25);

          case 35:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[3, 21, 25, 35], [26,, 30, 34]]);
  }));
  return _makeTextEncoderIterator.apply(this, arguments);
}

function makeLineIterator(_x3) {
  return _makeLineIterator.apply(this, arguments);
}

function _makeLineIterator() {
  _makeLineIterator = (0, _wrapAsyncGenerator2.default)(_regenerator.default.mark(function _callee3(textIterator) {
    var previous, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _value3, textChunk, eolIndex, line;

    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            previous = '';
            _iteratorNormalCompletion3 = true;
            _didIteratorError3 = false;
            _context3.prev = 3;
            _iterator3 = (0, _asyncIterator2.default)(textIterator);

          case 5:
            _context3.next = 7;
            return (0, _awaitAsyncGenerator2.default)(_iterator3.next());

          case 7:
            _step3 = _context3.sent;
            _iteratorNormalCompletion3 = _step3.done;
            _context3.next = 11;
            return (0, _awaitAsyncGenerator2.default)(_step3.value);

          case 11:
            _value3 = _context3.sent;

            if (_iteratorNormalCompletion3) {
              _context3.next = 26;
              break;
            }

            textChunk = _value3;
            previous += textChunk;
            eolIndex = void 0;

          case 16:
            if (!((eolIndex = previous.indexOf('\n')) >= 0)) {
              _context3.next = 23;
              break;
            }

            line = previous.slice(0, eolIndex + 1);
            previous = previous.slice(eolIndex + 1);
            _context3.next = 21;
            return line;

          case 21:
            _context3.next = 16;
            break;

          case 23:
            _iteratorNormalCompletion3 = true;
            _context3.next = 5;
            break;

          case 26:
            _context3.next = 32;
            break;

          case 28:
            _context3.prev = 28;
            _context3.t0 = _context3["catch"](3);
            _didIteratorError3 = true;
            _iteratorError3 = _context3.t0;

          case 32:
            _context3.prev = 32;
            _context3.prev = 33;

            if (!(!_iteratorNormalCompletion3 && _iterator3.return != null)) {
              _context3.next = 37;
              break;
            }

            _context3.next = 37;
            return (0, _awaitAsyncGenerator2.default)(_iterator3.return());

          case 37:
            _context3.prev = 37;

            if (!_didIteratorError3) {
              _context3.next = 40;
              break;
            }

            throw _iteratorError3;

          case 40:
            return _context3.finish(37);

          case 41:
            return _context3.finish(32);

          case 42:
            if (!(previous.length > 0)) {
              _context3.next = 45;
              break;
            }

            _context3.next = 45;
            return previous;

          case 45:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[3, 28, 32, 42], [33,, 37, 41]]);
  }));
  return _makeLineIterator.apply(this, arguments);
}

function makeNumberedLineIterator(_x4) {
  return _makeNumberedLineIterator.apply(this, arguments);
}

function _makeNumberedLineIterator() {
  _makeNumberedLineIterator = (0, _wrapAsyncGenerator2.default)(_regenerator.default.mark(function _callee4(lineIterator) {
    var counter, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, _value4, line;

    return _regenerator.default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            counter = 1;
            _iteratorNormalCompletion4 = true;
            _didIteratorError4 = false;
            _context4.prev = 3;
            _iterator4 = (0, _asyncIterator2.default)(lineIterator);

          case 5:
            _context4.next = 7;
            return (0, _awaitAsyncGenerator2.default)(_iterator4.next());

          case 7:
            _step4 = _context4.sent;
            _iteratorNormalCompletion4 = _step4.done;
            _context4.next = 11;
            return (0, _awaitAsyncGenerator2.default)(_step4.value);

          case 11:
            _value4 = _context4.sent;

            if (_iteratorNormalCompletion4) {
              _context4.next = 20;
              break;
            }

            line = _value4;
            _context4.next = 16;
            return {
              counter: counter,
              line: line
            };

          case 16:
            counter++;

          case 17:
            _iteratorNormalCompletion4 = true;
            _context4.next = 5;
            break;

          case 20:
            _context4.next = 26;
            break;

          case 22:
            _context4.prev = 22;
            _context4.t0 = _context4["catch"](3);
            _didIteratorError4 = true;
            _iteratorError4 = _context4.t0;

          case 26:
            _context4.prev = 26;
            _context4.prev = 27;

            if (!(!_iteratorNormalCompletion4 && _iterator4.return != null)) {
              _context4.next = 31;
              break;
            }

            _context4.next = 31;
            return (0, _awaitAsyncGenerator2.default)(_iterator4.return());

          case 31:
            _context4.prev = 31;

            if (!_didIteratorError4) {
              _context4.next = 34;
              break;
            }

            throw _iteratorError4;

          case 34:
            return _context4.finish(31);

          case 35:
            return _context4.finish(26);

          case 36:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, null, [[3, 22, 26, 36], [27,, 31, 35]]);
  }));
  return _makeNumberedLineIterator.apply(this, arguments);
}

},{"@babel/runtime/helpers/asyncIterator":9,"@babel/runtime/helpers/awaitAsyncGenerator":11,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/wrapAsyncGenerator":31,"@babel/runtime/regenerator":33}],85:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseJSON = parseJSON;

var _getFirstCharacters = require("../binary-utils/get-first-characters");

function parseJSON(string) {
  try {
    return JSON.parse(string);
  } catch (_) {
    throw new Error("Failed to parse JSON from data starting with \"".concat((0, _getFirstCharacters.getFirstCharacters)(string), "\""));
  }
}

},{"../binary-utils/get-first-characters":79}],86:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setPathPrefix = setPathPrefix;
exports.getPathPrefix = getPathPrefix;
exports.addAliases = addAliases;
exports.resolvePath = resolvePath;
var pathPrefix = '';
var fileAliases = {};

function setPathPrefix(prefix) {
  pathPrefix = prefix;
}

function getPathPrefix() {
  return pathPrefix;
}

function addAliases(aliases) {
  Object.assign(fileAliases, aliases);
}

function resolvePath(filename) {
  for (var alias in fileAliases) {
    if (filename.startsWith(alias)) {
      var replacement = fileAliases[alias];
      filename = filename.replace(alias, replacement);
    }
  }

  if (!filename.startsWith('http://') && !filename.startsWith('https://')) {
    filename = "".concat(pathPrefix).concat(filename);
  }

  return filename;
}

},{}],87:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dirname = dirname;
exports.join = join;

function dirname(url) {
  var slashIndex = url && url.lastIndexOf('/');
  return slashIndex >= 0 ? url.substr(0, slashIndex) : '';
}

function join() {
  for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
    parts[_key] = arguments[_key];
  }

  var separator = '/';
  parts = parts.map(function (part, index) {
    if (index) {
      part = part.replace(new RegExp("^".concat(separator)), '');
    }

    if (index !== parts.length - 1) {
      part = part.replace(new RegExp("".concat(separator, "$")), '');
    }

    return part;
  });
  return parts.join(separator);
}

},{}],88:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _stats = require("@probe.gl/stats");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var STAT_QUEUED_REQUESTS = 'Queued Requests';
var STAT_ACTIVE_REQUESTS = 'Active Requests';
var STAT_CANCELLED_REQUESTS = 'Cancelled Requests';
var STAT_QUEUED_REQUESTS_EVER = 'Queued Requests Ever';
var STAT_ACTIVE_REQUESTS_EVER = 'Active Requests Ever';
var DEFAULT_PROPS = {
  id: 'request-scheduler',
  throttleRequests: true,
  maxRequests: 6
};

var RequestScheduler = function () {
  function RequestScheduler() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, RequestScheduler);
    (0, _defineProperty2.default)(this, "props", void 0);
    (0, _defineProperty2.default)(this, "stats", void 0);
    (0, _defineProperty2.default)(this, "activeRequestCount", 0);
    (0, _defineProperty2.default)(this, "requestQueue", []);
    (0, _defineProperty2.default)(this, "requestMap", new Map());
    (0, _defineProperty2.default)(this, "deferredUpdate", null);
    this.props = _objectSpread(_objectSpread({}, DEFAULT_PROPS), props);
    this.stats = new _stats.Stats({
      id: this.props.id
    });
    this.stats.get(STAT_QUEUED_REQUESTS);
    this.stats.get(STAT_ACTIVE_REQUESTS);
    this.stats.get(STAT_CANCELLED_REQUESTS);
    this.stats.get(STAT_QUEUED_REQUESTS_EVER);
    this.stats.get(STAT_ACTIVE_REQUESTS_EVER);
  }

  (0, _createClass2.default)(RequestScheduler, [{
    key: "scheduleRequest",
    value: function scheduleRequest(handle) {
      var getPriority = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
        return 0;
      };

      if (!this.props.throttleRequests) {
        return Promise.resolve({
          done: function done() {}
        });
      }

      if (this.requestMap.has(handle)) {
        return this.requestMap.get(handle);
      }

      var request = {
        handle: handle,
        priority: 0,
        getPriority: getPriority
      };
      var promise = new Promise(function (resolve) {
        request.resolve = resolve;
        return request;
      });
      this.requestQueue.push(request);
      this.requestMap.set(handle, promise);

      this._issueNewRequests();

      return promise;
    }
  }, {
    key: "_issueRequest",
    value: function _issueRequest(request) {
      var _this = this;

      var handle = request.handle,
          resolve = request.resolve;
      var isDone = false;

      var done = function done() {
        if (!isDone) {
          isDone = true;

          _this.requestMap.delete(handle);

          _this.activeRequestCount--;

          _this._issueNewRequests();
        }
      };

      this.activeRequestCount++;
      return resolve ? resolve({
        done: done
      }) : Promise.resolve({
        done: done
      });
    }
  }, {
    key: "_issueNewRequests",
    value: function _issueNewRequests() {
      var _this2 = this;

      if (!this.deferredUpdate) {
        this.deferredUpdate = setTimeout(function () {
          return _this2._issueNewRequestsAsync();
        }, 0);
      }
    }
  }, {
    key: "_issueNewRequestsAsync",
    value: function _issueNewRequestsAsync() {
      this.deferredUpdate = null;
      var freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);

      if (freeSlots === 0) {
        return;
      }

      this._updateAllRequests();

      for (var i = 0; i < freeSlots; ++i) {
        var request = this.requestQueue.shift();

        if (request) {
          this._issueRequest(request);
        }
      }
    }
  }, {
    key: "_updateAllRequests",
    value: function _updateAllRequests() {
      var requestQueue = this.requestQueue;

      for (var i = 0; i < requestQueue.length; ++i) {
        var request = requestQueue[i];

        if (!this._updateRequest(request)) {
          requestQueue.splice(i, 1);
          this.requestMap.delete(request.handle);
          i--;
        }
      }

      requestQueue.sort(function (a, b) {
        return a.priority - b.priority;
      });
    }
  }, {
    key: "_updateRequest",
    value: function _updateRequest(request) {
      request.priority = request.getPriority(request.handle);

      if (request.priority < 0) {
        request.resolve(null);
        return false;
      }

      return true;
    }
  }]);
  return RequestScheduler;
}();

exports.default = RequestScheduler;

},{"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@probe.gl/stats":126}],89:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createLoaderWorker = createLoaderWorker;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _workerUtils = require("@loaders.gl/worker-utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var requestId = 0;

function createLoaderWorker(loader) {
  if (typeof self === 'undefined') {
    return;
  }

  _workerUtils.WorkerBody.onmessage = function () {
    var _ref = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(type, payload) {
      var input, _payload$options, options, result, message;

      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.t0 = type;
              _context.next = _context.t0 === 'process' ? 3 : 16;
              break;

            case 3:
              _context.prev = 3;
              input = payload.input, _payload$options = payload.options, options = _payload$options === void 0 ? {} : _payload$options;
              _context.next = 7;
              return parseData({
                loader: loader,
                arrayBuffer: input,
                options: options,
                context: {
                  parse: parseOnMainThread
                }
              });

            case 7:
              result = _context.sent;

              _workerUtils.WorkerBody.postMessage('done', {
                result: result
              });

              _context.next = 15;
              break;

            case 11:
              _context.prev = 11;
              _context.t1 = _context["catch"](3);
              message = _context.t1 instanceof Error ? _context.t1.message : '';

              _workerUtils.WorkerBody.postMessage('error', {
                error: message
              });

            case 15:
              return _context.abrupt("break", 16);

            case 16:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[3, 11]]);
    }));

    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();
}

function parseOnMainThread(arrayBuffer, options) {
  return new Promise(function (resolve, reject) {
    var id = requestId++;

    var onMessage = function onMessage(type, payload) {
      if (payload.id !== id) {
        return;
      }

      switch (type) {
        case 'done':
          _workerUtils.WorkerBody.removeEventListener(onMessage);

          resolve(payload.result);
          break;

        case 'error':
          _workerUtils.WorkerBody.removeEventListener(onMessage);

          reject(payload.error);
          break;

        default:
      }
    };

    _workerUtils.WorkerBody.addEventListener(onMessage);

    var payload = {
      id: id,
      input: arrayBuffer,
      options: options
    };

    _workerUtils.WorkerBody.postMessage('process', payload);
  });
}

function parseData(_x3) {
  return _parseData.apply(this, arguments);
}

function _parseData() {
  _parseData = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(_ref2) {
    var loader, arrayBuffer, options, context, data, parser, textDecoder;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            loader = _ref2.loader, arrayBuffer = _ref2.arrayBuffer, options = _ref2.options, context = _ref2.context;

            if (!(loader.parseSync || loader.parse)) {
              _context2.next = 6;
              break;
            }

            data = arrayBuffer;
            parser = loader.parseSync || loader.parse;
            _context2.next = 13;
            break;

          case 6:
            if (!loader.parseTextSync) {
              _context2.next = 12;
              break;
            }

            textDecoder = new TextDecoder();
            data = textDecoder.decode(arrayBuffer);
            parser = loader.parseTextSync;
            _context2.next = 13;
            break;

          case 12:
            throw new Error("Could not load data with ".concat(loader.name, " loader"));

          case 13:
            options = _objectSpread(_objectSpread({}, options), {}, {
              modules: loader && loader.options && loader.options.modules || {},
              worker: false
            });
            _context2.next = 16;
            return parser(data, _objectSpread({}, options), context, loader);

          case 16:
            return _context2.abrupt("return", _context2.sent);

          case 17:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _parseData.apply(this, arguments);
}

},{"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33,"@loaders.gl/worker-utils":108}],90:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.canParseWithWorker = canParseWithWorker;
exports.parseWithWorker = parseWithWorker;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _workerUtils = require("@loaders.gl/worker-utils");

function canParseWithWorker(loader, options) {
  if (!_workerUtils.WorkerFarm.isSupported()) {
    return false;
  }

  return loader.worker && (options === null || options === void 0 ? void 0 : options.worker);
}

function parseWithWorker(_x, _x2, _x3, _x4, _x5) {
  return _parseWithWorker.apply(this, arguments);
}

function _parseWithWorker() {
  _parseWithWorker = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(loader, data, options, context, parseOnMainThread) {
    var name, url, workerFarm, workerPool, job, result;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            name = loader.id;
            url = (0, _workerUtils.getWorkerURL)(loader, options);
            workerFarm = _workerUtils.WorkerFarm.getWorkerFarm(options);
            workerPool = workerFarm.getWorkerPool({
              name: name,
              url: url
            });
            options = JSON.parse(JSON.stringify(options));
            _context.next = 7;
            return workerPool.startJob('process-on-worker', onMessage.bind(null, parseOnMainThread));

          case 7:
            job = _context.sent;
            job.postMessage('process', {
              input: data,
              options: options
            });
            _context.next = 11;
            return job.result;

          case 11:
            result = _context.sent;
            _context.next = 14;
            return result.result;

          case 14:
            return _context.abrupt("return", _context.sent);

          case 15:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _parseWithWorker.apply(this, arguments);
}

function onMessage(_x6, _x7, _x8, _x9) {
  return _onMessage.apply(this, arguments);
}

function _onMessage() {
  _onMessage = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(parseOnMainThread, job, type, payload) {
    var id, input, options, result, message;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.t0 = type;
            _context2.next = _context2.t0 === 'done' ? 3 : _context2.t0 === 'error' ? 5 : _context2.t0 === 'process' ? 7 : 20;
            break;

          case 3:
            job.done(payload);
            return _context2.abrupt("break", 21);

          case 5:
            job.error(payload.error);
            return _context2.abrupt("break", 21);

          case 7:
            id = payload.id, input = payload.input, options = payload.options;
            _context2.prev = 8;
            _context2.next = 11;
            return parseOnMainThread(input, options);

          case 11:
            result = _context2.sent;
            job.postMessage('done', {
              id: id,
              result: result
            });
            _context2.next = 19;
            break;

          case 15:
            _context2.prev = 15;
            _context2.t1 = _context2["catch"](8);
            message = _context2.t1 instanceof Error ? _context2.t1.message : 'unknown error';
            job.postMessage('error', {
              id: id,
              error: message
            });

          case 19:
            return _context2.abrupt("break", 21);

          case 20:
            console.warn("parse-with-worker unknown message ".concat(type));

          case 21:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[8, 15]]);
  }));
  return _onMessage.apply(this, arguments);
}

},{"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33,"@loaders.gl/worker-utils":108}],91:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMeshSize = getMeshSize;
exports.getMeshBoundingBox = getMeshBoundingBox;

function getMeshSize(attributes) {
  var size = 0;

  for (var attributeName in attributes) {
    var attribute = attributes[attributeName];

    if (ArrayBuffer.isView(attribute)) {
      size += attribute.byteLength * attribute.BYTES_PER_ELEMENT;
    }
  }

  return size;
}

function getMeshBoundingBox(attributes) {
  var minX = Infinity;
  var minY = Infinity;
  var minZ = Infinity;
  var maxX = -Infinity;
  var maxY = -Infinity;
  var maxZ = -Infinity;
  var positions = attributes.POSITION ? attributes.POSITION.value : [];
  var len = positions && positions.length;

  for (var i = 0; i < len; i += 3) {
    var x = positions[i];
    var y = positions[i + 1];
    var z = positions[i + 2];
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    minZ = z < minZ ? z : minZ;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    maxZ = z > maxZ ? z : maxZ;
  }

  return [[minX, minY, minZ], [maxX, maxY, maxZ]];
}

},{}],92:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "TableBatchBuilder", {
  enumerable: true,
  get: function get() {
    return _tableBatchBuilder.default;
  }
});
Object.defineProperty(exports, "RowTableBatchAggregator", {
  enumerable: true,
  get: function get() {
    return _rowTableBatchAggregator.default;
  }
});
Object.defineProperty(exports, "ColumnarTableBatchAggregator", {
  enumerable: true,
  get: function get() {
    return _columnarTableBatchAggregator.default;
  }
});
Object.defineProperty(exports, "convertToObjectRow", {
  enumerable: true,
  get: function get() {
    return _rowUtils.convertToObjectRow;
  }
});
Object.defineProperty(exports, "convertToArrayRow", {
  enumerable: true,
  get: function get() {
    return _rowUtils.convertToArrayRow;
  }
});
Object.defineProperty(exports, "getMeshSize", {
  enumerable: true,
  get: function get() {
    return _meshUtils.getMeshSize;
  }
});
Object.defineProperty(exports, "getMeshBoundingBox", {
  enumerable: true,
  get: function get() {
    return _meshUtils.getMeshBoundingBox;
  }
});
Object.defineProperty(exports, "Schema", {
  enumerable: true,
  get: function get() {
    return _schema.Schema;
  }
});
Object.defineProperty(exports, "Field", {
  enumerable: true,
  get: function get() {
    return _schema.Field;
  }
});
Object.defineProperty(exports, "DataType", {
  enumerable: true,
  get: function get() {
    return _schema.DataType;
  }
});
Object.defineProperty(exports, "Null", {
  enumerable: true,
  get: function get() {
    return _schema.Null;
  }
});
Object.defineProperty(exports, "Binary", {
  enumerable: true,
  get: function get() {
    return _schema.Binary;
  }
});
Object.defineProperty(exports, "Bool", {
  enumerable: true,
  get: function get() {
    return _schema.Bool;
  }
});
Object.defineProperty(exports, "Int", {
  enumerable: true,
  get: function get() {
    return _schema.Int;
  }
});
Object.defineProperty(exports, "Int8", {
  enumerable: true,
  get: function get() {
    return _schema.Int8;
  }
});
Object.defineProperty(exports, "Int16", {
  enumerable: true,
  get: function get() {
    return _schema.Int16;
  }
});
Object.defineProperty(exports, "Int32", {
  enumerable: true,
  get: function get() {
    return _schema.Int32;
  }
});
Object.defineProperty(exports, "Int64", {
  enumerable: true,
  get: function get() {
    return _schema.Int64;
  }
});
Object.defineProperty(exports, "Uint8", {
  enumerable: true,
  get: function get() {
    return _schema.Uint8;
  }
});
Object.defineProperty(exports, "Uint16", {
  enumerable: true,
  get: function get() {
    return _schema.Uint16;
  }
});
Object.defineProperty(exports, "Uint32", {
  enumerable: true,
  get: function get() {
    return _schema.Uint32;
  }
});
Object.defineProperty(exports, "Uint64", {
  enumerable: true,
  get: function get() {
    return _schema.Uint64;
  }
});
Object.defineProperty(exports, "Float", {
  enumerable: true,
  get: function get() {
    return _schema.Float;
  }
});
Object.defineProperty(exports, "Float16", {
  enumerable: true,
  get: function get() {
    return _schema.Float16;
  }
});
Object.defineProperty(exports, "Float32", {
  enumerable: true,
  get: function get() {
    return _schema.Float32;
  }
});
Object.defineProperty(exports, "Float64", {
  enumerable: true,
  get: function get() {
    return _schema.Float64;
  }
});
Object.defineProperty(exports, "Utf8", {
  enumerable: true,
  get: function get() {
    return _schema.Utf8;
  }
});
Object.defineProperty(exports, "Date", {
  enumerable: true,
  get: function get() {
    return _schema.Date;
  }
});
Object.defineProperty(exports, "DateDay", {
  enumerable: true,
  get: function get() {
    return _schema.DateDay;
  }
});
Object.defineProperty(exports, "DateMillisecond", {
  enumerable: true,
  get: function get() {
    return _schema.DateMillisecond;
  }
});
Object.defineProperty(exports, "Time", {
  enumerable: true,
  get: function get() {
    return _schema.Time;
  }
});
Object.defineProperty(exports, "TimeMillisecond", {
  enumerable: true,
  get: function get() {
    return _schema.TimeMillisecond;
  }
});
Object.defineProperty(exports, "TimeSecond", {
  enumerable: true,
  get: function get() {
    return _schema.TimeSecond;
  }
});
Object.defineProperty(exports, "Timestamp", {
  enumerable: true,
  get: function get() {
    return _schema.Timestamp;
  }
});
Object.defineProperty(exports, "TimestampSecond", {
  enumerable: true,
  get: function get() {
    return _schema.TimestampSecond;
  }
});
Object.defineProperty(exports, "TimestampMillisecond", {
  enumerable: true,
  get: function get() {
    return _schema.TimestampMillisecond;
  }
});
Object.defineProperty(exports, "TimestampMicrosecond", {
  enumerable: true,
  get: function get() {
    return _schema.TimestampMicrosecond;
  }
});
Object.defineProperty(exports, "TimestampNanosecond", {
  enumerable: true,
  get: function get() {
    return _schema.TimestampNanosecond;
  }
});
Object.defineProperty(exports, "Interval", {
  enumerable: true,
  get: function get() {
    return _schema.Interval;
  }
});
Object.defineProperty(exports, "IntervalDayTime", {
  enumerable: true,
  get: function get() {
    return _schema.IntervalDayTime;
  }
});
Object.defineProperty(exports, "IntervalYearMonth", {
  enumerable: true,
  get: function get() {
    return _schema.IntervalYearMonth;
  }
});
Object.defineProperty(exports, "FixedSizeList", {
  enumerable: true,
  get: function get() {
    return _schema.FixedSizeList;
  }
});
Object.defineProperty(exports, "deduceTableSchema", {
  enumerable: true,
  get: function get() {
    return _deduceTableSchema.deduceTableSchema;
  }
});
Object.defineProperty(exports, "getTypeInfo", {
  enumerable: true,
  get: function get() {
    return _getTypeInfo.getTypeInfo;
  }
});
Object.defineProperty(exports, "getArrowTypeFromTypedArray", {
  enumerable: true,
  get: function get() {
    return _typeUtils.getArrowTypeFromTypedArray;
  }
});
Object.defineProperty(exports, "AsyncQueue", {
  enumerable: true,
  get: function get() {
    return _asyncQueue.default;
  }
});

var _tableBatchBuilder = _interopRequireDefault(require("./lib/table/table-batch-builder"));

var _rowTableBatchAggregator = _interopRequireDefault(require("./lib/table/row-table-batch-aggregator"));

var _columnarTableBatchAggregator = _interopRequireDefault(require("./lib/table/columnar-table-batch-aggregator"));

var _rowUtils = require("./lib/utils/row-utils");

var _meshUtils = require("./category/mesh/mesh-utils");

var _schema = require("./lib/schema");

var _deduceTableSchema = require("./lib/schema-utils/deduce-table-schema");

var _getTypeInfo = require("./lib/schema-utils/get-type-info");

var _typeUtils = require("./lib/schema-utils/type-utils");

var _asyncQueue = _interopRequireDefault(require("./lib/utils/async-queue"));

},{"./category/mesh/mesh-utils":91,"./lib/schema":100,"./lib/schema-utils/deduce-table-schema":93,"./lib/schema-utils/get-type-info":94,"./lib/schema-utils/type-utils":95,"./lib/table/columnar-table-batch-aggregator":102,"./lib/table/row-table-batch-aggregator":103,"./lib/table/table-batch-builder":104,"./lib/utils/async-queue":106,"./lib/utils/row-utils":107,"@babel/runtime/helpers/interopRequireDefault":18}],93:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deduceTableSchema = deduceTableSchema;

function deduceTableSchema(table, schema) {
  var deducedSchema = Array.isArray(table) ? deduceSchemaForRowTable(table) : deduceSchemaForColumnarTable(table);
  return Object.assign(deducedSchema, schema);
}

function deduceSchemaForColumnarTable(columnarTable) {
  var schema = {};

  for (var field in columnarTable) {
    var column = columnarTable[field];

    if (ArrayBuffer.isView(column)) {
      schema[field] = column.constructor;
    } else if (column.length) {
      var value = column[0];
      schema[field] = deduceTypeFromValue(value);
    }

    schema[field] = schema[field] || null;
  }

  return schema;
}

function deduceSchemaForRowTable(rowTable) {
  var schema = {};

  if (rowTable.length) {
    var row = rowTable[0];

    for (var field in row) {
      var value = row[field];
      schema[field] = deduceTypeFromValue(value);
    }
  }

  return schema;
}

function deduceTypeFromValue(value) {
  if (value instanceof Date) {
    return Date;
  } else if (value instanceof Number) {
    return Float32Array;
  } else if (typeof value === 'string') {
    return String;
  }

  return null;
}

},{}],94:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTypeInfo = getTypeInfo;

var _schema = require("../schema");

function getTypeInfo(arrowTypeLike) {
  return {
    typeId: arrowTypeLike.typeId,
    ArrayType: arrowTypeLike.ArrayType,
    typeName: arrowTypeLike.toString(),
    typeEnumName: getTypeKey(arrowTypeLike.typeId),
    precision: arrowTypeLike.precision
  };
}

var ReverseType = null;

function getTypeKey(typeKey) {
  if (!ReverseType) {
    ReverseType = {};

    for (var _key in _schema.Type) {
      ReverseType[_schema.Type[_key]] = _key;
    }
  }

  return ReverseType[typeKey];
}

},{"../schema":100}],95:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getArrowTypeFromTypedArray = getArrowTypeFromTypedArray;

var _schema = require("../schema");

function getArrowTypeFromTypedArray(array) {
  switch (array.constructor) {
    case Int8Array:
      return new _schema.Int8();

    case Uint8Array:
      return new _schema.Uint8();

    case Int16Array:
      return new _schema.Int16();

    case Uint16Array:
      return new _schema.Uint16();

    case Int32Array:
      return new _schema.Int32();

    case Uint32Array:
      return new _schema.Uint32();

    case Float32Array:
      return new _schema.Float32();

    case Float64Array:
      return new _schema.Float64();

    default:
      throw new Error('array type not supported');
  }
}

},{"../schema":100}],96:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Type = void 0;
var Type;
exports.Type = Type;

(function (Type) {
  Type[Type["NONE"] = 0] = "NONE";
  Type[Type["Null"] = 1] = "Null";
  Type[Type["Int"] = 2] = "Int";
  Type[Type["Float"] = 3] = "Float";
  Type[Type["Binary"] = 4] = "Binary";
  Type[Type["Utf8"] = 5] = "Utf8";
  Type[Type["Bool"] = 6] = "Bool";
  Type[Type["Decimal"] = 7] = "Decimal";
  Type[Type["Date"] = 8] = "Date";
  Type[Type["Time"] = 9] = "Time";
  Type[Type["Timestamp"] = 10] = "Timestamp";
  Type[Type["Interval"] = 11] = "Interval";
  Type[Type["List"] = 12] = "List";
  Type[Type["Struct"] = 13] = "Struct";
  Type[Type["Union"] = 14] = "Union";
  Type[Type["FixedSizeBinary"] = 15] = "FixedSizeBinary";
  Type[Type["FixedSizeList"] = 16] = "FixedSizeList";
  Type[Type["Map"] = 17] = "Map";
  Type[Type["Dictionary"] = -1] = "Dictionary";
  Type[Type["Int8"] = -2] = "Int8";
  Type[Type["Int16"] = -3] = "Int16";
  Type[Type["Int32"] = -4] = "Int32";
  Type[Type["Int64"] = -5] = "Int64";
  Type[Type["Uint8"] = -6] = "Uint8";
  Type[Type["Uint16"] = -7] = "Uint16";
  Type[Type["Uint32"] = -8] = "Uint32";
  Type[Type["Uint64"] = -9] = "Uint64";
  Type[Type["Float16"] = -10] = "Float16";
  Type[Type["Float32"] = -11] = "Float32";
  Type[Type["Float64"] = -12] = "Float64";
  Type[Type["DateDay"] = -13] = "DateDay";
  Type[Type["DateMillisecond"] = -14] = "DateMillisecond";
  Type[Type["TimestampSecond"] = -15] = "TimestampSecond";
  Type[Type["TimestampMillisecond"] = -16] = "TimestampMillisecond";
  Type[Type["TimestampMicrosecond"] = -17] = "TimestampMicrosecond";
  Type[Type["TimestampNanosecond"] = -18] = "TimestampNanosecond";
  Type[Type["TimeSecond"] = -19] = "TimeSecond";
  Type[Type["TimeMillisecond"] = -20] = "TimeMillisecond";
  Type[Type["TimeMicrosecond"] = -21] = "TimeMicrosecond";
  Type[Type["TimeNanosecond"] = -22] = "TimeNanosecond";
  Type[Type["DenseUnion"] = -23] = "DenseUnion";
  Type[Type["SparseUnion"] = -24] = "SparseUnion";
  Type[Type["IntervalDayTime"] = -25] = "IntervalDayTime";
  Type[Type["IntervalYearMonth"] = -26] = "IntervalYearMonth";
})(Type || (exports.Type = Type = {}));

},{}],97:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var Field = function () {
  function Field(name, type) {
    var nullable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var metadata = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Map();
    (0, _classCallCheck2.default)(this, Field);
    (0, _defineProperty2.default)(this, "name", void 0);
    (0, _defineProperty2.default)(this, "type", void 0);
    (0, _defineProperty2.default)(this, "nullable", void 0);
    (0, _defineProperty2.default)(this, "metadata", void 0);
    this.name = name;
    this.type = type;
    this.nullable = nullable;
    this.metadata = metadata;
  }

  (0, _createClass2.default)(Field, [{
    key: "typeId",
    get: function get() {
      return this.type && this.type.typeId;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new Field(this.name, this.type, this.nullable, this.metadata);
    }
  }, {
    key: "compareTo",
    value: function compareTo(other) {
      return this.name === other.name && this.type === other.type && this.nullable === other.nullable && this.metadata === other.metadata;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "".concat(this.type).concat(this.nullable ? ', nullable' : '').concat(this.metadata ? ", metadata: ".concat(this.metadata) : '');
    }
  }]);
  return Field;
}();

exports.default = Field;

},{"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18}],98:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _assert = require("../../utils/assert");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var Schema = function () {
  function Schema(fields, metadata) {
    (0, _classCallCheck2.default)(this, Schema);
    (0, _defineProperty2.default)(this, "fields", void 0);
    (0, _defineProperty2.default)(this, "metadata", void 0);
    (0, _assert.assert)(Array.isArray(fields));
    checkNames(fields);
    this.fields = fields;
    this.metadata = metadata || new Map();
  }

  (0, _createClass2.default)(Schema, [{
    key: "compareTo",
    value: function compareTo(other) {
      if (this.metadata !== other.metadata) {
        return false;
      }

      if (this.fields.length !== other.fields.length) {
        return false;
      }

      for (var i = 0; i < this.fields.length; ++i) {
        if (!this.fields[i].compareTo(other.fields[i])) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "select",
    value: function select() {
      var nameMap = Object.create(null);

      for (var _len = arguments.length, columnNames = new Array(_len), _key = 0; _key < _len; _key++) {
        columnNames[_key] = arguments[_key];
      }

      for (var _i = 0, _columnNames = columnNames; _i < _columnNames.length; _i++) {
        var name = _columnNames[_i];
        nameMap[name] = true;
      }

      var selectedFields = this.fields.filter(function (field) {
        return nameMap[field.name];
      });
      return new Schema(selectedFields, this.metadata);
    }
  }, {
    key: "selectAt",
    value: function selectAt() {
      var _this = this;

      for (var _len2 = arguments.length, columnIndices = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        columnIndices[_key2] = arguments[_key2];
      }

      var selectedFields = columnIndices.map(function (index) {
        return _this.fields[index];
      }).filter(Boolean);
      return new Schema(selectedFields, this.metadata);
    }
  }, {
    key: "assign",
    value: function assign(schemaOrFields) {
      var fields;
      var metadata = this.metadata;

      if (schemaOrFields instanceof Schema) {
        var otherSchema = schemaOrFields;
        fields = otherSchema.fields;
        metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);
      } else {
        fields = schemaOrFields;
      }

      var fieldMap = Object.create(null);

      var _iterator = _createForOfIteratorHelper(this.fields),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var field = _step.value;
          fieldMap[field.name] = field;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var _iterator2 = _createForOfIteratorHelper(fields),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _field = _step2.value;
          fieldMap[_field.name] = _field;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      var mergedFields = Object.values(fieldMap);
      return new Schema(mergedFields, metadata);
    }
  }]);
  return Schema;
}();

exports.default = Schema;

function checkNames(fields) {
  var usedNames = {};

  var _iterator3 = _createForOfIteratorHelper(fields),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var field = _step3.value;

      if (usedNames[field.name]) {
        console.warn('Schema: duplicated field name', field.name, field);
      }

      usedNames[field.name] = true;
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
}

function mergeMaps(m1, m2) {
  return new Map([].concat((0, _toConsumableArray2.default)(m1 || new Map()), (0, _toConsumableArray2.default)(m2 || new Map())));
}

},{"../../utils/assert":105,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/toConsumableArray":28}],99:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Type", {
  enumerable: true,
  get: function get() {
    return _enum.Type;
  }
});
exports.FixedSizeList = exports.IntervalYearMonth = exports.IntervalDayTime = exports.Interval = exports.TimestampNanosecond = exports.TimestampMicrosecond = exports.TimestampMillisecond = exports.TimestampSecond = exports.Timestamp = exports.TimeMillisecond = exports.TimeSecond = exports.Time = exports.DateMillisecond = exports.DateDay = exports.Date = exports.Utf8 = exports.Binary = exports.Float64 = exports.Float32 = exports.Float16 = exports.Float = exports.Uint64 = exports.Uint32 = exports.Uint16 = exports.Uint8 = exports.Int64 = exports.Int32 = exports.Int16 = exports.Int8 = exports.Int = exports.Bool = exports.Null = exports.DataType = void 0;

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _enum = require("./enum");

var _Symbol$toStringTag, _Symbol$toStringTag2, _Symbol$toStringTag3, _Symbol$toStringTag4, _Symbol$toStringTag5, _Symbol$toStringTag6, _Symbol$toStringTag7;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var DataType = function () {
  function DataType() {
    (0, _classCallCheck2.default)(this, DataType);
  }

  (0, _createClass2.default)(DataType, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.NONE;
    }
  }, {
    key: "compareTo",
    value: function compareTo(other) {
      return this === other;
    }
  }], [{
    key: "isNull",
    value: function isNull(x) {
      return x && x.typeId === _enum.Type.Null;
    }
  }, {
    key: "isInt",
    value: function isInt(x) {
      return x && x.typeId === _enum.Type.Int;
    }
  }, {
    key: "isFloat",
    value: function isFloat(x) {
      return x && x.typeId === _enum.Type.Float;
    }
  }, {
    key: "isBinary",
    value: function isBinary(x) {
      return x && x.typeId === _enum.Type.Binary;
    }
  }, {
    key: "isUtf8",
    value: function isUtf8(x) {
      return x && x.typeId === _enum.Type.Utf8;
    }
  }, {
    key: "isBool",
    value: function isBool(x) {
      return x && x.typeId === _enum.Type.Bool;
    }
  }, {
    key: "isDecimal",
    value: function isDecimal(x) {
      return x && x.typeId === _enum.Type.Decimal;
    }
  }, {
    key: "isDate",
    value: function isDate(x) {
      return x && x.typeId === _enum.Type.Date;
    }
  }, {
    key: "isTime",
    value: function isTime(x) {
      return x && x.typeId === _enum.Type.Time;
    }
  }, {
    key: "isTimestamp",
    value: function isTimestamp(x) {
      return x && x.typeId === _enum.Type.Timestamp;
    }
  }, {
    key: "isInterval",
    value: function isInterval(x) {
      return x && x.typeId === _enum.Type.Interval;
    }
  }, {
    key: "isList",
    value: function isList(x) {
      return x && x.typeId === _enum.Type.List;
    }
  }, {
    key: "isStruct",
    value: function isStruct(x) {
      return x && x.typeId === _enum.Type.Struct;
    }
  }, {
    key: "isUnion",
    value: function isUnion(x) {
      return x && x.typeId === _enum.Type.Union;
    }
  }, {
    key: "isFixedSizeBinary",
    value: function isFixedSizeBinary(x) {
      return x && x.typeId === _enum.Type.FixedSizeBinary;
    }
  }, {
    key: "isFixedSizeList",
    value: function isFixedSizeList(x) {
      return x && x.typeId === _enum.Type.FixedSizeList;
    }
  }, {
    key: "isMap",
    value: function isMap(x) {
      return x && x.typeId === _enum.Type.Map;
    }
  }, {
    key: "isDictionary",
    value: function isDictionary(x) {
      return x && x.typeId === _enum.Type.Dictionary;
    }
  }]);
  return DataType;
}();

exports.DataType = DataType;

var Null = function (_DataType) {
  (0, _inherits2.default)(Null, _DataType);

  var _super = _createSuper(Null);

  function Null() {
    (0, _classCallCheck2.default)(this, Null);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(Null, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.Null;
    }
  }, {
    key: Symbol.toStringTag,
    get: function get() {
      return 'Null';
    }
  }, {
    key: "toString",
    value: function toString() {
      return 'Null';
    }
  }]);
  return Null;
}(DataType);

exports.Null = Null;

var Bool = function (_DataType2) {
  (0, _inherits2.default)(Bool, _DataType2);

  var _super2 = _createSuper(Bool);

  function Bool() {
    (0, _classCallCheck2.default)(this, Bool);
    return _super2.apply(this, arguments);
  }

  (0, _createClass2.default)(Bool, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.Bool;
    }
  }, {
    key: Symbol.toStringTag,
    get: function get() {
      return 'Bool';
    }
  }, {
    key: "toString",
    value: function toString() {
      return 'Bool';
    }
  }]);
  return Bool;
}(DataType);

exports.Bool = Bool;
_Symbol$toStringTag = Symbol.toStringTag;

var Int = function (_DataType3) {
  (0, _inherits2.default)(Int, _DataType3);

  var _super3 = _createSuper(Int);

  function Int(isSigned, bitWidth) {
    var _this;

    (0, _classCallCheck2.default)(this, Int);
    _this = _super3.call(this);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "isSigned", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "bitWidth", void 0);
    _this.isSigned = isSigned;
    _this.bitWidth = bitWidth;
    return _this;
  }

  (0, _createClass2.default)(Int, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.Int;
    }
  }, {
    key: _Symbol$toStringTag,
    get: function get() {
      return 'Int';
    }
  }, {
    key: "toString",
    value: function toString() {
      return "".concat(this.isSigned ? 'I' : 'Ui', "nt").concat(this.bitWidth);
    }
  }]);
  return Int;
}(DataType);

exports.Int = Int;

var Int8 = function (_Int) {
  (0, _inherits2.default)(Int8, _Int);

  var _super4 = _createSuper(Int8);

  function Int8() {
    (0, _classCallCheck2.default)(this, Int8);
    return _super4.call(this, true, 8);
  }

  return Int8;
}(Int);

exports.Int8 = Int8;

var Int16 = function (_Int2) {
  (0, _inherits2.default)(Int16, _Int2);

  var _super5 = _createSuper(Int16);

  function Int16() {
    (0, _classCallCheck2.default)(this, Int16);
    return _super5.call(this, true, 16);
  }

  return Int16;
}(Int);

exports.Int16 = Int16;

var Int32 = function (_Int3) {
  (0, _inherits2.default)(Int32, _Int3);

  var _super6 = _createSuper(Int32);

  function Int32() {
    (0, _classCallCheck2.default)(this, Int32);
    return _super6.call(this, true, 32);
  }

  return Int32;
}(Int);

exports.Int32 = Int32;

var Int64 = function (_Int4) {
  (0, _inherits2.default)(Int64, _Int4);

  var _super7 = _createSuper(Int64);

  function Int64() {
    (0, _classCallCheck2.default)(this, Int64);
    return _super7.call(this, true, 64);
  }

  return Int64;
}(Int);

exports.Int64 = Int64;

var Uint8 = function (_Int5) {
  (0, _inherits2.default)(Uint8, _Int5);

  var _super8 = _createSuper(Uint8);

  function Uint8() {
    (0, _classCallCheck2.default)(this, Uint8);
    return _super8.call(this, false, 8);
  }

  return Uint8;
}(Int);

exports.Uint8 = Uint8;

var Uint16 = function (_Int6) {
  (0, _inherits2.default)(Uint16, _Int6);

  var _super9 = _createSuper(Uint16);

  function Uint16() {
    (0, _classCallCheck2.default)(this, Uint16);
    return _super9.call(this, false, 16);
  }

  return Uint16;
}(Int);

exports.Uint16 = Uint16;

var Uint32 = function (_Int7) {
  (0, _inherits2.default)(Uint32, _Int7);

  var _super10 = _createSuper(Uint32);

  function Uint32() {
    (0, _classCallCheck2.default)(this, Uint32);
    return _super10.call(this, false, 32);
  }

  return Uint32;
}(Int);

exports.Uint32 = Uint32;

var Uint64 = function (_Int8) {
  (0, _inherits2.default)(Uint64, _Int8);

  var _super11 = _createSuper(Uint64);

  function Uint64() {
    (0, _classCallCheck2.default)(this, Uint64);
    return _super11.call(this, false, 64);
  }

  return Uint64;
}(Int);

exports.Uint64 = Uint64;
var Precision = {
  HALF: 16,
  SINGLE: 32,
  DOUBLE: 64
};
_Symbol$toStringTag2 = Symbol.toStringTag;

var Float = function (_DataType4) {
  (0, _inherits2.default)(Float, _DataType4);

  var _super12 = _createSuper(Float);

  function Float(precision) {
    var _this2;

    (0, _classCallCheck2.default)(this, Float);
    _this2 = _super12.call(this);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this2), "precision", void 0);
    _this2.precision = precision;
    return _this2;
  }

  (0, _createClass2.default)(Float, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.Float;
    }
  }, {
    key: _Symbol$toStringTag2,
    get: function get() {
      return 'Float';
    }
  }, {
    key: "toString",
    value: function toString() {
      return "Float".concat(this.precision);
    }
  }]);
  return Float;
}(DataType);

exports.Float = Float;

var Float16 = function (_Float) {
  (0, _inherits2.default)(Float16, _Float);

  var _super13 = _createSuper(Float16);

  function Float16() {
    (0, _classCallCheck2.default)(this, Float16);
    return _super13.call(this, Precision.HALF);
  }

  return Float16;
}(Float);

exports.Float16 = Float16;

var Float32 = function (_Float2) {
  (0, _inherits2.default)(Float32, _Float2);

  var _super14 = _createSuper(Float32);

  function Float32() {
    (0, _classCallCheck2.default)(this, Float32);
    return _super14.call(this, Precision.SINGLE);
  }

  return Float32;
}(Float);

exports.Float32 = Float32;

var Float64 = function (_Float3) {
  (0, _inherits2.default)(Float64, _Float3);

  var _super15 = _createSuper(Float64);

  function Float64() {
    (0, _classCallCheck2.default)(this, Float64);
    return _super15.call(this, Precision.DOUBLE);
  }

  return Float64;
}(Float);

exports.Float64 = Float64;

var Binary = function (_DataType5) {
  (0, _inherits2.default)(Binary, _DataType5);

  var _super16 = _createSuper(Binary);

  function Binary() {
    (0, _classCallCheck2.default)(this, Binary);
    return _super16.call(this);
  }

  (0, _createClass2.default)(Binary, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.Binary;
    }
  }, {
    key: "toString",
    value: function toString() {
      return 'Binary';
    }
  }, {
    key: Symbol.toStringTag,
    get: function get() {
      return 'Binary';
    }
  }]);
  return Binary;
}(DataType);

exports.Binary = Binary;

var Utf8 = function (_DataType6) {
  (0, _inherits2.default)(Utf8, _DataType6);

  var _super17 = _createSuper(Utf8);

  function Utf8() {
    (0, _classCallCheck2.default)(this, Utf8);
    return _super17.apply(this, arguments);
  }

  (0, _createClass2.default)(Utf8, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.Utf8;
    }
  }, {
    key: Symbol.toStringTag,
    get: function get() {
      return 'Utf8';
    }
  }, {
    key: "toString",
    value: function toString() {
      return 'Utf8';
    }
  }]);
  return Utf8;
}(DataType);

exports.Utf8 = Utf8;
var DateUnit = {
  DAY: 0,
  MILLISECOND: 1
};
_Symbol$toStringTag3 = Symbol.toStringTag;

var Date = function (_DataType7) {
  (0, _inherits2.default)(Date, _DataType7);

  var _super18 = _createSuper(Date);

  function Date(unit) {
    var _this3;

    (0, _classCallCheck2.default)(this, Date);
    _this3 = _super18.call(this);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this3), "unit", void 0);
    _this3.unit = unit;
    return _this3;
  }

  (0, _createClass2.default)(Date, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.Date;
    }
  }, {
    key: _Symbol$toStringTag3,
    get: function get() {
      return 'Date';
    }
  }, {
    key: "toString",
    value: function toString() {
      return "Date".concat((this.unit + 1) * 32, "<").concat(DateUnit[this.unit], ">");
    }
  }]);
  return Date;
}(DataType);

exports.Date = Date;

var DateDay = function (_Date) {
  (0, _inherits2.default)(DateDay, _Date);

  var _super19 = _createSuper(DateDay);

  function DateDay() {
    (0, _classCallCheck2.default)(this, DateDay);
    return _super19.call(this, DateUnit.DAY);
  }

  return DateDay;
}(Date);

exports.DateDay = DateDay;

var DateMillisecond = function (_Date2) {
  (0, _inherits2.default)(DateMillisecond, _Date2);

  var _super20 = _createSuper(DateMillisecond);

  function DateMillisecond() {
    (0, _classCallCheck2.default)(this, DateMillisecond);
    return _super20.call(this, DateUnit.MILLISECOND);
  }

  return DateMillisecond;
}(Date);

exports.DateMillisecond = DateMillisecond;
var TimeUnit = {
  SECOND: 1,
  MILLISECOND: 1e3,
  MICROSECOND: 1e6,
  NANOSECOND: 1e9
};
_Symbol$toStringTag4 = Symbol.toStringTag;

var Time = function (_DataType8) {
  (0, _inherits2.default)(Time, _DataType8);

  var _super21 = _createSuper(Time);

  function Time(unit, bitWidth) {
    var _this4;

    (0, _classCallCheck2.default)(this, Time);
    _this4 = _super21.call(this);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this4), "unit", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this4), "bitWidth", void 0);
    _this4.unit = unit;
    _this4.bitWidth = bitWidth;
    return _this4;
  }

  (0, _createClass2.default)(Time, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.Time;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "Time".concat(this.bitWidth, "<").concat(TimeUnit[this.unit], ">");
    }
  }, {
    key: _Symbol$toStringTag4,
    get: function get() {
      return 'Time';
    }
  }]);
  return Time;
}(DataType);

exports.Time = Time;

var TimeSecond = function (_Time) {
  (0, _inherits2.default)(TimeSecond, _Time);

  var _super22 = _createSuper(TimeSecond);

  function TimeSecond() {
    (0, _classCallCheck2.default)(this, TimeSecond);
    return _super22.call(this, TimeUnit.SECOND, 32);
  }

  return TimeSecond;
}(Time);

exports.TimeSecond = TimeSecond;

var TimeMillisecond = function (_Time2) {
  (0, _inherits2.default)(TimeMillisecond, _Time2);

  var _super23 = _createSuper(TimeMillisecond);

  function TimeMillisecond() {
    (0, _classCallCheck2.default)(this, TimeMillisecond);
    return _super23.call(this, TimeUnit.MILLISECOND, 32);
  }

  return TimeMillisecond;
}(Time);

exports.TimeMillisecond = TimeMillisecond;
_Symbol$toStringTag5 = Symbol.toStringTag;

var Timestamp = function (_DataType9) {
  (0, _inherits2.default)(Timestamp, _DataType9);

  var _super24 = _createSuper(Timestamp);

  function Timestamp(unit) {
    var _this5;

    var timezone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    (0, _classCallCheck2.default)(this, Timestamp);
    _this5 = _super24.call(this);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this5), "unit", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this5), "timezone", void 0);
    _this5.unit = unit;
    _this5.timezone = timezone;
    return _this5;
  }

  (0, _createClass2.default)(Timestamp, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.Timestamp;
    }
  }, {
    key: _Symbol$toStringTag5,
    get: function get() {
      return 'Timestamp';
    }
  }, {
    key: "toString",
    value: function toString() {
      return "Timestamp<".concat(TimeUnit[this.unit]).concat(this.timezone ? ", ".concat(this.timezone) : '', ">");
    }
  }]);
  return Timestamp;
}(DataType);

exports.Timestamp = Timestamp;

var TimestampSecond = function (_Timestamp) {
  (0, _inherits2.default)(TimestampSecond, _Timestamp);

  var _super25 = _createSuper(TimestampSecond);

  function TimestampSecond() {
    var timezone = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    (0, _classCallCheck2.default)(this, TimestampSecond);
    return _super25.call(this, TimeUnit.SECOND, timezone);
  }

  return TimestampSecond;
}(Timestamp);

exports.TimestampSecond = TimestampSecond;

var TimestampMillisecond = function (_Timestamp2) {
  (0, _inherits2.default)(TimestampMillisecond, _Timestamp2);

  var _super26 = _createSuper(TimestampMillisecond);

  function TimestampMillisecond() {
    var timezone = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    (0, _classCallCheck2.default)(this, TimestampMillisecond);
    return _super26.call(this, TimeUnit.MILLISECOND, timezone);
  }

  return TimestampMillisecond;
}(Timestamp);

exports.TimestampMillisecond = TimestampMillisecond;

var TimestampMicrosecond = function (_Timestamp3) {
  (0, _inherits2.default)(TimestampMicrosecond, _Timestamp3);

  var _super27 = _createSuper(TimestampMicrosecond);

  function TimestampMicrosecond() {
    var timezone = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    (0, _classCallCheck2.default)(this, TimestampMicrosecond);
    return _super27.call(this, TimeUnit.MICROSECOND, timezone);
  }

  return TimestampMicrosecond;
}(Timestamp);

exports.TimestampMicrosecond = TimestampMicrosecond;

var TimestampNanosecond = function (_Timestamp4) {
  (0, _inherits2.default)(TimestampNanosecond, _Timestamp4);

  var _super28 = _createSuper(TimestampNanosecond);

  function TimestampNanosecond() {
    var timezone = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    (0, _classCallCheck2.default)(this, TimestampNanosecond);
    return _super28.call(this, TimeUnit.NANOSECOND, timezone);
  }

  return TimestampNanosecond;
}(Timestamp);

exports.TimestampNanosecond = TimestampNanosecond;
var IntervalUnit = {
  DAY_TIME: 0,
  YEAR_MONTH: 1
};
_Symbol$toStringTag6 = Symbol.toStringTag;

var Interval = function (_DataType10) {
  (0, _inherits2.default)(Interval, _DataType10);

  var _super29 = _createSuper(Interval);

  function Interval(unit) {
    var _this6;

    (0, _classCallCheck2.default)(this, Interval);
    _this6 = _super29.call(this);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this6), "unit", void 0);
    _this6.unit = unit;
    return _this6;
  }

  (0, _createClass2.default)(Interval, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.Interval;
    }
  }, {
    key: _Symbol$toStringTag6,
    get: function get() {
      return 'Interval';
    }
  }, {
    key: "toString",
    value: function toString() {
      return "Interval<".concat(IntervalUnit[this.unit], ">");
    }
  }]);
  return Interval;
}(DataType);

exports.Interval = Interval;

var IntervalDayTime = function (_Interval) {
  (0, _inherits2.default)(IntervalDayTime, _Interval);

  var _super30 = _createSuper(IntervalDayTime);

  function IntervalDayTime() {
    (0, _classCallCheck2.default)(this, IntervalDayTime);
    return _super30.call(this, IntervalUnit.DAY_TIME);
  }

  return IntervalDayTime;
}(Interval);

exports.IntervalDayTime = IntervalDayTime;

var IntervalYearMonth = function (_Interval2) {
  (0, _inherits2.default)(IntervalYearMonth, _Interval2);

  var _super31 = _createSuper(IntervalYearMonth);

  function IntervalYearMonth() {
    (0, _classCallCheck2.default)(this, IntervalYearMonth);
    return _super31.call(this, IntervalUnit.YEAR_MONTH);
  }

  return IntervalYearMonth;
}(Interval);

exports.IntervalYearMonth = IntervalYearMonth;
_Symbol$toStringTag7 = Symbol.toStringTag;

var FixedSizeList = function (_DataType11) {
  (0, _inherits2.default)(FixedSizeList, _DataType11);

  var _super32 = _createSuper(FixedSizeList);

  function FixedSizeList(listSize, child) {
    var _this7;

    (0, _classCallCheck2.default)(this, FixedSizeList);
    _this7 = _super32.call(this);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this7), "listSize", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this7), "children", void 0);
    _this7.listSize = listSize;
    _this7.children = [child];
    return _this7;
  }

  (0, _createClass2.default)(FixedSizeList, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.FixedSizeList;
    }
  }, {
    key: "valueType",
    get: function get() {
      return this.children[0].type;
    }
  }, {
    key: "valueField",
    get: function get() {
      return this.children[0];
    }
  }, {
    key: _Symbol$toStringTag7,
    get: function get() {
      return 'FixedSizeList';
    }
  }, {
    key: "toString",
    value: function toString() {
      return "FixedSizeList[".concat(this.listSize, "]<").concat(this.valueType, ">");
    }
  }]);
  return FixedSizeList;
}(DataType);

exports.FixedSizeList = FixedSizeList;

},{"./enum":96,"@babel/runtime/helpers/assertThisInitialized":7,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/getPrototypeOf":16,"@babel/runtime/helpers/inherits":17,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/possibleConstructorReturn":25}],100:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Schema", {
  enumerable: true,
  get: function get() {
    return _schema.default;
  }
});
Object.defineProperty(exports, "Field", {
  enumerable: true,
  get: function get() {
    return _field.default;
  }
});
Object.defineProperty(exports, "Type", {
  enumerable: true,
  get: function get() {
    return _type.Type;
  }
});
Object.defineProperty(exports, "DataType", {
  enumerable: true,
  get: function get() {
    return _type.DataType;
  }
});
Object.defineProperty(exports, "Null", {
  enumerable: true,
  get: function get() {
    return _type.Null;
  }
});
Object.defineProperty(exports, "Bool", {
  enumerable: true,
  get: function get() {
    return _type.Bool;
  }
});
Object.defineProperty(exports, "Int", {
  enumerable: true,
  get: function get() {
    return _type.Int;
  }
});
Object.defineProperty(exports, "Int8", {
  enumerable: true,
  get: function get() {
    return _type.Int8;
  }
});
Object.defineProperty(exports, "Int16", {
  enumerable: true,
  get: function get() {
    return _type.Int16;
  }
});
Object.defineProperty(exports, "Int32", {
  enumerable: true,
  get: function get() {
    return _type.Int32;
  }
});
Object.defineProperty(exports, "Int64", {
  enumerable: true,
  get: function get() {
    return _type.Int64;
  }
});
Object.defineProperty(exports, "Uint8", {
  enumerable: true,
  get: function get() {
    return _type.Uint8;
  }
});
Object.defineProperty(exports, "Uint16", {
  enumerable: true,
  get: function get() {
    return _type.Uint16;
  }
});
Object.defineProperty(exports, "Uint32", {
  enumerable: true,
  get: function get() {
    return _type.Uint32;
  }
});
Object.defineProperty(exports, "Uint64", {
  enumerable: true,
  get: function get() {
    return _type.Uint64;
  }
});
Object.defineProperty(exports, "Float", {
  enumerable: true,
  get: function get() {
    return _type.Float;
  }
});
Object.defineProperty(exports, "Float16", {
  enumerable: true,
  get: function get() {
    return _type.Float16;
  }
});
Object.defineProperty(exports, "Float32", {
  enumerable: true,
  get: function get() {
    return _type.Float32;
  }
});
Object.defineProperty(exports, "Float64", {
  enumerable: true,
  get: function get() {
    return _type.Float64;
  }
});
Object.defineProperty(exports, "Binary", {
  enumerable: true,
  get: function get() {
    return _type.Binary;
  }
});
Object.defineProperty(exports, "Utf8", {
  enumerable: true,
  get: function get() {
    return _type.Utf8;
  }
});
Object.defineProperty(exports, "Date", {
  enumerable: true,
  get: function get() {
    return _type.Date;
  }
});
Object.defineProperty(exports, "DateDay", {
  enumerable: true,
  get: function get() {
    return _type.DateDay;
  }
});
Object.defineProperty(exports, "DateMillisecond", {
  enumerable: true,
  get: function get() {
    return _type.DateMillisecond;
  }
});
Object.defineProperty(exports, "Time", {
  enumerable: true,
  get: function get() {
    return _type.Time;
  }
});
Object.defineProperty(exports, "TimeSecond", {
  enumerable: true,
  get: function get() {
    return _type.TimeSecond;
  }
});
Object.defineProperty(exports, "TimeMillisecond", {
  enumerable: true,
  get: function get() {
    return _type.TimeMillisecond;
  }
});
Object.defineProperty(exports, "Timestamp", {
  enumerable: true,
  get: function get() {
    return _type.Timestamp;
  }
});
Object.defineProperty(exports, "TimestampSecond", {
  enumerable: true,
  get: function get() {
    return _type.TimestampSecond;
  }
});
Object.defineProperty(exports, "TimestampMillisecond", {
  enumerable: true,
  get: function get() {
    return _type.TimestampMillisecond;
  }
});
Object.defineProperty(exports, "TimestampMicrosecond", {
  enumerable: true,
  get: function get() {
    return _type.TimestampMicrosecond;
  }
});
Object.defineProperty(exports, "TimestampNanosecond", {
  enumerable: true,
  get: function get() {
    return _type.TimestampNanosecond;
  }
});
Object.defineProperty(exports, "Interval", {
  enumerable: true,
  get: function get() {
    return _type.Interval;
  }
});
Object.defineProperty(exports, "IntervalDayTime", {
  enumerable: true,
  get: function get() {
    return _type.IntervalDayTime;
  }
});
Object.defineProperty(exports, "IntervalYearMonth", {
  enumerable: true,
  get: function get() {
    return _type.IntervalYearMonth;
  }
});
Object.defineProperty(exports, "FixedSizeList", {
  enumerable: true,
  get: function get() {
    return _type.FixedSizeList;
  }
});

var _schema = _interopRequireDefault(require("./impl/schema"));

var _field = _interopRequireDefault(require("./impl/field"));

var _type = require("./impl/type");

},{"./impl/field":97,"./impl/schema":98,"./impl/type":99,"@babel/runtime/helpers/interopRequireDefault":18}],101:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var DEFAULT_ROW_COUNT = 100;

var RowTableBatchAggregator = function () {
  function RowTableBatchAggregator(schema, options) {
    (0, _classCallCheck2.default)(this, RowTableBatchAggregator);
    (0, _defineProperty2.default)(this, "schema", void 0);
    (0, _defineProperty2.default)(this, "options", void 0);
    (0, _defineProperty2.default)(this, "length", 0);
    (0, _defineProperty2.default)(this, "rows", null);
    (0, _defineProperty2.default)(this, "cursor", 0);
    (0, _defineProperty2.default)(this, "_headers", []);
    this.options = options;
    this.schema = schema;

    if (!Array.isArray(schema)) {
      this._headers = [];

      for (var key in schema) {
        this._headers[schema[key].index] = schema[key].name;
      }
    }
  }

  (0, _createClass2.default)(RowTableBatchAggregator, [{
    key: "rowCount",
    value: function rowCount() {
      return this.length;
    }
  }, {
    key: "addArrayRow",
    value: function addArrayRow(row, cursor) {
      if (Number.isFinite(cursor)) {
        this.cursor = cursor;
      }

      this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);
      this.rows[this.length] = row;
      this.length++;
    }
  }, {
    key: "addObjectRow",
    value: function addObjectRow(row, cursor) {
      if (Number.isFinite(cursor)) {
        this.cursor = cursor;
      }

      this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);
      this.rows[this.length] = row;
      this.length++;
    }
  }, {
    key: "getBatch",
    value: function getBatch() {
      var rows = this.rows;

      if (!rows) {
        return null;
      }

      rows = rows.slice(0, this.length);
      this.rows = null;
      var batch = {
        shape: this.options.shape,
        batchType: 'data',
        data: rows,
        length: this.length,
        schema: this.schema,
        cursor: this.cursor
      };
      return batch;
    }
  }]);
  return RowTableBatchAggregator;
}();

exports.default = RowTableBatchAggregator;

},{"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18}],102:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var DEFAULT_ROW_COUNT = 100;

var ColumnarTableBatchAggregator = function () {
  function ColumnarTableBatchAggregator(schema, options) {
    (0, _classCallCheck2.default)(this, ColumnarTableBatchAggregator);
    (0, _defineProperty2.default)(this, "schema", void 0);
    (0, _defineProperty2.default)(this, "length", 0);
    (0, _defineProperty2.default)(this, "allocated", 0);
    (0, _defineProperty2.default)(this, "columns", {});
    this.schema = schema;

    this._reallocateColumns();
  }

  (0, _createClass2.default)(ColumnarTableBatchAggregator, [{
    key: "rowCount",
    value: function rowCount() {
      return this.length;
    }
  }, {
    key: "addArrayRow",
    value: function addArrayRow(row) {
      this._reallocateColumns();

      var i = 0;

      for (var fieldName in this.columns) {
        this.columns[fieldName][this.length] = row[i++];
      }

      this.length++;
    }
  }, {
    key: "addObjectRow",
    value: function addObjectRow(row) {
      this._reallocateColumns();

      for (var fieldName in row) {
        this.columns[fieldName][this.length] = row[fieldName];
      }

      this.length++;
    }
  }, {
    key: "getBatch",
    value: function getBatch() {
      this._pruneColumns();

      var columns = Array.isArray(this.schema) ? this.columns : {};

      if (!Array.isArray(this.schema)) {
        for (var fieldName in this.schema) {
          var field = this.schema[fieldName];
          columns[field.name] = this.columns[field.index];
        }
      }

      this.columns = {};
      var batch = {
        shape: 'columnar-table',
        batchType: 'data',
        data: columns,
        schema: this.schema,
        length: this.length
      };
      return batch;
    }
  }, {
    key: "_reallocateColumns",
    value: function _reallocateColumns() {
      if (this.length < this.allocated) {
        return;
      }

      this.allocated = this.allocated > 0 ? this.allocated *= 2 : DEFAULT_ROW_COUNT;
      this.columns = {};

      for (var fieldName in this.schema) {
        var field = this.schema[fieldName];
        var ArrayType = field.type || Float32Array;
        var oldColumn = this.columns[field.index];

        if (oldColumn && ArrayBuffer.isView(oldColumn)) {
          var typedArray = new ArrayType(this.allocated);
          typedArray.set(oldColumn);
          this.columns[field.index] = typedArray;
        } else if (oldColumn) {
          oldColumn.length = this.allocated;
          this.columns[field.index] = oldColumn;
        } else {
          this.columns[field.index] = new ArrayType(this.allocated);
        }
      }
    }
  }, {
    key: "_pruneColumns",
    value: function _pruneColumns() {
      for (var _i = 0, _Object$entries = Object.entries(this.columns); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = (0, _slicedToArray2.default)(_Object$entries[_i], 2),
            _columnName = _Object$entries$_i[0],
            column = _Object$entries$_i[1];

        this.columns[_columnName] = column.slice(0, this.length);
      }
    }
  }]);
  return ColumnarTableBatchAggregator;
}();

exports.default = ColumnarTableBatchAggregator;

},{"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/slicedToArray":27}],103:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _rowUtils = require("../utils/row-utils");

var DEFAULT_ROW_COUNT = 100;

var RowTableBatchAggregator = function () {
  function RowTableBatchAggregator(schema, options) {
    (0, _classCallCheck2.default)(this, RowTableBatchAggregator);
    (0, _defineProperty2.default)(this, "schema", void 0);
    (0, _defineProperty2.default)(this, "options", void 0);
    (0, _defineProperty2.default)(this, "length", 0);
    (0, _defineProperty2.default)(this, "objectRows", null);
    (0, _defineProperty2.default)(this, "arrayRows", null);
    (0, _defineProperty2.default)(this, "cursor", 0);
    (0, _defineProperty2.default)(this, "_headers", []);
    this.options = options;
    this.schema = schema;

    if (!Array.isArray(schema)) {
      this._headers = [];

      for (var key in schema) {
        this._headers[schema[key].index] = schema[key].name;
      }
    }
  }

  (0, _createClass2.default)(RowTableBatchAggregator, [{
    key: "rowCount",
    value: function rowCount() {
      return this.length;
    }
  }, {
    key: "addArrayRow",
    value: function addArrayRow(row, cursor) {
      if (Number.isFinite(cursor)) {
        this.cursor = cursor;
      }

      switch (this.options.shape) {
        case 'object-row-table':
          var rowObject = (0, _rowUtils.convertToObjectRow)(row, this._headers);
          this.addObjectRow(rowObject, cursor);
          break;

        case 'array-row-table':
          this.arrayRows = this.arrayRows || new Array(DEFAULT_ROW_COUNT);
          this.arrayRows[this.length] = row;
          this.length++;
          break;
      }
    }
  }, {
    key: "addObjectRow",
    value: function addObjectRow(row, cursor) {
      if (Number.isFinite(cursor)) {
        this.cursor = cursor;
      }

      switch (this.options.shape) {
        case 'array-row-table':
          var rowArray = (0, _rowUtils.convertToArrayRow)(row, this._headers);
          this.addArrayRow(rowArray, cursor);
          break;

        case 'object-row-table':
          this.objectRows = this.objectRows || new Array(DEFAULT_ROW_COUNT);
          this.objectRows[this.length] = row;
          this.length++;
          break;
      }
    }
  }, {
    key: "getBatch",
    value: function getBatch() {
      var rows = this.arrayRows || this.objectRows;

      if (!rows) {
        return null;
      }

      rows = rows.slice(0, this.length);
      this.arrayRows = null;
      this.objectRows = null;
      return {
        shape: this.options.shape,
        batchType: 'data',
        data: rows,
        length: this.length,
        schema: this.schema,
        cursor: this.cursor
      };
    }
  }]);
  return RowTableBatchAggregator;
}();

exports.default = RowTableBatchAggregator;

},{"../utils/row-utils":107,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18}],104:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _baseTableBatchAggregator = _interopRequireDefault(require("./base-table-batch-aggregator"));

var _rowTableBatchAggregator = _interopRequireDefault(require("./row-table-batch-aggregator"));

var _columnarTableBatchAggregator = _interopRequireDefault(require("./columnar-table-batch-aggregator"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var DEFAULT_OPTIONS = {
  shape: 'array-row-table',
  batchSize: 'auto',
  batchDebounceMs: 0,
  limit: 0,
  _limitMB: 0
};
var ERR_MESSAGE = 'TableBatchBuilder';

var TableBatchBuilder = function () {
  function TableBatchBuilder(schema, options) {
    (0, _classCallCheck2.default)(this, TableBatchBuilder);
    (0, _defineProperty2.default)(this, "schema", void 0);
    (0, _defineProperty2.default)(this, "options", void 0);
    (0, _defineProperty2.default)(this, "aggregator", null);
    (0, _defineProperty2.default)(this, "batchCount", 0);
    (0, _defineProperty2.default)(this, "bytesUsed", 0);
    (0, _defineProperty2.default)(this, "isChunkComplete", false);
    (0, _defineProperty2.default)(this, "lastBatchEmittedMs", Date.now());
    (0, _defineProperty2.default)(this, "totalLength", 0);
    (0, _defineProperty2.default)(this, "totalBytes", 0);
    (0, _defineProperty2.default)(this, "rowBytes", 0);
    this.schema = schema;
    this.options = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS), options);
  }

  (0, _createClass2.default)(TableBatchBuilder, [{
    key: "limitReached",
    value: function limitReached() {
      var _this$options, _this$options2;

      if (Boolean((_this$options = this.options) === null || _this$options === void 0 ? void 0 : _this$options.limit) && this.totalLength >= this.options.limit) {
        return true;
      }

      if (Boolean((_this$options2 = this.options) === null || _this$options2 === void 0 ? void 0 : _this$options2._limitMB) && this.totalBytes / 1e6 >= this.options._limitMB) {
        return true;
      }

      return false;
    }
  }, {
    key: "addRow",
    value: function addRow(row) {
      if (this.limitReached()) {
        return;
      }

      this.totalLength++;
      this.rowBytes = this.rowBytes || this._estimateRowMB(row);
      this.totalBytes += this.rowBytes;

      if (Array.isArray(row)) {
        this.addArrayRow(row);
      } else {
        this.addObjectRow(row);
      }
    }
  }, {
    key: "addArrayRow",
    value: function addArrayRow(row) {
      if (!this.aggregator) {
        var TableBatchType = this._getTableBatchType();

        this.aggregator = new TableBatchType(this.schema, this.options);
      }

      this.aggregator.addArrayRow(row);
    }
  }, {
    key: "addObjectRow",
    value: function addObjectRow(row) {
      if (!this.aggregator) {
        var TableBatchType = this._getTableBatchType();

        this.aggregator = new TableBatchType(this.schema, this.options);
      }

      this.aggregator.addObjectRow(row);
    }
  }, {
    key: "chunkComplete",
    value: function chunkComplete(chunk) {
      if (chunk instanceof ArrayBuffer) {
        this.bytesUsed += chunk.byteLength;
      }

      if (typeof chunk === 'string') {
        this.bytesUsed += chunk.length;
      }

      this.isChunkComplete = true;
    }
  }, {
    key: "getFullBatch",
    value: function getFullBatch(options) {
      return this._isFull() ? this._getBatch(options) : null;
    }
  }, {
    key: "getFinalBatch",
    value: function getFinalBatch(options) {
      return this._getBatch(options);
    }
  }, {
    key: "_estimateRowMB",
    value: function _estimateRowMB(row) {
      return Array.isArray(row) ? row.length * 8 : Object.keys(row).length * 8;
    }
  }, {
    key: "_isFull",
    value: function _isFull() {
      if (!this.aggregator || this.aggregator.rowCount() === 0) {
        return false;
      }

      if (this.options.batchSize === 'auto') {
        if (!this.isChunkComplete) {
          return false;
        }
      } else if (this.options.batchSize > this.aggregator.rowCount()) {
        return false;
      }

      if (this.options.batchDebounceMs > Date.now() - this.lastBatchEmittedMs) {
        return false;
      }

      this.isChunkComplete = false;
      this.lastBatchEmittedMs = Date.now();
      return true;
    }
  }, {
    key: "_getBatch",
    value: function _getBatch(options) {
      if (!this.aggregator) {
        return null;
      }

      if (options !== null && options !== void 0 && options.bytesUsed) {
        this.bytesUsed = options.bytesUsed;
      }

      var normalizedBatch = this.aggregator.getBatch();
      normalizedBatch.count = this.batchCount;
      normalizedBatch.bytesUsed = this.bytesUsed;
      Object.assign(normalizedBatch, options);
      this.batchCount++;
      this.aggregator = null;
      return normalizedBatch;
    }
  }, {
    key: "_getTableBatchType",
    value: function _getTableBatchType() {
      switch (this.options.shape) {
        case 'row-table':
          return _baseTableBatchAggregator.default;

        case 'array-row-table':
        case 'object-row-table':
          return _rowTableBatchAggregator.default;

        case 'columnar-table':
          return _columnarTableBatchAggregator.default;

        case 'arrow-table':
          if (!TableBatchBuilder.ArrowBatch) {
            throw new Error(ERR_MESSAGE);
          }

          return TableBatchBuilder.ArrowBatch;

        default:
          throw new Error(ERR_MESSAGE);
      }
    }
  }]);
  return TableBatchBuilder;
}();

exports.default = TableBatchBuilder;
(0, _defineProperty2.default)(TableBatchBuilder, "ArrowBatch", void 0);

},{"./base-table-batch-aggregator":101,"./columnar-table-batch-aggregator":102,"./row-table-batch-aggregator":103,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18}],105:[function(require,module,exports){
arguments[4][81][0].apply(exports,arguments)
},{"dup":81}],106:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.takeAsync = takeAsync;
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));

var _Symbol$asyncIterator;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var ArrayQueue = function (_Array) {
  (0, _inherits2.default)(ArrayQueue, _Array);

  var _super = _createSuper(ArrayQueue);

  function ArrayQueue() {
    (0, _classCallCheck2.default)(this, ArrayQueue);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(ArrayQueue, [{
    key: "enqueue",
    value: function enqueue(value) {
      return this.push(value);
    }
  }, {
    key: "dequeue",
    value: function dequeue() {
      return this.shift();
    }
  }]);
  return ArrayQueue;
}((0, _wrapNativeSuper2.default)(Array));

_Symbol$asyncIterator = Symbol.asyncIterator;

var AsyncQueue = function () {
  function AsyncQueue() {
    (0, _classCallCheck2.default)(this, AsyncQueue);
    (0, _defineProperty2.default)(this, "_values", void 0);
    (0, _defineProperty2.default)(this, "_settlers", void 0);
    (0, _defineProperty2.default)(this, "_closed", void 0);
    this._values = new ArrayQueue();
    this._settlers = new ArrayQueue();
    this._closed = false;
  }

  (0, _createClass2.default)(AsyncQueue, [{
    key: "close",
    value: function close() {
      while (this._settlers.length > 0) {
        this._settlers.dequeue().resolve({
          done: true
        });
      }

      this._closed = true;
    }
  }, {
    key: _Symbol$asyncIterator,
    value: function value() {
      return this;
    }
  }, {
    key: "enqueue",
    value: function enqueue(value) {
      if (this._closed) {
        throw new Error('Closed');
      }

      if (this._settlers.length > 0) {
        if (this._values.length > 0) {
          throw new Error('Illegal internal state');
        }

        var settler = this._settlers.dequeue();

        if (value instanceof Error) {
          settler.reject(value);
        } else {
          settler.resolve({
            value: value
          });
        }
      } else {
        this._values.enqueue(value);
      }
    }
  }, {
    key: "next",
    value: function next() {
      var _this = this;

      if (this._values.length > 0) {
        var value = this._values.dequeue();

        if (value instanceof Error) {
          return Promise.reject(value);
        }

        return Promise.resolve({
          value: value
        });
      }

      if (this._closed) {
        if (this._settlers.length > 0) {
          throw new Error('Illegal internal state');
        }

        return Promise.resolve({
          done: true
        });
      }

      return new Promise(function (resolve, reject) {
        _this._settlers.enqueue({
          resolve: resolve,
          reject: reject
        });
      });
    }
  }]);
  return AsyncQueue;
}();

exports.default = AsyncQueue;

function takeAsync(_x) {
  return _takeAsync.apply(this, arguments);
}

function _takeAsync() {
  _takeAsync = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(asyncIterable) {
    var count,
        result,
        iterator,
        _yield$iterator$next,
        value,
        done,
        _args = arguments;

    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            count = _args.length > 1 && _args[1] !== undefined ? _args[1] : Infinity;
            result = [];
            iterator = asyncIterable[Symbol.asyncIterator]();

          case 3:
            if (!(result.length < count)) {
              _context.next = 14;
              break;
            }

            _context.next = 6;
            return iterator.next();

          case 6:
            _yield$iterator$next = _context.sent;
            value = _yield$iterator$next.value;
            done = _yield$iterator$next.done;

            if (!done) {
              _context.next = 11;
              break;
            }

            return _context.abrupt("break", 14);

          case 11:
            result.push(value);
            _context.next = 3;
            break;

          case 14:
            return _context.abrupt("return", result);

          case 15:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _takeAsync.apply(this, arguments);
}

},{"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/getPrototypeOf":16,"@babel/runtime/helpers/inherits":17,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/possibleConstructorReturn":25,"@babel/runtime/helpers/wrapNativeSuper":32,"@babel/runtime/regenerator":33}],107:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertToObjectRow = convertToObjectRow;
exports.convertToArrayRow = convertToArrayRow;

function convertToObjectRow(arrayRow, headers) {
  if (!arrayRow) {
    throw new Error('null row');
  }

  if (!headers) {
    throw new Error('no headers');
  }

  var objectRow = {};

  for (var i = 0; i < headers.length; i++) {
    objectRow[headers[i]] = arrayRow[i];
  }

  return objectRow;
}

function convertToArrayRow(objectRow, headers) {
  if (!objectRow) {
    throw new Error('null row');
  }

  if (!headers) {
    throw new Error('no headers');
  }

  var arrayRow = new Array(headers.length);

  for (var i = 0; i < headers.length; i++) {
    arrayRow[i] = objectRow[headers[i]];
  }

  return arrayRow;
}

},{}],108:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function get() {
    return _assert.assert;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function get() {
    return _globals.isBrowser;
  }
});
Object.defineProperty(exports, "isWorker", {
  enumerable: true,
  get: function get() {
    return _globals.isWorker;
  }
});
Object.defineProperty(exports, "WorkerJob", {
  enumerable: true,
  get: function get() {
    return _workerJob.default;
  }
});
Object.defineProperty(exports, "WorkerThread", {
  enumerable: true,
  get: function get() {
    return _workerThread.default;
  }
});
Object.defineProperty(exports, "WorkerFarm", {
  enumerable: true,
  get: function get() {
    return _workerFarm.default;
  }
});
Object.defineProperty(exports, "WorkerPool", {
  enumerable: true,
  get: function get() {
    return _workerPool.default;
  }
});
Object.defineProperty(exports, "WorkerBody", {
  enumerable: true,
  get: function get() {
    return _workerBody.default;
  }
});
Object.defineProperty(exports, "processOnWorker", {
  enumerable: true,
  get: function get() {
    return _processOnWorker.processOnWorker;
  }
});
Object.defineProperty(exports, "canProcessOnWorker", {
  enumerable: true,
  get: function get() {
    return _processOnWorker.canProcessOnWorker;
  }
});
Object.defineProperty(exports, "createWorker", {
  enumerable: true,
  get: function get() {
    return _createWorker.createWorker;
  }
});
Object.defineProperty(exports, "getWorkerURL", {
  enumerable: true,
  get: function get() {
    return _getWorkerUrl.getWorkerURL;
  }
});
Object.defineProperty(exports, "validateWorkerVersion", {
  enumerable: true,
  get: function get() {
    return _validateWorkerVersion.validateWorkerVersion;
  }
});
Object.defineProperty(exports, "getTransferList", {
  enumerable: true,
  get: function get() {
    return _getTransferList.getTransferList;
  }
});
Object.defineProperty(exports, "getLibraryUrl", {
  enumerable: true,
  get: function get() {
    return _libraryUtils.getLibraryUrl;
  }
});
Object.defineProperty(exports, "loadLibrary", {
  enumerable: true,
  get: function get() {
    return _libraryUtils.loadLibrary;
  }
});
Object.defineProperty(exports, "AsyncQueue", {
  enumerable: true,
  get: function get() {
    return _asyncQueue.default;
  }
});
Object.defineProperty(exports, "ChildProcessProxy", {
  enumerable: true,
  get: function get() {
    return _childProcessProxy.default;
  }
});
exports.NullWorker = void 0;

var _version = require("./lib/env-utils/version");

var _assert = require("./lib/env-utils/assert");

var _globals = require("./lib/env-utils/globals");

var _workerJob = _interopRequireDefault(require("./lib/worker-farm/worker-job"));

var _workerThread = _interopRequireDefault(require("./lib/worker-farm/worker-thread"));

var _workerFarm = _interopRequireDefault(require("./lib/worker-farm/worker-farm"));

var _workerPool = _interopRequireDefault(require("./lib/worker-farm/worker-pool"));

var _workerBody = _interopRequireDefault(require("./lib/worker-farm/worker-body"));

var _processOnWorker = require("./lib/worker-api/process-on-worker");

var _createWorker = require("./lib/worker-api/create-worker");

var _getWorkerUrl = require("./lib/worker-api/get-worker-url");

var _validateWorkerVersion = require("./lib/worker-api/validate-worker-version");

var _getTransferList = require("./lib/worker-utils/get-transfer-list");

var _libraryUtils = require("./lib/library-utils/library-utils");

var _asyncQueue = _interopRequireDefault(require("./lib/async-queue/async-queue"));

var _childProcessProxy = _interopRequireDefault(require("./lib/process-utils/child-process-proxy"));

var NullWorker = {
  id: 'null',
  name: 'null',
  module: 'worker-utils',
  version: _version.VERSION,
  options: {
    null: {}
  }
};
exports.NullWorker = NullWorker;

},{"./lib/async-queue/async-queue":109,"./lib/env-utils/assert":110,"./lib/env-utils/globals":111,"./lib/env-utils/version":112,"./lib/library-utils/library-utils":113,"./lib/process-utils/child-process-proxy":130,"./lib/worker-api/create-worker":114,"./lib/worker-api/get-worker-url":115,"./lib/worker-api/process-on-worker":116,"./lib/worker-api/validate-worker-version":117,"./lib/worker-farm/worker-body":118,"./lib/worker-farm/worker-farm":119,"./lib/worker-farm/worker-job":120,"./lib/worker-farm/worker-pool":121,"./lib/worker-farm/worker-thread":122,"./lib/worker-utils/get-transfer-list":124,"@babel/runtime/helpers/interopRequireDefault":18}],109:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _Symbol$asyncIterator;

_Symbol$asyncIterator = Symbol.asyncIterator;

var AsyncQueue = function () {
  function AsyncQueue() {
    (0, _classCallCheck2.default)(this, AsyncQueue);
    (0, _defineProperty2.default)(this, "_values", void 0);
    (0, _defineProperty2.default)(this, "_settlers", void 0);
    (0, _defineProperty2.default)(this, "_closed", void 0);
    this._values = [];
    this._settlers = [];
    this._closed = false;
  }

  (0, _createClass2.default)(AsyncQueue, [{
    key: _Symbol$asyncIterator,
    value: function value() {
      return this;
    }
  }, {
    key: "push",
    value: function push(value) {
      return this.enqueue(value);
    }
  }, {
    key: "enqueue",
    value: function enqueue(value) {
      if (this._closed) {
        throw new Error('Closed');
      }

      if (this._settlers.length > 0) {
        if (this._values.length > 0) {
          throw new Error('Illegal internal state');
        }

        var settler = this._settlers.shift();

        if (value instanceof Error) {
          settler.reject(value);
        } else {
          settler.resolve({
            value: value
          });
        }
      } else {
        this._values.push(value);
      }
    }
  }, {
    key: "close",
    value: function close() {
      while (this._settlers.length > 0) {
        var settler = this._settlers.shift();

        settler.resolve({
          done: true
        });
      }

      this._closed = true;
    }
  }, {
    key: "next",
    value: function next() {
      var _this = this;

      if (this._values.length > 0) {
        var value = this._values.shift();

        if (value instanceof Error) {
          return Promise.reject(value);
        }

        return Promise.resolve({
          done: false,
          value: value
        });
      }

      if (this._closed) {
        if (this._settlers.length > 0) {
          throw new Error('Illegal internal state');
        }

        return Promise.resolve({
          done: true,
          value: undefined
        });
      }

      return new Promise(function (resolve, reject) {
        _this._settlers.push({
          resolve: resolve,
          reject: reject
        });
      });
    }
  }]);
  return AsyncQueue;
}();

exports.default = AsyncQueue;

},{"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18}],110:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assert = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'loaders.gl assertion failed.');
  }
}

},{}],111:[function(require,module,exports){
(function (process,global){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nodeVersion = exports.isMobile = exports.isWorker = exports.isBrowser = exports.document = exports.global = exports.window = exports.self = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};
var self_ = globals.self || globals.window || globals.global || {};
exports.self = self_;
var window_ = globals.window || globals.self || globals.global || {};
exports.window = window_;
var global_ = globals.global || globals.self || globals.window || {};
exports.global = global_;
var document_ = globals.document || {};
exports.document = document_;
var isBrowser = (typeof process === "undefined" ? "undefined" : (0, _typeof2.default)(process)) !== 'object' || String(process) !== '[object process]' || process.browser;
exports.isBrowser = isBrowser;
var isWorker = typeof importScripts === 'function';
exports.isWorker = isWorker;
var isMobile = typeof window !== 'undefined' && typeof window.orientation !== 'undefined';
exports.isMobile = isMobile;
var matches = typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);
var nodeVersion = matches && parseFloat(matches[1]) || 0;
exports.nodeVersion = nodeVersion;

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"_process":153}],112:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VERSION = void 0;
var DEFAULT_VERSION = 'beta';
var VERSION = typeof "3.0.9" !== 'undefined' ? "3.0.9" : DEFAULT_VERSION;
exports.VERSION = VERSION;

if (typeof "3.0.9" === 'undefined') {
  console.error('loaders.gl: The __VERSION__ variable is not injected using babel plugin. Latest unstable workers would be fetched from the CDN.');
}

},{}],113:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadLibrary = loadLibrary;
exports.getLibraryUrl = getLibraryUrl;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _globals = require("../env-utils/globals");

var node = _interopRequireWildcard(require("../node/require-utils.node"));

var _assert = require("../env-utils/assert");

var _version = require("../env-utils/version");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var LATEST = 'beta';
var VERSION = typeof "3.0.9" !== 'undefined' ? "3.0.9" : LATEST;
var loadLibraryPromises = {};

function loadLibrary(_x) {
  return _loadLibrary.apply(this, arguments);
}

function _loadLibrary() {
  _loadLibrary = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(libraryUrl) {
    var moduleName,
        options,
        _args = arguments;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            moduleName = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;
            options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};

            if (moduleName) {
              libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);
            }

            loadLibraryPromises[libraryUrl] = loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);
            _context.next = 6;
            return loadLibraryPromises[libraryUrl];

          case 6:
            return _context.abrupt("return", _context.sent);

          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _loadLibrary.apply(this, arguments);
}

function getLibraryUrl(library, moduleName, options) {
  if (library.startsWith('http')) {
    return library;
  }

  var modules = options.modules || {};

  if (modules[library]) {
    return modules[library];
  }

  if (!_globals.isBrowser) {
    return "modules/".concat(moduleName, "/dist/libs/").concat(library);
  }

  if (options.CDN) {
    (0, _assert.assert)(options.CDN.startsWith('http'));
    return "".concat(options.CDN, "/").concat(moduleName, "@").concat(VERSION, "/dist/libs/").concat(library);
  }

  if (_globals.isWorker) {
    return "../src/libs/".concat(library);
  }

  return "modules/".concat(moduleName, "/src/libs/").concat(library);
}

function loadLibraryFromFile(_x2) {
  return _loadLibraryFromFile.apply(this, arguments);
}

function _loadLibraryFromFile() {
  _loadLibraryFromFile = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(libraryUrl) {
    var _response, response, scriptSource;

    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!libraryUrl.endsWith('wasm')) {
              _context2.next = 7;
              break;
            }

            _context2.next = 3;
            return fetch(libraryUrl);

          case 3:
            _response = _context2.sent;
            _context2.next = 6;
            return _response.arrayBuffer();

          case 6:
            return _context2.abrupt("return", _context2.sent);

          case 7:
            if (_globals.isBrowser) {
              _context2.next = 14;
              break;
            }

            _context2.t0 = node.requireFromFile;

            if (!_context2.t0) {
              _context2.next = 13;
              break;
            }

            _context2.next = 12;
            return node.requireFromFile(libraryUrl);

          case 12:
            _context2.t0 = _context2.sent;

          case 13:
            return _context2.abrupt("return", _context2.t0);

          case 14:
            if (!_globals.isWorker) {
              _context2.next = 16;
              break;
            }

            return _context2.abrupt("return", importScripts(libraryUrl));

          case 16:
            _context2.next = 18;
            return fetch(libraryUrl);

          case 18:
            response = _context2.sent;
            _context2.next = 21;
            return response.text();

          case 21:
            scriptSource = _context2.sent;
            return _context2.abrupt("return", loadLibraryFromString(scriptSource, libraryUrl));

          case 23:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _loadLibraryFromFile.apply(this, arguments);
}

function loadLibraryFromString(scriptSource, id) {
  if (!_globals.isBrowser) {
    return node.requireFromString && node.requireFromString(scriptSource, id);
  }

  if (_globals.isWorker) {
    eval.call(_globals.global, scriptSource);
    return null;
  }

  var script = document.createElement('script');
  script.id = id;

  try {
    script.appendChild(document.createTextNode(scriptSource));
  } catch (e) {
    script.text = scriptSource;
  }

  document.body.appendChild(script);
  return null;
}

},{"../env-utils/assert":110,"../env-utils/globals":111,"../env-utils/version":112,"../node/require-utils.node":130,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"@babel/runtime/regenerator":33}],114:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createWorker = createWorker;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

var _asyncQueue = _interopRequireDefault(require("../async-queue/async-queue"));

var _workerBody = _interopRequireDefault(require("../worker-farm/worker-body"));

var requestId = 0;
var inputBatches;
var options;

function createWorker(process, processInBatches) {
  if (typeof self === 'undefined') {
    return;
  }

  var context = {
    process: processOnMainThread
  };

  _workerBody.default.onmessage = function () {
    var _ref = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(type, payload) {
      var result, resultIterator, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, batch, message;

      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.t0 = type;
              _context.next = _context.t0 === 'process' ? 4 : _context.t0 === 'process-in-batches' ? 11 : _context.t0 === 'input-batch' ? 51 : _context.t0 === 'input-done' ? 53 : 55;
              break;

            case 4:
              if (process) {
                _context.next = 6;
                break;
              }

              throw new Error('Worker does not support atomic processing');

            case 6:
              _context.next = 8;
              return process(payload.input, payload.options || {}, context);

            case 8:
              result = _context.sent;

              _workerBody.default.postMessage('done', {
                result: result
              });

              return _context.abrupt("break", 55);

            case 11:
              if (processInBatches) {
                _context.next = 13;
                break;
              }

              throw new Error('Worker does not support batched processing');

            case 13:
              inputBatches = new _asyncQueue.default();
              options = payload.options || {};
              resultIterator = processInBatches(inputBatches, options, context === null || context === void 0 ? void 0 : context.processInBatches);
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _context.prev = 18;
              _iterator = (0, _asyncIterator2.default)(resultIterator);

            case 20:
              _context.next = 22;
              return _iterator.next();

            case 22:
              _step = _context.sent;
              _iteratorNormalCompletion = _step.done;
              _context.next = 26;
              return _step.value;

            case 26:
              _value = _context.sent;

              if (_iteratorNormalCompletion) {
                _context.next = 33;
                break;
              }

              batch = _value;

              _workerBody.default.postMessage('output-batch', {
                result: batch
              });

            case 30:
              _iteratorNormalCompletion = true;
              _context.next = 20;
              break;

            case 33:
              _context.next = 39;
              break;

            case 35:
              _context.prev = 35;
              _context.t1 = _context["catch"](18);
              _didIteratorError = true;
              _iteratorError = _context.t1;

            case 39:
              _context.prev = 39;
              _context.prev = 40;

              if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
                _context.next = 44;
                break;
              }

              _context.next = 44;
              return _iterator.return();

            case 44:
              _context.prev = 44;

              if (!_didIteratorError) {
                _context.next = 47;
                break;
              }

              throw _iteratorError;

            case 47:
              return _context.finish(44);

            case 48:
              return _context.finish(39);

            case 49:
              _workerBody.default.postMessage('done', {});

              return _context.abrupt("break", 55);

            case 51:
              inputBatches.push(payload.input);
              return _context.abrupt("break", 55);

            case 53:
              inputBatches.close();
              return _context.abrupt("break", 55);

            case 55:
              _context.next = 61;
              break;

            case 57:
              _context.prev = 57;
              _context.t2 = _context["catch"](0);
              message = _context.t2 instanceof Error ? _context.t2.message : '';

              _workerBody.default.postMessage('error', {
                error: message
              });

            case 61:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[0, 57], [18, 35, 39, 49], [40,, 44, 48]]);
    }));

    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();
}

function processOnMainThread(arrayBuffer) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return new Promise(function (resolve, reject) {
    var id = requestId++;

    var onMessage = function onMessage(type, payload) {
      if (payload.id !== id) {
        return;
      }

      switch (type) {
        case 'done':
          _workerBody.default.removeEventListener(onMessage);

          resolve(payload.result);
          break;

        case 'error':
          _workerBody.default.removeEventListener(onMessage);

          reject(payload.error);
          break;

        default:
      }
    };

    _workerBody.default.addEventListener(onMessage);

    var payload = {
      id: id,
      input: arrayBuffer,
      options: options
    };

    _workerBody.default.postMessage('process', payload);
  });
}

},{"../async-queue/async-queue":109,"../worker-farm/worker-body":118,"@babel/runtime/helpers/asyncIterator":9,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],115:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getWorkerName = getWorkerName;
exports.getWorkerURL = getWorkerURL;

var _assert = require("../env-utils/assert");

var _version = require("../env-utils/version");

var NPM_TAG = 'latest';
var VERSION = typeof "3.0.9" !== 'undefined' ? "3.0.9" : NPM_TAG;

function getWorkerName(worker) {
  var warning = worker.version !== VERSION ? " (worker-utils@".concat(VERSION, ")") : '';
  return "".concat(worker.name, "@").concat(worker.version).concat(warning);
}

function getWorkerURL(worker) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var workerOptions = options[worker.id] || {};
  var workerFile = "".concat(worker.id, "-worker.js");
  var url = workerOptions.workerUrl;

  if (options._workerType === 'test') {
    url = "modules/".concat(worker.module, "/dist/").concat(workerFile);
  }

  if (!url) {
    var version = worker.version;

    if (version === 'latest') {
      version = NPM_TAG;
    }

    var versionTag = version ? "@".concat(version) : '';
    url = "https://unpkg.com/@loaders.gl/".concat(worker.module).concat(versionTag, "/dist/").concat(workerFile);
  }

  (0, _assert.assert)(url);
  return url;
}

},{"../env-utils/assert":110,"../env-utils/version":112}],116:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.canProcessOnWorker = canProcessOnWorker;
exports.processOnWorker = processOnWorker;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _workerFarm = _interopRequireDefault(require("../worker-farm/worker-farm"));

var _removeNontransferableOptions = require("../worker-utils/remove-nontransferable-options");

var _getWorkerUrl = require("./get-worker-url");

function canProcessOnWorker(worker, options) {
  if (!_workerFarm.default.isSupported()) {
    return false;
  }

  return worker.worker && (options === null || options === void 0 ? void 0 : options.worker);
}

function processOnWorker(_x, _x2) {
  return _processOnWorker.apply(this, arguments);
}

function _processOnWorker() {
  _processOnWorker = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(worker, data) {
    var options,
        context,
        name,
        url,
        workerFarm,
        workerPool,
        jobName,
        job,
        transferableOptions,
        result,
        _args = arguments;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
            context = _args.length > 3 && _args[3] !== undefined ? _args[3] : {};
            name = (0, _getWorkerUrl.getWorkerName)(worker);
            url = (0, _getWorkerUrl.getWorkerURL)(worker, options);
            workerFarm = _workerFarm.default.getWorkerFarm(options);
            workerPool = workerFarm.getWorkerPool({
              name: name,
              url: url
            });
            jobName = options.jobName || worker.name;
            _context.next = 9;
            return workerPool.startJob(jobName, onMessage.bind(null, context));

          case 9:
            job = _context.sent;
            transferableOptions = (0, _removeNontransferableOptions.removeNontransferableOptions)(options);
            job.postMessage('process', {
              input: data,
              options: transferableOptions
            });
            _context.next = 14;
            return job.result;

          case 14:
            result = _context.sent;
            return _context.abrupt("return", result.result);

          case 16:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _processOnWorker.apply(this, arguments);
}

function onMessage(_x3, _x4, _x5, _x6) {
  return _onMessage.apply(this, arguments);
}

function _onMessage() {
  _onMessage = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(context, job, type, payload) {
    var id, input, options, result, message;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.t0 = type;
            _context2.next = _context2.t0 === 'done' ? 3 : _context2.t0 === 'error' ? 5 : _context2.t0 === 'process' ? 7 : 23;
            break;

          case 3:
            job.done(payload);
            return _context2.abrupt("break", 24);

          case 5:
            job.error(payload.error);
            return _context2.abrupt("break", 24);

          case 7:
            id = payload.id, input = payload.input, options = payload.options;
            _context2.prev = 8;

            if (context.process) {
              _context2.next = 12;
              break;
            }

            job.postMessage('error', {
              id: id,
              error: 'Worker not set up to process on main thread'
            });
            return _context2.abrupt("return");

          case 12:
            _context2.next = 14;
            return context.process(input, options);

          case 14:
            result = _context2.sent;
            job.postMessage('done', {
              id: id,
              result: result
            });
            _context2.next = 22;
            break;

          case 18:
            _context2.prev = 18;
            _context2.t1 = _context2["catch"](8);
            message = _context2.t1 instanceof Error ? _context2.t1.message : 'unknown error';
            job.postMessage('error', {
              id: id,
              error: message
            });

          case 22:
            return _context2.abrupt("break", 24);

          case 23:
            console.warn("process-on-worker: unknown message ".concat(type));

          case 24:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[8, 18]]);
  }));
  return _onMessage.apply(this, arguments);
}

},{"../worker-farm/worker-farm":119,"../worker-utils/remove-nontransferable-options":125,"./get-worker-url":115,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],117:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateWorkerVersion = validateWorkerVersion;

var _assert = require("../env-utils/assert");

var _version = require("../env-utils/version");

function validateWorkerVersion(worker) {
  var coreVersion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _version.VERSION;
  (0, _assert.assert)(worker, 'no worker provided');
  var workerVersion = worker.version;

  if (!coreVersion || !workerVersion) {
    return false;
  }

  return true;
}

function parseVersion(version) {
  var parts = version.split('.').map(Number);
  return {
    major: parts[0],
    minor: parts[1]
  };
}

},{"../env-utils/assert":110,"../env-utils/version":112}],118:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _getTransferList = require("../worker-utils/get-transfer-list");

var onMessageWrapperMap = new Map();

var WorkerBody = function () {
  function WorkerBody() {
    (0, _classCallCheck2.default)(this, WorkerBody);
  }

  (0, _createClass2.default)(WorkerBody, null, [{
    key: "onmessage",
    set: function set(onMessage) {
      self.onmessage = function (message) {
        if (!isKnownMessage(message)) {
          return;
        }

        var _message$data = message.data,
            type = _message$data.type,
            payload = _message$data.payload;
        onMessage(type, payload);
      };
    }
  }, {
    key: "addEventListener",
    value: function addEventListener(onMessage) {
      var onMessageWrapper = onMessageWrapperMap.get(onMessage);

      if (!onMessageWrapper) {
        onMessageWrapper = function onMessageWrapper(message) {
          if (!isKnownMessage(message)) {
            return;
          }

          var _message$data2 = message.data,
              type = _message$data2.type,
              payload = _message$data2.payload;
          onMessage(type, payload);
        };
      }

      self.addEventListener('message', onMessageWrapper);
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(onMessage) {
      var onMessageWrapper = onMessageWrapperMap.get(onMessage);
      onMessageWrapperMap.delete(onMessage);
      self.removeEventListener('message', onMessageWrapper);
    }
  }, {
    key: "postMessage",
    value: function postMessage(type, payload) {
      if (self) {
        var data = {
          source: 'loaders.gl',
          type: type,
          payload: payload
        };
        var transferList = (0, _getTransferList.getTransferList)(payload);
        self.postMessage(data, transferList);
      }
    }
  }]);
  return WorkerBody;
}();

exports.default = WorkerBody;

function isKnownMessage(message) {
  var type = message.type,
      data = message.data;
  return type === 'message' && data && typeof data.source === 'string' && data.source.startsWith('loaders.gl');
}

},{"../worker-utils/get-transfer-list":124,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/interopRequireDefault":18}],119:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _workerPool = _interopRequireDefault(require("./worker-pool"));

var _workerThread = _interopRequireDefault(require("./worker-thread"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var DEFAULT_PROPS = {
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  onDebug: function onDebug() {},
  reuseWorkers: true
};

var WorkerFarm = function () {
  function WorkerFarm(props) {
    (0, _classCallCheck2.default)(this, WorkerFarm);
    (0, _defineProperty2.default)(this, "props", void 0);
    (0, _defineProperty2.default)(this, "workerPools", new Map());
    this.props = _objectSpread({}, DEFAULT_PROPS);
    this.setProps(props);
    this.workerPools = new Map();
  }

  (0, _createClass2.default)(WorkerFarm, [{
    key: "destroy",
    value: function destroy() {
      var _iterator = _createForOfIteratorHelper(this.workerPools.values()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var workerPool = _step.value;
          workerPool.destroy();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      this.props = _objectSpread(_objectSpread({}, this.props), props);

      var _iterator2 = _createForOfIteratorHelper(this.workerPools.values()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var workerPool = _step2.value;
          workerPool.setProps(this._getWorkerPoolProps());
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }, {
    key: "getWorkerPool",
    value: function getWorkerPool(options) {
      var name = options.name,
          source = options.source,
          url = options.url;
      var workerPool = this.workerPools.get(name);

      if (!workerPool) {
        workerPool = new _workerPool.default({
          name: name,
          source: source,
          url: url
        });
        workerPool.setProps(this._getWorkerPoolProps());
        this.workerPools.set(name, workerPool);
      }

      return workerPool;
    }
  }, {
    key: "_getWorkerPoolProps",
    value: function _getWorkerPoolProps() {
      return {
        maxConcurrency: this.props.maxConcurrency,
        maxMobileConcurrency: this.props.maxMobileConcurrency,
        reuseWorkers: this.props.reuseWorkers,
        onDebug: this.props.onDebug
      };
    }
  }], [{
    key: "isSupported",
    value: function isSupported() {
      return _workerThread.default.isSupported();
    }
  }, {
    key: "getWorkerFarm",
    value: function getWorkerFarm() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      WorkerFarm._workerFarm = WorkerFarm._workerFarm || new WorkerFarm({});

      WorkerFarm._workerFarm.setProps(props);

      return WorkerFarm._workerFarm;
    }
  }]);
  return WorkerFarm;
}();

exports.default = WorkerFarm;
(0, _defineProperty2.default)(WorkerFarm, "_workerFarm", void 0);

},{"./worker-pool":121,"./worker-thread":122,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18}],120:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _assert = require("../env-utils/assert");

var WorkerJob = function () {
  function WorkerJob(jobName, workerThread) {
    var _this = this;

    (0, _classCallCheck2.default)(this, WorkerJob);
    (0, _defineProperty2.default)(this, "name", void 0);
    (0, _defineProperty2.default)(this, "workerThread", void 0);
    (0, _defineProperty2.default)(this, "isRunning", void 0);
    (0, _defineProperty2.default)(this, "result", void 0);
    (0, _defineProperty2.default)(this, "_resolve", void 0);
    (0, _defineProperty2.default)(this, "_reject", void 0);
    this.name = jobName;
    this.workerThread = workerThread;
    this.isRunning = true;

    this._resolve = function () {};

    this._reject = function () {};

    this.result = new Promise(function (resolve, reject) {
      _this._resolve = resolve;
      _this._reject = reject;
    });
  }

  (0, _createClass2.default)(WorkerJob, [{
    key: "postMessage",
    value: function postMessage(type, payload) {
      this.workerThread.postMessage({
        source: 'loaders.gl',
        type: type,
        payload: payload
      });
    }
  }, {
    key: "done",
    value: function done(value) {
      (0, _assert.assert)(this.isRunning);
      this.isRunning = false;

      this._resolve(value);
    }
  }, {
    key: "error",
    value: function error(_error) {
      (0, _assert.assert)(this.isRunning);
      this.isRunning = false;

      this._reject(_error);
    }
  }]);
  return WorkerJob;
}();

exports.default = WorkerJob;

},{"../env-utils/assert":110,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18}],121:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _globals = require("../env-utils/globals");

var _workerThread = _interopRequireDefault(require("./worker-thread"));

var _workerJob = _interopRequireDefault(require("./worker-job"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var WorkerPool = function () {
  function WorkerPool(props) {
    (0, _classCallCheck2.default)(this, WorkerPool);
    (0, _defineProperty2.default)(this, "name", 'unnamed');
    (0, _defineProperty2.default)(this, "source", void 0);
    (0, _defineProperty2.default)(this, "url", void 0);
    (0, _defineProperty2.default)(this, "maxConcurrency", 1);
    (0, _defineProperty2.default)(this, "maxMobileConcurrency", 1);
    (0, _defineProperty2.default)(this, "onDebug", function () {});
    (0, _defineProperty2.default)(this, "reuseWorkers", true);
    (0, _defineProperty2.default)(this, "props", {});
    (0, _defineProperty2.default)(this, "jobQueue", []);
    (0, _defineProperty2.default)(this, "idleQueue", []);
    (0, _defineProperty2.default)(this, "count", 0);
    (0, _defineProperty2.default)(this, "isDestroyed", false);
    this.source = props.source;
    this.url = props.url;
    this.setProps(props);
  }

  (0, _createClass2.default)(WorkerPool, [{
    key: "destroy",
    value: function destroy() {
      this.idleQueue.forEach(function (worker) {
        return worker.destroy();
      });
      this.isDestroyed = true;
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      this.props = _objectSpread(_objectSpread({}, this.props), props);

      if (props.name !== undefined) {
        this.name = props.name;
      }

      if (props.maxConcurrency !== undefined) {
        this.maxConcurrency = props.maxConcurrency;
      }

      if (props.maxMobileConcurrency !== undefined) {
        this.maxMobileConcurrency = props.maxMobileConcurrency;
      }

      if (props.reuseWorkers !== undefined) {
        this.reuseWorkers = props.reuseWorkers;
      }

      if (props.onDebug !== undefined) {
        this.onDebug = props.onDebug;
      }
    }
  }, {
    key: "startJob",
    value: function () {
      var _startJob = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(name) {
        var _this = this;

        var onMessage,
            onError,
            startPromise,
            _args = arguments;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                onMessage = _args.length > 1 && _args[1] !== undefined ? _args[1] : function (job, type, data) {
                  return job.done(data);
                };
                onError = _args.length > 2 && _args[2] !== undefined ? _args[2] : function (job, error) {
                  return job.error(error);
                };
                startPromise = new Promise(function (onStart) {
                  _this.jobQueue.push({
                    name: name,
                    onMessage: onMessage,
                    onError: onError,
                    onStart: onStart
                  });

                  return _this;
                });

                this._startQueuedJob();

                _context.next = 6;
                return startPromise;

              case 6:
                return _context.abrupt("return", _context.sent);

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function startJob(_x) {
        return _startJob.apply(this, arguments);
      }

      return startJob;
    }()
  }, {
    key: "_startQueuedJob",
    value: function () {
      var _startQueuedJob2 = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2() {
        var workerThread, queuedJob, _job;

        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this.jobQueue.length) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return");

              case 2:
                workerThread = this._getAvailableWorker();

                if (workerThread) {
                  _context2.next = 5;
                  break;
                }

                return _context2.abrupt("return");

              case 5:
                queuedJob = this.jobQueue.shift();

                if (!queuedJob) {
                  _context2.next = 18;
                  break;
                }

                this.onDebug({
                  message: 'Starting job',
                  name: queuedJob.name,
                  workerThread: workerThread,
                  backlog: this.jobQueue.length
                });
                _job = new _workerJob.default(queuedJob.name, workerThread);

                workerThread.onMessage = function (data) {
                  return queuedJob.onMessage(_job, data.type, data.payload);
                };

                workerThread.onError = function (error) {
                  return queuedJob.onError(_job, error);
                };

                queuedJob.onStart(_job);
                _context2.prev = 12;
                _context2.next = 15;
                return _job.result;

              case 15:
                _context2.prev = 15;
                this.returnWorkerToQueue(workerThread);
                return _context2.finish(15);

              case 18:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[12,, 15, 18]]);
      }));

      function _startQueuedJob() {
        return _startQueuedJob2.apply(this, arguments);
      }

      return _startQueuedJob;
    }()
  }, {
    key: "returnWorkerToQueue",
    value: function returnWorkerToQueue(worker) {
      var shouldDestroyWorker = this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();

      if (shouldDestroyWorker) {
        worker.destroy();
        this.count--;
      } else {
        this.idleQueue.push(worker);
      }

      if (!this.isDestroyed) {
        this._startQueuedJob();
      }
    }
  }, {
    key: "_getAvailableWorker",
    value: function _getAvailableWorker() {
      if (this.idleQueue.length > 0) {
        return this.idleQueue.shift() || null;
      }

      if (this.count < this._getMaxConcurrency()) {
        this.count++;
        var name = "".concat(this.name.toLowerCase(), " (#").concat(this.count, " of ").concat(this.maxConcurrency, ")");
        return new _workerThread.default({
          name: name,
          source: this.source,
          url: this.url
        });
      }

      return null;
    }
  }, {
    key: "_getMaxConcurrency",
    value: function _getMaxConcurrency() {
      return _globals.isMobile ? this.maxMobileConcurrency : this.maxConcurrency;
    }
  }]);
  return WorkerPool;
}();

exports.default = WorkerPool;

},{"../env-utils/globals":111,"./worker-job":120,"./worker-thread":122,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],122:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _assert = require("../env-utils/assert");

var _getLoadableWorkerUrl = require("../worker-utils/get-loadable-worker-url");

var _getTransferList = require("../worker-utils/get-transfer-list");

var NOOP = function NOOP() {};

var WorkerThread = function () {
  function WorkerThread(props) {
    (0, _classCallCheck2.default)(this, WorkerThread);
    (0, _defineProperty2.default)(this, "name", void 0);
    (0, _defineProperty2.default)(this, "source", void 0);
    (0, _defineProperty2.default)(this, "url", void 0);
    (0, _defineProperty2.default)(this, "terminated", false);
    (0, _defineProperty2.default)(this, "worker", void 0);
    (0, _defineProperty2.default)(this, "onMessage", void 0);
    (0, _defineProperty2.default)(this, "onError", void 0);
    (0, _defineProperty2.default)(this, "_loadableURL", '');
    var name = props.name,
        source = props.source,
        url = props.url;
    (0, _assert.assert)(source || url);
    this.name = name;
    this.source = source;
    this.url = url;
    this.onMessage = NOOP;

    this.onError = function (error) {
      return console.log(error);
    };

    this.worker = this._createBrowserWorker();
  }

  (0, _createClass2.default)(WorkerThread, [{
    key: "destroy",
    value: function destroy() {
      this.onMessage = NOOP;
      this.onError = NOOP;
      this.worker.terminate();
      this.terminated = true;
    }
  }, {
    key: "isRunning",
    get: function get() {
      return Boolean(this.onMessage);
    }
  }, {
    key: "postMessage",
    value: function postMessage(data, transferList) {
      transferList = transferList || (0, _getTransferList.getTransferList)(data);
      this.worker.postMessage(data, transferList);
    }
  }, {
    key: "_getErrorFromErrorEvent",
    value: function _getErrorFromErrorEvent(event) {
      var message = 'Failed to load ';
      message += "worker ".concat(this.name, ". ");

      if (event.message) {
        message += "".concat(event.message, " in ");
      }

      if (event.lineno) {
        message += ":".concat(event.lineno, ":").concat(event.colno);
      }

      return new Error(message);
    }
  }, {
    key: "_createBrowserWorker",
    value: function _createBrowserWorker() {
      var _this = this;

      this._loadableURL = (0, _getLoadableWorkerUrl.getLoadableWorkerURL)({
        source: this.source,
        url: this.url
      });
      var worker = new Worker(this._loadableURL, {
        name: this.name
      });

      worker.onmessage = function (event) {
        if (!event.data) {
          _this.onError(new Error('No data received'));
        } else {
          _this.onMessage(event.data);
        }
      };

      worker.onerror = function (error) {
        _this.onError(_this._getErrorFromErrorEvent(error));

        _this.terminated = true;
      };

      worker.onmessageerror = function (event) {
        return console.error(event);
      };

      return worker;
    }
  }], [{
    key: "isSupported",
    value: function isSupported() {
      return typeof Worker !== 'undefined';
    }
  }]);
  return WorkerThread;
}();

exports.default = WorkerThread;

},{"../env-utils/assert":110,"../worker-utils/get-loadable-worker-url":123,"../worker-utils/get-transfer-list":124,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18}],123:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLoadableWorkerURL = getLoadableWorkerURL;

var _assert = require("../env-utils/assert");

var workerURLCache = new Map();

function getLoadableWorkerURL(props) {
  (0, _assert.assert)(props.source && !props.url || !props.source && props.url);
  var workerURL = workerURLCache.get(props.source || props.url);

  if (!workerURL) {
    if (props.url) {
      workerURL = getLoadableWorkerURLFromURL(props.url);
      workerURLCache.set(props.url, workerURL);
    }

    if (props.source) {
      workerURL = getLoadableWorkerURLFromSource(props.source);
      workerURLCache.set(props.source, workerURL);
    }
  }

  (0, _assert.assert)(workerURL);
  return workerURL;
}

function getLoadableWorkerURLFromURL(url) {
  if (!url.startsWith('http')) {
    return url;
  }

  var workerSource = buildScriptSource(url);
  return getLoadableWorkerURLFromSource(workerSource);
}

function getLoadableWorkerURLFromSource(workerSource) {
  var blob = new Blob([workerSource], {
    type: 'application/javascript'
  });
  return URL.createObjectURL(blob);
}

function buildScriptSource(workerUrl) {
  return "try {\n  importScripts('".concat(workerUrl, "');\n} catch (error) {\n  console.error(error);\n  throw error;\n}");
}

},{"../env-utils/assert":110}],124:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTransferList = getTransferList;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

function getTransferList(object) {
  var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var transfers = arguments.length > 2 ? arguments[2] : undefined;
  var transfersSet = transfers || new Set();

  if (!object) {} else if (isTransferable(object)) {
    transfersSet.add(object);
  } else if (isTransferable(object.buffer)) {
    transfersSet.add(object.buffer);
  } else if (ArrayBuffer.isView(object)) {} else if (recursive && (0, _typeof2.default)(object) === 'object') {
    for (var key in object) {
      getTransferList(object[key], recursive, transfersSet);
    }
  }

  return transfers === undefined ? Array.from(transfersSet) : [];
}

function isTransferable(object) {
  if (!object) {
    return false;
  }

  if (object instanceof ArrayBuffer) {
    return true;
  }

  if (typeof MessagePort !== 'undefined' && object instanceof MessagePort) {
    return true;
  }

  if (typeof ImageBitmap !== 'undefined' && object instanceof ImageBitmap) {
    return true;
  }

  if (typeof OffscreenCanvas !== 'undefined' && object instanceof OffscreenCanvas) {
    return true;
  }

  return false;
}

},{"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29}],125:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeNontransferableOptions = removeNontransferableOptions;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

function removeNontransferableOptions(object) {
  return JSON.parse(stringifyJSON(object));
}

function stringifyJSON(v) {
  var cache = new Set();
  return JSON.stringify(v, function (key, value) {
    if ((0, _typeof2.default)(value) === 'object' && value !== null) {
      if (cache.has(value)) {
        try {
          return JSON.parse(JSON.stringify(value));
        } catch (err) {
          return undefined;
        }
      }

      cache.add(value);
    }

    return value;
  });
}

},{"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29}],126:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Stats", {
  enumerable: true,
  get: function get() {
    return _stats.default;
  }
});
Object.defineProperty(exports, "Stat", {
  enumerable: true,
  get: function get() {
    return _stat.default;
  }
});
Object.defineProperty(exports, "_getHiResTimestamp", {
  enumerable: true,
  get: function get() {
    return _hiResTimestamp.default;
  }
});

var _stats = _interopRequireDefault(require("./lib/stats"));

var _stat = _interopRequireDefault(require("./lib/stat"));

var _hiResTimestamp = _interopRequireDefault(require("./utils/hi-res-timestamp"));

},{"./lib/stat":127,"./lib/stats":128,"./utils/hi-res-timestamp":129,"@babel/runtime/helpers/interopRequireDefault":18}],127:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _hiResTimestamp = _interopRequireDefault(require("../utils/hi-res-timestamp"));

var Stat = function () {
  function Stat(name, type) {
    (0, _classCallCheck2.default)(this, Stat);
    this.name = name;
    this.type = type;
    this.sampleSize = 1;
    this.reset();
  }

  (0, _createClass2.default)(Stat, [{
    key: "setSampleSize",
    value: function setSampleSize(samples) {
      this.sampleSize = samples;
      return this;
    }
  }, {
    key: "incrementCount",
    value: function incrementCount() {
      this.addCount(1);
      return this;
    }
  }, {
    key: "decrementCount",
    value: function decrementCount() {
      this.subtractCount(1);
      return this;
    }
  }, {
    key: "addCount",
    value: function addCount(value) {
      this._count += value;
      this._samples++;

      this._checkSampling();

      return this;
    }
  }, {
    key: "subtractCount",
    value: function subtractCount(value) {
      this._count -= value;
      this._samples++;

      this._checkSampling();

      return this;
    }
  }, {
    key: "addTime",
    value: function addTime(time) {
      this._time += time;
      this.lastTiming = time;
      this._samples++;

      this._checkSampling();

      return this;
    }
  }, {
    key: "timeStart",
    value: function timeStart() {
      this._startTime = (0, _hiResTimestamp.default)();
      this._timerPending = true;
      return this;
    }
  }, {
    key: "timeEnd",
    value: function timeEnd() {
      if (!this._timerPending) {
        return this;
      }

      this.addTime((0, _hiResTimestamp.default)() - this._startTime);
      this._timerPending = false;

      this._checkSampling();

      return this;
    }
  }, {
    key: "getSampleAverageCount",
    value: function getSampleAverageCount() {
      return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
    }
  }, {
    key: "getSampleAverageTime",
    value: function getSampleAverageTime() {
      return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
    }
  }, {
    key: "getSampleHz",
    value: function getSampleHz() {
      return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1000) : 0;
    }
  }, {
    key: "getAverageCount",
    value: function getAverageCount() {
      return this.samples > 0 ? this.count / this.samples : 0;
    }
  }, {
    key: "getAverageTime",
    value: function getAverageTime() {
      return this.samples > 0 ? this.time / this.samples : 0;
    }
  }, {
    key: "getHz",
    value: function getHz() {
      return this.time > 0 ? this.samples / (this.time / 1000) : 0;
    }
  }, {
    key: "reset",
    value: function reset() {
      this.time = 0;
      this.count = 0;
      this.samples = 0;
      this.lastTiming = 0;
      this.lastSampleTime = 0;
      this.lastSampleCount = 0;
      this._count = 0;
      this._time = 0;
      this._samples = 0;
      this._startTime = 0;
      this._timerPending = false;
      return this;
    }
  }, {
    key: "_checkSampling",
    value: function _checkSampling() {
      if (this._samples === this.sampleSize) {
        this.lastSampleTime = this._time;
        this.lastSampleCount = this._count;
        this.count += this._count;
        this.time += this._time;
        this.samples += this._samples;
        this._time = 0;
        this._count = 0;
        this._samples = 0;
      }
    }
  }]);
  return Stat;
}();

exports.default = Stat;

},{"../utils/hi-res-timestamp":129,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/interopRequireDefault":18}],128:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _stat = _interopRequireDefault(require("./stat"));

var Stats = function () {
  function Stats(_ref) {
    var id = _ref.id,
        stats = _ref.stats;
    (0, _classCallCheck2.default)(this, Stats);
    this.id = id;
    this.stats = {};

    this._initializeStats(stats);

    Object.seal(this);
  }

  (0, _createClass2.default)(Stats, [{
    key: "get",
    value: function get(name) {
      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'count';
      return this._getOrCreate({
        name: name,
        type: type
      });
    }
  }, {
    key: "size",
    get: function get() {
      return Object.keys(this.stats).length;
    }
  }, {
    key: "reset",
    value: function reset() {
      for (var key in this.stats) {
        this.stats[key].reset();
      }

      return this;
    }
  }, {
    key: "forEach",
    value: function forEach(fn) {
      for (var key in this.stats) {
        fn(this.stats[key]);
      }
    }
  }, {
    key: "getTable",
    value: function getTable() {
      var table = {};
      this.forEach(function (stat) {
        table[stat.name] = {
          time: stat.time || 0,
          count: stat.count || 0,
          average: stat.getAverageTime() || 0,
          hz: stat.getHz() || 0
        };
      });
      return table;
    }
  }, {
    key: "_initializeStats",
    value: function _initializeStats() {
      var _this = this;

      var stats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      stats.forEach(function (stat) {
        return _this._getOrCreate(stat);
      });
    }
  }, {
    key: "_getOrCreate",
    value: function _getOrCreate(stat) {
      if (!stat || !stat.name) {
        return null;
      }

      var name = stat.name,
          type = stat.type;

      if (!this.stats[name]) {
        if (stat instanceof _stat.default) {
          this.stats[name] = stat;
        } else {
          this.stats[name] = new _stat.default(name, type);
        }
      }

      return this.stats[name];
    }
  }]);
  return Stats;
}();

exports.default = Stats;

},{"./stat":127,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/interopRequireDefault":18}],129:[function(require,module,exports){
(function (process){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getHiResTimestamp;

function getHiResTimestamp() {
  var timestamp;

  if (typeof window !== 'undefined' && window.performance) {
    timestamp = window.performance.now();
  } else if (typeof process !== 'undefined' && process.hrtime) {
    var timeParts = process.hrtime();
    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }

  return timestamp;
}

}).call(this)}).call(this,require('_process'))

},{"_process":153}],130:[function(require,module,exports){

},{}],131:[function(require,module,exports){
module.exports = attributeToProperty

var transform = {
  'class': 'className',
  'for': 'htmlFor',
  'http-equiv': 'httpEquiv'
}

function attributeToProperty (h) {
  return function (tagName, attrs, children) {
    for (var attr in attrs) {
      if (attr in transform) {
        attrs[transform[attr]] = attrs[attr]
        delete attrs[attr]
      }
    }
    return h(tagName, attrs, children)
  }
}

},{}],132:[function(require,module,exports){
var attrToProp = require('hyperscript-attribute-to-property')

var VAR = 0, TEXT = 1, OPEN = 2, CLOSE = 3, ATTR = 4
var ATTR_KEY = 5, ATTR_KEY_W = 6
var ATTR_VALUE_W = 7, ATTR_VALUE = 8
var ATTR_VALUE_SQ = 9, ATTR_VALUE_DQ = 10
var ATTR_EQ = 11, ATTR_BREAK = 12
var COMMENT = 13

module.exports = function (h, opts) {
  if (!opts) opts = {}
  var concat = opts.concat || function (a, b) {
    return String(a) + String(b)
  }
  if (opts.attrToProp !== false) {
    h = attrToProp(h)
  }

  return function (strings) {
    var state = TEXT, reg = ''
    var arglen = arguments.length
    var parts = []

    for (var i = 0; i < strings.length; i++) {
      if (i < arglen - 1) {
        var arg = arguments[i+1]
        var p = parse(strings[i])
        var xstate = state
        if (xstate === ATTR_VALUE_DQ) xstate = ATTR_VALUE
        if (xstate === ATTR_VALUE_SQ) xstate = ATTR_VALUE
        if (xstate === ATTR_VALUE_W) xstate = ATTR_VALUE
        if (xstate === ATTR) xstate = ATTR_KEY
        if (xstate === OPEN) {
          if (reg === '/') {
            p.push([ OPEN, '/', arg ])
            reg = ''
          } else {
            p.push([ OPEN, arg ])
          }
        } else if (xstate === COMMENT && opts.comments) {
          reg += String(arg)
        } else if (xstate !== COMMENT) {
          p.push([ VAR, xstate, arg ])
        }
        parts.push.apply(parts, p)
      } else parts.push.apply(parts, parse(strings[i]))
    }

    var tree = [null,{},[]]
    var stack = [[tree,-1]]
    for (var i = 0; i < parts.length; i++) {
      var cur = stack[stack.length-1][0]
      var p = parts[i], s = p[0]
      if (s === OPEN && /^\//.test(p[1])) {
        var ix = stack[stack.length-1][1]
        if (stack.length > 1) {
          stack.pop()
          stack[stack.length-1][0][2][ix] = h(
            cur[0], cur[1], cur[2].length ? cur[2] : undefined
          )
        }
      } else if (s === OPEN) {
        var c = [p[1],{},[]]
        cur[2].push(c)
        stack.push([c,cur[2].length-1])
      } else if (s === ATTR_KEY || (s === VAR && p[1] === ATTR_KEY)) {
        var key = ''
        var copyKey
        for (; i < parts.length; i++) {
          if (parts[i][0] === ATTR_KEY) {
            key = concat(key, parts[i][1])
          } else if (parts[i][0] === VAR && parts[i][1] === ATTR_KEY) {
            if (typeof parts[i][2] === 'object' && !key) {
              for (copyKey in parts[i][2]) {
                if (parts[i][2].hasOwnProperty(copyKey) && !cur[1][copyKey]) {
                  cur[1][copyKey] = parts[i][2][copyKey]
                }
              }
            } else {
              key = concat(key, parts[i][2])
            }
          } else break
        }
        if (parts[i][0] === ATTR_EQ) i++
        var j = i
        for (; i < parts.length; i++) {
          if (parts[i][0] === ATTR_VALUE || parts[i][0] === ATTR_KEY) {
            if (!cur[1][key]) cur[1][key] = strfn(parts[i][1])
            else parts[i][1]==="" || (cur[1][key] = concat(cur[1][key], parts[i][1]));
          } else if (parts[i][0] === VAR
          && (parts[i][1] === ATTR_VALUE || parts[i][1] === ATTR_KEY)) {
            if (!cur[1][key]) cur[1][key] = strfn(parts[i][2])
            else parts[i][2]==="" || (cur[1][key] = concat(cur[1][key], parts[i][2]));
          } else {
            if (key.length && !cur[1][key] && i === j
            && (parts[i][0] === CLOSE || parts[i][0] === ATTR_BREAK)) {
              // https://html.spec.whatwg.org/multipage/infrastructure.html#boolean-attributes
              // empty string is falsy, not well behaved value in browser
              cur[1][key] = key.toLowerCase()
            }
            if (parts[i][0] === CLOSE) {
              i--
            }
            break
          }
        }
      } else if (s === ATTR_KEY) {
        cur[1][p[1]] = true
      } else if (s === VAR && p[1] === ATTR_KEY) {
        cur[1][p[2]] = true
      } else if (s === CLOSE) {
        if (selfClosing(cur[0]) && stack.length) {
          var ix = stack[stack.length-1][1]
          stack.pop()
          stack[stack.length-1][0][2][ix] = h(
            cur[0], cur[1], cur[2].length ? cur[2] : undefined
          )
        }
      } else if (s === VAR && p[1] === TEXT) {
        if (p[2] === undefined || p[2] === null) p[2] = ''
        else if (!p[2]) p[2] = concat('', p[2])
        if (Array.isArray(p[2][0])) {
          cur[2].push.apply(cur[2], p[2])
        } else {
          cur[2].push(p[2])
        }
      } else if (s === TEXT) {
        cur[2].push(p[1])
      } else if (s === ATTR_EQ || s === ATTR_BREAK) {
        // no-op
      } else {
        throw new Error('unhandled: ' + s)
      }
    }

    if (tree[2].length > 1 && /^\s*$/.test(tree[2][0])) {
      tree[2].shift()
    }

    if (tree[2].length > 2
    || (tree[2].length === 2 && /\S/.test(tree[2][1]))) {
      if (opts.createFragment) return opts.createFragment(tree[2])
      throw new Error(
        'multiple root elements must be wrapped in an enclosing tag'
      )
    }
    if (Array.isArray(tree[2][0]) && typeof tree[2][0][0] === 'string'
    && Array.isArray(tree[2][0][2])) {
      tree[2][0] = h(tree[2][0][0], tree[2][0][1], tree[2][0][2])
    }
    return tree[2][0]

    function parse (str) {
      var res = []
      if (state === ATTR_VALUE_W) state = ATTR
      for (var i = 0; i < str.length; i++) {
        var c = str.charAt(i)
        if (state === TEXT && c === '<') {
          if (reg.length) res.push([TEXT, reg])
          reg = ''
          state = OPEN
        } else if (c === '>' && !quot(state) && state !== COMMENT) {
          if (state === OPEN && reg.length) {
            res.push([OPEN,reg])
          } else if (state === ATTR_KEY) {
            res.push([ATTR_KEY,reg])
          } else if (state === ATTR_VALUE && reg.length) {
            res.push([ATTR_VALUE,reg])
          }
          res.push([CLOSE])
          reg = ''
          state = TEXT
        } else if (state === COMMENT && /-$/.test(reg) && c === '-') {
          if (opts.comments) {
            res.push([ATTR_VALUE,reg.substr(0, reg.length - 1)])
          }
          reg = ''
          state = TEXT
        } else if (state === OPEN && /^!--$/.test(reg)) {
          if (opts.comments) {
            res.push([OPEN, reg],[ATTR_KEY,'comment'],[ATTR_EQ])
          }
          reg = c
          state = COMMENT
        } else if (state === TEXT || state === COMMENT) {
          reg += c
        } else if (state === OPEN && c === '/' && reg.length) {
          // no-op, self closing tag without a space <br/>
        } else if (state === OPEN && /\s/.test(c)) {
          if (reg.length) {
            res.push([OPEN, reg])
          }
          reg = ''
          state = ATTR
        } else if (state === OPEN) {
          reg += c
        } else if (state === ATTR && /[^\s"'=/]/.test(c)) {
          state = ATTR_KEY
          reg = c
        } else if (state === ATTR && /\s/.test(c)) {
          if (reg.length) res.push([ATTR_KEY,reg])
          res.push([ATTR_BREAK])
        } else if (state === ATTR_KEY && /\s/.test(c)) {
          res.push([ATTR_KEY,reg])
          reg = ''
          state = ATTR_KEY_W
        } else if (state === ATTR_KEY && c === '=') {
          res.push([ATTR_KEY,reg],[ATTR_EQ])
          reg = ''
          state = ATTR_VALUE_W
        } else if (state === ATTR_KEY) {
          reg += c
        } else if ((state === ATTR_KEY_W || state === ATTR) && c === '=') {
          res.push([ATTR_EQ])
          state = ATTR_VALUE_W
        } else if ((state === ATTR_KEY_W || state === ATTR) && !/\s/.test(c)) {
          res.push([ATTR_BREAK])
          if (/[\w-]/.test(c)) {
            reg += c
            state = ATTR_KEY
          } else state = ATTR
        } else if (state === ATTR_VALUE_W && c === '"') {
          state = ATTR_VALUE_DQ
        } else if (state === ATTR_VALUE_W && c === "'") {
          state = ATTR_VALUE_SQ
        } else if (state === ATTR_VALUE_DQ && c === '"') {
          res.push([ATTR_VALUE,reg],[ATTR_BREAK])
          reg = ''
          state = ATTR
        } else if (state === ATTR_VALUE_SQ && c === "'") {
          res.push([ATTR_VALUE,reg],[ATTR_BREAK])
          reg = ''
          state = ATTR
        } else if (state === ATTR_VALUE_W && !/\s/.test(c)) {
          state = ATTR_VALUE
          i--
        } else if (state === ATTR_VALUE && /\s/.test(c)) {
          res.push([ATTR_VALUE,reg],[ATTR_BREAK])
          reg = ''
          state = ATTR
        } else if (state === ATTR_VALUE || state === ATTR_VALUE_SQ
        || state === ATTR_VALUE_DQ) {
          reg += c
        }
      }
      if (state === TEXT && reg.length) {
        res.push([TEXT,reg])
        reg = ''
      } else if (state === ATTR_VALUE && reg.length) {
        res.push([ATTR_VALUE,reg])
        reg = ''
      } else if (state === ATTR_VALUE_DQ && reg.length) {
        res.push([ATTR_VALUE,reg])
        reg = ''
      } else if (state === ATTR_VALUE_SQ && reg.length) {
        res.push([ATTR_VALUE,reg])
        reg = ''
      } else if (state === ATTR_KEY) {
        res.push([ATTR_KEY,reg])
        reg = ''
      }
      return res
    }
  }

  function strfn (x) {
    if (typeof x === 'function') return x
    else if (typeof x === 'string') return x
    else if (x && typeof x === 'object') return x
    else if (x === null || x === undefined) return x
    else return concat('', x)
  }
}

function quot (state) {
  return state === ATTR_VALUE_SQ || state === ATTR_VALUE_DQ
}

var closeRE = RegExp('^(' + [
  'area', 'base', 'basefont', 'bgsound', 'br', 'col', 'command', 'embed',
  'frame', 'hr', 'img', 'input', 'isindex', 'keygen', 'link', 'meta', 'param',
  'source', 'track', 'wbr', '!--',
  // SVG TAGS
  'animate', 'animateTransform', 'circle', 'cursor', 'desc', 'ellipse',
  'feBlend', 'feColorMatrix', 'feComposite',
  'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap',
  'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR',
  'feGaussianBlur', 'feImage', 'feMergeNode', 'feMorphology',
  'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile',
  'feTurbulence', 'font-face-format', 'font-face-name', 'font-face-uri',
  'glyph', 'glyphRef', 'hkern', 'image', 'line', 'missing-glyph', 'mpath',
  'path', 'polygon', 'polyline', 'rect', 'set', 'stop', 'tref', 'use', 'view',
  'vkern'
].join('|') + ')(?:[\.#][a-zA-Z0-9\u007F-\uFFFF_:-]+)*$')
function selfClosing (tag) { return closeRE.test(tag) }

},{"hyperscript-attribute-to-property":131}],133:[function(require,module,exports){
'use strict'

var trailingNewlineRegex = /\n[\s]+$/
var leadingNewlineRegex = /^\n[\s]+/
var trailingSpaceRegex = /[\s]+$/
var leadingSpaceRegex = /^[\s]+/
var multiSpaceRegex = /[\n\s]+/g

var TEXT_TAGS = [
  'a', 'abbr', 'b', 'bdi', 'bdo', 'br', 'cite', 'data', 'dfn', 'em', 'i',
  'kbd', 'mark', 'q', 'rp', 'rt', 'rtc', 'ruby', 's', 'amp', 'small', 'span',
  'strong', 'sub', 'sup', 'time', 'u', 'var', 'wbr'
]

var VERBATIM_TAGS = [
  'code', 'pre', 'textarea'
]

module.exports = function appendChild (el, childs) {
  if (!Array.isArray(childs)) return

  var nodeName = el.nodeName.toLowerCase()

  var hadText = false
  var value, leader

  for (var i = 0, len = childs.length; i < len; i++) {
    var node = childs[i]
    if (Array.isArray(node)) {
      appendChild(el, node)
      continue
    }

    if (typeof node === 'number' ||
      typeof node === 'boolean' ||
      typeof node === 'function' ||
      node instanceof Date ||
      node instanceof RegExp) {
      node = node.toString()
    }

    var lastChild = el.childNodes[el.childNodes.length - 1]

    // Iterate over text nodes
    if (typeof node === 'string') {
      hadText = true

      // If we already had text, append to the existing text
      if (lastChild && lastChild.nodeName === '#text') {
        lastChild.nodeValue += node

      // We didn't have a text node yet, create one
      } else {
        node = el.ownerDocument.createTextNode(node)
        el.appendChild(node)
        lastChild = node
      }

      // If this is the last of the child nodes, make sure we close it out
      // right
      if (i === len - 1) {
        hadText = false
        // Trim the child text nodes if the current node isn't a
        // node where whitespace matters.
        if (TEXT_TAGS.indexOf(nodeName) === -1 &&
          VERBATIM_TAGS.indexOf(nodeName) === -1) {
          value = lastChild.nodeValue
            .replace(leadingNewlineRegex, '')
            .replace(trailingSpaceRegex, '')
            .replace(trailingNewlineRegex, '')
            .replace(multiSpaceRegex, ' ')
          if (value === '') {
            el.removeChild(lastChild)
          } else {
            lastChild.nodeValue = value
          }
        } else if (VERBATIM_TAGS.indexOf(nodeName) === -1) {
          // The very first node in the list should not have leading
          // whitespace. Sibling text nodes should have whitespace if there
          // was any.
          leader = i === 0 ? '' : ' '
          value = lastChild.nodeValue
            .replace(leadingNewlineRegex, leader)
            .replace(leadingSpaceRegex, ' ')
            .replace(trailingSpaceRegex, '')
            .replace(trailingNewlineRegex, '')
            .replace(multiSpaceRegex, ' ')
          lastChild.nodeValue = value
        }
      }

    // Iterate over DOM nodes
    } else if (node && node.nodeType) {
      // If the last node was a text node, make sure it is properly closed out
      if (hadText) {
        hadText = false

        // Trim the child text nodes if the current node isn't a
        // text node or a code node
        if (TEXT_TAGS.indexOf(nodeName) === -1 &&
          VERBATIM_TAGS.indexOf(nodeName) === -1) {
          value = lastChild.nodeValue
            .replace(leadingNewlineRegex, '')
            .replace(trailingNewlineRegex, ' ')
            .replace(multiSpaceRegex, ' ')

          // Remove empty text nodes, append otherwise
          if (value === '') {
            el.removeChild(lastChild)
          } else {
            lastChild.nodeValue = value
          }
        // Trim the child nodes but preserve the appropriate whitespace
        } else if (VERBATIM_TAGS.indexOf(nodeName) === -1) {
          value = lastChild.nodeValue
            .replace(leadingSpaceRegex, ' ')
            .replace(leadingNewlineRegex, '')
            .replace(trailingNewlineRegex, ' ')
            .replace(multiSpaceRegex, ' ')
          lastChild.nodeValue = value
        }
      }

      // Store the last nodename
      var _nodeName = node.nodeName
      if (_nodeName) nodeName = _nodeName.toLowerCase()

      // Append the node to the DOM
      el.appendChild(node)
    }
  }
}

},{}],134:[function(require,module,exports){
'use strict'

module.exports = [
  'async', 'autofocus', 'autoplay', 'checked', 'controls', 'default',
  'defaultchecked', 'defer', 'disabled', 'formnovalidate', 'hidden',
  'ismap', 'loop', 'multiple', 'muted', 'novalidate', 'open', 'playsinline',
  'readonly', 'required', 'reversed', 'selected'
]

},{}],135:[function(require,module,exports){
module.exports = require('./dom')(document)

},{"./dom":137}],136:[function(require,module,exports){
'use strict'

module.exports = [
  'indeterminate'
]

},{}],137:[function(require,module,exports){
'use strict'

var hyperx = require('hyperx')
var appendChild = require('./append-child')
var SVG_TAGS = require('./svg-tags')
var BOOL_PROPS = require('./bool-props')
// Props that need to be set directly rather than with el.setAttribute()
var DIRECT_PROPS = require('./direct-props')

var SVGNS = 'http://www.w3.org/2000/svg'
var XLINKNS = 'http://www.w3.org/1999/xlink'

var COMMENT_TAG = '!--'

module.exports = function (document) {
  function nanoHtmlCreateElement (tag, props, children) {
    var el

    // If an svg tag, it needs a namespace
    if (SVG_TAGS.indexOf(tag) !== -1) {
      props.namespace = SVGNS
    }

    // If we are using a namespace
    var ns = false
    if (props.namespace) {
      ns = props.namespace
      delete props.namespace
    }

    // If we are extending a builtin element
    var isCustomElement = false
    if (props.is) {
      isCustomElement = props.is
      delete props.is
    }

    // Create the element
    if (ns) {
      if (isCustomElement) {
        el = document.createElementNS(ns, tag, { is: isCustomElement })
      } else {
        el = document.createElementNS(ns, tag)
      }
    } else if (tag === COMMENT_TAG) {
      return document.createComment(props.comment)
    } else if (isCustomElement) {
      el = document.createElement(tag, { is: isCustomElement })
    } else {
      el = document.createElement(tag)
    }

    // Create the properties
    for (var p in props) {
      if (props.hasOwnProperty(p)) {
        var key = p.toLowerCase()
        var val = props[p]
        // Normalize className
        if (key === 'classname') {
          key = 'class'
          p = 'class'
        }
        // The for attribute gets transformed to htmlFor, but we just set as for
        if (p === 'htmlFor') {
          p = 'for'
        }
        // If a property is boolean, set itself to the key
        if (BOOL_PROPS.indexOf(key) !== -1) {
          if (String(val) === 'true') val = key
          else if (String(val) === 'false') continue
        }
        // If a property prefers being set directly vs setAttribute
        if (key.slice(0, 2) === 'on' || DIRECT_PROPS.indexOf(key) !== -1) {
          el[p] = val
        } else {
          if (ns) {
            if (p === 'xlink:href') {
              el.setAttributeNS(XLINKNS, p, val)
            } else if (/^xmlns($|:)/i.test(p)) {
              // skip xmlns definitions
            } else {
              el.setAttributeNS(null, p, val)
            }
          } else {
            el.setAttribute(p, val)
          }
        }
      }
    }

    appendChild(el, children)
    return el
  }

  function createFragment (nodes) {
    var fragment = document.createDocumentFragment()
    for (var i = 0; i < nodes.length; i++) {
      if (nodes[i] == null) continue
      if (Array.isArray(nodes[i])) {
        fragment.appendChild(createFragment(nodes[i]))
      } else {
        if (typeof nodes[i] === 'string') nodes[i] = document.createTextNode(nodes[i])
        fragment.appendChild(nodes[i])
      }
    }
    return fragment
  }

  var exports = hyperx(nanoHtmlCreateElement, {
    comments: true,
    createFragment: createFragment
  })
  exports.default = exports
  exports.createComment = nanoHtmlCreateElement
  return exports
}

},{"./append-child":133,"./bool-props":134,"./direct-props":136,"./svg-tags":138,"hyperx":132}],138:[function(require,module,exports){
'use strict'

module.exports = [
  'svg', 'altGlyph', 'altGlyphDef', 'altGlyphItem', 'animate', 'animateColor',
  'animateMotion', 'animateTransform', 'circle', 'clipPath', 'color-profile',
  'cursor', 'defs', 'desc', 'ellipse', 'feBlend', 'feColorMatrix',
  'feComponentTransfer', 'feComposite', 'feConvolveMatrix',
  'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood',
  'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage',
  'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight',
  'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence', 'filter',
  'font', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src',
  'font-face-uri', 'foreignObject', 'g', 'glyph', 'glyphRef', 'hkern', 'image',
  'line', 'linearGradient', 'marker', 'mask', 'metadata', 'missing-glyph',
  'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect',
  'set', 'stop', 'switch', 'symbol', 'text', 'textPath', 'title', 'tref',
  'tspan', 'use', 'view', 'vkern'
]

},{}],139:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isMobile = isMobile;
exports.default = getBrowser;

var _globals = require("./globals");

var _isBrowser = _interopRequireDefault(require("./is-browser"));

var _isElectron = _interopRequireDefault(require("./is-electron"));

function isMobile() {
  return typeof _globals.window.orientation !== 'undefined';
}

function getBrowser(mockUserAgent) {
  if (!mockUserAgent && !(0, _isBrowser.default)()) {
    return 'Node';
  }

  if ((0, _isElectron.default)(mockUserAgent)) {
    return 'Electron';
  }

  var navigator_ = typeof navigator !== 'undefined' ? navigator : {};
  var userAgent = mockUserAgent || navigator_.userAgent || '';

  if (userAgent.indexOf('Edge') > -1) {
    return 'Edge';
  }

  var isMSIE = userAgent.indexOf('MSIE ') !== -1;
  var isTrident = userAgent.indexOf('Trident/') !== -1;

  if (isMSIE || isTrident) {
    return 'IE';
  }

  if (_globals.window.chrome) {
    return 'Chrome';
  }

  if (_globals.window.safari) {
    return 'Safari';
  }

  if (_globals.window.mozInnerScreenX) {
    return 'Firefox';
  }

  return 'Unknown';
}

},{"./globals":140,"./is-browser":141,"./is-electron":142,"@babel/runtime/helpers/interopRequireDefault":18}],140:[function(require,module,exports){
(function (process,global){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.console = exports.process = exports.document = exports.global = exports.window = exports.self = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document,
  process: (typeof process === "undefined" ? "undefined" : (0, _typeof2.default)(process)) === 'object' && process
};
var self_ = globals.self || globals.window || globals.global;
exports.self = self_;
var window_ = globals.window || globals.self || globals.global;
exports.window = window_;
var global_ = globals.global || globals.self || globals.window;
exports.global = global_;
var document_ = globals.document || {};
exports.document = document_;
var process_ = globals.process || {};
exports.process = process_;
var console_ = console;
exports.console = console_;

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"_process":153}],141:[function(require,module,exports){
(function (process){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isBrowser;
exports.isBrowserMainThread = isBrowserMainThread;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _isElectron = _interopRequireDefault(require("./is-electron"));

function isBrowser() {
  var isNode = (typeof process === "undefined" ? "undefined" : (0, _typeof2.default)(process)) === 'object' && String(process) === '[object process]' && !process.browser;
  return !isNode || (0, _isElectron.default)();
}

function isBrowserMainThread() {
  return isBrowser() && typeof document !== 'undefined';
}

}).call(this)}).call(this,require('_process'))

},{"./is-electron":142,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"_process":153}],142:[function(require,module,exports){
(function (process){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isElectron;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

function isElectron(mockUserAgent) {
  if (typeof window !== 'undefined' && (0, _typeof2.default)(window.process) === 'object' && window.process.type === 'renderer') {
    return true;
  }

  if (typeof process !== 'undefined' && (0, _typeof2.default)(process.versions) === 'object' && Boolean(process.versions.electron)) {
    return true;
  }

  var realUserAgent = (typeof navigator === "undefined" ? "undefined" : (0, _typeof2.default)(navigator)) === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent;
  var userAgent = mockUserAgent || realUserAgent;

  if (userAgent && userAgent.indexOf('Electron') >= 0) {
    return true;
  }

  return false;
}

}).call(this)}).call(this,require('_process'))

},{"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"_process":153}],143:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Log", {
  enumerable: true,
  get: function get() {
    return _log.default;
  }
});
Object.defineProperty(exports, "VERSION", {
  enumerable: true,
  get: function get() {
    return _globals.VERSION;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function get() {
    return _globals2.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function get() {
    return _globals2.window;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function get() {
    return _globals2.global;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function get() {
    return _globals2.document;
  }
});
Object.defineProperty(exports, "process", {
  enumerable: true,
  get: function get() {
    return _globals2.process;
  }
});
Object.defineProperty(exports, "console", {
  enumerable: true,
  get: function get() {
    return _globals2.console;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function get() {
    return _isBrowser.default;
  }
});
Object.defineProperty(exports, "isBrowserMainThread", {
  enumerable: true,
  get: function get() {
    return _isBrowser.isBrowserMainThread;
  }
});
Object.defineProperty(exports, "getBrowser", {
  enumerable: true,
  get: function get() {
    return _getBrowser.default;
  }
});
Object.defineProperty(exports, "isMobile", {
  enumerable: true,
  get: function get() {
    return _getBrowser.isMobile;
  }
});
Object.defineProperty(exports, "isElectron", {
  enumerable: true,
  get: function get() {
    return _isElectron.default;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function get() {
    return _assert.default;
  }
});
Object.defineProperty(exports, "COLOR", {
  enumerable: true,
  get: function get() {
    return _color.COLOR;
  }
});
Object.defineProperty(exports, "addColor", {
  enumerable: true,
  get: function get() {
    return _color.addColor;
  }
});
Object.defineProperty(exports, "leftPad", {
  enumerable: true,
  get: function get() {
    return _formatters.leftPad;
  }
});
Object.defineProperty(exports, "rightPad", {
  enumerable: true,
  get: function get() {
    return _formatters.rightPad;
  }
});
Object.defineProperty(exports, "autobind", {
  enumerable: true,
  get: function get() {
    return _autobind.autobind;
  }
});
Object.defineProperty(exports, "LocalStorage", {
  enumerable: true,
  get: function get() {
    return _localStorage.default;
  }
});
Object.defineProperty(exports, "getHiResTimestamp", {
  enumerable: true,
  get: function get() {
    return _hiResTimestamp.default;
  }
});
Object.defineProperty(exports, "Stats", {
  enumerable: true,
  get: function get() {
    return _stats.Stats;
  }
});
Object.defineProperty(exports, "Stat", {
  enumerable: true,
  get: function get() {
    return _stats.Stat;
  }
});
exports.default = void 0;

require("./init");

var _log = _interopRequireDefault(require("./lib/log"));

var _globals = require("./utils/globals");

var _globals2 = require("./env/globals");

var _isBrowser = _interopRequireWildcard(require("./env/is-browser"));

var _getBrowser = _interopRequireWildcard(require("./env/get-browser"));

var _isElectron = _interopRequireDefault(require("./env/is-electron"));

var _assert = _interopRequireDefault(require("./utils/assert"));

var _color = require("./utils/color");

var _formatters = require("./utils/formatters");

var _autobind = require("./utils/autobind");

var _localStorage = _interopRequireDefault(require("./utils/local-storage"));

var _hiResTimestamp = _interopRequireDefault(require("./utils/hi-res-timestamp"));

var _stats = require("@probe.gl/stats");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var _default = new _log.default({
  id: 'probe.gl'
});

exports.default = _default;

},{"./env/get-browser":139,"./env/globals":140,"./env/is-browser":141,"./env/is-electron":142,"./init":144,"./lib/log":145,"./utils/assert":146,"./utils/autobind":147,"./utils/color":148,"./utils/formatters":149,"./utils/globals":150,"./utils/hi-res-timestamp":151,"./utils/local-storage":152,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"@probe.gl/stats":126}],144:[function(require,module,exports){
"use strict";

var _globals = require("./utils/globals");

_globals.global.probe = {};

},{"./utils/globals":150}],145:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalizeArguments = normalizeArguments;
exports.default = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _globals = require("../utils/globals");

var _localStorage = _interopRequireDefault(require("../utils/local-storage"));

var _formatters = require("../utils/formatters");

var _color = require("../utils/color");

var _autobind = require("../utils/autobind");

var _assert2 = _interopRequireDefault(require("../utils/assert"));

var _hiResTimestamp = _interopRequireDefault(require("../utils/hi-res-timestamp"));

var originalConsole = {
  debug: _globals.isBrowser ? console.debug || console.log : console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
};
var DEFAULT_SETTINGS = {
  enabled: true,
  level: 0
};

function noop() {}

var cache = {};
var ONCE = {
  once: true
};

function getTableHeader(table) {
  for (var key in table) {
    for (var title in table[key]) {
      return title || 'untitled';
    }
  }

  return 'empty';
}

var Log = function () {
  function Log() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      id: ''
    },
        id = _ref.id;

    (0, _classCallCheck2.default)(this, Log);
    this.id = id;
    this.VERSION = _globals.VERSION;
    this._startTs = (0, _hiResTimestamp.default)();
    this._deltaTs = (0, _hiResTimestamp.default)();
    this.LOG_THROTTLE_TIMEOUT = 0;
    this._storage = new _localStorage.default("__probe-".concat(this.id, "__"), DEFAULT_SETTINGS);
    this.userData = {};
    this.timeStamp("".concat(this.id, " started"));
    (0, _autobind.autobind)(this);
    Object.seal(this);
  }

  (0, _createClass2.default)(Log, [{
    key: "level",
    get: function get() {
      return this.getLevel();
    },
    set: function set(newLevel) {
      this.setLevel(newLevel);
    }
  }, {
    key: "isEnabled",
    value: function isEnabled() {
      return this._storage.config.enabled;
    }
  }, {
    key: "getLevel",
    value: function getLevel() {
      return this._storage.config.level;
    }
  }, {
    key: "getTotal",
    value: function getTotal() {
      return Number(((0, _hiResTimestamp.default)() - this._startTs).toPrecision(10));
    }
  }, {
    key: "getDelta",
    value: function getDelta() {
      return Number(((0, _hiResTimestamp.default)() - this._deltaTs).toPrecision(10));
    }
  }, {
    key: "priority",
    get: function get() {
      return this.level;
    },
    set: function set(newPriority) {
      this.level = newPriority;
    }
  }, {
    key: "getPriority",
    value: function getPriority() {
      return this.level;
    }
  }, {
    key: "enable",
    value: function enable() {
      var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this._storage.updateConfiguration({
        enabled: enabled
      });

      return this;
    }
  }, {
    key: "setLevel",
    value: function setLevel(level) {
      this._storage.updateConfiguration({
        level: level
      });

      return this;
    }
  }, {
    key: "assert",
    value: function assert(condition, message) {
      (0, _assert2.default)(condition, message);
    }
  }, {
    key: "warn",
    value: function warn(message) {
      return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);
    }
  }, {
    key: "error",
    value: function error(message) {
      return this._getLogFunction(0, message, originalConsole.error, arguments);
    }
  }, {
    key: "deprecated",
    value: function deprecated(oldUsage, newUsage) {
      return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
    }
  }, {
    key: "removed",
    value: function removed(oldUsage, newUsage) {
      return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
    }
  }, {
    key: "probe",
    value: function probe(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {
        time: true,
        once: true
      });
    }
  }, {
    key: "log",
    value: function log(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);
    }
  }, {
    key: "info",
    value: function info(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.info, arguments);
    }
  }, {
    key: "once",
    value: function once(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole.debug || originalConsole.info, arguments, ONCE);
    }
  }, {
    key: "table",
    value: function table(logLevel, _table, columns) {
      if (_table) {
        return this._getLogFunction(logLevel, _table, console.table || noop, columns && [columns], {
          tag: getTableHeader(_table)
        });
      }

      return noop;
    }
  }, {
    key: "image",
    value: function image(_ref2) {
      var logLevel = _ref2.logLevel,
          priority = _ref2.priority,
          _image = _ref2.image,
          _ref2$message = _ref2.message,
          message = _ref2$message === void 0 ? '' : _ref2$message,
          _ref2$scale = _ref2.scale,
          scale = _ref2$scale === void 0 ? 1 : _ref2$scale;

      if (!this._shouldLog(logLevel || priority)) {
        return noop;
      }

      return _globals.isBrowser ? logImageInBrowser({
        image: _image,
        message: message,
        scale: scale
      }) : logImageInNode({
        image: _image,
        message: message,
        scale: scale
      });
    }
  }, {
    key: "settings",
    value: function settings() {
      if (console.table) {
        console.table(this._storage.config);
      } else {
        console.log(this._storage.config);
      }
    }
  }, {
    key: "get",
    value: function get(setting) {
      return this._storage.config[setting];
    }
  }, {
    key: "set",
    value: function set(setting, value) {
      this._storage.updateConfiguration((0, _defineProperty2.default)({}, setting, value));
    }
  }, {
    key: "time",
    value: function time(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
    }
  }, {
    key: "timeEnd",
    value: function timeEnd(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
    }
  }, {
    key: "timeStamp",
    value: function timeStamp(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.timeStamp || noop);
    }
  }, {
    key: "group",
    value: function group(logLevel, message) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
        collapsed: false
      };
      opts = normalizeArguments({
        logLevel: logLevel,
        message: message,
        opts: opts
      });
      var _opts = opts,
          collapsed = _opts.collapsed;
      opts.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
      return this._getLogFunction(opts);
    }
  }, {
    key: "groupCollapsed",
    value: function groupCollapsed(logLevel, message) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return this.group(logLevel, message, Object.assign({}, opts, {
        collapsed: true
      }));
    }
  }, {
    key: "groupEnd",
    value: function groupEnd(logLevel) {
      return this._getLogFunction(logLevel, '', console.groupEnd || noop);
    }
  }, {
    key: "withGroup",
    value: function withGroup(logLevel, message, func) {
      this.group(logLevel, message)();

      try {
        func();
      } finally {
        this.groupEnd(logLevel)();
      }
    }
  }, {
    key: "trace",
    value: function trace() {
      if (console.trace) {
        console.trace();
      }
    }
  }, {
    key: "_shouldLog",
    value: function _shouldLog(logLevel) {
      return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
    }
  }, {
    key: "_getLogFunction",
    value: function _getLogFunction(logLevel, message, method) {
      var args = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
      var opts = arguments.length > 4 ? arguments[4] : undefined;

      if (this._shouldLog(logLevel)) {
        var _method;

        opts = normalizeArguments({
          logLevel: logLevel,
          message: message,
          args: args,
          opts: opts
        });
        method = method || opts.method;
        (0, _assert2.default)(method);
        opts.total = this.getTotal();
        opts.delta = this.getDelta();
        this._deltaTs = (0, _hiResTimestamp.default)();
        var tag = opts.tag || opts.message;

        if (opts.once) {
          if (!cache[tag]) {
            cache[tag] = (0, _hiResTimestamp.default)();
          } else {
            return noop;
          }
        }

        message = decorateMessage(this.id, opts.message, opts);
        return (_method = method).bind.apply(_method, [console, message].concat((0, _toConsumableArray2.default)(opts.args)));
      }

      return noop;
    }
  }]);
  return Log;
}();

exports.default = Log;
Log.VERSION = _globals.VERSION;

function normalizeLogLevel(logLevel) {
  if (!logLevel) {
    return 0;
  }

  var resolvedLevel;

  switch ((0, _typeof2.default)(logLevel)) {
    case 'number':
      resolvedLevel = logLevel;
      break;

    case 'object':
      resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
      break;

    default:
      return 0;
  }

  (0, _assert2.default)(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
  return resolvedLevel;
}

function normalizeArguments(opts) {
  var logLevel = opts.logLevel,
      message = opts.message;
  opts.logLevel = normalizeLogLevel(logLevel);
  var args = opts.args ? Array.from(opts.args) : [];

  while (args.length && args.shift() !== message) {}

  opts.args = args;

  switch ((0, _typeof2.default)(logLevel)) {
    case 'string':
    case 'function':
      if (message !== undefined) {
        args.unshift(message);
      }

      opts.message = logLevel;
      break;

    case 'object':
      Object.assign(opts, logLevel);
      break;

    default:
  }

  if (typeof opts.message === 'function') {
    opts.message = opts.message();
  }

  var messageType = (0, _typeof2.default)(opts.message);
  (0, _assert2.default)(messageType === 'string' || messageType === 'object');
  return Object.assign(opts, opts.opts);
}

function decorateMessage(id, message, opts) {
  if (typeof message === 'string') {
    var time = opts.time ? (0, _formatters.leftPad)((0, _formatters.formatTime)(opts.total)) : '';
    message = opts.time ? "".concat(id, ": ").concat(time, "  ").concat(message) : "".concat(id, ": ").concat(message);
    message = (0, _color.addColor)(message, opts.color, opts.background);
  }

  return message;
}

function logImageInNode(_ref3) {
  var image = _ref3.image,
      _ref3$message = _ref3.message,
      message = _ref3$message === void 0 ? '' : _ref3$message,
      _ref3$scale = _ref3.scale,
      scale = _ref3$scale === void 0 ? 1 : _ref3$scale;
  var asciify = null;

  try {
    asciify = module.require('asciify-image');
  } catch (error) {}

  if (asciify) {
    return function () {
      return asciify(image, {
        fit: 'box',
        width: "".concat(Math.round(80 * scale), "%")
      }).then(function (data) {
        return console.log(data);
      });
    };
  }

  return noop;
}

function logImageInBrowser(_ref4) {
  var image = _ref4.image,
      _ref4$message = _ref4.message,
      message = _ref4$message === void 0 ? '' : _ref4$message,
      _ref4$scale = _ref4.scale,
      scale = _ref4$scale === void 0 ? 1 : _ref4$scale;

  if (typeof image === 'string') {
    var img = new Image();

    img.onload = function () {
      var _console;

      var args = (0, _formatters.formatImage)(img, message, scale);

      (_console = console).log.apply(_console, (0, _toConsumableArray2.default)(args));
    };

    img.src = image;
    return noop;
  }

  var element = image.nodeName || '';

  if (element.toLowerCase() === 'img') {
    var _console2;

    (_console2 = console).log.apply(_console2, (0, _toConsumableArray2.default)((0, _formatters.formatImage)(image, message, scale)));

    return noop;
  }

  if (element.toLowerCase() === 'canvas') {
    var _img = new Image();

    _img.onload = function () {
      var _console3;

      return (_console3 = console).log.apply(_console3, (0, _toConsumableArray2.default)((0, _formatters.formatImage)(_img, message, scale)));
    };

    _img.src = image.toDataURL();
    return noop;
  }

  return noop;
}

},{"../utils/assert":146,"../utils/autobind":147,"../utils/color":148,"../utils/formatters":149,"../utils/globals":150,"../utils/hi-res-timestamp":151,"../utils/local-storage":152,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/toConsumableArray":28,"@babel/runtime/helpers/typeof":29}],146:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'Assertion failed');
  }
}

},{}],147:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.autobind = autobind;

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function autobind(obj) {
  var predefined = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['constructor'];
  var proto = Object.getPrototypeOf(obj);
  var propNames = Object.getOwnPropertyNames(proto);

  var _iterator = _createForOfIteratorHelper(propNames),
      _step;

  try {
    var _loop = function _loop() {
      var key = _step.value;

      if (typeof obj[key] === 'function') {
        if (!predefined.find(function (name) {
          return key === name;
        })) {
          obj[key] = obj[key].bind(obj);
        }
      }
    };

    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      _loop();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}

},{}],148:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addColor = addColor;
exports.COLOR = void 0;

var _globals = require("./globals");

var COLOR = {
  BLACK: 30,
  RED: 31,
  GREEN: 32,
  YELLOW: 33,
  BLUE: 34,
  MAGENTA: 35,
  CYAN: 36,
  WHITE: 37,
  BRIGHT_BLACK: 90,
  BRIGHT_RED: 91,
  BRIGHT_GREEN: 92,
  BRIGHT_YELLOW: 93,
  BRIGHT_BLUE: 94,
  BRIGHT_MAGENTA: 95,
  BRIGHT_CYAN: 96,
  BRIGHT_WHITE: 97
};
exports.COLOR = COLOR;

function getColor(color) {
  return typeof color === 'string' ? COLOR[color.toUpperCase()] || COLOR.WHITE : color;
}

function addColor(string, color, background) {
  if (!_globals.isBrowser && typeof string === 'string') {
    if (color) {
      color = getColor(color);
      string = "\x1B[".concat(color, "m").concat(string, "\x1B[39m");
    }

    if (background) {
      color = getColor(background);
      string = "\x1B[".concat(background + 10, "m").concat(string, "\x1B[49m");
    }
  }

  return string;
}

},{"./globals":150}],149:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatTime = formatTime;
exports.leftPad = leftPad;
exports.rightPad = rightPad;
exports.formatValue = formatValue;
exports.formatImage = formatImage;

function formatTime(ms) {
  var formatted;

  if (ms < 10) {
    formatted = "".concat(ms.toFixed(2), "ms");
  } else if (ms < 100) {
    formatted = "".concat(ms.toFixed(1), "ms");
  } else if (ms < 1000) {
    formatted = "".concat(ms.toFixed(0), "ms");
  } else {
    formatted = "".concat((ms / 1000).toFixed(2), "s");
  }

  return formatted;
}

function leftPad(string) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  var padLength = Math.max(length - string.length, 0);
  return "".concat(' '.repeat(padLength)).concat(string);
}

function rightPad(string) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  var padLength = Math.max(length - string.length, 0);
  return "".concat(string).concat(' '.repeat(padLength));
}

function formatValue(v) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var EPSILON = 1e-16;
  var _opts$isInteger = opts.isInteger,
      isInteger = _opts$isInteger === void 0 ? false : _opts$isInteger;

  if (Array.isArray(v) || ArrayBuffer.isView(v)) {
    return formatArrayValue(v, opts);
  }

  if (!Number.isFinite(v)) {
    return String(v);
  }

  if (Math.abs(v) < EPSILON) {
    return isInteger ? '0' : '0.';
  }

  if (isInteger) {
    return v.toFixed(0);
  }

  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {
    return v.toFixed(0);
  }

  var string = v.toPrecision(2);
  var decimal = string.indexOf('.0');
  return decimal === string.length - 2 ? string.slice(0, -1) : string;
}

function formatArrayValue(v, opts) {
  var _opts$maxElts = opts.maxElts,
      maxElts = _opts$maxElts === void 0 ? 16 : _opts$maxElts,
      _opts$size = opts.size,
      size = _opts$size === void 0 ? 1 : _opts$size;
  var string = '[';

  for (var i = 0; i < v.length && i < maxElts; ++i) {
    if (i > 0) {
      string += ",".concat(i % size === 0 ? ' ' : '');
    }

    string += formatValue(v[i], opts);
  }

  var terminator = v.length > maxElts ? '...' : ']';
  return "".concat(string).concat(terminator);
}

function formatImage(image, message, scale) {
  var maxWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 600;
  var imageUrl = image.src.replace(/\(/g, '%28').replace(/\)/g, '%29');

  if (image.width > maxWidth) {
    scale = Math.min(scale, maxWidth / image.width);
  }

  var width = image.width * scale;
  var height = image.height * scale;
  var style = ['font-size:1px;', "padding:".concat(Math.floor(height / 2), "px ").concat(Math.floor(width / 2), "px;"), "line-height:".concat(height, "px;"), "background:url(".concat(imageUrl, ");"), "background-size:".concat(width, "px ").concat(height, "px;"), 'color:transparent;'].join('');
  return ["".concat(message, " %c+"), style];
}

},{}],150:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function get() {
    return _globals.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function get() {
    return _globals.window;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function get() {
    return _globals.global;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function get() {
    return _globals.document;
  }
});
Object.defineProperty(exports, "process", {
  enumerable: true,
  get: function get() {
    return _globals.process;
  }
});
Object.defineProperty(exports, "console", {
  enumerable: true,
  get: function get() {
    return _globals.console;
  }
});
exports.isBrowser = exports.VERSION = void 0;

var _isBrowser = _interopRequireDefault(require("../env/is-browser"));

var _globals = require("../env/globals");

var VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'untranspiled source';
exports.VERSION = VERSION;
var isBrowser = (0, _isBrowser.default)();
exports.isBrowser = isBrowser;

},{"../env/globals":140,"../env/is-browser":141,"@babel/runtime/helpers/interopRequireDefault":18}],151:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getHiResTimestamp;

var _globals = require("./globals");

function getHiResTimestamp() {
  var timestamp;

  if (_globals.isBrowser && _globals.window.performance) {
    timestamp = _globals.window.performance.now();
  } else if (_globals.process.hrtime) {
    var timeParts = _globals.process.hrtime();

    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }

  return timestamp;
}

},{"./globals":150}],152:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function getStorage(type) {
  try {
    var storage = window[type];
    var x = '__storage_test__';
    storage.setItem(x, x);
    storage.removeItem(x);
    return storage;
  } catch (e) {
    return null;
  }
}

var LocalStorage = function () {
  function LocalStorage(id, defaultSettings) {
    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'sessionStorage';
    (0, _classCallCheck2.default)(this, LocalStorage);
    this.storage = getStorage(type);
    this.id = id;
    this.config = {};
    Object.assign(this.config, defaultSettings);

    this._loadConfiguration();
  }

  (0, _createClass2.default)(LocalStorage, [{
    key: "getConfiguration",
    value: function getConfiguration() {
      return this.config;
    }
  }, {
    key: "setConfiguration",
    value: function setConfiguration(configuration) {
      this.config = {};
      return this.updateConfiguration(configuration);
    }
  }, {
    key: "updateConfiguration",
    value: function updateConfiguration(configuration) {
      Object.assign(this.config, configuration);

      if (this.storage) {
        var serialized = JSON.stringify(this.config);
        this.storage.setItem(this.id, serialized);
      }

      return this;
    }
  }, {
    key: "_loadConfiguration",
    value: function _loadConfiguration() {
      var configuration = {};

      if (this.storage) {
        var serializedConfiguration = this.storage.getItem(this.id);
        configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
      }

      Object.assign(this.config, configuration);
      return this;
    }
  }]);
  return LocalStorage;
}();

exports.default = LocalStorage;

},{"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/interopRequireDefault":18}],153:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],154:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  define(Gp, "constructor", GeneratorFunctionPrototype);
  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  define(Gp, iteratorSymbol, function() {
    return this;
  });

  define(Gp, "toString", function() {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  typeof module === "object" ? module.exports : {}
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJleGFtcGxlLWRhdGEtbG9hZGluZy9zY3JpcHQuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9Bc3luY0dlbmVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL0F3YWl0VmFsdWUuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRoSG9sZXMuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jR2VuZXJhdG9yRGVsZWdhdGUuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY0l0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2F3YWl0QXN5bmNHZW5lcmF0b3IuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NvbnN0cnVjdC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXNOYXRpdmVGdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVSZXN0LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVTcHJlYWQuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2V0UHJvdG90eXBlT2YuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3dyYXBBc3luY0dlbmVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3dyYXBOYXRpdmVTdXBlci5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvaXRlcmF0b3JzL21ha2UtaXRlcmF0b3IvbWFrZS1hcnJheS1idWZmZXItaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9pdGVyYXRvcnMvbWFrZS1pdGVyYXRvci9tYWtlLWJsb2ItaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9pdGVyYXRvcnMvbWFrZS1pdGVyYXRvci9tYWtlLWl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvaXRlcmF0b3JzL21ha2UtaXRlcmF0b3IvbWFrZS1zdHJlYW0taXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9pdGVyYXRvcnMvbWFrZS1pdGVyYXRvci9tYWtlLXN0cmluZy1pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2l0ZXJhdG9ycy9tYWtlLXN0cmVhbS9tYWtlLWRvbS1zdHJlYW0uanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9pdGVyYXRvcnMvbWFrZS1zdHJlYW0vbWFrZS1zdHJlYW0uanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9qYXZhc2NyaXB0LXV0aWxzL2lzLXR5cGUuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9saWIvYXBpL2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2xpYi9hcGkvbG9hZC1pbi1iYXRjaGVzLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvbGliL2FwaS9sb2FkLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvbGliL2FwaS9wYXJzZS1pbi1iYXRjaGVzLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvbGliL2FwaS9wYXJzZS1zeW5jLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvbGliL2FwaS9wYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2xpYi9hcGkvcmVnaXN0ZXItbG9hZGVycy5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2xpYi9hcGkvc2F2ZS5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2xpYi9hcGkvc2VsZWN0LWxvYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2xpYi9hcGkvc2V0LWxvYWRlci1vcHRpb25zLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvbGliL2ZldGNoL2ZldGNoLWZpbGUuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9saWIvZmV0Y2gvcmVhZC1hcnJheS1idWZmZXIuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9saWIvZmV0Y2gvcmVhZC1maWxlLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvbGliL2ZldGNoL3dyaXRlLWZpbGUuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9saWIvZmlsZXN5c3RlbXMvYnJvd3Nlci1maWxlc3lzdGVtLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvbGliL2xvYWRlci11dGlscy9nZXQtZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2xpYi9sb2FkZXItdXRpbHMvbG9hZGVyLWNvbnRleHQuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9saWIvbG9hZGVyLXV0aWxzL2xvZ2dlcnMuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9saWIvbG9hZGVyLXV0aWxzL25vcm1hbGl6ZS1sb2FkZXIuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9saWIvbG9hZGVyLXV0aWxzL29wdGlvbi1kZWZhdWx0cy5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2xpYi9sb2FkZXItdXRpbHMvb3B0aW9uLXV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvbGliL3Byb2dyZXNzL2ZldGNoLXByb2dyZXNzLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvbGliL3V0aWxzL21pbWUtdHlwZS11dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2xpYi91dGlscy9yZXNvdXJjZS11dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2xpYi91dGlscy9yZXNwb25zZS11dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L251bGwtbG9hZGVyLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2Nzdi9kaXN0L2VzNS9jc3YtbG9hZGVyLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2Nzdi9kaXN0L2VzNS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jc3YvZGlzdC9lczUvbGliL2FzeW5jLWl0ZXJhdG9yLXN0cmVhbWVyLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2Nzdi9kaXN0L2VzNS9saWJzL3BhcGFwYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9lczUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzL2Rpc3QvZXM1L2pzb24tbG9hZGVyLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscy9kaXN0L2VzNS9saWIvYmluYXJ5LXV0aWxzL2FycmF5LWJ1ZmZlci11dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9lczUvbGliL2JpbmFyeS11dGlscy9iaW5hcnktY29weS11dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9lczUvbGliL2JpbmFyeS11dGlscy9idWZmZXItdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzL2Rpc3QvZXM1L2xpYi9iaW5hcnktdXRpbHMvZW5jb2RlLXV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscy9kaXN0L2VzNS9saWIvYmluYXJ5LXV0aWxzL2dldC1maXJzdC1jaGFyYWN0ZXJzLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscy9kaXN0L2VzNS9saWIvYmluYXJ5LXV0aWxzL21lbW9yeS1jb3B5LXV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscy9kaXN0L2VzNS9saWIvZW52LXV0aWxzL2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9lczUvbGliL2Vudi11dGlscy9nbG9iYWxzLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscy9kaXN0L2VzNS9saWIvaXRlcmF0b3JzL2FzeW5jLWl0ZXJhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9lczUvbGliL2l0ZXJhdG9ycy90ZXh0LWl0ZXJhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9lczUvbGliL3BhcnNlci11dGlscy9wYXJzZS1qc29uLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscy9kaXN0L2VzNS9saWIvcGF0aC11dGlscy9maWxlLWFsaWFzZXMuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzL2Rpc3QvZXM1L2xpYi9wYXRoLXV0aWxzL3BhdGguanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzL2Rpc3QvZXM1L2xpYi9yZXF1ZXN0LXV0aWxzL3JlcXVlc3Qtc2NoZWR1bGVyLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscy9kaXN0L2VzNS9saWIvd29ya2VyLWxvYWRlci11dGlscy9jcmVhdGUtbG9hZGVyLXdvcmtlci5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9lczUvbGliL3dvcmtlci1sb2FkZXItdXRpbHMvcGFyc2Utd2l0aC13b3JrZXIuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvc2NoZW1hL2Rpc3QvZXM1L2NhdGVnb3J5L21lc2gvbWVzaC11dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9zY2hlbWEvZGlzdC9lczUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvc2NoZW1hL2Rpc3QvZXM1L2xpYi9zY2hlbWEtdXRpbHMvZGVkdWNlLXRhYmxlLXNjaGVtYS5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9zY2hlbWEvZGlzdC9lczUvbGliL3NjaGVtYS11dGlscy9nZXQtdHlwZS1pbmZvLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3NjaGVtYS9kaXN0L2VzNS9saWIvc2NoZW1hLXV0aWxzL3R5cGUtdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvc2NoZW1hL2Rpc3QvZXM1L2xpYi9zY2hlbWEvaW1wbC9lbnVtLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3NjaGVtYS9kaXN0L2VzNS9saWIvc2NoZW1hL2ltcGwvZmllbGQuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvc2NoZW1hL2Rpc3QvZXM1L2xpYi9zY2hlbWEvaW1wbC9zY2hlbWEuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvc2NoZW1hL2Rpc3QvZXM1L2xpYi9zY2hlbWEvaW1wbC90eXBlLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3NjaGVtYS9kaXN0L2VzNS9saWIvc2NoZW1hL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3NjaGVtYS9kaXN0L2VzNS9saWIvdGFibGUvYmFzZS10YWJsZS1iYXRjaC1hZ2dyZWdhdG9yLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3NjaGVtYS9kaXN0L2VzNS9saWIvdGFibGUvY29sdW1uYXItdGFibGUtYmF0Y2gtYWdncmVnYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9zY2hlbWEvZGlzdC9lczUvbGliL3RhYmxlL3Jvdy10YWJsZS1iYXRjaC1hZ2dyZWdhdG9yLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3NjaGVtYS9kaXN0L2VzNS9saWIvdGFibGUvdGFibGUtYmF0Y2gtYnVpbGRlci5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9zY2hlbWEvZGlzdC9lczUvbGliL3V0aWxzL2FzeW5jLXF1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3NjaGVtYS9kaXN0L2VzNS9saWIvdXRpbHMvcm93LXV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2VzNS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9lczUvbGliL2FzeW5jLXF1ZXVlL2FzeW5jLXF1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2VzNS9saWIvZW52LXV0aWxzL2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9lczUvbGliL2Vudi11dGlscy9nbG9iYWxzLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2VzNS9saWIvZW52LXV0aWxzL3ZlcnNpb24uanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvd29ya2VyLXV0aWxzL2Rpc3QvZXM1L2xpYi9saWJyYXJ5LXV0aWxzL2xpYnJhcnktdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvd29ya2VyLXV0aWxzL2Rpc3QvZXM1L2xpYi93b3JrZXItYXBpL2NyZWF0ZS13b3JrZXIuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvd29ya2VyLXV0aWxzL2Rpc3QvZXM1L2xpYi93b3JrZXItYXBpL2dldC13b3JrZXItdXJsLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2VzNS9saWIvd29ya2VyLWFwaS9wcm9jZXNzLW9uLXdvcmtlci5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9lczUvbGliL3dvcmtlci1hcGkvdmFsaWRhdGUtd29ya2VyLXZlcnNpb24uanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvd29ya2VyLXV0aWxzL2Rpc3QvZXM1L2xpYi93b3JrZXItZmFybS93b3JrZXItYm9keS5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9lczUvbGliL3dvcmtlci1mYXJtL3dvcmtlci1mYXJtLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2VzNS9saWIvd29ya2VyLWZhcm0vd29ya2VyLWpvYi5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9lczUvbGliL3dvcmtlci1mYXJtL3dvcmtlci1wb29sLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2VzNS9saWIvd29ya2VyLWZhcm0vd29ya2VyLXRocmVhZC5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9lczUvbGliL3dvcmtlci11dGlscy9nZXQtbG9hZGFibGUtd29ya2VyLXVybC5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9lczUvbGliL3dvcmtlci11dGlscy9nZXQtdHJhbnNmZXItbGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9lczUvbGliL3dvcmtlci11dGlscy9yZW1vdmUtbm9udHJhbnNmZXJhYmxlLW9wdGlvbnMuanMiLCJub2RlX21vZHVsZXMvQHByb2JlLmdsL3N0YXRzL2Rpc3QvZXM1L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0Bwcm9iZS5nbC9zdGF0cy9kaXN0L2VzNS9saWIvc3RhdC5qcyIsIm5vZGVfbW9kdWxlcy9AcHJvYmUuZ2wvc3RhdHMvZGlzdC9lczUvbGliL3N0YXRzLmpzIiwibm9kZV9tb2R1bGVzL0Bwcm9iZS5nbC9zdGF0cy9kaXN0L2VzNS91dGlscy9oaS1yZXMtdGltZXN0YW1wLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9oeXBlcnNjcmlwdC1hdHRyaWJ1dGUtdG8tcHJvcGVydHkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaHlwZXJ4L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL25hbm9odG1sL2xpYi9hcHBlbmQtY2hpbGQuanMiLCJub2RlX21vZHVsZXMvbmFub2h0bWwvbGliL2Jvb2wtcHJvcHMuanMiLCJub2RlX21vZHVsZXMvbmFub2h0bWwvbGliL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvbmFub2h0bWwvbGliL2RpcmVjdC1wcm9wcy5qcyIsIm5vZGVfbW9kdWxlcy9uYW5vaHRtbC9saWIvZG9tLmpzIiwibm9kZV9tb2R1bGVzL25hbm9odG1sL2xpYi9zdmctdGFncy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9iZS5nbC9kaXN0L2VzNS9lbnYvZ2V0LWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHJvYmUuZ2wvZGlzdC9lczUvZW52L2dsb2JhbHMuanMiLCJub2RlX21vZHVsZXMvcHJvYmUuZ2wvZGlzdC9lczUvZW52L2lzLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHJvYmUuZ2wvZGlzdC9lczUvZW52L2lzLWVsZWN0cm9uLmpzIiwibm9kZV9tb2R1bGVzL3Byb2JlLmdsL2Rpc3QvZXM1L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb2JlLmdsL2Rpc3QvZXM1L2luaXQuanMiLCJub2RlX21vZHVsZXMvcHJvYmUuZ2wvZGlzdC9lczUvbGliL2xvZy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9iZS5nbC9kaXN0L2VzNS91dGlscy9hc3NlcnQuanMiLCJub2RlX21vZHVsZXMvcHJvYmUuZ2wvZGlzdC9lczUvdXRpbHMvYXV0b2JpbmQuanMiLCJub2RlX21vZHVsZXMvcHJvYmUuZ2wvZGlzdC9lczUvdXRpbHMvY29sb3IuanMiLCJub2RlX21vZHVsZXMvcHJvYmUuZ2wvZGlzdC9lczUvdXRpbHMvZm9ybWF0dGVycy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9iZS5nbC9kaXN0L2VzNS91dGlscy9nbG9iYWxzLmpzIiwibm9kZV9tb2R1bGVzL3Byb2JlLmdsL2Rpc3QvZXM1L3V0aWxzL2hpLXJlcy10aW1lc3RhbXAuanMiLCJub2RlX21vZHVsZXMvcHJvYmUuZ2wvZGlzdC9lczUvdXRpbHMvbG9jYWwtc3RvcmFnZS5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUNnQkE7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7OztBQWxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBMkIsSUFBM0I7QUFBQSxJQUFPLE1BQVAsU0FBTyxNQUFQO0FBQUEsSUFBZSxRQUFmLFNBQWUsUUFBZixDLENBQ0E7O0FBS0EsSUFBSSxHQUFKO0FBQ0EsSUFBSSxTQUFKO0FBQ0EsSUFBSSxPQUFPLEdBQUcsVUFBZDtBQUVBLElBQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyxRQUFQLENBQWdCLElBQWhCLENBQXFCLE9BQXJCLENBQTZCLHdCQUE3QixFQUF1RCxFQUF2RCxDQUFoQjtBQUVBLElBQU0sV0FBVywyQkFBakI7QUFFQSxJQUFNLFdBQVcsMkJBQWpCLEMsQ0FFQTs7QUFDQSxJQUFNLFFBQVEsR0FBRyxDQUFDO0FBQ2hCLEVBQUEsS0FBSyxFQUFFLFdBRFM7QUFDSTtBQUNwQixFQUFBLEVBQUUsRUFBRSxXQUZZO0FBRUE7QUFDaEIsRUFBQSxHQUFHLEVBQUUsV0FIVztBQUloQixFQUFBLFVBQVUsRUFBRTtBQUpJLENBQUQsRUFLZDtBQUNELEVBQUEsS0FBSyxFQUFFLFFBRE47QUFFRCxFQUFBLEVBQUUsRUFBRSxRQUZIO0FBR0QsRUFBQSxHQUFHLEVBQUUsUUFISjtBQUlELEVBQUEsVUFBVSxFQUFFO0FBSlgsQ0FMYyxFQVdoQjtBQUNDLEVBQUEsS0FBSyxFQUFFLFNBRFI7QUFFQyxFQUFBLEVBQUUsRUFBRSxTQUZMO0FBR0MsRUFBQSxHQUFHLEVBQUUsU0FITjtBQUlDLEVBQUEsVUFBVSxFQUFFO0FBSmIsQ0FYZ0IsQ0FBakI7QUFtQkEsSUFBTSxRQUFRLEdBQUcsQ0FBQztBQUNoQixFQUFBLEtBQUssRUFBRSxrQkFEUztBQUVoQixFQUFBLEVBQUUsRUFBRSxVQUZZO0FBR2hCLEVBQUEsR0FBRyxFQUFFLEVBSFc7QUFJaEIsRUFBQSxTQUFTLEVBQUUsWUFKSztBQUtoQixFQUFBLE9BQU8sRUFBRSxZQUxPO0FBTWhCLEVBQUEsUUFBUSxFQUFFLENBQUMsWUFBRCxFQUFlLFdBQWYsRUFBNEIsY0FBNUI7QUFOTSxDQUFELENBQWpCO0FBU0EsUUFBUSxDQUFDLE9BQVQsQ0FBaUIsVUFBQyxPQUFELEVBQVUsQ0FBVixFQUFnQjtBQUMvQixNQUFNLEdBQUcsYUFBTSxPQUFOLFNBQWdCLFdBQWhCLFNBQThCLE9BQU8sQ0FBQyxHQUF0Qyw4QkFBNkQsSUFBSSxDQUFDLEdBQUwsRUFBN0QsQ0FBVCxDQUQrQixDQUNvRDs7QUFDbkYsRUFBQSxPQUFPLENBQUMsS0FBUixHQUFnQixDQUFFLEdBQUYsQ0FBaEI7QUFDQSxFQUFBLE9BQU8sQ0FBQyxRQUFSLEdBQW1CLEtBQW5CO0FBQ0EsRUFBQSxPQUFPLENBQUMsUUFBUixHQUFtQixJQUFJLEtBQUosQ0FBVSxPQUFPLENBQUMsVUFBbEIsRUFBOEIsSUFBOUIsQ0FBbUMsQ0FBbkMsRUFBc0MsR0FBdEMsQ0FBMEMsVUFBQyxDQUFELEVBQUksQ0FBSjtBQUFBLFdBQVUsSUFBSSxDQUFDLE1BQUwsRUFBVjtBQUFBLEdBQTFDLENBQW5CO0FBQ0QsQ0FMRDtBQU9BLElBQU0sUUFBUSxHQUFHLEdBQWpCO0FBQ0EsSUFBSSxnQkFBZ0IsR0FBRyxDQUF2QjtBQUNBLGNBQWMsQ0FBQyxXQUFELENBQWQsQyxDQUNBOztBQUVBLE9BQU8sQ0FBQyxHQUFSLENBQVksVUFBWixFQUF3QixRQUF4QixFQUFrQyxTQUFsQztBQUVBLElBQU0sTUFBTSxPQUFHLG9CQUFILDZJQUFaOztBQUNBLElBQU0sWUFBWSxHQUFHLFNBQWYsWUFBZTtBQUFBLE1BQUMsSUFBRCx1RUFBUSxJQUFSO0FBQUEsMkZBQTBGLElBQTFGO0FBQUEsQ0FBckI7O0FBQ0EsSUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBZjtBQUVBLElBQU0sU0FBUyxPQUFHLG9CQUFILDBNQUNxQixVQUFDLENBQUQsRUFBTztBQUFFLEVBQUEsY0FBYyxDQUFDLENBQUMsQ0FBQyxNQUFGLENBQVMsS0FBVixDQUFkO0FBQStCLENBRDdELEVBRVosUUFBUSxDQUFDLEdBQVQsQ0FBYSxVQUFDLE9BQUQ7QUFBQSxhQUFhLG9CQUFiLGtIQUFtQyxPQUFPLENBQUMsRUFBM0MsRUFBa0QsT0FBTyxDQUFDLEVBQVIsS0FBZSxTQUFTLENBQUMsRUFBekIsR0FBNEIsVUFBNUIsR0FBdUMsRUFBekYsRUFBK0YsT0FBTyxDQUFDLEtBQXZHO0FBQUEsQ0FBYixDQUZZLENBQWY7QUFLQSxNQUFNLENBQUMsV0FBUCxDQUFtQixTQUFuQjtBQUNBLE1BQU0sQ0FBQyxXQUFQLENBQW1CLE1BQW5CLEUsQ0FHQTtBQUNBO0FBQ0E7QUFDQTs7U0FDZSxPOzs7OztxRUFBZjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDRSxZQUFBLGdCQUFnQjtBQUNoQixnQkFBRyxnQkFBZ0IsR0FBRyxRQUF0QixFQUFnQyxnQkFBZ0IsR0FBRyxDQUFuQjtBQUMxQixZQUFBLENBSFIsR0FHWSxJQUFJLElBQUosRUFIWjtBQUlFLFlBQUEsQ0FBQyxDQUFDLE9BQUYsQ0FBVSxDQUFDLFFBQUQsR0FBWSxnQkFBdEI7QUFDTSxZQUFBLE9BTFIsR0FLa0IsQ0FBQyxDQUFDLGtCQUFGLENBQXFCLE9BQXJCLENBTGxCLEVBS2dEOztBQUM5QyxZQUFBLE1BQU0sQ0FBQyxTQUFQLEdBQW1CLFlBQVksQ0FBQyxPQUFELENBQS9CO0FBTkY7QUFBQSxtQkFPd0IsMEJBQVEsT0FBUixTQUFrQixXQUFsQixTQUFnQyxPQUFoQyxjQUEyQyxTQUFTLENBQUMsRUFBckQsNkJBQTBFLE9BQTFFLFdBQXlGLGNBQXpGLENBUHhCOztBQUFBO0FBT1EsWUFBQSxPQVBSO0FBUUU7QUFDQSxZQUFBLFNBQVMsQ0FBQyxRQUFWLEdBQXNCLFNBQVMsQ0FBQyxRQUFWLENBQW1CLEdBQW5CLENBQXVCLFVBQUMsQ0FBRCxFQUFJLENBQUo7QUFBQSxxQkFBVSxPQUFPLENBQUMsQ0FBRCxDQUFQLENBQVcsUUFBckI7QUFBQSxhQUF2QixDQUF0QixDQVRGLENBVUE7QUFDQTs7QUFDRSxZQUFBLE1BQU07O0FBWlI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRzs7OztBQWNBLE9BQU87O0FBRVAsU0FBUyxjQUFULENBQXlCLEVBQXpCLEVBQTZCO0FBQzNCLEVBQUEsUUFBUSxDQUFDLE9BQVQsQ0FBaUIsVUFBQyxPQUFELEVBQWE7QUFDNUIsUUFBRyxPQUFPLENBQUMsRUFBUixLQUFlLEVBQWxCLEVBQXNCO0FBQ3BCLE1BQUEsT0FBTyxDQUFDLE9BQVIsR0FBa0IsSUFBbEI7QUFDQSxNQUFBLFNBQVMsR0FBRyxPQUFaO0FBQ0QsS0FIRCxNQUdPO0FBQ0wsTUFBQSxPQUFPLENBQUMsT0FBUixHQUFrQixLQUFsQjtBQUNEO0FBQ0YsR0FQRDtBQVFEOztBQUVELFNBQVMsTUFBVCxHQUFtQjtBQUNqQjtBQUNBLE1BQU0sTUFBTSxHQUFHLFFBQVEsQ0FBQyxHQUFULENBQWEsVUFBQyxPQUFEO0FBQUEsV0FBYSxJQUFJLFFBQUosQ0FBYTtBQUNwRDtBQUNBLE1BQUEsRUFBRSxFQUFFLE9BQU8sQ0FBQyxFQUZ3QztBQUdwRCxNQUFBLElBQUksRUFBRSxPQUFPLENBQUMsS0FIc0M7QUFJcEQsTUFBQSxRQUFRLEVBQUUsT0FBTyxDQUFDLE9BSmtDO0FBS3BELE1BQUEsWUFBWSxFQUFFLHNCQUFDLEdBQUQsRUFBUztBQUNyQjtBQUNBLFlBQU0sQ0FBQyxHQUFHLE9BQU8sQ0FBQyxRQUFSLENBQWlCLEdBQUcsQ0FBQyxFQUFyQixDQUFWO0FBQ0QsZUFBTyxDQUFDLENBQUMsR0FBRyxHQUFMLEVBQVUsQ0FBQyxHQUFHLEdBQWQsRUFBbUIsQ0FBQyxHQUFHLEdBQXZCLENBQVAsQ0FIc0IsQ0FJdEI7QUFDQSxPQVZtRDtBQVdwRCxNQUFBLFlBQVksRUFBRSxDQVhzQztBQVl0RCxNQUFBLFdBQVcsRUFBRTtBQUNYLFFBQUEsWUFBWSxFQUFFO0FBREgsT0FaeUM7QUFldEQsTUFBQSxjQUFjLEVBQUU7QUFDZDtBQUNBLFFBQUEsWUFBWSxFQUFFLENBQUMsZ0JBQUQ7QUFGQSxPQWZzQztBQW1CdEQsTUFBQSxPQUFPLEVBQUUsT0FBTyxDQUFDLE9BbkJxQztBQW9CdEQsTUFBQSxrQkFBa0IsRUFBRSxDQXBCa0M7QUFxQnRELE1BQUEsT0FBTyxFQUFFLEVBckI2QztBQXNCdEQsTUFBQSxPQUFPLEVBQUU7QUF0QjZDLEtBQWIsQ0FBYjtBQUFBLEdBQWIsQ0FBZjtBQXlCQSxFQUFBLEdBQUcsQ0FBQyxRQUFKLENBQWE7QUFBQyxJQUFBLE1BQU0sRUFBRTtBQUFULEdBQWI7QUFDRDs7QUFDRCxHQUFHLEdBQUcsSUFBSSxNQUFKLENBQVc7QUFFZixFQUFBLGdCQUFnQixFQUFFO0FBQ2hCO0FBQ0EsSUFBQSxRQUFRLEVBQUUsaUJBRk07QUFHaEIsSUFBQSxTQUFTLEVBQUUsZ0JBSEs7QUFJaEI7QUFDRDtBQUNDO0FBQ0EsSUFBQSxJQUFJLEVBQUUsQ0FQVTtBQVFoQixJQUFBLE9BQU8sRUFBRSxFQVJPO0FBU2hCLElBQUEsS0FBSyxFQUFFLEVBVFM7QUFVaEIsSUFBQSxPQUFPLEVBQUU7QUFWTyxHQUZIO0FBY2YsRUFBQSxVQUFVLEVBQUUsSUFkRztBQWVmLEVBQUEsZUFBZSxFQUFFLEtBZkY7QUFnQmYsRUFBQSxVQUFVLEVBQUUsMEJBQWdCO0FBQUEsUUFBYixNQUFhLFFBQWIsTUFBYTs7QUFDMUIsUUFBRyxNQUFILEVBQVc7QUFDVCxNQUFBLE9BQU8sQ0FBQyxHQUFSLENBQVksTUFBTSxDQUFDLEVBQW5CLEVBQXVCLE1BQU0sQ0FBQyxVQUE5QixFQUEwQyxNQUFNLENBQUMsVUFBUCxDQUFrQixHQUE1RDtBQUVBLHVCQUFVLE1BQU0sQ0FBQyxVQUFQLENBQWtCLEdBQTVCLGNBQW1DLE1BQU0sQ0FBQyxVQUFQLENBQWtCLEdBQXJELHVCQUFxRSxTQUFTLENBQUMsUUFBVixDQUFtQixNQUFNLENBQUMsRUFBMUIsQ0FBckU7QUFDRDs7QUFDRCxXQUFPLElBQVA7QUFDRCxHQXZCYyxDQXdCZjs7QUF4QmUsQ0FBWCxDQUFOO0FBMkJBLFdBQVcsQ0FBQyxZQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0YsRUFBQSxPQUFPLEdBUlcsQ0FTakI7QUFDQSxDQVZVLEVBVVIsSUFWUSxDQUFYO0FBYUEsUUFBUSxDQUFDLElBQVQsQ0FBYyxXQUFkLENBQTBCLE1BQTFCLEUsQ0FFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9TQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5a0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2piQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2M0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyQkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIi8qXG4qIFRvIGRvOlxuKiAtIGhvdyB0byB1cGRhdGUgdG9vbHRpcCB3aGVuIGRhdGUgaXMgdXBkYXRlZD8gXG4qIC0gZGVmaW5pdGlvbiBmaWxlIGZvciBkYXRhc2V0c1xuKiAtIG1ha2UgZGF0YXNldCBmaWxlcyB0aGF0IG9ubHkgY29udGFpbiB2YWx1ZXMsIG5vdCBnZW9pZFxuKiAtIGltcGxlbWVudCBzdGFydCBkYXRlIGFuZCBlbmQgZGF0ZVxuKiAtIGFkZCBzYW1wbGUgZGF0YSBmb3IgdGltZXNlcmllc1xuKiAtIGxvYWRpbmcgc3Bpbm5lciB3aGlsZSBkYXRhIGlzIGxvYWRpbmdcbiogLSBzaG93IHNlbGVjdGVkIGVsZW1lbnRzIGFzIHNlcGFyYXRlIGFycmF5XG4qIFxuKiBhc3N1bXB0aW9uczogZ2VvIGlkIGluIHRpbGVzZXQgcmVmZXJzIHRvIGRhdGEgb3JkZXIgKD8pXG4qIGFyZSB0aGVyZSBkYXRhc2V0cyB0aGF0IG9ubHkgZXhpc3QgYXQgY2VydGFpbiBnZW9sZXZlbHM/XG4qIGh0dHBzOi8vZGVjay5nbC9kb2NzL2FwaS1yZWZlcmVuY2UvZ2VvLWxheWVycy9tdnQtbGF5ZXJcbiovXG5jb25zdCB7RGVja0dMLCBNVlRMYXllcn0gPSBkZWNrO1xuLy9pbXBvcnQgeyBjc3YgfSBmcm9tICdkMydcbmltcG9ydCB7bG9hZH0gZnJvbSAnQGxvYWRlcnMuZ2wvY29yZSc7XG5pbXBvcnQge0NTVkxvYWRlcn0gZnJvbSAnQGxvYWRlcnMuZ2wvY3N2JztcbmltcG9ydCBodG1sIGZyb20gJ25hbm9odG1sJ1xuXG5sZXQgdml6XG5sZXQgZ2VvUmVnaW9uXG5sZXQgZGF0YXNldCA9ICdtb2JpbGl0eSdcblxuY29uc3QgYmFzZVVSTCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLnJlcGxhY2UoJy9leGFtcGxlLWRhdGEtbG9hZGluZy8nLCAnJylcblxuY29uc3QgZGF0YXNldFBhdGggPSBgL3NhbXBsZS1kYXRhL2RhdGFzZXRzL2BcblxuY29uc3QgdGlsZXNldFBhdGggPSBgL3NhbXBsZS1kYXRhL3RpbGVzZXRzL2BcblxuLy8gc2V0cyBvZiB2ZWN0b3IgdGlsZXNldHMgcmVwcmVzZW50aW5nIGRpZmZlcmVudCBnZW8tcmVnaW9uc1xuY29uc3QgdGlsZXNldHMgPSBbe1xuICBsYWJlbDogJ2dlbWVpbmRlbicsIC8vIFxuICBpZDogJ2dlbWVpbmRlbicsLy8gXG4gIHVybDogJ2dlbWVpbmRlbicsXG4gIG51bUVudHJpZXM6IDExNDMxLFxufSwge1xuICBsYWJlbDogJ2tyZWlzZScsXG4gIGlkOiAna3JlaXNlJyxcbiAgdXJsOiAna3JlaXNlJyxcbiAgbnVtRW50cmllczogNDMyXG59LFxuIHtcbiAgbGFiZWw6ICdsYWVuZGVyJyxcbiAgaWQ6ICdsYWVuZGVyJyxcbiAgdXJsOiAnbGFlbmRlcicsXG4gIG51bUVudHJpZXM6IDM0XG59XG5dXG5cbmNvbnN0IGRhdGFzZXRzID0gW3tcbiAgbGFiZWw6ICdNb2JpbGl0eSBieSBEYXRlJyxcbiAgaWQ6ICdtb2JpbGl0eScsXG4gIHVybDogJycsXG4gIHN0YXJ0RGF0ZTogJzIwMjEtMDUtMjMnLFxuICBlbmREYXRlOiAnMjAyMS0wOC0zMCcsXG4gIHRpbGVzZXRzOiBbJ2xhZW5kZXJnZW8nLCAna3JlaXNlZ2VvJywgJ2dlbWVpbmRlbmdlbyddXG59XVxuXG50aWxlc2V0cy5mb3JFYWNoKCh0aWxlc2V0LCBpKSA9PiB7XG4gIGNvbnN0IFVSTCA9IGAke2Jhc2VVUkx9JHt0aWxlc2V0UGF0aH0ke3RpbGVzZXQudXJsfS97en0ve3h9L3t5fS5wYmY/JHtEYXRlLm5vdygpfWAgLy8gQFRPRE86IHJlbW92ZSBkYXRlIG5vdywgb25seSBmb3IgcmVzZXR0aW5nIGJyb3dzZXIgY2FjaGUgaW4gZGV2IHZlcnNpb25cbiAgdGlsZXNldC50aWxlcyA9IFsgVVJMIF1cbiAgdGlsZXNldC52aXNpYmlsZSA9IGZhbHNlXG4gIHRpbGVzZXQubW9iaWxpdHkgPSBuZXcgQXJyYXkodGlsZXNldC5udW1FbnRyaWVzKS5maWxsKDApLm1hcCgoXywgaSkgPT4gTWF0aC5yYW5kb20oKSlcbn0pXG5cbmNvbnN0IG51bURhdGVzID0gMTAwXG5sZXQgY3VycmVudERhdGVJbmRleCA9IDBcbnNlbGVjdEdlb0xldmVsKCdnZW1laW5kZW4nKVxuLy9nZW9SZWdpb24gPSB0aWxlc2V0c1swXVxuXG5jb25zb2xlLmxvZygnYmFzZSB1cmwnLCB0aWxlc2V0cywgZ2VvUmVnaW9uKVxuXG5jb25zdCBmb290ZXIgPSBodG1sYDxkaXYgc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTtib3R0b206MHB4O3JpZ2h0OjBweDt3aWR0aDoxMDAlXCI+PC9kaXY+YFxuY29uc3QgZ2VuZXJhdGVEYXRlID0gKGRhdGUgPSAnaGknKSA9PiBgPGRpdiBzdHlsZT1cImZvbnQtc2l6ZTo0cmVtO2NvbG9yOndoaXRlO2JhY2tncm91bmQ6cmdiYSgwLCAwLCAwLCAwLjQpXCI+JHtkYXRlfTwvZGl2PmBcbmNvbnN0IGRhdGVFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG5cbmNvbnN0IGdlb1NlbGVjdCA9IGh0bWxgPGxhYmVsIGZvcj1cImdlb2xldmVsXCI+U2VsZWN0IG1hcCBnZW8gbGV2ZWw8L2xhYmVsPlxuPHNlbGVjdCBsYWJlbD1cImdlb2xldmVsXCIgb25jaGFuZ2U9JHsoZSkgPT4geyBzZWxlY3RHZW9MZXZlbChlLnRhcmdldC52YWx1ZSl9fSBpZD1cImdlb2xldmVsXCI+XG4gJHt0aWxlc2V0cy5tYXAoKHRpbGVzZXQpID0+IGh0bWxgPG9wdGlvbiB2YWx1ZT1cIiR7dGlsZXNldC5pZH1cIiAke3RpbGVzZXQuaWQgPT09IGdlb1JlZ2lvbi5pZD8nc2VsZWN0ZWQnOicnfT4ke3RpbGVzZXQubGFiZWx9PC9vcHRpb24+YCl9XG48L3NlbGVjdD5gXG5cbmZvb3Rlci5hcHBlbmRDaGlsZChnZW9TZWxlY3QpXG5mb290ZXIuYXBwZW5kQ2hpbGQoZGF0ZUVsKVxuXG5cbi8vIG9wdGltaXphdGlvbnMgZm9yIHRoaXM6IGxvYWQgZGlyZWN0bHkgYXMgYW4gYXJyYXkgYW5kIGRvIG5vdCBwYXJzZSBpbnRvIG9iamVjdHNcbi8vIHN0b3JlIGFscmVhZHkgbG9hZGVkIGRhdGEgaW4gc29tZSB3YXkgYW5kIG9ubHkgbG9hZCBuZXcgZGF0YSBhcyBuZWNlc3Nhcnlcbi8vIHJlYWQgbW9yZSBhYm91dCBkZWNrZ2wgLyB3ZWJnbCBwZXJmb3JtYW5jZVxuLy8gc2hvdyBsb2FkaW5nIGFuaW1hdGlvbiB3aGlsZSBsb2FkaW5nXG5hc3luYyBmdW5jdGlvbiBnZXREYXRhKCkge1xuICBjdXJyZW50RGF0ZUluZGV4KytcbiAgaWYoY3VycmVudERhdGVJbmRleCA+IG51bURhdGVzKSBjdXJyZW50RGF0ZUluZGV4ID0gMFxuICBjb25zdCBkID0gbmV3IERhdGUoKVxuICBkLnNldERhdGUoLW51bURhdGVzICsgY3VycmVudERhdGVJbmRleClcbiAgY29uc3QgZGF0ZVN0ciA9IGQudG9Mb2NhbGVEYXRlU3RyaW5nKCdlbi1DQScpIC8vZGF0ZS5mb3JtYXQoZCwgJ1lZWVktTU0tREQnKVxuICBkYXRlRWwuaW5uZXJIVE1MID0gZ2VuZXJhdGVEYXRlKGRhdGVTdHIpXG4gIGNvbnN0IG5ld0RhdGEgPSBhd2FpdCBsb2FkKGAke2Jhc2VVUkx9JHtkYXRhc2V0UGF0aH0ke2RhdGFzZXR9LyR7Z2VvUmVnaW9uLmlkfS92YWx1ZXMtYnktZGF0ZS8ke2RhdGVTdHJ9LmNzdmAsIENTVkxvYWRlcik7XG4gIC8vIGNvbnNvbGUubG9nKCdsb2FkZWQnLCBuZXdEYXRhLCBnZW9SZWdpb24pXG4gIGdlb1JlZ2lvbi5tb2JpbGl0eSA9ICBnZW9SZWdpb24ubW9iaWxpdHkubWFwKChfLCBpKSA9PiBuZXdEYXRhW2ldLm1vYmlsaXR5KVxuLy9nZW1laW5kZW46IG5ldyBBcnJheSgxMTQzMSkuZmlsbCgwKS5tYXAoKF8sIGkpID0+IE1hdGgucmFuZG9tKCkpLFxuLy9rcmVpc2U6IG5ldyBBcnJheSg0MzIpLmZpbGwoMCkubWFwKChfLCBpKSA9PiBNYXRoLnJhbmRvbSgpKVxuICByZW5kZXIoKVxufVxuZ2V0RGF0YSgpXG5cbmZ1bmN0aW9uIHNlbGVjdEdlb0xldmVsIChpZCkge1xuICB0aWxlc2V0cy5mb3JFYWNoKCh0aWxlc2V0KSA9PiB7XG4gICAgaWYodGlsZXNldC5pZCA9PT0gaWQpIHtcbiAgICAgIHRpbGVzZXQudmlzaWJsZSA9IHRydWVcbiAgICAgIGdlb1JlZ2lvbiA9IHRpbGVzZXRcbiAgICB9IGVsc2Uge1xuICAgICAgdGlsZXNldC52aXNpYmxlID0gZmFsc2VcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gIC8vIGNvbnNvbGUubG9nKHRpbGVzZXRzLCAndGlsZXNldHMnKVxuICBjb25zdCBsYXllcnMgPSB0aWxlc2V0cy5tYXAoKHRpbGVzZXQpID0+IG5ldyBNVlRMYXllcih7XG4gICAgLy8gaWQ6IHRpbGVzZXQuaWQsXG4gICAgaWQ6IHRpbGVzZXQuaWQsXG4gICAgZGF0YTogdGlsZXNldC50aWxlcyxcbiAgICBwaWNrYWJsZTogdGlsZXNldC52aXNpYmxlLFxuICAgIGdldEZpbGxDb2xvcjogKG9iaikgPT4ge1xuICAgICAgLy9jb25zb2xlLmxvZygnZ2V0dGluZyBtb2JpbGl0eSBhdCcsIG9iai5pZCwgdGlsZXNldC5tb2JpbGl0eSlcbiAgICAgIGNvbnN0IGogPSB0aWxlc2V0Lm1vYmlsaXR5W29iai5pZF1cbiAgICAgcmV0dXJuIFtqICogMjU1LCBqICogMjU1LCBqICogMjU1XVxuICAgICAvL3JldHVybiBbTWF0aC5yYW5kb20oKSAqIDI1NSwgTWF0aC5yYW5kb20oKSAqIDI1NSwgTWF0aC5yYW5kb20oKSAqIDI1NV1cbiAgICB9LCBcbiAgICBnZXRMaW5lV2lkdGg6IDQsXG4gIHRyYW5zaXRpb25zOiB7XG4gICAgZ2V0RmlsbENvbG9yOiAxMDAsXG4gIH0sXG4gIHVwZGF0ZVRyaWdnZXJzOiB7XG4gICAgLy8gaWYgY3VycmVudERhdGVJbmRleCBjaGFuZ2VzLCByZWNvbXB1dGUgZ2V0RmlsbENvbG9yIGZvciBlYWNoIHBvaW50XG4gICAgZ2V0RmlsbENvbG9yOiBbY3VycmVudERhdGVJbmRleF1cbiAgfSxcbiAgdmlzaWJsZTogdGlsZXNldC52aXNpYmxlLFxuICBsaW5lV2lkdGhNaW5QaXhlbHM6IDAsXG4gIG1heFpvb206IDEzLFxuICBtaW5ab29tOiAwLFxufSkpXG5cbiAgdml6LnNldFByb3BzKHtsYXllcnM6IGxheWVyc30pXG59XG52aXogPSBuZXcgRGVja0dMKHtcbiAgXG4gIGluaXRpYWxWaWV3U3RhdGU6IHtcbiAgICAvLyBsb25naXR1ZGU6IC0xMjIuNCxcbiAgICBsYXRpdHVkZTogNTEuNjY0MDM3ODE2NTgxMjEsXG4gICAgbG9uZ2l0dWRlOiAxMC42NDYwOTUyNzU4Nzg5LFxuICAgIC8vIGxhdGl0dWRlOiAzNy43NCxcbiAgIC8vIGxvbmdpdHVkZTogMTMuNzY1ODY5LFxuICAgIC8vMTMuNzY1ODY5LDU0LjExNzM4MlxuICAgIHpvb206IDYsXG4gICAgbWF4Wm9vbTogMjAsXG4gICAgcGl0Y2g6IDMwLFxuICAgIGJlYXJpbmc6IDBcbiAgfSxcbiAgY29udHJvbGxlcjogdHJ1ZSxcbiAgdXNlRGV2aWNlUGl4ZWxzOiBmYWxzZSxcbiAgZ2V0VG9vbHRpcDogKHsgb2JqZWN0IH0pID0+IHsgXG4gICAgaWYob2JqZWN0KSB7XG4gICAgICBjb25zb2xlLmxvZyhvYmplY3QuaWQsIG9iamVjdC5wcm9wZXJ0aWVzLCBvYmplY3QucHJvcGVydGllcy5BR1MpXG5cbiAgICAgIHJldHVybiBgJHtvYmplY3QucHJvcGVydGllcy5HRU59ICR7b2JqZWN0LnByb3BlcnRpZXMuQUdTfSBtb2JpbGl0eSAke2dlb1JlZ2lvbi5tb2JpbGl0eVtvYmplY3QuaWRdfWBcbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICAvL2xheWVyczogW2xheWVyXVxufSk7XG4gIFxuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuLy8gIGNvbnNvbGUubG9nKHNob3VsZFVwZGF0ZSlcbi8vIGZha2VEYXRhLmxhZW5kZXIgPSBmYWtlRGF0YS5sYWVuZGVyLm1hcCgoXywgaSkgPT4gTWF0aC5yYW5kb20oKSlcbi8vIGZha2VEYXRhLmtyZWlzZSA9IGZha2VEYXRhLmtyZWlzZS5tYXAoKF8sIGkpID0+IE1hdGgucmFuZG9tKCkpXG4vL2Zha2VEYXRhW2dlb1JlZ2lvbl0gPSBmYWtlRGF0YVtnZW9SZWdpb25dLm1hcCgoXywgaSkgPT4gTWF0aC5yYW5kb20oKSlcbi8vZ2VtZWluZGVuOiBuZXcgQXJyYXkoMTE0MzEpLmZpbGwoMCkubWFwKChfLCBpKSA9PiBNYXRoLnJhbmRvbSgpKSxcbi8va3JlaXNlOiBuZXcgQXJyYXkoNDMyKS5maWxsKDApLm1hcCgoXywgaSkgPT4gTWF0aC5yYW5kb20oKSlcbiAgLy9yZW5kZXIoKVxuZ2V0RGF0YSgpXG4gLy8gc2hvdWxkVXBkYXRlICsrXG59LCAyMDAwKVxuXG5cbmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9vdGVyKVxuXG4vLyAgIGNvbnN0IHRpbGVVUkwgPSBgJHt3aW5kb3cubG9jYXRpb24ub3JpZ2lufS9nZW1laW5kZW4tejctdW5jb21wcmVzc2VkL3t6fS97eH0ve3l9LnBiZmBcblxuLy8gY29uc3QgREFUQSA9IFtcbi8vICAgICB0aWxlVVJMXG4vLyAgICAgLy8naHR0cHM6Ly90aWxlcy1hLmJhc2VtYXBzLmNhcnRvY2RuLmNvbS92ZWN0b3J0aWxlcy9jYXJ0by5zdHJlZXRzL3YxL3t6fS97eH0ve3l9Lm12dCdcbi8vICAgXVxuXG4vLyBmdW5jdGlvbiByZW5kZXIgKCkge1xuLy8gY29uc3QgZ2VtZWluZGVuID0gbmV3IE1WVExheWVyKHtcbi8vICAgaWQ6ICdnZW1laW5kZW5nZW8nLFxuLy8gICBkYXRhOiBEQVRBLFxuLy8gICBwaWNrYWJsZTogdHJ1ZSxcbi8vICAgZ2V0RmlsbENvbG9yOiAoKSA9PiB7XG4vLyAgICAvLyBjb25zb2xlLmxvZyhzaG91bGRVcGRhdGUpXG4vLyAgICByZXR1cm4gW01hdGgucmFuZG9tKCkgKiAyNTUsIE1hdGgucmFuZG9tKCkgKiAyNTUsIE1hdGgucmFuZG9tKCkgKiAyNTVdXG4vLyAgIH0sXG4vLyAgIGdldExpbmVDb2xvcjogKCkgPT4gW01hdGgucmFuZG9tKCkgKiAyNTUsIE1hdGgucmFuZG9tKCkgKiAyNTUsIE1hdGgucmFuZG9tKCkgKiAyNTVdLFxuLy8gICBnZXRMaW5lV2lkdGg6IDQsXG4vLyAgIHRyYW5zaXRpb25zOiB7XG4vLyAgICAgZ2V0RmlsbENvbG9yOiAxMDAsXG4vLyAgIH0sXG4vLyAgIHVwZGF0ZVRyaWdnZXJzOiB7XG4vLyAgICAgLy8gaWYgc2hvd0xpYnJhcmllcyBjaGFuZ2VzLCByZWNvbXB1dGUgZ2V0RmlsbENvbG9yIGZvciBlYWNoIHBvaW50XG4vLyAgICAgZ2V0RmlsbENvbG9yOiBbc2hvdWxkVXBkYXRlXVxuLy8gICB9LFxuLy8gICBsaW5lV2lkdGhNaW5QaXhlbHM6IDEsXG4gIFxuLy8gICAvKiBwcm9wcyBmcm9tIE1WVExheWVyIGNsYXNzICovXG4gIFxuLy8gICAvLyBiaW5hcnk6IGZhbHNlLFxuLy8gICAvLyBoaWdobGlnaHRlZEZlYXR1cmVJZDogbnVsbCxcbi8vICAgLy8gbG9hZGVyczogLFxuLy8gICAvLyB1bmlxdWVJZFByb3BlcnR5OiAnJyxcbiAgXG4vLyAgIC8qIHByb3BzIGluaGVyaXRlZCBmcm9tIFRpbGVMYXllciBjbGFzcyAqL1xuICBcbi8vICAgLy8gZXh0ZW50OiBudWxsLFxuLy8gICAvLyBnZXRUaWxlRGF0YTogbnVsbCxcbi8vICAgLy8gbWF4Q2FjaGVCeXRlU2l6ZTogbnVsbCxcbi8vICAgLy8gbWF4Q2FjaGVTaXplOiBudWxsLFxuLy8gICAvLyBtYXhSZXF1ZXN0czogNixcbi8vICAgbWF4Wm9vbTogMTMsXG4vLyAgIG1pblpvb206IDcsXG4vLyAgIC8vIG9uVGlsZUVycm9yOiBudWxsLFxuLy8gICAvLyBvblRpbGVMb2FkOiBudWxsLFxuLy8gICAvLyBvblRpbGVVbmxvYWQ6IG51bGwsXG4vLyAgIC8vIG9uVmlld3BvcnRMb2FkOiBudWxsLFxuLy8gICAvLyByZWZpbmVtZW50U3RyYXRlZ3k6ICdiZXN0LWF2YWlsYWJsZScsXG4vLyAgIC8vIHJlbmRlclN1YkxheWVyczogbnVsbCxcbi8vICAgLy8gdGlsZVNpemU6IDUxMixcbi8vICAgLy8gelJhbmdlOiBudWxsLFxuICBcbi8vICAgLyogcHJvcHMgaW5oZXJpdGVkIGZyb20gTGF5ZXIgY2xhc3MgKi9cbiAgXG4vLyAgIC8vIGF1dG9IaWdobGlnaHQ6IGZhbHNlLFxuLy8gICAvLyBjb29yZGluYXRlT3JpZ2luOiBbMCwgMCwgMF0sXG4vLyAgIC8vIGNvb3JkaW5hdGVTeXN0ZW06IENPT1JESU5BVEVfU1lTVEVNLkxOR0xBVCxcbi8vICAgLy8gaGlnaGxpZ2h0Q29sb3I6IFswLCAwLCAxMjgsIDEyOF0sXG4vLyAgIC8vIG1vZGVsTWF0cml4OiBudWxsLFxuLy8gICAvLyBvcGFjaXR5OiAxLFxuLy8gICAvLyBwaWNrYWJsZTogZmFsc2UsXG4vLyAgIC8vIHZpc2libGU6IHRydWUsXG4vLyAgIC8vIHdyYXBMb25naXR1ZGU6IGZhbHNlLFxuLy8gfSk7IiwidmFyIEF3YWl0VmFsdWUgPSByZXF1aXJlKFwiLi9Bd2FpdFZhbHVlLmpzXCIpO1xuXG5mdW5jdGlvbiBBc3luY0dlbmVyYXRvcihnZW4pIHtcbiAgdmFyIGZyb250LCBiYWNrO1xuXG4gIGZ1bmN0aW9uIHNlbmQoa2V5LCBhcmcpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlcXVlc3QgPSB7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICBhcmc6IGFyZyxcbiAgICAgICAgcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICAgICAgcmVqZWN0OiByZWplY3QsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG5cbiAgICAgIGlmIChiYWNrKSB7XG4gICAgICAgIGJhY2sgPSBiYWNrLm5leHQgPSByZXF1ZXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJvbnQgPSBiYWNrID0gcmVxdWVzdDtcbiAgICAgICAgcmVzdW1lKGtleSwgYXJnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc3VtZShrZXksIGFyZykge1xuICAgIHRyeSB7XG4gICAgICB2YXIgcmVzdWx0ID0gZ2VuW2tleV0oYXJnKTtcbiAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgIHZhciB3cmFwcGVkQXdhaXQgPSB2YWx1ZSBpbnN0YW5jZW9mIEF3YWl0VmFsdWU7XG4gICAgICBQcm9taXNlLnJlc29sdmUod3JhcHBlZEF3YWl0ID8gdmFsdWUud3JhcHBlZCA6IHZhbHVlKS50aGVuKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgaWYgKHdyYXBwZWRBd2FpdCkge1xuICAgICAgICAgIHJlc3VtZShrZXkgPT09IFwicmV0dXJuXCIgPyBcInJldHVyblwiIDogXCJuZXh0XCIsIGFyZyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0dGxlKHJlc3VsdC5kb25lID8gXCJyZXR1cm5cIiA6IFwibm9ybWFsXCIsIGFyZyk7XG4gICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHJlc3VtZShcInRocm93XCIsIGVycik7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHNldHRsZShcInRocm93XCIsIGVycik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0dGxlKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwicmV0dXJuXCI6XG4gICAgICAgIGZyb250LnJlc29sdmUoe1xuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcInRocm93XCI6XG4gICAgICAgIGZyb250LnJlamVjdCh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBmcm9udC5yZXNvbHZlKHtcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGZyb250ID0gZnJvbnQubmV4dDtcblxuICAgIGlmIChmcm9udCkge1xuICAgICAgcmVzdW1lKGZyb250LmtleSwgZnJvbnQuYXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFjayA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5faW52b2tlID0gc2VuZDtcblxuICBpZiAodHlwZW9mIGdlbltcInJldHVyblwiXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhpc1tcInJldHVyblwiXSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5Bc3luY0dlbmVyYXRvci5wcm90b3R5cGVbdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCJdID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5cbkFzeW5jR2VuZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gdGhpcy5faW52b2tlKFwibmV4dFwiLCBhcmcpO1xufTtcblxuQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlW1widGhyb3dcIl0gPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiB0aGlzLl9pbnZva2UoXCJ0aHJvd1wiLCBhcmcpO1xufTtcblxuQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlW1wicmV0dXJuXCJdID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gdGhpcy5faW52b2tlKFwicmV0dXJuXCIsIGFyZyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFzeW5jR2VuZXJhdG9yO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9Bd2FpdFZhbHVlKHZhbHVlKSB7XG4gIHRoaXMud3JhcHBlZCA9IHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9Bd2FpdFZhbHVlO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlMaWtlVG9BcnJheTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aEhvbGVzO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsInZhciBhcnJheUxpa2VUb0FycmF5ID0gcmVxdWlyZShcIi4vYXJyYXlMaWtlVG9BcnJheS5qc1wiKTtcblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhvdXRIb2xlcztcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQ7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX2FzeW5jR2VuZXJhdG9yRGVsZWdhdGUoaW5uZXIsIGF3YWl0V3JhcCkge1xuICB2YXIgaXRlciA9IHt9LFxuICAgICAgd2FpdGluZyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHB1bXAoa2V5LCB2YWx1ZSkge1xuICAgIHdhaXRpbmcgPSB0cnVlO1xuICAgIHZhbHVlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIHJlc29sdmUoaW5uZXJba2V5XSh2YWx1ZSkpO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBkb25lOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBhd2FpdFdyYXAodmFsdWUpXG4gICAgfTtcbiAgfVxuXG4gIDtcblxuICBpdGVyW3R5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBpdGVyLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAod2FpdGluZykge1xuICAgICAgd2FpdGluZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBwdW1wKFwibmV4dFwiLCB2YWx1ZSk7XG4gIH07XG5cbiAgaWYgKHR5cGVvZiBpbm5lcltcInRocm93XCJdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBpdGVyW1widGhyb3dcIl0gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh3YWl0aW5nKSB7XG4gICAgICAgIHdhaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhyb3cgdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwdW1wKFwidGhyb3dcIiwgdmFsdWUpO1xuICAgIH07XG4gIH1cblxuICBpZiAodHlwZW9mIGlubmVyW1wicmV0dXJuXCJdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBpdGVyW1wicmV0dXJuXCJdID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAod2FpdGluZykge1xuICAgICAgICB3YWl0aW5nID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHB1bXAoXCJyZXR1cm5cIiwgdmFsdWUpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gaXRlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXN5bmNHZW5lcmF0b3JEZWxlZ2F0ZTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfYXN5bmNJdGVyYXRvcihpdGVyYWJsZSkge1xuICB2YXIgbWV0aG9kO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaWYgKFN5bWJvbC5hc3luY0l0ZXJhdG9yKSBtZXRob2QgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl07XG4gICAgaWYgKG1ldGhvZCA9PSBudWxsICYmIFN5bWJvbC5pdGVyYXRvcikgbWV0aG9kID0gaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXTtcbiAgfVxuXG4gIGlmIChtZXRob2QgPT0gbnVsbCkgbWV0aG9kID0gaXRlcmFibGVbXCJAQGFzeW5jSXRlcmF0b3JcIl07XG4gIGlmIChtZXRob2QgPT0gbnVsbCkgbWV0aG9kID0gaXRlcmFibGVbXCJAQGl0ZXJhdG9yXCJdO1xuICBpZiAobWV0aG9kID09IG51bGwpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgaXMgbm90IGFzeW5jIGl0ZXJhYmxlXCIpO1xuICByZXR1cm4gbWV0aG9kLmNhbGwoaXRlcmFibGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3luY0l0ZXJhdG9yO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3luY1RvR2VuZXJhdG9yO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsInZhciBBd2FpdFZhbHVlID0gcmVxdWlyZShcIi4vQXdhaXRWYWx1ZS5qc1wiKTtcblxuZnVuY3Rpb24gX2F3YWl0QXN5bmNHZW5lcmF0b3IodmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBBd2FpdFZhbHVlKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXdhaXRBc3luY0dlbmVyYXRvcjtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jbGFzc0NhbGxDaGVjaztcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZi5qc1wiKTtcblxudmFyIGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IHJlcXVpcmUoXCIuL2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdC5qc1wiKTtcblxuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gIGlmIChpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0O1xuICAgIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpO1xuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICBpZiAoQ2xhc3MpIHNldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3Q7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jcmVhdGVDbGFzcztcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmaW5lUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2Y7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwidmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2YuanNcIik7XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW5oZXJpdHM7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICBcImRlZmF1bHRcIjogb2JqXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikge1xuICByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pc05hdGl2ZUZ1bmN0aW9uO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3Q7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXk7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07XG5cbiAgaWYgKF9pID09IG51bGwpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG5cbiAgdmFyIF9zLCBfZTtcblxuICB0cnkge1xuICAgIGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXlMaW1pdDtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVJlc3Q7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVTcHJlYWQ7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIilbXCJkZWZhdWx0XCJdO1xuXG52YXIgYXNzZXJ0VGhpc0luaXRpYWxpemVkID0gcmVxdWlyZShcIi4vYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzXCIpO1xuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGFzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsInZhciBhcnJheVdpdGhIb2xlcyA9IHJlcXVpcmUoXCIuL2FycmF5V2l0aEhvbGVzLmpzXCIpO1xuXG52YXIgaXRlcmFibGVUb0FycmF5TGltaXQgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qc1wiKTtcblxudmFyIHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanNcIik7XG5cbnZhciBub25JdGVyYWJsZVJlc3QgPSByZXF1aXJlKFwiLi9ub25JdGVyYWJsZVJlc3QuanNcIik7XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgbm9uSXRlcmFibGVSZXN0KCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NsaWNlZFRvQXJyYXk7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwidmFyIGFycmF5V2l0aG91dEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRob3V0SG9sZXMuanNcIik7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXkuanNcIik7XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzXCIpO1xuXG52YXIgbm9uSXRlcmFibGVTcHJlYWQgPSByZXF1aXJlKFwiLi9ub25JdGVyYWJsZVNwcmVhZC5qc1wiKTtcblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3RvQ29uc3VtYWJsZUFycmF5O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3R5cGVvZjtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXkuanNcIik7XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsInZhciBBc3luY0dlbmVyYXRvciA9IHJlcXVpcmUoXCIuL0FzeW5jR2VuZXJhdG9yLmpzXCIpO1xuXG5mdW5jdGlvbiBfd3JhcEFzeW5jR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBBc3luY0dlbmVyYXRvcihmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfd3JhcEFzeW5jR2VuZXJhdG9yO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsInZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL2dldFByb3RvdHlwZU9mLmpzXCIpO1xuXG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZi5qc1wiKTtcblxudmFyIGlzTmF0aXZlRnVuY3Rpb24gPSByZXF1aXJlKFwiLi9pc05hdGl2ZUZ1bmN0aW9uLmpzXCIpO1xuXG52YXIgY29uc3RydWN0ID0gcmVxdWlyZShcIi4vY29uc3RydWN0LmpzXCIpO1xuXG5mdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gIHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICAgIGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzcztcblxuICAgIGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTtcblxuICAgICAgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcbiAgICAgIHJldHVybiBjb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpO1xuICAgIH1cblxuICAgIFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBXcmFwcGVyLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuICByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3dyYXBOYXRpdmVTdXBlcjtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZmV0Y2hGaWxlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9mZXRjaEZpbGUuZmV0Y2hGaWxlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlYWRBcnJheUJ1ZmZlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfcmVhZEFycmF5QnVmZmVyLnJlYWRBcnJheUJ1ZmZlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWFkRmlsZVN5bmNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3JlYWRGaWxlLnJlYWRGaWxlU3luYztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ3cml0ZUZpbGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3dyaXRlRmlsZS53cml0ZUZpbGU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwid3JpdGVGaWxlU3luY1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfd3JpdGVGaWxlLndyaXRlRmlsZVN5bmM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2V0TG9hZGVyT3B0aW9uc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2V0TG9hZGVyT3B0aW9ucy5zZXRMb2FkZXJPcHRpb25zO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlZ2lzdGVyTG9hZGVyc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfcmVnaXN0ZXJMb2FkZXJzLnJlZ2lzdGVyTG9hZGVycztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfdW5yZWdpc3RlckxvYWRlcnNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3JlZ2lzdGVyTG9hZGVycy5fdW5yZWdpc3RlckxvYWRlcnM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2VsZWN0TG9hZGVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zZWxlY3RMb2FkZXIuc2VsZWN0TG9hZGVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNlbGVjdExvYWRlclN5bmNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NlbGVjdExvYWRlci5zZWxlY3RMb2FkZXJTeW5jO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9wYXJzZS5wYXJzZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZVN5bmNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3BhcnNlU3luYy5wYXJzZVN5bmM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VJbkJhdGNoZXNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3BhcnNlSW5CYXRjaGVzLnBhcnNlSW5CYXRjaGVzO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxvYWRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2xvYWQubG9hZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJsb2FkSW5CYXRjaGVzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9sb2FkSW5CYXRjaGVzLmxvYWRJbkJhdGNoZXM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9lbmNvZGUuZW5jb2RlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZVN5bmNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2VuY29kZS5lbmNvZGVTeW5jO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZUluQmF0Y2hlc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZW5jb2RlLmVuY29kZUluQmF0Y2hlcztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVUZXh0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9lbmNvZGUuZW5jb2RlVGV4dDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVVUkx0b1VSTFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZW5jb2RlLmVuY29kZVVSTHRvVVJMO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNhdmVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NhdmUuc2F2ZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzYXZlU3luY1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2F2ZS5zYXZlU3luYztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzZXRQYXRoUHJlZml4XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9sb2FkZXJVdGlscy5zZXRQYXRoUHJlZml4O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFBhdGhQcmVmaXhcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2xvYWRlclV0aWxzLmdldFBhdGhQcmVmaXg7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVzb2x2ZVBhdGhcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2xvYWRlclV0aWxzLnJlc29sdmVQYXRoO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RTY2hlZHVsZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2xvYWRlclV0aWxzLlJlcXVlc3RTY2hlZHVsZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSlNPTkxvYWRlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbG9hZGVyVXRpbHMuSlNPTkxvYWRlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0Jyb3dzZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2xvYWRlclV0aWxzLmlzQnJvd3NlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1dvcmtlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbG9hZGVyVXRpbHMuaXNXb3JrZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2VsZlwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbG9hZGVyVXRpbHMuc2VsZjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ3aW5kb3dcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2xvYWRlclV0aWxzLndpbmRvdztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnbG9iYWxcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2xvYWRlclV0aWxzLmdsb2JhbDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkb2N1bWVudFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbG9hZGVyVXRpbHMuZG9jdW1lbnQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXNzZXJ0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9sb2FkZXJVdGlscy5hc3NlcnQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZm9yRWFjaFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbG9hZGVyVXRpbHMuZm9yRWFjaDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb25jYXRlbmF0ZUFycmF5QnVmZmVyc0FzeW5jXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9sb2FkZXJVdGlscy5jb25jYXRlbmF0ZUFycmF5QnVmZmVyc0FzeW5jO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1ha2VUZXh0RGVjb2Rlckl0ZXJhdG9yXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9sb2FkZXJVdGlscy5tYWtlVGV4dERlY29kZXJJdGVyYXRvcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYWtlVGV4dEVuY29kZXJJdGVyYXRvclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbG9hZGVyVXRpbHMubWFrZVRleHRFbmNvZGVySXRlcmF0b3I7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWFrZUxpbmVJdGVyYXRvclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbG9hZGVyVXRpbHMubWFrZUxpbmVJdGVyYXRvcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYWtlTnVtYmVyZWRMaW5lSXRlcmF0b3JcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2xvYWRlclV0aWxzLm1ha2VOdW1iZXJlZExpbmVJdGVyYXRvcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYWtlSXRlcmF0b3JcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX21ha2VJdGVyYXRvci5tYWtlSXRlcmF0b3I7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWFrZVN0cmVhbVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbWFrZVN0cmVhbS5tYWtlU3RyZWFtO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1ha2VET01TdHJlYW1cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX21ha2VEb21TdHJlYW0ubWFrZURPTVN0cmVhbTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYWtlTm9kZVN0cmVhbVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbWFrZU5vZGVTdHJlYW0uZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOdWxsV29ya2VyTG9hZGVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9udWxsTG9hZGVyLk51bGxXb3JrZXJMb2FkZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTnVsbExvYWRlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbnVsbExvYWRlci5OdWxsTG9hZGVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9mZXRjaFByb2dyZXNzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9mZXRjaFByb2dyZXNzLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX0Jyb3dzZXJGaWxlU3lzdGVtXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9icm93c2VyRmlsZXN5c3RlbS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzUHVyZU9iamVjdFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaXNUeXBlLmlzUHVyZU9iamVjdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1Byb21pc2VcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2lzVHlwZS5pc1Byb21pc2U7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNJdGVyYWJsZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaXNUeXBlLmlzSXRlcmFibGU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNBc3luY0l0ZXJhYmxlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pc1R5cGUuaXNBc3luY0l0ZXJhYmxlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzSXRlcmF0b3JcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2lzVHlwZS5pc0l0ZXJhdG9yO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzUmVzcG9uc2VcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2lzVHlwZS5pc1Jlc3BvbnNlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzUmVhZGFibGVTdHJlYW1cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2lzVHlwZS5pc1JlYWRhYmxlU3RyZWFtO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzV3JpdGFibGVTdHJlYW1cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2lzVHlwZS5pc1dyaXRhYmxlU3RyZWFtO1xuICB9XG59KTtcblxudmFyIF9mZXRjaEZpbGUgPSByZXF1aXJlKFwiLi9saWIvZmV0Y2gvZmV0Y2gtZmlsZVwiKTtcblxudmFyIF9yZWFkQXJyYXlCdWZmZXIgPSByZXF1aXJlKFwiLi9saWIvZmV0Y2gvcmVhZC1hcnJheS1idWZmZXJcIik7XG5cbnZhciBfcmVhZEZpbGUgPSByZXF1aXJlKFwiLi9saWIvZmV0Y2gvcmVhZC1maWxlXCIpO1xuXG52YXIgX3dyaXRlRmlsZSA9IHJlcXVpcmUoXCIuL2xpYi9mZXRjaC93cml0ZS1maWxlXCIpO1xuXG52YXIgX3NldExvYWRlck9wdGlvbnMgPSByZXF1aXJlKFwiLi9saWIvYXBpL3NldC1sb2FkZXItb3B0aW9uc1wiKTtcblxudmFyIF9yZWdpc3RlckxvYWRlcnMgPSByZXF1aXJlKFwiLi9saWIvYXBpL3JlZ2lzdGVyLWxvYWRlcnNcIik7XG5cbnZhciBfc2VsZWN0TG9hZGVyID0gcmVxdWlyZShcIi4vbGliL2FwaS9zZWxlY3QtbG9hZGVyXCIpO1xuXG52YXIgX3BhcnNlID0gcmVxdWlyZShcIi4vbGliL2FwaS9wYXJzZVwiKTtcblxudmFyIF9wYXJzZVN5bmMgPSByZXF1aXJlKFwiLi9saWIvYXBpL3BhcnNlLXN5bmNcIik7XG5cbnZhciBfcGFyc2VJbkJhdGNoZXMgPSByZXF1aXJlKFwiLi9saWIvYXBpL3BhcnNlLWluLWJhdGNoZXNcIik7XG5cbnZhciBfbG9hZCA9IHJlcXVpcmUoXCIuL2xpYi9hcGkvbG9hZFwiKTtcblxudmFyIF9sb2FkSW5CYXRjaGVzID0gcmVxdWlyZShcIi4vbGliL2FwaS9sb2FkLWluLWJhdGNoZXNcIik7XG5cbnZhciBfZW5jb2RlID0gcmVxdWlyZShcIi4vbGliL2FwaS9lbmNvZGVcIik7XG5cbnZhciBfc2F2ZSA9IHJlcXVpcmUoXCIuL2xpYi9hcGkvc2F2ZVwiKTtcblxudmFyIF9sb2FkZXJVdGlscyA9IHJlcXVpcmUoXCJAbG9hZGVycy5nbC9sb2FkZXItdXRpbHNcIik7XG5cbnZhciBfbWFrZUl0ZXJhdG9yID0gcmVxdWlyZShcIi4vaXRlcmF0b3JzL21ha2UtaXRlcmF0b3IvbWFrZS1pdGVyYXRvclwiKTtcblxudmFyIF9tYWtlU3RyZWFtID0gcmVxdWlyZShcIi4vaXRlcmF0b3JzL21ha2Utc3RyZWFtL21ha2Utc3RyZWFtXCIpO1xuXG52YXIgX21ha2VEb21TdHJlYW0gPSByZXF1aXJlKFwiLi9pdGVyYXRvcnMvbWFrZS1zdHJlYW0vbWFrZS1kb20tc3RyZWFtXCIpO1xuXG52YXIgX21ha2VOb2RlU3RyZWFtID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pdGVyYXRvcnMvbWFrZS1zdHJlYW0vbWFrZS1ub2RlLXN0cmVhbVwiKSk7XG5cbnZhciBfbnVsbExvYWRlciA9IHJlcXVpcmUoXCIuL251bGwtbG9hZGVyXCIpO1xuXG52YXIgX2ZldGNoUHJvZ3Jlc3MgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9wcm9ncmVzcy9mZXRjaC1wcm9ncmVzc1wiKSk7XG5cbnZhciBfYnJvd3NlckZpbGVzeXN0ZW0gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9maWxlc3lzdGVtcy9icm93c2VyLWZpbGVzeXN0ZW1cIikpO1xuXG52YXIgX2lzVHlwZSA9IHJlcXVpcmUoXCIuL2phdmFzY3JpcHQtdXRpbHMvaXMtdHlwZVwiKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubWFrZUFycmF5QnVmZmVySXRlcmF0b3IgPSBtYWtlQXJyYXlCdWZmZXJJdGVyYXRvcjtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9tYXJrZWQgPSBfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKG1ha2VBcnJheUJ1ZmZlckl0ZXJhdG9yKTtcblxudmFyIERFRkFVTFRfQ0hVTktfU0laRSA9IDI1NiAqIDEwMjQ7XG5cbmZ1bmN0aW9uIG1ha2VBcnJheUJ1ZmZlckl0ZXJhdG9yKGFycmF5QnVmZmVyKSB7XG4gIHZhciBvcHRpb25zLFxuICAgICAgX29wdGlvbnMkY2h1bmtTaXplLFxuICAgICAgY2h1bmtTaXplLFxuICAgICAgYnl0ZU9mZnNldCxcbiAgICAgIGNodW5rQnl0ZUxlbmd0aCxcbiAgICAgIGNodW5rLFxuICAgICAgc291cmNlQXJyYXksXG4gICAgICBjaHVua0FycmF5LFxuICAgICAgX2FyZ3MgPSBhcmd1bWVudHM7XG5cbiAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gbWFrZUFycmF5QnVmZmVySXRlcmF0b3IkKF9jb250ZXh0KSB7XG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIG9wdGlvbnMgPSBfYXJncy5sZW5ndGggPiAxICYmIF9hcmdzWzFdICE9PSB1bmRlZmluZWQgPyBfYXJnc1sxXSA6IHt9O1xuICAgICAgICAgIF9vcHRpb25zJGNodW5rU2l6ZSA9IG9wdGlvbnMuY2h1bmtTaXplLCBjaHVua1NpemUgPSBfb3B0aW9ucyRjaHVua1NpemUgPT09IHZvaWQgMCA/IERFRkFVTFRfQ0hVTktfU0laRSA6IF9vcHRpb25zJGNodW5rU2l6ZTtcbiAgICAgICAgICBieXRlT2Zmc2V0ID0gMDtcblxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgaWYgKCEoYnl0ZU9mZnNldCA8IGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpKSB7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaHVua0J5dGVMZW5ndGggPSBNYXRoLm1pbihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoIC0gYnl0ZU9mZnNldCwgY2h1bmtTaXplKTtcbiAgICAgICAgICBjaHVuayA9IG5ldyBBcnJheUJ1ZmZlcihjaHVua0J5dGVMZW5ndGgpO1xuICAgICAgICAgIHNvdXJjZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIsIGJ5dGVPZmZzZXQsIGNodW5rQnl0ZUxlbmd0aCk7XG4gICAgICAgICAgY2h1bmtBcnJheSA9IG5ldyBVaW50OEFycmF5KGNodW5rKTtcbiAgICAgICAgICBjaHVua0FycmF5LnNldChzb3VyY2VBcnJheSk7XG4gICAgICAgICAgYnl0ZU9mZnNldCArPSBjaHVua0J5dGVMZW5ndGg7XG4gICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEyO1xuICAgICAgICAgIHJldHVybiBjaHVuaztcblxuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTQ6XG4gICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgX21hcmtlZCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWtlLWFycmF5LWJ1ZmZlci1pdGVyYXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm1ha2VCbG9iSXRlcmF0b3IgPSBtYWtlQmxvYkl0ZXJhdG9yO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2F3YWl0QXN5bmNHZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hd2FpdEFzeW5jR2VuZXJhdG9yXCIpKTtcblxudmFyIF93cmFwQXN5bmNHZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy93cmFwQXN5bmNHZW5lcmF0b3JcIikpO1xuXG52YXIgREVGQVVMVF9DSFVOS19TSVpFID0gMTAyNCAqIDEwMjQ7XG5cbmZ1bmN0aW9uIG1ha2VCbG9iSXRlcmF0b3IoX3gsIF94Mikge1xuICByZXR1cm4gX21ha2VCbG9iSXRlcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX21ha2VCbG9iSXRlcmF0b3IoKSB7XG4gIF9tYWtlQmxvYkl0ZXJhdG9yID0gKDAsIF93cmFwQXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZShibG9iLCBvcHRpb25zKSB7XG4gICAgdmFyIGNodW5rU2l6ZSwgb2Zmc2V0LCBlbmQsIGNodW5rO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2h1bmtTaXplID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jaHVua1NpemUpIHx8IERFRkFVTFRfQ0hVTktfU0laRTtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBpZiAoIShvZmZzZXQgPCBibG9iLnNpemUpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVuZCA9IG9mZnNldCArIGNodW5rU2l6ZTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2O1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfYXdhaXRBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoYmxvYi5zbGljZShvZmZzZXQsIGVuZCkuYXJyYXlCdWZmZXIoKSk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBjaHVuayA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTA7XG4gICAgICAgICAgICByZXR1cm4gY2h1bms7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUpO1xuICB9KSk7XG4gIHJldHVybiBfbWFrZUJsb2JJdGVyYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFrZS1ibG9iLWl0ZXJhdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5tYWtlSXRlcmF0b3IgPSBtYWtlSXRlcmF0b3I7XG5cbnZhciBfbWFrZVN0cmluZ0l0ZXJhdG9yID0gcmVxdWlyZShcIi4vbWFrZS1zdHJpbmctaXRlcmF0b3JcIik7XG5cbnZhciBfbWFrZUFycmF5QnVmZmVySXRlcmF0b3IgPSByZXF1aXJlKFwiLi9tYWtlLWFycmF5LWJ1ZmZlci1pdGVyYXRvclwiKTtcblxudmFyIF9tYWtlQmxvYkl0ZXJhdG9yID0gcmVxdWlyZShcIi4vbWFrZS1ibG9iLWl0ZXJhdG9yXCIpO1xuXG52YXIgX21ha2VTdHJlYW1JdGVyYXRvciA9IHJlcXVpcmUoXCIuL21ha2Utc3RyZWFtLWl0ZXJhdG9yXCIpO1xuXG52YXIgX2lzVHlwZSA9IHJlcXVpcmUoXCIuLi8uLi9qYXZhc2NyaXB0LXV0aWxzL2lzLXR5cGVcIik7XG5cbmZ1bmN0aW9uIG1ha2VJdGVyYXRvcihkYXRhLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gKDAsIF9tYWtlU3RyaW5nSXRlcmF0b3IubWFrZVN0cmluZ0l0ZXJhdG9yKShkYXRhLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gKDAsIF9tYWtlQXJyYXlCdWZmZXJJdGVyYXRvci5tYWtlQXJyYXlCdWZmZXJJdGVyYXRvcikoZGF0YSwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoKDAsIF9pc1R5cGUuaXNCbG9iKShkYXRhKSkge1xuICAgIHJldHVybiAoMCwgX21ha2VCbG9iSXRlcmF0b3IubWFrZUJsb2JJdGVyYXRvcikoZGF0YSwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoKDAsIF9pc1R5cGUuaXNSZWFkYWJsZVN0cmVhbSkoZGF0YSkpIHtcbiAgICByZXR1cm4gKDAsIF9tYWtlU3RyZWFtSXRlcmF0b3IubWFrZVN0cmVhbUl0ZXJhdG9yKShkYXRhLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmICgoMCwgX2lzVHlwZS5pc1Jlc3BvbnNlKShkYXRhKSkge1xuICAgIHZhciByZXNwb25zZSA9IGRhdGE7XG4gICAgcmV0dXJuICgwLCBfbWFrZVN0cmVhbUl0ZXJhdG9yLm1ha2VTdHJlYW1JdGVyYXRvcikocmVzcG9uc2UuYm9keSwgb3B0aW9ucyk7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ21ha2VJdGVyYXRvcicpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFrZS1pdGVyYXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm1ha2VTdHJlYW1JdGVyYXRvciA9IG1ha2VTdHJlYW1JdGVyYXRvcjtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY0l0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNJdGVyYXRvclwiKSk7XG5cbnZhciBfYXdhaXRBc3luY0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2F3YWl0QXN5bmNHZW5lcmF0b3JcIikpO1xuXG52YXIgX3dyYXBBc3luY0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3dyYXBBc3luY0dlbmVyYXRvclwiKSk7XG5cbnZhciBfbG9hZGVyVXRpbHMgPSByZXF1aXJlKFwiQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzXCIpO1xuXG5mdW5jdGlvbiBtYWtlU3RyZWFtSXRlcmF0b3Ioc3RyZWFtLCBvcHRpb25zKSB7XG4gIHJldHVybiBfbG9hZGVyVXRpbHMuaXNCcm93c2VyID8gbWFrZUJyb3dzZXJTdHJlYW1JdGVyYXRvcihzdHJlYW0sIG9wdGlvbnMpIDogbWFrZU5vZGVTdHJlYW1JdGVyYXRvcihzdHJlYW0sIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBtYWtlQnJvd3NlclN0cmVhbUl0ZXJhdG9yKF94LCBfeDIpIHtcbiAgcmV0dXJuIF9tYWtlQnJvd3NlclN0cmVhbUl0ZXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9tYWtlQnJvd3NlclN0cmVhbUl0ZXJhdG9yKCkge1xuICBfbWFrZUJyb3dzZXJTdHJlYW1JdGVyYXRvciA9ICgwLCBfd3JhcEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoc3RyZWFtLCBvcHRpb25zKSB7XG4gICAgdmFyIHJlYWRlciwgbmV4dEJhdGNoUHJvbWlzZSwgY3VycmVudEJhdGNoUHJvbWlzZSwgX3lpZWxkJF9hd2FpdEFzeW5jR2VuLCBkb25lLCB2YWx1ZTtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDE7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBpZiAoIXRydWUpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE2O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudEJhdGNoUHJvbWlzZSA9IG5leHRCYXRjaFByb21pc2UgfHwgcmVhZGVyLnJlYWQoKTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwICYmIG9wdGlvbnMuX3N0cmVhbVJlYWRBaGVhZCkge1xuICAgICAgICAgICAgICBuZXh0QmF0Y2hQcm9taXNlID0gcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9hd2FpdEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShjdXJyZW50QmF0Y2hQcm9taXNlKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIF95aWVsZCRfYXdhaXRBc3luY0dlbiA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICBkb25lID0gX3lpZWxkJF9hd2FpdEFzeW5jR2VuLmRvbmU7XG4gICAgICAgICAgICB2YWx1ZSA9IF95aWVsZCRfYXdhaXRBc3luY0dlbi52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIik7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE0O1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfbG9hZGVyVXRpbHMudG9BcnJheUJ1ZmZlcikodmFsdWUpO1xuXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIxO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDE4O1xuICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDEpO1xuICAgICAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG5cbiAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlLCBudWxsLCBbWzEsIDE4XV0pO1xuICB9KSk7XG4gIHJldHVybiBfbWFrZUJyb3dzZXJTdHJlYW1JdGVyYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBtYWtlTm9kZVN0cmVhbUl0ZXJhdG9yKF94MywgX3g0KSB7XG4gIHJldHVybiBfbWFrZU5vZGVTdHJlYW1JdGVyYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfbWFrZU5vZGVTdHJlYW1JdGVyYXRvcigpIHtcbiAgX21ha2VOb2RlU3RyZWFtSXRlcmF0b3IgPSAoMCwgX3dyYXBBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMihzdHJlYW0sIG9wdGlvbnMpIHtcbiAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiwgX2RpZEl0ZXJhdG9yRXJyb3IsIF9pdGVyYXRvckVycm9yLCBfaXRlcmF0b3IsIF9zdGVwLCBfdmFsdWUsIGNodW5rO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAyO1xuICAgICAgICAgICAgX2l0ZXJhdG9yID0gKDAsIF9hc3luY0l0ZXJhdG9yMi5kZWZhdWx0KShzdHJlYW0pO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA2O1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfYXdhaXRBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoX2l0ZXJhdG9yLm5leHQoKSk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBfc3RlcCA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IF9zdGVwLmRvbmU7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEwO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfYXdhaXRBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoX3N0ZXAudmFsdWUpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIF92YWx1ZSA9IF9jb250ZXh0Mi5zZW50O1xuXG4gICAgICAgICAgICBpZiAoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbikge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2h1bmsgPSBfdmFsdWU7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE1O1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfbG9hZGVyVXRpbHMudG9BcnJheUJ1ZmZlcikoY2h1bmspO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA0O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyNDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMjA7XG4gICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDJbXCJjYXRjaFwiXSgyKTtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gX2NvbnRleHQyLnQwO1xuXG4gICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMjQ7XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDI1O1xuXG4gICAgICAgICAgICBpZiAoISghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI5O1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfYXdhaXRBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoX2l0ZXJhdG9yLnJldHVybigpKTtcblxuICAgICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDI5O1xuXG4gICAgICAgICAgICBpZiAoIV9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMzI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcblxuICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmZpbmlzaCgyOSk7XG5cbiAgICAgICAgICBjYXNlIDMzOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5maW5pc2goMjQpO1xuXG4gICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyLCBudWxsLCBbWzIsIDIwLCAyNCwgMzRdLCBbMjUsLCAyOSwgMzNdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9tYWtlTm9kZVN0cmVhbUl0ZXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWtlLXN0cmVhbS1pdGVyYXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm1ha2VTdHJpbmdJdGVyYXRvciA9IG1ha2VTdHJpbmdJdGVyYXRvcjtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9tYXJrZWQgPSBfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKG1ha2VTdHJpbmdJdGVyYXRvcik7XG5cbnZhciBERUZBVUxUX0NIVU5LX1NJWkUgPSAyNTYgKiAxMDI0O1xuXG5mdW5jdGlvbiBtYWtlU3RyaW5nSXRlcmF0b3Ioc3RyaW5nLCBvcHRpb25zKSB7XG4gIHZhciBjaHVua1NpemUsIG9mZnNldCwgdGV4dEVuY29kZXIsIGNodW5rTGVuZ3RoLCBjaHVuaztcbiAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gbWFrZVN0cmluZ0l0ZXJhdG9yJChfY29udGV4dCkge1xuICAgIHdoaWxlICgxKSB7XG4gICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjaHVua1NpemUgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNodW5rU2l6ZSkgfHwgREVGQVVMVF9DSFVOS19TSVpFO1xuICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcblxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgaWYgKCEob2Zmc2V0IDwgc3RyaW5nLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNodW5rTGVuZ3RoID0gTWF0aC5taW4oc3RyaW5nLmxlbmd0aCAtIG9mZnNldCwgY2h1bmtTaXplKTtcbiAgICAgICAgICBjaHVuayA9IHN0cmluZy5zbGljZShvZmZzZXQsIG9mZnNldCArIGNodW5rTGVuZ3RoKTtcbiAgICAgICAgICBvZmZzZXQgKz0gY2h1bmtMZW5ndGg7XG4gICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgcmV0dXJuIHRleHRFbmNvZGVyLmVuY29kZShjaHVuayk7XG5cbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgX21hcmtlZCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWtlLXN0cmluZy1pdGVyYXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm1ha2VET01TdHJlYW0gPSBtYWtlRE9NU3RyZWFtO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIG1ha2VET01TdHJlYW0oc291cmNlLCBvcHRpb25zKSB7XG4gIHZhciBpdGVyYXRvciA9IHNvdXJjZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPyBzb3VyY2VbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkgOiBzb3VyY2VbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICB0eXBlOiAnYnl0ZXMnLFxuICAgIHB1bGw6IGZ1bmN0aW9uIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgcmV0dXJuICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICB2YXIgX3lpZWxkJGl0ZXJhdG9yJG5leHQsIGRvbmUsIHZhbHVlO1xuXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAwO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvci5uZXh0KCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIF95aWVsZCRpdGVyYXRvciRuZXh0ID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgICBkb25lID0gX3lpZWxkJGl0ZXJhdG9yJG5leHQuZG9uZTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IF95aWVsZCRpdGVyYXRvciRuZXh0LnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gOTtcbiAgICAgICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihfY29udGV4dC50MCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCBudWxsLCBbWzAsIDldXSk7XG4gICAgICB9KSkoKTtcbiAgICB9LFxuICAgIGNhbmNlbDogZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgcmV0dXJuICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvciRyZXR1cm47XG5cbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0b3IgPT09IG51bGwgfHwgaXRlcmF0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfaXRlcmF0b3IkcmV0dXJuID0gaXRlcmF0b3IucmV0dXJuKSA9PT0gbnVsbCB8fCBfaXRlcmF0b3IkcmV0dXJuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaXRlcmF0b3IkcmV0dXJuLmNhbGwoaXRlcmF0b3IpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIpO1xuICAgICAgfSkpKCk7XG4gICAgfVxuICB9LCBfb2JqZWN0U3ByZWFkKHtcbiAgICBoaWdoV2F0ZXJNYXJrOiBNYXRoLnBvdygyLCAyNClcbiAgfSwgb3B0aW9ucykpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFrZS1kb20tc3RyZWFtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubWFrZVN0cmVhbSA9IG1ha2VTdHJlYW07XG5cbnZhciBfbG9hZGVyVXRpbHMgPSByZXF1aXJlKFwiQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzXCIpO1xuXG52YXIgX21ha2VEb21TdHJlYW0gPSByZXF1aXJlKFwiLi9tYWtlLWRvbS1zdHJlYW1cIik7XG5cbnZhciBfbWFrZU5vZGVTdHJlYW0gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL21ha2Utbm9kZS1zdHJlYW1cIikpO1xuXG5mdW5jdGlvbiBtYWtlU3RyZWFtKGRhdGEsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9sb2FkZXJVdGlscy5pc0Jyb3dzZXIgPyAoMCwgX21ha2VEb21TdHJlYW0ubWFrZURPTVN0cmVhbSkoZGF0YSwgb3B0aW9ucykgOiAoMCwgX21ha2VOb2RlU3RyZWFtLmRlZmF1bHQpKGRhdGEsIG9wdGlvbnMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFrZS1zdHJlYW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5pc1dyaXRhYmxlU3RyZWFtID0gZXhwb3J0cy5pc1JlYWRhYmxlU3RyZWFtID0gZXhwb3J0cy5pc1JlYWRhYmxlTm9kZVN0cmVhbSA9IGV4cG9ydHMuaXNXcml0YWJsZU5vZGVTdHJlYW0gPSBleHBvcnRzLmlzQnVmZmVyID0gZXhwb3J0cy5pc1JlYWRhYmxlRE9NU3RyZWFtID0gZXhwb3J0cy5pc1dyaXRhYmxlRE9NU3RyZWFtID0gZXhwb3J0cy5pc0Jsb2IgPSBleHBvcnRzLmlzRmlsZSA9IGV4cG9ydHMuaXNSZXNwb25zZSA9IGV4cG9ydHMuaXNJdGVyYXRvciA9IGV4cG9ydHMuaXNBc3luY0l0ZXJhYmxlID0gZXhwb3J0cy5pc0l0ZXJhYmxlID0gZXhwb3J0cy5pc1Byb21pc2UgPSBleHBvcnRzLmlzUHVyZU9iamVjdCA9IGV4cG9ydHMuaXNPYmplY3QgPSB2b2lkIDA7XG5cbnZhciBfdHlwZW9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpKTtcblxudmFyIGlzQm9vbGVhbiA9IGZ1bmN0aW9uIGlzQm9vbGVhbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Jvb2xlYW4nO1xufTtcblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xufTtcblxudmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3QoeCkge1xuICByZXR1cm4geCAhPT0gbnVsbCAmJiAoMCwgX3R5cGVvZjIuZGVmYXVsdCkoeCkgPT09ICdvYmplY3QnO1xufTtcblxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG52YXIgaXNQdXJlT2JqZWN0ID0gZnVuY3Rpb24gaXNQdXJlT2JqZWN0KHgpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHgpICYmIHguY29uc3RydWN0b3IgPT09IHt9LmNvbnN0cnVjdG9yO1xufTtcblxuZXhwb3J0cy5pc1B1cmVPYmplY3QgPSBpc1B1cmVPYmplY3Q7XG5cbnZhciBpc1Byb21pc2UgPSBmdW5jdGlvbiBpc1Byb21pc2UoeCkge1xuICByZXR1cm4gaXNPYmplY3QoeCkgJiYgaXNGdW5jdGlvbih4LnRoZW4pO1xufTtcblxuZXhwb3J0cy5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5cbnZhciBpc0l0ZXJhYmxlID0gZnVuY3Rpb24gaXNJdGVyYWJsZSh4KSB7XG4gIHJldHVybiB4ICYmIHR5cGVvZiB4W1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG59O1xuXG5leHBvcnRzLmlzSXRlcmFibGUgPSBpc0l0ZXJhYmxlO1xuXG52YXIgaXNBc3luY0l0ZXJhYmxlID0gZnVuY3Rpb24gaXNBc3luY0l0ZXJhYmxlKHgpIHtcbiAgcmV0dXJuIHggJiYgdHlwZW9mIHhbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xufTtcblxuZXhwb3J0cy5pc0FzeW5jSXRlcmFibGUgPSBpc0FzeW5jSXRlcmFibGU7XG5cbnZhciBpc0l0ZXJhdG9yID0gZnVuY3Rpb24gaXNJdGVyYXRvcih4KSB7XG4gIHJldHVybiB4ICYmIGlzRnVuY3Rpb24oeC5uZXh0KTtcbn07XG5cbmV4cG9ydHMuaXNJdGVyYXRvciA9IGlzSXRlcmF0b3I7XG5cbnZhciBpc1Jlc3BvbnNlID0gZnVuY3Rpb24gaXNSZXNwb25zZSh4KSB7XG4gIHJldHVybiB0eXBlb2YgUmVzcG9uc2UgIT09ICd1bmRlZmluZWQnICYmIHggaW5zdGFuY2VvZiBSZXNwb25zZSB8fCB4ICYmIHguYXJyYXlCdWZmZXIgJiYgeC50ZXh0ICYmIHguanNvbjtcbn07XG5cbmV4cG9ydHMuaXNSZXNwb25zZSA9IGlzUmVzcG9uc2U7XG5cbnZhciBpc0ZpbGUgPSBmdW5jdGlvbiBpc0ZpbGUoeCkge1xuICByZXR1cm4gdHlwZW9mIEZpbGUgIT09ICd1bmRlZmluZWQnICYmIHggaW5zdGFuY2VvZiBGaWxlO1xufTtcblxuZXhwb3J0cy5pc0ZpbGUgPSBpc0ZpbGU7XG5cbnZhciBpc0Jsb2IgPSBmdW5jdGlvbiBpc0Jsb2IoeCkge1xuICByZXR1cm4gdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIHggaW5zdGFuY2VvZiBCbG9iO1xufTtcblxuZXhwb3J0cy5pc0Jsb2IgPSBpc0Jsb2I7XG5cbnZhciBpc1dyaXRhYmxlRE9NU3RyZWFtID0gZnVuY3Rpb24gaXNXcml0YWJsZURPTVN0cmVhbSh4KSB7XG4gIHJldHVybiBpc09iamVjdCh4KSAmJiBpc0Z1bmN0aW9uKHguYWJvcnQpICYmIGlzRnVuY3Rpb24oeC5nZXRXcml0ZXIpO1xufTtcblxuZXhwb3J0cy5pc1dyaXRhYmxlRE9NU3RyZWFtID0gaXNXcml0YWJsZURPTVN0cmVhbTtcblxudmFyIGlzUmVhZGFibGVET01TdHJlYW0gPSBmdW5jdGlvbiBpc1JlYWRhYmxlRE9NU3RyZWFtKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiBSZWFkYWJsZVN0cmVhbSAhPT0gJ3VuZGVmaW5lZCcgJiYgeCBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtIHx8IGlzT2JqZWN0KHgpICYmIGlzRnVuY3Rpb24oeC50ZWUpICYmIGlzRnVuY3Rpb24oeC5jYW5jZWwpICYmIGlzRnVuY3Rpb24oeC5nZXRSZWFkZXIpO1xufTtcblxuZXhwb3J0cy5pc1JlYWRhYmxlRE9NU3RyZWFtID0gaXNSZWFkYWJsZURPTVN0cmVhbTtcblxudmFyIGlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIoeCkge1xuICByZXR1cm4geCAmJiAoMCwgX3R5cGVvZjIuZGVmYXVsdCkoeCkgPT09ICdvYmplY3QnICYmIHguaXNCdWZmZXI7XG59O1xuXG5leHBvcnRzLmlzQnVmZmVyID0gaXNCdWZmZXI7XG5cbnZhciBpc1dyaXRhYmxlTm9kZVN0cmVhbSA9IGZ1bmN0aW9uIGlzV3JpdGFibGVOb2RlU3RyZWFtKHgpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHgpICYmIGlzRnVuY3Rpb24oeC5lbmQpICYmIGlzRnVuY3Rpb24oeC53cml0ZSkgJiYgaXNCb29sZWFuKHgud3JpdGFibGUpO1xufTtcblxuZXhwb3J0cy5pc1dyaXRhYmxlTm9kZVN0cmVhbSA9IGlzV3JpdGFibGVOb2RlU3RyZWFtO1xuXG52YXIgaXNSZWFkYWJsZU5vZGVTdHJlYW0gPSBmdW5jdGlvbiBpc1JlYWRhYmxlTm9kZVN0cmVhbSh4KSB7XG4gIHJldHVybiBpc09iamVjdCh4KSAmJiBpc0Z1bmN0aW9uKHgucmVhZCkgJiYgaXNGdW5jdGlvbih4LnBpcGUpICYmIGlzQm9vbGVhbih4LnJlYWRhYmxlKTtcbn07XG5cbmV4cG9ydHMuaXNSZWFkYWJsZU5vZGVTdHJlYW0gPSBpc1JlYWRhYmxlTm9kZVN0cmVhbTtcblxudmFyIGlzUmVhZGFibGVTdHJlYW0gPSBmdW5jdGlvbiBpc1JlYWRhYmxlU3RyZWFtKHgpIHtcbiAgcmV0dXJuIGlzUmVhZGFibGVET01TdHJlYW0oeCkgfHwgaXNSZWFkYWJsZU5vZGVTdHJlYW0oeCk7XG59O1xuXG5leHBvcnRzLmlzUmVhZGFibGVTdHJlYW0gPSBpc1JlYWRhYmxlU3RyZWFtO1xuXG52YXIgaXNXcml0YWJsZVN0cmVhbSA9IGZ1bmN0aW9uIGlzV3JpdGFibGVTdHJlYW0oeCkge1xuICByZXR1cm4gaXNXcml0YWJsZURPTVN0cmVhbSh4KSB8fCBpc1dyaXRhYmxlTm9kZVN0cmVhbSh4KTtcbn07XG5cbmV4cG9ydHMuaXNXcml0YWJsZVN0cmVhbSA9IGlzV3JpdGFibGVTdHJlYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy10eXBlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuZXhwb3J0cy5lbmNvZGVTeW5jID0gZW5jb2RlU3luYztcbmV4cG9ydHMuZW5jb2RlVGV4dCA9IGVuY29kZVRleHQ7XG5leHBvcnRzLmVuY29kZUluQmF0Y2hlcyA9IGVuY29kZUluQmF0Y2hlcztcbmV4cG9ydHMuZW5jb2RlVVJMdG9VUkwgPSBlbmNvZGVVUkx0b1VSTDtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNJdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jSXRlcmF0b3JcIikpO1xuXG52YXIgX2xvYWRlclV0aWxzID0gcmVxdWlyZShcIkBsb2FkZXJzLmdsL2xvYWRlci11dGlsc1wiKTtcblxudmFyIF93cml0ZUZpbGUgPSByZXF1aXJlKFwiLi4vZmV0Y2gvd3JpdGUtZmlsZVwiKTtcblxudmFyIF9mZXRjaEZpbGUgPSByZXF1aXJlKFwiLi4vZmV0Y2gvZmV0Y2gtZmlsZVwiKTtcblxuZnVuY3Rpb24gZW5jb2RlKF94LCBfeDIsIF94Mykge1xuICByZXR1cm4gX2VuY29kZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZW5jb2RlKCkge1xuICBfZW5jb2RlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoZGF0YSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgdmFyIGJhdGNoZXMsIGNodW5rcywgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiwgX2RpZEl0ZXJhdG9yRXJyb3IsIF9pdGVyYXRvckVycm9yLCBfaXRlcmF0b3IsIF9zdGVwLCBfdmFsdWUsIGJhdGNoLCB0bXBJbnB1dEZpbGVuYW1lLCB0bXBPdXRwdXRGaWxlbmFtZSwgb3V0cHV0RmlsZW5hbWUsIHJlc3BvbnNlO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoIXdyaXRlci5lbmNvZGUpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXIuZW5jb2RlKGRhdGEsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dC5zZW50KTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGlmICghd3JpdGVyLmVuY29kZVN5bmMpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHdyaXRlci5lbmNvZGVTeW5jKGRhdGEsIG9wdGlvbnMpKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIGlmICghd3JpdGVyLmVuY29kZVRleHQpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQudDAgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMDtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXIuZW5jb2RlVGV4dChkYXRhLCBvcHRpb25zKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBfY29udGV4dC50MSA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0LnQwLmVuY29kZS5jYWxsKF9jb250ZXh0LnQwLCBfY29udGV4dC50MSkpO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIGlmICghd3JpdGVyLmVuY29kZUluQmF0Y2hlcykge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBiYXRjaGVzID0gZW5jb2RlSW5CYXRjaGVzKGRhdGEsIHdyaXRlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjaHVua3MgPSBbXTtcbiAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxNztcbiAgICAgICAgICAgIF9pdGVyYXRvciA9ICgwLCBfYXN5bmNJdGVyYXRvcjIuZGVmYXVsdCkoYmF0Y2hlcyk7XG5cbiAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIxO1xuICAgICAgICAgICAgcmV0dXJuIF9pdGVyYXRvci5uZXh0KCk7XG5cbiAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgX3N0ZXAgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IF9zdGVwLmRvbmU7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjU7XG4gICAgICAgICAgICByZXR1cm4gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgX3ZhbHVlID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgaWYgKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24pIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDMyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYmF0Y2ggPSBfdmFsdWU7XG4gICAgICAgICAgICBjaHVua3MucHVzaChiYXRjaCk7XG5cbiAgICAgICAgICBjYXNlIDI5OlxuICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMzg7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMzQ7XG4gICAgICAgICAgICBfY29udGV4dC50MiA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMTcpO1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBfY29udGV4dC50MjtcblxuICAgICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMzg7XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMzk7XG5cbiAgICAgICAgICAgIGlmICghKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQzO1xuICAgICAgICAgICAgcmV0dXJuIF9pdGVyYXRvci5yZXR1cm4oKTtcblxuICAgICAgICAgIGNhc2UgNDM6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gNDM7XG5cbiAgICAgICAgICAgIGlmICghX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ2O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG5cbiAgICAgICAgICBjYXNlIDQ2OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmZpbmlzaCg0Myk7XG5cbiAgICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmZpbmlzaCgzOCk7XG5cbiAgICAgICAgICBjYXNlIDQ4OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBfbG9hZGVyVXRpbHMuY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnMuYXBwbHkodm9pZCAwLCBjaHVua3MpKTtcblxuICAgICAgICAgIGNhc2UgNDk6XG4gICAgICAgICAgICBpZiAoISghX2xvYWRlclV0aWxzLmlzQnJvd3NlciAmJiB3cml0ZXIuZW5jb2RlVVJMdG9VUkwpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2MTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRtcElucHV0RmlsZW5hbWUgPSBnZXRUZW1wb3JhcnlGaWxlbmFtZSgnaW5wdXQnKTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA1MztcbiAgICAgICAgICAgIHJldHVybiAoMCwgX3dyaXRlRmlsZS53cml0ZUZpbGUpKHRtcElucHV0RmlsZW5hbWUsIGRhdGEpO1xuXG4gICAgICAgICAgY2FzZSA1MzpcbiAgICAgICAgICAgIHRtcE91dHB1dEZpbGVuYW1lID0gZ2V0VGVtcG9yYXJ5RmlsZW5hbWUoJ291dHB1dCcpO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDU2O1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZVVSTHRvVVJMKHRtcElucHV0RmlsZW5hbWUsIHRtcE91dHB1dEZpbGVuYW1lLCB3cml0ZXIsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgY2FzZSA1NjpcbiAgICAgICAgICAgIG91dHB1dEZpbGVuYW1lID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA1OTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2ZldGNoRmlsZS5mZXRjaEZpbGUpKG91dHB1dEZpbGVuYW1lKTtcblxuICAgICAgICAgIGNhc2UgNTk6XG4gICAgICAgICAgICByZXNwb25zZSA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpO1xuXG4gICAgICAgICAgY2FzZSA2MTpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV3JpdGVyIGNvdWxkIG5vdCBlbmNvZGUgZGF0YScpO1xuXG4gICAgICAgICAgY2FzZSA2MjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSwgbnVsbCwgW1sxNywgMzQsIDM4LCA0OF0sIFszOSwsIDQzLCA0N11dKTtcbiAgfSkpO1xuICByZXR1cm4gX2VuY29kZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVTeW5jKGRhdGEsIHdyaXRlciwgb3B0aW9ucykge1xuICBpZiAod3JpdGVyLmVuY29kZVN5bmMpIHtcbiAgICByZXR1cm4gd3JpdGVyLmVuY29kZVN5bmMoZGF0YSwgb3B0aW9ucyk7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1dyaXRlciBjb3VsZCBub3Qgc3luY2hyb25vdXNseSBlbmNvZGUgZGF0YScpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVUZXh0KF94NCwgX3g1LCBfeDYpIHtcbiAgcmV0dXJuIF9lbmNvZGVUZXh0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9lbmNvZGVUZXh0KCkge1xuICBfZW5jb2RlVGV4dCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMihkYXRhLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICB2YXIgYXJyYXlCdWZmZXI7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCEod3JpdGVyLnRleHQgJiYgd3JpdGVyLmVuY29kZVRleHQpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXIuZW5jb2RlVGV4dChkYXRhLCBvcHRpb25zKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0Mi5zZW50KTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGlmICghKHdyaXRlci50ZXh0ICYmICh3cml0ZXIuZW5jb2RlIHx8IHdyaXRlci5lbmNvZGVJbkJhdGNoZXMpKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDc7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlKGRhdGEsIHdyaXRlciwgb3B0aW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBhcnJheUJ1ZmZlciA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGFycmF5QnVmZmVyKSk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dyaXRlciBjb3VsZCBub3QgZW5jb2RlIGRhdGEgYXMgdGV4dCcpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyKTtcbiAgfSkpO1xuICByZXR1cm4gX2VuY29kZVRleHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlSW5CYXRjaGVzKGRhdGEsIHdyaXRlciwgb3B0aW9ucykge1xuICBpZiAod3JpdGVyLmVuY29kZUluQmF0Y2hlcykge1xuICAgIHZhciBkYXRhSXRlcmF0b3IgPSBnZXRJdGVyYXRvcihkYXRhKTtcbiAgICByZXR1cm4gd3JpdGVyLmVuY29kZUluQmF0Y2hlcyhkYXRhSXRlcmF0b3IsIG9wdGlvbnMpO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdXcml0ZXIgY291bGQgbm90IGVuY29kZSBkYXRhIGluIGJhdGNoZXMnKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlVVJMdG9VUkwoX3g3LCBfeDgsIF94OSwgX3gxMCkge1xuICByZXR1cm4gX2VuY29kZVVSTHRvVVJMLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9lbmNvZGVVUkx0b1VSTCgpIHtcbiAgX2VuY29kZVVSTHRvVVJMID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKGlucHV0VXJsLCBvdXRwdXRVcmwsIHdyaXRlciwgb3B0aW9ucykge1xuICAgIHZhciBvdXRwdXRGaWxlbmFtZTtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpbnB1dFVybCA9ICgwLCBfbG9hZGVyVXRpbHMucmVzb2x2ZVBhdGgpKGlucHV0VXJsKTtcbiAgICAgICAgICAgIG91dHB1dFVybCA9ICgwLCBfbG9hZGVyVXRpbHMucmVzb2x2ZVBhdGgpKG91dHB1dFVybCk7XG5cbiAgICAgICAgICAgIGlmICghKF9sb2FkZXJVdGlscy5pc0Jyb3dzZXIgfHwgIXdyaXRlci5lbmNvZGVVUkx0b1VSTCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDY7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyLmVuY29kZVVSTHRvVVJMKGlucHV0VXJsLCBvdXRwdXRVcmwsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgb3V0cHV0RmlsZW5hbWUgPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIG91dHB1dEZpbGVuYW1lKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUzKTtcbiAgfSkpO1xuICByZXR1cm4gX2VuY29kZVVSTHRvVVJMLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yKGRhdGEpIHtcbiAgdmFyIGRhdGFJdGVyYXRvciA9IFt7XG4gICAgdGFibGU6IGRhdGEsXG4gICAgc3RhcnQ6IDAsXG4gICAgZW5kOiBkYXRhLmxlbmd0aFxuICB9XTtcbiAgcmV0dXJuIGRhdGFJdGVyYXRvcjtcbn1cblxuZnVuY3Rpb24gZ2V0VGVtcG9yYXJ5RmlsZW5hbWUoZmlsZW5hbWUpIHtcbiAgcmV0dXJuIFwiL3RtcC9cIi5jb25jYXQoZmlsZW5hbWUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5jb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubG9hZEluQmF0Y2hlcyA9IGxvYWRJbkJhdGNoZXM7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX25vcm1hbGl6ZUxvYWRlciA9IHJlcXVpcmUoXCIuLi9sb2FkZXItdXRpbHMvbm9ybWFsaXplLWxvYWRlclwiKTtcblxudmFyIF9vcHRpb25VdGlscyA9IHJlcXVpcmUoXCIuLi9sb2FkZXItdXRpbHMvb3B0aW9uLXV0aWxzXCIpO1xuXG52YXIgX3BhcnNlSW5CYXRjaGVzID0gcmVxdWlyZShcIi4vcGFyc2UtaW4tYmF0Y2hlc1wiKTtcblxuZnVuY3Rpb24gbG9hZEluQmF0Y2hlcyhmaWxlcywgbG9hZGVycywgb3B0aW9ucywgY29udGV4dCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobG9hZGVycykgJiYgISgwLCBfbm9ybWFsaXplTG9hZGVyLmlzTG9hZGVyT2JqZWN0KShsb2FkZXJzKSkge1xuICAgIGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgb3B0aW9ucyA9IGxvYWRlcnM7XG4gICAgbG9hZGVycyA9IG51bGw7XG4gIH1cblxuICB2YXIgZmV0Y2ggPSAoMCwgX29wdGlvblV0aWxzLmdldEZldGNoRnVuY3Rpb24pKG9wdGlvbnMgfHwge30pO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShmaWxlcykpIHtcbiAgICByZXR1cm4gbG9hZE9uZUZpbGVJbkJhdGNoZXMoZmlsZXMsIGxvYWRlcnMsIG9wdGlvbnMsIGZldGNoKTtcbiAgfVxuXG4gIHZhciBwcm9taXNlcyA9IGZpbGVzLm1hcChmdW5jdGlvbiAoZmlsZSkge1xuICAgIHJldHVybiBsb2FkT25lRmlsZUluQmF0Y2hlcyhmaWxlLCBsb2FkZXJzLCBvcHRpb25zLCBmZXRjaCk7XG4gIH0pO1xuICByZXR1cm4gcHJvbWlzZXM7XG59XG5cbmZ1bmN0aW9uIGxvYWRPbmVGaWxlSW5CYXRjaGVzKF94LCBfeDIsIF94MywgX3g0KSB7XG4gIHJldHVybiBfbG9hZE9uZUZpbGVJbkJhdGNoZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2xvYWRPbmVGaWxlSW5CYXRjaGVzKCkge1xuICBfbG9hZE9uZUZpbGVJbkJhdGNoZXMgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZShmaWxlLCBsb2FkZXJzLCBvcHRpb25zLCBmZXRjaCkge1xuICAgIHZhciB1cmwsIHJlc3BvbnNlO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCEodHlwZW9mIGZpbGUgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVybCA9IGZpbGU7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaCh1cmwpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmVzcG9uc2UgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9wYXJzZUluQmF0Y2hlcy5wYXJzZUluQmF0Y2hlcykocmVzcG9uc2UsIGxvYWRlcnMsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dC5zZW50KTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMDtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX3BhcnNlSW5CYXRjaGVzLnBhcnNlSW5CYXRjaGVzKShmaWxlLCBsb2FkZXJzLCBvcHRpb25zKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0LnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9sb2FkT25lRmlsZUluQmF0Y2hlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZC1pbi1iYXRjaGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2lzVHlwZSA9IHJlcXVpcmUoXCIuLi8uLi9qYXZhc2NyaXB0LXV0aWxzL2lzLXR5cGVcIik7XG5cbnZhciBfbm9ybWFsaXplTG9hZGVyID0gcmVxdWlyZShcIi4uL2xvYWRlci11dGlscy9ub3JtYWxpemUtbG9hZGVyXCIpO1xuXG52YXIgX29wdGlvblV0aWxzID0gcmVxdWlyZShcIi4uL2xvYWRlci11dGlscy9vcHRpb24tdXRpbHNcIik7XG5cbnZhciBfcGFyc2UgPSByZXF1aXJlKFwiLi9wYXJzZVwiKTtcblxuZnVuY3Rpb24gbG9hZChfeCwgX3gyLCBfeDMsIF94NCkge1xuICByZXR1cm4gX2xvYWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2xvYWQoKSB7XG4gIF9sb2FkID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUodXJsLCBsb2FkZXJzLCBvcHRpb25zLCBjb250ZXh0KSB7XG4gICAgdmFyIGZldGNoLCBkYXRhO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGxvYWRlcnMpICYmICEoMCwgX25vcm1hbGl6ZUxvYWRlci5pc0xvYWRlck9iamVjdCkobG9hZGVycykpIHtcbiAgICAgICAgICAgICAgY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgb3B0aW9ucyA9IGxvYWRlcnM7XG4gICAgICAgICAgICAgIGxvYWRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZldGNoID0gKDAsIF9vcHRpb25VdGlscy5nZXRGZXRjaEZ1bmN0aW9uKShvcHRpb25zKTtcbiAgICAgICAgICAgIGRhdGEgPSB1cmw7XG5cbiAgICAgICAgICAgIGlmICghKHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2O1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoKHVybCk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBkYXRhID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGlmICghKDAsIF9pc1R5cGUuaXNCbG9iKSh1cmwpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMDtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaCh1cmwpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMztcbiAgICAgICAgICAgIHJldHVybiAoMCwgX3BhcnNlLnBhcnNlKShkYXRhLCBsb2FkZXJzLCBvcHRpb25zKTtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0LnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9sb2FkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucGFyc2VJbkJhdGNoZXMgPSBwYXJzZUluQmF0Y2hlcztcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF93cmFwQXN5bmNHZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy93cmFwQXN5bmNHZW5lcmF0b3JcIikpO1xuXG52YXIgX2F3YWl0QXN5bmNHZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hd2FpdEFzeW5jR2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY0l0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNJdGVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNHZW5lcmF0b3JEZWxlZ2F0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jR2VuZXJhdG9yRGVsZWdhdGVcIikpO1xuXG52YXIgX2xvYWRlclV0aWxzID0gcmVxdWlyZShcIkBsb2FkZXJzLmdsL2xvYWRlci11dGlsc1wiKTtcblxudmFyIF9ub3JtYWxpemVMb2FkZXIgPSByZXF1aXJlKFwiLi4vbG9hZGVyLXV0aWxzL25vcm1hbGl6ZS1sb2FkZXJcIik7XG5cbnZhciBfb3B0aW9uVXRpbHMgPSByZXF1aXJlKFwiLi4vbG9hZGVyLXV0aWxzL29wdGlvbi11dGlsc1wiKTtcblxudmFyIF9sb2FkZXJDb250ZXh0ID0gcmVxdWlyZShcIi4uL2xvYWRlci11dGlscy9sb2FkZXItY29udGV4dFwiKTtcblxudmFyIF9nZXREYXRhID0gcmVxdWlyZShcIi4uL2xvYWRlci11dGlscy9nZXQtZGF0YVwiKTtcblxudmFyIF9yZXNvdXJjZVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzL3Jlc291cmNlLXV0aWxzXCIpO1xuXG52YXIgX3NlbGVjdExvYWRlciA9IHJlcXVpcmUoXCIuL3NlbGVjdC1sb2FkZXJcIik7XG5cbnZhciBfcGFyc2UgPSByZXF1aXJlKFwiLi9wYXJzZVwiKTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIHBhcnNlSW5CYXRjaGVzKF94MiwgX3gzLCBfeDQsIF94NSkge1xuICByZXR1cm4gX3BhcnNlSW5CYXRjaGVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9wYXJzZUluQmF0Y2hlcygpIHtcbiAgX3BhcnNlSW5CYXRjaGVzID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGRhdGEsIGxvYWRlcnMsIG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgICB2YXIgX2dldFJlc291cmNlVXJsQW5kVHlwLCB1cmwsIGxvYWRlcjtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICgwLCBfbG9hZGVyVXRpbHMuYXNzZXJ0KSghY29udGV4dCB8fCAoMCwgX3R5cGVvZjIuZGVmYXVsdCkoY29udGV4dCkgPT09ICdvYmplY3QnKTtcblxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGxvYWRlcnMpICYmICEoMCwgX25vcm1hbGl6ZUxvYWRlci5pc0xvYWRlck9iamVjdCkobG9hZGVycykpIHtcbiAgICAgICAgICAgICAgY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgb3B0aW9ucyA9IGxvYWRlcnM7XG4gICAgICAgICAgICAgIGxvYWRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgZGF0YSA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgICBfZ2V0UmVzb3VyY2VVcmxBbmRUeXAgPSAoMCwgX3Jlc291cmNlVXRpbHMuZ2V0UmVzb3VyY2VVcmxBbmRUeXBlKShkYXRhKSwgdXJsID0gX2dldFJlc291cmNlVXJsQW5kVHlwLnVybDtcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gOTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX3NlbGVjdExvYWRlci5zZWxlY3RMb2FkZXIpKGRhdGEsIGxvYWRlcnMsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgbG9hZGVyID0gX2NvbnRleHQzLnNlbnQ7XG5cbiAgICAgICAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIG51bGwpO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIG9wdGlvbnMgPSAoMCwgX29wdGlvblV0aWxzLm5vcm1hbGl6ZU9wdGlvbnMpKG9wdGlvbnMsIGxvYWRlciwgbG9hZGVycywgdXJsKTtcbiAgICAgICAgICAgIGNvbnRleHQgPSAoMCwgX2xvYWRlckNvbnRleHQuZ2V0TG9hZGVyQ29udGV4dCkoe1xuICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgcGFyc2VJbkJhdGNoZXM6IHBhcnNlSW5CYXRjaGVzLFxuICAgICAgICAgICAgICBwYXJzZTogX3BhcnNlLnBhcnNlLFxuICAgICAgICAgICAgICBsb2FkZXJzOiBsb2FkZXJzXG4gICAgICAgICAgICB9LCBvcHRpb25zLCBjb250ZXh0KTtcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTY7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VXaXRoTG9hZGVySW5CYXRjaGVzKGxvYWRlciwgZGF0YSwgb3B0aW9ucywgY29udGV4dCk7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQzLnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyKTtcbiAgfSkpO1xuICByZXR1cm4gX3BhcnNlSW5CYXRjaGVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2l0aExvYWRlckluQmF0Y2hlcyhsb2FkZXIsIGRhdGEsIG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgdmFyIG91dHB1dEl0ZXJhdG9yLCBtZXRhZGF0YUJhdGNoLCBtYWtlTWV0YWRhdGFCYXRjaEl0ZXJhdG9yLCBfbWFrZU1ldGFkYXRhQmF0Y2hJdGVyYXRvcjtcblxuICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQuYXN5bmMoZnVuY3Rpb24gcGFyc2VXaXRoTG9hZGVySW5CYXRjaGVzJChfY29udGV4dCkge1xuICAgIHdoaWxlICgxKSB7XG4gICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBfbWFrZU1ldGFkYXRhQmF0Y2hJdGVyYXRvciA9IGZ1bmN0aW9uIF9tYWtlTWV0YWRhdGFCYXRjaEl0ZTIoKSB7XG4gICAgICAgICAgICBfbWFrZU1ldGFkYXRhQmF0Y2hJdGVyYXRvciA9ICgwLCBfd3JhcEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoaXRlcmF0b3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YUJhdGNoO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmRlbGVnYXRlWWllbGQoKDAsIF9hc3luY0dlbmVyYXRvckRlbGVnYXRlMi5kZWZhdWx0KSgoMCwgX2FzeW5jSXRlcmF0b3IyLmRlZmF1bHQpKGl0ZXJhdG9yKSwgX2F3YWl0QXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpLCBcInQwXCIsIDMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwgX2NhbGxlZSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4gX21ha2VNZXRhZGF0YUJhdGNoSXRlcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgbWFrZU1ldGFkYXRhQmF0Y2hJdGVyYXRvciA9IGZ1bmN0aW9uIF9tYWtlTWV0YWRhdGFCYXRjaEl0ZShfeCkge1xuICAgICAgICAgICAgcmV0dXJuIF9tYWtlTWV0YWRhdGFCYXRjaEl0ZXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC5hd3JhcChwYXJzZVRvT3V0cHV0SXRlcmF0b3IobG9hZGVyLCBkYXRhLCBvcHRpb25zLCBjb250ZXh0KSk7XG5cbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIG91dHB1dEl0ZXJhdG9yID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgIGlmIChvcHRpb25zLm1ldGFkYXRhKSB7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgb3V0cHV0SXRlcmF0b3IpO1xuXG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICBtZXRhZGF0YUJhdGNoID0ge1xuICAgICAgICAgICAgYmF0Y2hUeXBlOiAnbWV0YWRhdGEnLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgX2xvYWRlcjogbG9hZGVyLFxuICAgICAgICAgICAgICBfY29udGV4dDogY29udGV4dFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRhdGE6IFtdLFxuICAgICAgICAgICAgYnl0ZXNVc2VkOiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG1ha2VNZXRhZGF0YUJhdGNoSXRlcmF0b3Iob3V0cHV0SXRlcmF0b3IpKTtcblxuICAgICAgICBjYXNlIDk6XG4gICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgbnVsbCwgbnVsbCwgbnVsbCwgUHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVG9PdXRwdXRJdGVyYXRvcihfeDYsIF94NywgX3g4LCBfeDkpIHtcbiAgcmV0dXJuIF9wYXJzZVRvT3V0cHV0SXRlcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3BhcnNlVG9PdXRwdXRJdGVyYXRvcigpIHtcbiAgX3BhcnNlVG9PdXRwdXRJdGVyYXRvciA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlNChsb2FkZXIsIGRhdGEsIG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgICB2YXIgaW5wdXRJdGVyYXRvciwgdHJhbnNmb3JtZWRJdGVyYXRvciwgcGFyc2VDaHVua0luQmF0Y2hlcywgX3BhcnNlQ2h1bmtJbkJhdGNoZXM7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ1KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfcGFyc2VDaHVua0luQmF0Y2hlcyA9IGZ1bmN0aW9uIF9wYXJzZUNodW5rSW5CYXRjaGVzMygpIHtcbiAgICAgICAgICAgICAgX3BhcnNlQ2h1bmtJbkJhdGNoZXMgPSAoMCwgX3dyYXBBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMygpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJyYXlCdWZmZXIsIHBhcnNlZERhdGEsIGJhdGNoO1xuICAgICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDQpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX2F3YWl0QXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKCgwLCBfbG9hZGVyVXRpbHMuY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnNBc3luYykodHJhbnNmb3JtZWRJdGVyYXRvcikpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlCdWZmZXIgPSBfY29udGV4dDQuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX2F3YWl0QXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKCgwLCBfcGFyc2UucGFyc2UpKGFycmF5QnVmZmVyLCBsb2FkZXIsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBsb2FkZXIubWltZVR5cGVzWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgY29udGV4dCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkRGF0YSA9IF9jb250ZXh0NC5zZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgYmF0Y2ggPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBsb2FkZXIubWltZVR5cGVzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZTogQXJyYXkuaXNBcnJheShwYXJzZWREYXRhKSA/ICdyb3ctdGFibGUnIDogJ3Vua25vd24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBiYXRjaFR5cGU6ICdkYXRhJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcGFyc2VkRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiBBcnJheS5pc0FycmF5KHBhcnNlZERhdGEpID8gcGFyc2VkRGF0YS5sZW5ndGggOiAxXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA5O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhdGNoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgX2NhbGxlZTMpO1xuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIHJldHVybiBfcGFyc2VDaHVua0luQmF0Y2hlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcGFyc2VDaHVua0luQmF0Y2hlcyA9IGZ1bmN0aW9uIF9wYXJzZUNodW5rSW5CYXRjaGVzMigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9wYXJzZUNodW5rSW5CYXRjaGVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDQ7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9nZXREYXRhLmdldEFzeW5jSXRlcmFibGVGcm9tRGF0YSkoZGF0YSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBpbnB1dEl0ZXJhdG9yID0gX2NvbnRleHQ1LnNlbnQ7XG4gICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDc7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHlJbnB1dFRyYW5zZm9ybXMoaW5wdXRJdGVyYXRvciwgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFuc2Zvcm1zKSB8fCBbXSk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZEl0ZXJhdG9yID0gX2NvbnRleHQ1LnNlbnQ7XG5cbiAgICAgICAgICAgIGlmICghbG9hZGVyLnBhcnNlSW5CYXRjaGVzKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCBsb2FkZXIucGFyc2VJbkJhdGNoZXModHJhbnNmb3JtZWRJdGVyYXRvciwgb3B0aW9ucywgY29udGV4dCkpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIHBhcnNlQ2h1bmtJbkJhdGNoZXMoKSk7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTQpO1xuICB9KSk7XG4gIHJldHVybiBfcGFyc2VUb091dHB1dEl0ZXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5SW5wdXRUcmFuc2Zvcm1zKF94MTApIHtcbiAgcmV0dXJuIF9hcHBseUlucHV0VHJhbnNmb3Jtcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfYXBwbHlJbnB1dFRyYW5zZm9ybXMoKSB7XG4gIF9hcHBseUlucHV0VHJhbnNmb3JtcyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlNShpbnB1dEl0ZXJhdG9yKSB7XG4gICAgdmFyIHRyYW5zZm9ybXMsXG4gICAgICAgIGl0ZXJhdG9yQ2hhaW4sXG4gICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24sXG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yLFxuICAgICAgICBfaXRlcmF0b3JFcnJvcixcbiAgICAgICAgX2l0ZXJhdG9yLFxuICAgICAgICBfc3RlcCxcbiAgICAgICAgX3ZhbHVlLFxuICAgICAgICB0cmFuc2Zvcm1CYXRjaGVzLFxuICAgICAgICBfYXJnczYgPSBhcmd1bWVudHM7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ2KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB0cmFuc2Zvcm1zID0gX2FyZ3M2Lmxlbmd0aCA+IDEgJiYgX2FyZ3M2WzFdICE9PSB1bmRlZmluZWQgPyBfYXJnczZbMV0gOiBbXTtcbiAgICAgICAgICAgIGl0ZXJhdG9yQ2hhaW4gPSBpbnB1dEl0ZXJhdG9yO1xuICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgX2NvbnRleHQ2LnByZXYgPSA0O1xuICAgICAgICAgICAgX2l0ZXJhdG9yID0gKDAsIF9hc3luY0l0ZXJhdG9yMi5kZWZhdWx0KSh0cmFuc2Zvcm1zKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gODtcbiAgICAgICAgICAgIHJldHVybiBfaXRlcmF0b3IubmV4dCgpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgX3N0ZXAgPSBfY29udGV4dDYuc2VudDtcbiAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSBfc3RlcC5kb25lO1xuICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAxMjtcbiAgICAgICAgICAgIHJldHVybiBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBfdmFsdWUgPSBfY29udGV4dDYuc2VudDtcblxuICAgICAgICAgICAgaWYgKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24pIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyYW5zZm9ybUJhdGNoZXMgPSBfdmFsdWU7XG4gICAgICAgICAgICBpdGVyYXRvckNoYWluID0gdHJhbnNmb3JtQmF0Y2hlcyhpdGVyYXRvckNoYWluKTtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gNjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMjU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICBfY29udGV4dDYucHJldiA9IDIxO1xuICAgICAgICAgICAgX2NvbnRleHQ2LnQwID0gX2NvbnRleHQ2W1wiY2F0Y2hcIl0oNCk7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IF9jb250ZXh0Ni50MDtcblxuICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgICBfY29udGV4dDYucHJldiA9IDI1O1xuICAgICAgICAgICAgX2NvbnRleHQ2LnByZXYgPSAyNjtcblxuICAgICAgICAgICAgaWYgKCEoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDMwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAzMDtcbiAgICAgICAgICAgIHJldHVybiBfaXRlcmF0b3IucmV0dXJuKCk7XG5cbiAgICAgICAgICBjYXNlIDMwOlxuICAgICAgICAgICAgX2NvbnRleHQ2LnByZXYgPSAzMDtcblxuICAgICAgICAgICAgaWYgKCFfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDMzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG5cbiAgICAgICAgICBjYXNlIDMzOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5maW5pc2goMzApO1xuXG4gICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuZmluaXNoKDI1KTtcblxuICAgICAgICAgIGNhc2UgMzU6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCBpdGVyYXRvckNoYWluKTtcblxuICAgICAgICAgIGNhc2UgMzY6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNSwgbnVsbCwgW1s0LCAyMSwgMjUsIDM1XSwgWzI2LCwgMzAsIDM0XV0pO1xuICB9KSk7XG4gIHJldHVybiBfYXBwbHlJbnB1dFRyYW5zZm9ybXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlLWluLWJhdGNoZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5wYXJzZVN5bmMgPSBwYXJzZVN5bmM7XG5cbnZhciBfdHlwZW9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpKTtcblxudmFyIF9sb2FkZXJVdGlscyA9IHJlcXVpcmUoXCJAbG9hZGVycy5nbC9sb2FkZXItdXRpbHNcIik7XG5cbnZhciBfc2VsZWN0TG9hZGVyID0gcmVxdWlyZShcIi4vc2VsZWN0LWxvYWRlclwiKTtcblxudmFyIF9ub3JtYWxpemVMb2FkZXIgPSByZXF1aXJlKFwiLi4vbG9hZGVyLXV0aWxzL25vcm1hbGl6ZS1sb2FkZXJcIik7XG5cbnZhciBfb3B0aW9uVXRpbHMgPSByZXF1aXJlKFwiLi4vbG9hZGVyLXV0aWxzL29wdGlvbi11dGlsc1wiKTtcblxudmFyIF9nZXREYXRhID0gcmVxdWlyZShcIi4uL2xvYWRlci11dGlscy9nZXQtZGF0YVwiKTtcblxudmFyIF9sb2FkZXJDb250ZXh0ID0gcmVxdWlyZShcIi4uL2xvYWRlci11dGlscy9sb2FkZXItY29udGV4dFwiKTtcblxudmFyIF9yZXNvdXJjZVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzL3Jlc291cmNlLXV0aWxzXCIpO1xuXG5mdW5jdGlvbiBwYXJzZVN5bmMoZGF0YSwgbG9hZGVycywgb3B0aW9ucywgY29udGV4dCkge1xuICAoMCwgX2xvYWRlclV0aWxzLmFzc2VydCkoIWNvbnRleHQgfHwgKDAsIF90eXBlb2YyLmRlZmF1bHQpKGNvbnRleHQpID09PSAnb2JqZWN0Jyk7XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGxvYWRlcnMpICYmICEoMCwgX25vcm1hbGl6ZUxvYWRlci5pc0xvYWRlck9iamVjdCkobG9hZGVycykpIHtcbiAgICBjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIG9wdGlvbnMgPSBsb2FkZXJzO1xuICAgIGxvYWRlcnMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGVkTG9hZGVycyA9IGxvYWRlcnM7XG4gIHZhciBjYW5kaWRhdGVMb2FkZXJzID0gKDAsIF9sb2FkZXJDb250ZXh0LmdldExvYWRlcnNGcm9tQ29udGV4dCkodHlwZWRMb2FkZXJzLCBjb250ZXh0KTtcbiAgdmFyIGxvYWRlciA9ICgwLCBfc2VsZWN0TG9hZGVyLnNlbGVjdExvYWRlclN5bmMpKGRhdGEsIGNhbmRpZGF0ZUxvYWRlcnMsIG9wdGlvbnMpO1xuXG4gIGlmICghbG9hZGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBvcHRpb25zID0gKDAsIF9vcHRpb25VdGlscy5ub3JtYWxpemVPcHRpb25zKShvcHRpb25zLCBsb2FkZXIsIGNhbmRpZGF0ZUxvYWRlcnMpO1xuXG4gIHZhciBfZ2V0UmVzb3VyY2VVcmxBbmRUeXAgPSAoMCwgX3Jlc291cmNlVXRpbHMuZ2V0UmVzb3VyY2VVcmxBbmRUeXBlKShkYXRhKSxcbiAgICAgIHVybCA9IF9nZXRSZXNvdXJjZVVybEFuZFR5cC51cmw7XG5cbiAgdmFyIHBhcnNlID0gZnVuY3Rpb24gcGFyc2UoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwYXJzZVN5bmMgY2FsbGVkIHBhcnNlJyk7XG4gIH07XG5cbiAgY29udGV4dCA9ICgwLCBfbG9hZGVyQ29udGV4dC5nZXRMb2FkZXJDb250ZXh0KSh7XG4gICAgdXJsOiB1cmwsXG4gICAgcGFyc2VTeW5jOiBwYXJzZVN5bmMsXG4gICAgcGFyc2U6IHBhcnNlLFxuICAgIGxvYWRlcnM6IGxvYWRlcnNcbiAgfSwgb3B0aW9ucyk7XG4gIHJldHVybiBwYXJzZVdpdGhMb2FkZXJTeW5jKGxvYWRlciwgZGF0YSwgb3B0aW9ucywgY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2l0aExvYWRlclN5bmMobG9hZGVyLCBkYXRhLCBvcHRpb25zLCBjb250ZXh0KSB7XG4gIGRhdGEgPSAoMCwgX2dldERhdGEuZ2V0QXJyYXlCdWZmZXJPclN0cmluZ0Zyb21EYXRhU3luYykoZGF0YSwgbG9hZGVyLCBvcHRpb25zKTtcblxuICBpZiAobG9hZGVyLnBhcnNlVGV4dFN5bmMgJiYgdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGxvYWRlci5wYXJzZVRleHRTeW5jKGRhdGEsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKGxvYWRlci5wYXJzZVN5bmMgJiYgZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGxvYWRlci5wYXJzZVN5bmMoZGF0YSwgb3B0aW9ucywgY29udGV4dCk7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJcIi5jb25jYXQobG9hZGVyLm5hbWUsIFwiIGxvYWRlcjogJ3BhcnNlU3luYycgbm90IHN1cHBvcnRlZCBieSB0aGlzIGxvYWRlciwgdXNlICdwYXJzZScgaW5zdGVhZC4gXCIpLmNvbmNhdChjb250ZXh0LnVybCB8fCAnJykpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2Utc3luYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfdHlwZW9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfd29ya2VyVXRpbHMgPSByZXF1aXJlKFwiQGxvYWRlcnMuZ2wvd29ya2VyLXV0aWxzXCIpO1xuXG52YXIgX2xvYWRlclV0aWxzID0gcmVxdWlyZShcIkBsb2FkZXJzLmdsL2xvYWRlci11dGlsc1wiKTtcblxudmFyIF9ub3JtYWxpemVMb2FkZXIgPSByZXF1aXJlKFwiLi4vbG9hZGVyLXV0aWxzL25vcm1hbGl6ZS1sb2FkZXJcIik7XG5cbnZhciBfb3B0aW9uVXRpbHMgPSByZXF1aXJlKFwiLi4vbG9hZGVyLXV0aWxzL29wdGlvbi11dGlsc1wiKTtcblxudmFyIF9nZXREYXRhID0gcmVxdWlyZShcIi4uL2xvYWRlci11dGlscy9nZXQtZGF0YVwiKTtcblxudmFyIF9sb2FkZXJDb250ZXh0ID0gcmVxdWlyZShcIi4uL2xvYWRlci11dGlscy9sb2FkZXItY29udGV4dFwiKTtcblxudmFyIF9yZXNvdXJjZVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzL3Jlc291cmNlLXV0aWxzXCIpO1xuXG52YXIgX3NlbGVjdExvYWRlciA9IHJlcXVpcmUoXCIuL3NlbGVjdC1sb2FkZXJcIik7XG5cbmZ1bmN0aW9uIHBhcnNlKF94LCBfeDIsIF94MywgX3g0KSB7XG4gIHJldHVybiBfcGFyc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3BhcnNlKCkge1xuICBfcGFyc2UgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZShkYXRhLCBsb2FkZXJzLCBvcHRpb25zLCBjb250ZXh0KSB7XG4gICAgdmFyIF9nZXRSZXNvdXJjZVVybEFuZFR5cCwgdXJsLCB0eXBlZExvYWRlcnMsIGNhbmRpZGF0ZUxvYWRlcnMsIGxvYWRlcjtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgKDAsIF93b3JrZXJVdGlscy5hc3NlcnQpKCFjb250ZXh0IHx8ICgwLCBfdHlwZW9mMi5kZWZhdWx0KShjb250ZXh0KSA9PT0gJ29iamVjdCcpO1xuXG4gICAgICAgICAgICBpZiAobG9hZGVycyAmJiAhQXJyYXkuaXNBcnJheShsb2FkZXJzKSAmJiAhKDAsIF9ub3JtYWxpemVMb2FkZXIuaXNMb2FkZXJPYmplY3QpKGxvYWRlcnMpKSB7XG4gICAgICAgICAgICAgIGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIG9wdGlvbnMgPSBsb2FkZXJzO1xuICAgICAgICAgICAgICBsb2FkZXJzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgZGF0YSA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIF9nZXRSZXNvdXJjZVVybEFuZFR5cCA9ICgwLCBfcmVzb3VyY2VVdGlscy5nZXRSZXNvdXJjZVVybEFuZFR5cGUpKGRhdGEpLCB1cmwgPSBfZ2V0UmVzb3VyY2VVcmxBbmRUeXAudXJsO1xuICAgICAgICAgICAgdHlwZWRMb2FkZXJzID0gbG9hZGVycztcbiAgICAgICAgICAgIGNhbmRpZGF0ZUxvYWRlcnMgPSAoMCwgX2xvYWRlckNvbnRleHQuZ2V0TG9hZGVyc0Zyb21Db250ZXh0KSh0eXBlZExvYWRlcnMsIGNvbnRleHQpO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDExO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfc2VsZWN0TG9hZGVyLnNlbGVjdExvYWRlcikoZGF0YSwgY2FuZGlkYXRlTG9hZGVycywgb3B0aW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgbG9hZGVyID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG51bGwpO1xuXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIG9wdGlvbnMgPSAoMCwgX29wdGlvblV0aWxzLm5vcm1hbGl6ZU9wdGlvbnMpKG9wdGlvbnMsIGxvYWRlciwgY2FuZGlkYXRlTG9hZGVycywgdXJsKTtcbiAgICAgICAgICAgIGNvbnRleHQgPSAoMCwgX2xvYWRlckNvbnRleHQuZ2V0TG9hZGVyQ29udGV4dCkoe1xuICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgcGFyc2U6IHBhcnNlLFxuICAgICAgICAgICAgICBsb2FkZXJzOiBjYW5kaWRhdGVMb2FkZXJzXG4gICAgICAgICAgICB9LCBvcHRpb25zLCBjb250ZXh0KTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxODtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVdpdGhMb2FkZXIobG9hZGVyLCBkYXRhLCBvcHRpb25zLCBjb250ZXh0KTtcblxuICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0LnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9wYXJzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVdpdGhMb2FkZXIoX3g1LCBfeDYsIF94NywgX3g4KSB7XG4gIHJldHVybiBfcGFyc2VXaXRoTG9hZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9wYXJzZVdpdGhMb2FkZXIoKSB7XG4gIF9wYXJzZVdpdGhMb2FkZXIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIobG9hZGVyLCBkYXRhLCBvcHRpb25zLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgKDAsIF93b3JrZXJVdGlscy52YWxpZGF0ZVdvcmtlclZlcnNpb24pKGxvYWRlcik7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9nZXREYXRhLmdldEFycmF5QnVmZmVyT3JTdHJpbmdGcm9tRGF0YSkoZGF0YSwgbG9hZGVyLCBvcHRpb25zKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dDIuc2VudDtcblxuICAgICAgICAgICAgaWYgKCEobG9hZGVyLnBhcnNlVGV4dFN5bmMgJiYgdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcHRpb25zLmRhdGFUeXBlID0gJ3RleHQnO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgbG9hZGVyLnBhcnNlVGV4dFN5bmMoZGF0YSwgb3B0aW9ucywgY29udGV4dCwgbG9hZGVyKSk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBpZiAoISgwLCBfbG9hZGVyVXRpbHMuY2FuUGFyc2VXaXRoV29ya2VyKShsb2FkZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEwO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfbG9hZGVyVXRpbHMucGFyc2VXaXRoV29ya2VyKShsb2FkZXIsIGRhdGEsIG9wdGlvbnMsIGNvbnRleHQsIHBhcnNlKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDIuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgaWYgKCEobG9hZGVyLnBhcnNlVGV4dCAmJiB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE0O1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRlci5wYXJzZVRleHQoZGF0YSwgb3B0aW9ucywgY29udGV4dCwgbG9hZGVyKTtcblxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDIuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgaWYgKCFsb2FkZXIucGFyc2UpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTg7XG4gICAgICAgICAgICByZXR1cm4gbG9hZGVyLnBhcnNlKGRhdGEsIG9wdGlvbnMsIGNvbnRleHQsIGxvYWRlcik7XG5cbiAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQyLnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICgwLCBfd29ya2VyVXRpbHMuYXNzZXJ0KSghbG9hZGVyLnBhcnNlU3luYyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIi5jb25jYXQobG9hZGVyLmlkLCBcIiBsb2FkZXIgLSBubyBwYXJzZXIgZm91bmQgYW5kIHdvcmtlciBpcyBkaXNhYmxlZFwiKSk7XG5cbiAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIpO1xuICB9KSk7XG4gIHJldHVybiBfcGFyc2VXaXRoTG9hZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucmVnaXN0ZXJMb2FkZXJzID0gcmVnaXN0ZXJMb2FkZXJzO1xuZXhwb3J0cy5nZXRSZWdpc3RlcmVkTG9hZGVycyA9IGdldFJlZ2lzdGVyZWRMb2FkZXJzO1xuZXhwb3J0cy5fdW5yZWdpc3RlckxvYWRlcnMgPSBfdW5yZWdpc3RlckxvYWRlcnM7XG5cbnZhciBfbm9ybWFsaXplTG9hZGVyID0gcmVxdWlyZShcIi4uL2xvYWRlci11dGlscy9ub3JtYWxpemUtbG9hZGVyXCIpO1xuXG52YXIgX29wdGlvblV0aWxzID0gcmVxdWlyZShcIi4uL2xvYWRlci11dGlscy9vcHRpb24tdXRpbHNcIik7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxudmFyIGdldEdsb2JhbExvYWRlclJlZ2lzdHJ5ID0gZnVuY3Rpb24gZ2V0R2xvYmFsTG9hZGVyUmVnaXN0cnkoKSB7XG4gIHZhciBzdGF0ZSA9ICgwLCBfb3B0aW9uVXRpbHMuZ2V0R2xvYmFsTG9hZGVyU3RhdGUpKCk7XG4gIHN0YXRlLmxvYWRlclJlZ2lzdHJ5ID0gc3RhdGUubG9hZGVyUmVnaXN0cnkgfHwgW107XG4gIHJldHVybiBzdGF0ZS5sb2FkZXJSZWdpc3RyeTtcbn07XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyTG9hZGVycyhsb2FkZXJzKSB7XG4gIHZhciBsb2FkZXJSZWdpc3RyeSA9IGdldEdsb2JhbExvYWRlclJlZ2lzdHJ5KCk7XG4gIGxvYWRlcnMgPSBBcnJheS5pc0FycmF5KGxvYWRlcnMpID8gbG9hZGVycyA6IFtsb2FkZXJzXTtcblxuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobG9hZGVycyksXG4gICAgICBfc3RlcDtcblxuICB0cnkge1xuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgdmFyIGxvYWRlciA9IF9zdGVwLnZhbHVlO1xuICAgICAgdmFyIG5vcm1hbGl6ZWRMb2FkZXIgPSAoMCwgX25vcm1hbGl6ZUxvYWRlci5ub3JtYWxpemVMb2FkZXIpKGxvYWRlcik7XG5cbiAgICAgIGlmICghbG9hZGVyUmVnaXN0cnkuZmluZChmdW5jdGlvbiAocmVnaXN0ZXJlZExvYWRlcikge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplZExvYWRlciA9PT0gcmVnaXN0ZXJlZExvYWRlcjtcbiAgICAgIH0pKSB7XG4gICAgICAgIGxvYWRlclJlZ2lzdHJ5LnVuc2hpZnQobm9ybWFsaXplZExvYWRlcik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICBfbG9vcCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJlZ2lzdGVyZWRMb2FkZXJzKCkge1xuICByZXR1cm4gZ2V0R2xvYmFsTG9hZGVyUmVnaXN0cnkoKTtcbn1cblxuZnVuY3Rpb24gX3VucmVnaXN0ZXJMb2FkZXJzKCkge1xuICB2YXIgc3RhdGUgPSAoMCwgX29wdGlvblV0aWxzLmdldEdsb2JhbExvYWRlclN0YXRlKSgpO1xuICBzdGF0ZS5sb2FkZXJSZWdpc3RyeSA9IFtdO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVnaXN0ZXItbG9hZGVycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5zYXZlU3luYyA9IHNhdmVTeW5jO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9lbmNvZGUgPSByZXF1aXJlKFwiLi9lbmNvZGVcIik7XG5cbnZhciBfd3JpdGVGaWxlID0gcmVxdWlyZShcIi4uL2ZldGNoL3dyaXRlLWZpbGVcIik7XG5cbmZ1bmN0aW9uIHNhdmUoX3gsIF94MiwgX3gzLCBfeDQpIHtcbiAgcmV0dXJuIF9zYXZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9zYXZlKCkge1xuICBfc2F2ZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKGRhdGEsIHVybCwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgdmFyIGVuY29kZWREYXRhO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9lbmNvZGUuZW5jb2RlKShkYXRhLCB3cml0ZXIsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgZW5jb2RlZERhdGEgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDU7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF93cml0ZUZpbGUud3JpdGVGaWxlKSh1cmwsIGVuY29kZWREYXRhKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUpO1xuICB9KSk7XG4gIHJldHVybiBfc2F2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBzYXZlU3luYyhkYXRhLCB1cmwsIHdyaXRlciwgb3B0aW9ucykge1xuICB2YXIgZW5jb2RlZERhdGEgPSAoMCwgX2VuY29kZS5lbmNvZGVTeW5jKShkYXRhLCB3cml0ZXIsIG9wdGlvbnMpO1xuICByZXR1cm4gKDAsIF93cml0ZUZpbGUud3JpdGVGaWxlU3luYykodXJsLCBlbmNvZGVkRGF0YSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zYXZlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc2VsZWN0TG9hZGVyID0gc2VsZWN0TG9hZGVyO1xuZXhwb3J0cy5zZWxlY3RMb2FkZXJTeW5jID0gc2VsZWN0TG9hZGVyU3luYztcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG52YXIgX3RvQ29uc3VtYWJsZUFycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXlcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9sb2FkZXJVdGlscyA9IHJlcXVpcmUoXCJAbG9hZGVycy5nbC9sb2FkZXItdXRpbHNcIik7XG5cbnZhciBfbm9ybWFsaXplTG9hZGVyID0gcmVxdWlyZShcIi4uL2xvYWRlci11dGlscy9ub3JtYWxpemUtbG9hZGVyXCIpO1xuXG52YXIgX3Jlc291cmNlVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMvcmVzb3VyY2UtdXRpbHNcIik7XG5cbnZhciBfcmVnaXN0ZXJMb2FkZXJzID0gcmVxdWlyZShcIi4vcmVnaXN0ZXItbG9hZGVyc1wiKTtcblxudmFyIF9pc1R5cGUgPSByZXF1aXJlKFwiLi4vLi4vamF2YXNjcmlwdC11dGlscy9pcy10eXBlXCIpO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG52YXIgRVhUX1BBVFRFUk4gPSAvXFwuKFteLl0rKSQvO1xuXG5mdW5jdGlvbiBzZWxlY3RMb2FkZXIoX3gpIHtcbiAgcmV0dXJuIF9zZWxlY3RMb2FkZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3NlbGVjdExvYWRlcigpIHtcbiAgX3NlbGVjdExvYWRlciA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKGRhdGEpIHtcbiAgICB2YXIgbG9hZGVycyxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgbG9hZGVyLFxuICAgICAgICBfYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGxvYWRlcnMgPSBfYXJncy5sZW5ndGggPiAxICYmIF9hcmdzWzFdICE9PSB1bmRlZmluZWQgPyBfYXJnc1sxXSA6IFtdO1xuICAgICAgICAgICAgb3B0aW9ucyA9IF9hcmdzLmxlbmd0aCA+IDIgPyBfYXJnc1syXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnRleHQgPSBfYXJncy5sZW5ndGggPiAzID8gX2FyZ3NbM10gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIGlmICh2YWxpZEhUVFBSZXNwb25zZShkYXRhKSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbnVsbCk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBsb2FkZXIgPSBzZWxlY3RMb2FkZXJTeW5jKGRhdGEsIGxvYWRlcnMsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgICAgIG5vdGhyb3c6IHRydWVcbiAgICAgICAgICAgIH0pLCBjb250ZXh0KTtcblxuICAgICAgICAgICAgaWYgKCFsb2FkZXIpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGxvYWRlcik7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBpZiAoISgwLCBfaXNUeXBlLmlzQmxvYikoZGF0YSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDExO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEuc2xpY2UoMCwgMTApLmFycmF5QnVmZmVyKCk7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgZGF0YSA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICBsb2FkZXIgPSBzZWxlY3RMb2FkZXJTeW5jKGRhdGEsIGxvYWRlcnMsIG9wdGlvbnMsIGNvbnRleHQpO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIGlmICghKCFsb2FkZXIgJiYgIShvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCAmJiBvcHRpb25zLm5vdGhyb3cpKSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0Tm9WYWxpZExvYWRlck1lc3NhZ2UoZGF0YSkpO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbG9hZGVyKTtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUpO1xuICB9KSk7XG4gIHJldHVybiBfc2VsZWN0TG9hZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdExvYWRlclN5bmMoZGF0YSkge1xuICB2YXIgbG9hZGVycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG5cbiAgaWYgKCF2YWxpZEhUVFBSZXNwb25zZShkYXRhKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGxvYWRlcnMgJiYgIUFycmF5LmlzQXJyYXkobG9hZGVycykpIHtcbiAgICByZXR1cm4gKDAsIF9ub3JtYWxpemVMb2FkZXIubm9ybWFsaXplTG9hZGVyKShsb2FkZXJzKTtcbiAgfVxuXG4gIHZhciBjYW5kaWRhdGVMb2FkZXJzID0gW107XG5cbiAgaWYgKGxvYWRlcnMpIHtcbiAgICBjYW5kaWRhdGVMb2FkZXJzID0gY2FuZGlkYXRlTG9hZGVycy5jb25jYXQobG9hZGVycyk7XG4gIH1cblxuICBpZiAoIShvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCAmJiBvcHRpb25zLmlnbm9yZVJlZ2lzdGVyZWRMb2FkZXJzKSkge1xuICAgIHZhciBfY2FuZGlkYXRlTG9hZGVycztcblxuICAgIChfY2FuZGlkYXRlTG9hZGVycyA9IGNhbmRpZGF0ZUxvYWRlcnMpLnB1c2guYXBwbHkoX2NhbmRpZGF0ZUxvYWRlcnMsICgwLCBfdG9Db25zdW1hYmxlQXJyYXkyLmRlZmF1bHQpKCgwLCBfcmVnaXN0ZXJMb2FkZXJzLmdldFJlZ2lzdGVyZWRMb2FkZXJzKSgpKSk7XG4gIH1cblxuICBub3JtYWxpemVMb2FkZXJzKGNhbmRpZGF0ZUxvYWRlcnMpO1xuICB2YXIgbG9hZGVyID0gc2VsZWN0TG9hZGVySW50ZXJuYWwoZGF0YSwgY2FuZGlkYXRlTG9hZGVycywgb3B0aW9ucywgY29udGV4dCk7XG5cbiAgaWYgKCFsb2FkZXIgJiYgIShvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCAmJiBvcHRpb25zLm5vdGhyb3cpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGdldE5vVmFsaWRMb2FkZXJNZXNzYWdlKGRhdGEpKTtcbiAgfVxuXG4gIHJldHVybiBsb2FkZXI7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdExvYWRlckludGVybmFsKGRhdGEsIGxvYWRlcnMsIG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgdmFyIF9nZXRSZXNvdXJjZVVybEFuZFR5cCA9ICgwLCBfcmVzb3VyY2VVdGlscy5nZXRSZXNvdXJjZVVybEFuZFR5cGUpKGRhdGEpLFxuICAgICAgdXJsID0gX2dldFJlc291cmNlVXJsQW5kVHlwLnVybCxcbiAgICAgIHR5cGUgPSBfZ2V0UmVzb3VyY2VVcmxBbmRUeXAudHlwZTtcblxuICB2YXIgdGVzdFVybCA9IHVybCB8fCAoY29udGV4dCA9PT0gbnVsbCB8fCBjb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZXh0LnVybCk7XG4gIHZhciBsb2FkZXIgPSBudWxsO1xuXG4gIGlmIChvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCAmJiBvcHRpb25zLm1pbWVUeXBlKSB7XG4gICAgbG9hZGVyID0gZmluZExvYWRlckJ5TUlNRVR5cGUobG9hZGVycywgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1pbWVUeXBlKTtcbiAgfVxuXG4gIGxvYWRlciA9IGxvYWRlciB8fCBmaW5kTG9hZGVyQnlVcmwobG9hZGVycywgdGVzdFVybCk7XG4gIGxvYWRlciA9IGxvYWRlciB8fCBmaW5kTG9hZGVyQnlNSU1FVHlwZShsb2FkZXJzLCB0eXBlKTtcbiAgbG9hZGVyID0gbG9hZGVyIHx8IGZpbmRMb2FkZXJCeUluaXRpYWxCeXRlcyhsb2FkZXJzLCBkYXRhKTtcbiAgbG9hZGVyID0gbG9hZGVyIHx8IGZpbmRMb2FkZXJCeU1JTUVUeXBlKGxvYWRlcnMsIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mYWxsYmFja01pbWVUeXBlKTtcbiAgcmV0dXJuIGxvYWRlcjtcbn1cblxuZnVuY3Rpb24gdmFsaWRIVFRQUmVzcG9uc2UoZGF0YSkge1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIFJlc3BvbnNlKSB7XG4gICAgaWYgKGRhdGEuc3RhdHVzID09PSAyMDQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9WYWxpZExvYWRlck1lc3NhZ2UoZGF0YSkge1xuICB2YXIgX2dldFJlc291cmNlVXJsQW5kVHlwMiA9ICgwLCBfcmVzb3VyY2VVdGlscy5nZXRSZXNvdXJjZVVybEFuZFR5cGUpKGRhdGEpLFxuICAgICAgdXJsID0gX2dldFJlc291cmNlVXJsQW5kVHlwMi51cmwsXG4gICAgICB0eXBlID0gX2dldFJlc291cmNlVXJsQW5kVHlwMi50eXBlO1xuXG4gIHZhciBtZXNzYWdlID0gJ05vIHZhbGlkIGxvYWRlciBmb3VuZCc7XG5cbiAgaWYgKGRhdGEpIHtcbiAgICBtZXNzYWdlICs9IFwiIGRhdGE6IFxcXCJcIi5jb25jYXQoZ2V0Rmlyc3RDaGFyYWN0ZXJzKGRhdGEpLCBcIlxcXCIsIGNvbnRlbnRUeXBlOiBcXFwiXCIpLmNvbmNhdCh0eXBlLCBcIlxcXCJcIik7XG4gIH1cblxuICBpZiAodXJsKSB7XG4gICAgbWVzc2FnZSArPSBcIiB1cmw6IFwiLmNvbmNhdCh1cmwpO1xuICB9XG5cbiAgcmV0dXJuIG1lc3NhZ2U7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxvYWRlcnMobG9hZGVycykge1xuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobG9hZGVycyksXG4gICAgICBfc3RlcDtcblxuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgbG9hZGVyID0gX3N0ZXAudmFsdWU7XG4gICAgICAoMCwgX25vcm1hbGl6ZUxvYWRlci5ub3JtYWxpemVMb2FkZXIpKGxvYWRlcik7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvci5mKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZExvYWRlckJ5VXJsKGxvYWRlcnMsIHVybCkge1xuICB2YXIgbWF0Y2ggPSB1cmwgJiYgRVhUX1BBVFRFUk4uZXhlYyh1cmwpO1xuICB2YXIgZXh0ZW5zaW9uID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gIHJldHVybiBleHRlbnNpb24gPyBmaW5kTG9hZGVyQnlFeHRlbnNpb24obG9hZGVycywgZXh0ZW5zaW9uKSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGZpbmRMb2FkZXJCeUV4dGVuc2lvbihsb2FkZXJzLCBleHRlbnNpb24pIHtcbiAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uLnRvTG93ZXJDYXNlKCk7XG5cbiAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihsb2FkZXJzKSxcbiAgICAgIF9zdGVwMjtcblxuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgbG9hZGVyID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGxvYWRlci5leHRlbnNpb25zKSxcbiAgICAgICAgICBfc3RlcDM7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGxvYWRlckV4dGVuc2lvbiA9IF9zdGVwMy52YWx1ZTtcblxuICAgICAgICAgIGlmIChsb2FkZXJFeHRlbnNpb24udG9Mb3dlckNhc2UoKSA9PT0gZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9hZGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IyLmYoKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBmaW5kTG9hZGVyQnlNSU1FVHlwZShsb2FkZXJzLCBtaW1lVHlwZSkge1xuICB2YXIgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGxvYWRlcnMpLFxuICAgICAgX3N0ZXA0O1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3I0LnMoKTsgIShfc3RlcDQgPSBfaXRlcmF0b3I0Lm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBsb2FkZXIgPSBfc3RlcDQudmFsdWU7XG5cbiAgICAgIGlmIChsb2FkZXIubWltZVR5cGVzICYmIGxvYWRlci5taW1lVHlwZXMuaW5jbHVkZXMobWltZVR5cGUpKSB7XG4gICAgICAgIHJldHVybiBsb2FkZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChtaW1lVHlwZSA9PT0gXCJhcHBsaWNhdGlvbi94LlwiLmNvbmNhdChsb2FkZXIuaWQpKSB7XG4gICAgICAgIHJldHVybiBsb2FkZXI7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3I0LmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3I0LmYoKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBmaW5kTG9hZGVyQnlJbml0aWFsQnl0ZXMobG9hZGVycywgZGF0YSkge1xuICBpZiAoIWRhdGEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBfaXRlcmF0b3I1ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobG9hZGVycyksXG4gICAgICBfc3RlcDU7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjUucygpOyAhKF9zdGVwNSA9IF9pdGVyYXRvcjUubigpKS5kb25lOykge1xuICAgICAgdmFyIGxvYWRlciA9IF9zdGVwNS52YWx1ZTtcblxuICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodGVzdERhdGFBZ2FpbnN0VGV4dChkYXRhLCBsb2FkZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIGxvYWRlcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICAgICAgaWYgKHRlc3REYXRhQWdhaW5zdEJpbmFyeShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBsb2FkZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIGxvYWRlcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgdmFyIGJ5dGVPZmZzZXQgPSAwO1xuXG4gICAgICAgIGlmICh0ZXN0RGF0YUFnYWluc3RCaW5hcnkoZGF0YSwgYnl0ZU9mZnNldCwgbG9hZGVyKSkge1xuICAgICAgICAgIHJldHVybiBsb2FkZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjUuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjUuZigpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHRlc3REYXRhQWdhaW5zdFRleHQoZGF0YSwgbG9hZGVyKSB7XG4gIGlmIChsb2FkZXIudGVzdFRleHQpIHtcbiAgICByZXR1cm4gbG9hZGVyLnRlc3RUZXh0KGRhdGEpO1xuICB9XG5cbiAgdmFyIHRlc3RzID0gQXJyYXkuaXNBcnJheShsb2FkZXIudGVzdHMpID8gbG9hZGVyLnRlc3RzIDogW2xvYWRlci50ZXN0c107XG4gIHJldHVybiB0ZXN0cy5zb21lKGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgcmV0dXJuIGRhdGEuc3RhcnRzV2l0aCh0ZXN0KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRlc3REYXRhQWdhaW5zdEJpbmFyeShkYXRhLCBieXRlT2Zmc2V0LCBsb2FkZXIpIHtcbiAgdmFyIHRlc3RzID0gQXJyYXkuaXNBcnJheShsb2FkZXIudGVzdHMpID8gbG9hZGVyLnRlc3RzIDogW2xvYWRlci50ZXN0c107XG4gIHJldHVybiB0ZXN0cy5zb21lKGZ1bmN0aW9uICh0ZXN0KSB7XG4gICAgcmV0dXJuIHRlc3RCaW5hcnkoZGF0YSwgYnl0ZU9mZnNldCwgbG9hZGVyLCB0ZXN0KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRlc3RCaW5hcnkoZGF0YSwgYnl0ZU9mZnNldCwgbG9hZGVyLCB0ZXN0KSB7XG4gIGlmICh0ZXN0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gKDAsIF9sb2FkZXJVdGlscy5jb21wYXJlQXJyYXlCdWZmZXJzKSh0ZXN0LCBkYXRhLCB0ZXN0LmJ5dGVMZW5ndGgpO1xuICB9XG5cbiAgc3dpdGNoICgoMCwgX3R5cGVvZjIuZGVmYXVsdCkodGVzdCkpIHtcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICByZXR1cm4gdGVzdChkYXRhLCBsb2FkZXIpO1xuXG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHZhciBtYWdpYyA9IGdldE1hZ2ljU3RyaW5nKGRhdGEsIGJ5dGVPZmZzZXQsIHRlc3QubGVuZ3RoKTtcbiAgICAgIHJldHVybiB0ZXN0ID09PSBtYWdpYztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Rmlyc3RDaGFyYWN0ZXJzKGRhdGEpIHtcbiAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogNTtcblxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRhdGEuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICByZXR1cm4gZ2V0TWFnaWNTdHJpbmcoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgYnl0ZU9mZnNldCA9IDA7XG4gICAgcmV0dXJuIGdldE1hZ2ljU3RyaW5nKGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldE1hZ2ljU3RyaW5nKGFycmF5QnVmZmVyLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgbGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgdmFyIGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKTtcbiAgdmFyIG1hZ2ljID0gJyc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIG1hZ2ljICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVZpZXcuZ2V0VWludDgoYnl0ZU9mZnNldCArIGkpKTtcbiAgfVxuXG4gIHJldHVybiBtYWdpYztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlbGVjdC1sb2FkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnNldExvYWRlck9wdGlvbnMgPSBzZXRMb2FkZXJPcHRpb25zO1xuXG52YXIgX29wdGlvblV0aWxzID0gcmVxdWlyZShcIi4uL2xvYWRlci11dGlscy9vcHRpb24tdXRpbHNcIik7XG5cbmZ1bmN0aW9uIHNldExvYWRlck9wdGlvbnMob3B0aW9ucykge1xuICAoMCwgX29wdGlvblV0aWxzLnNldEdsb2JhbE9wdGlvbnMpKG9wdGlvbnMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2V0LWxvYWRlci1vcHRpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZmV0Y2hGaWxlID0gZmV0Y2hGaWxlO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9sb2FkZXJVdGlscyA9IHJlcXVpcmUoXCJAbG9hZGVycy5nbC9sb2FkZXItdXRpbHNcIik7XG5cbnZhciBfcmVzcG9uc2VVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy9yZXNwb25zZS11dGlsc1wiKTtcblxuZnVuY3Rpb24gZmV0Y2hGaWxlKF94LCBfeDIpIHtcbiAgcmV0dXJuIF9mZXRjaEZpbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2ZldGNoRmlsZSgpIHtcbiAgX2ZldGNoRmlsZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKHVybCwgb3B0aW9ucykge1xuICAgIHZhciBmZXRjaE9wdGlvbnM7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoISh0eXBlb2YgdXJsID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1cmwgPSAoMCwgX2xvYWRlclV0aWxzLnJlc29sdmVQYXRoKSh1cmwpO1xuICAgICAgICAgICAgZmV0Y2hPcHRpb25zID0gb3B0aW9ucztcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwICYmIG9wdGlvbnMuZmV0Y2ggJiYgdHlwZW9mIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZmV0Y2gpICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGZldGNoT3B0aW9ucyA9IG9wdGlvbnMuZmV0Y2g7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2O1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoKHVybCwgZmV0Y2hPcHRpb25zKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gOTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX3Jlc3BvbnNlVXRpbHMubWFrZVJlc3BvbnNlKSh1cmwpO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dC5zZW50KTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUpO1xuICB9KSk7XG4gIHJldHVybiBfZmV0Y2hGaWxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZXRjaC1maWxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucmVhZEFycmF5QnVmZmVyID0gcmVhZEFycmF5QnVmZmVyO1xuZXhwb3J0cy5yZWFkQmxvYiA9IHJlYWRCbG9iO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9sb2FkZXJVdGlscyA9IHJlcXVpcmUoXCJAbG9hZGVycy5nbC9sb2FkZXItdXRpbHNcIik7XG5cbmZ1bmN0aW9uIHJlYWRBcnJheUJ1ZmZlcihfeCwgX3gyLCBfeDMpIHtcbiAgcmV0dXJuIF9yZWFkQXJyYXlCdWZmZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3JlYWRBcnJheUJ1ZmZlcigpIHtcbiAgX3JlYWRBcnJheUJ1ZmZlciA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKGZpbGUsIHN0YXJ0LCBsZW5ndGgpIHtcbiAgICB2YXIgc2xpY2U7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoISh0eXBlb2YgZmlsZSA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gX2xvYWRlclV0aWxzLmZzLl9yZWFkVG9BcnJheUJ1ZmZlcihmaWxlLCBzdGFydCwgbGVuZ3RoKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBpZiAoIShmaWxlIGluc3RhbmNlb2YgQmxvYikpIHtcbiAgICAgICAgICAgICAgZmlsZSA9IG5ldyBCbG9iKFtmaWxlXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNsaWNlID0gZmlsZS5zbGljZShzdGFydCwgc3RhcnQgKyBsZW5ndGgpO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDg7XG4gICAgICAgICAgICByZXR1cm4gcmVhZEJsb2Ioc2xpY2UpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dC5zZW50KTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9yZWFkQXJyYXlCdWZmZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2IoX3g0KSB7XG4gIHJldHVybiBfcmVhZEJsb2IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3JlYWRCbG9iKCkge1xuICBfcmVhZEJsb2IgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoYmxvYikge1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgIHZhciBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICAgICAgICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBfZXZlbnQkdGFyZ2V0O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZXZlbnQgPT09IG51bGwgfHwgZXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfZXZlbnQkdGFyZ2V0ID0gZXZlbnQudGFyZ2V0KSA9PT0gbnVsbCB8fCBfZXZlbnQkdGFyZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXZlbnQkdGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgZmlsZVJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQyLnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIpO1xuICB9KSk7XG4gIHJldHVybiBfcmVhZEJsb2IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWQtYXJyYXktYnVmZmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5yZWFkRmlsZVN5bmMgPSByZWFkRmlsZVN5bmM7XG5cbnZhciBfbG9hZGVyVXRpbHMgPSByZXF1aXJlKFwiQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzXCIpO1xuXG5mdW5jdGlvbiByZWFkRmlsZVN5bmModXJsKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdXJsID0gKDAsIF9sb2FkZXJVdGlscy5yZXNvbHZlUGF0aCkodXJsKTtcblxuICBpZiAoIV9sb2FkZXJVdGlscy5pc0Jyb3dzZXIpIHtcbiAgICB2YXIgYnVmZmVyID0gX2xvYWRlclV0aWxzLmZzLnJlYWRGaWxlU3luYyh1cmwsIG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHR5cGVvZiBidWZmZXIgIT09ICdzdHJpbmcnID8gKDAsIF9sb2FkZXJVdGlscy50b0FycmF5QnVmZmVyKShidWZmZXIpIDogYnVmZmVyO1xuICB9XG5cbiAgaWYgKCFvcHRpb25zLm5vdGhyb3cpIHtcbiAgICAoMCwgX2xvYWRlclV0aWxzLmFzc2VydCkoZmFsc2UpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFkLWZpbGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy53cml0ZUZpbGUgPSB3cml0ZUZpbGU7XG5leHBvcnRzLndyaXRlRmlsZVN5bmMgPSB3cml0ZUZpbGVTeW5jO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9sb2FkZXJVdGlscyA9IHJlcXVpcmUoXCJAbG9hZGVycy5nbC9sb2FkZXItdXRpbHNcIik7XG5cbmZ1bmN0aW9uIHdyaXRlRmlsZShfeCwgX3gyLCBfeDMpIHtcbiAgcmV0dXJuIF93cml0ZUZpbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3dyaXRlRmlsZSgpIHtcbiAgX3dyaXRlRmlsZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKGZpbGVQYXRoLCBhcnJheUJ1ZmZlck9yU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBmaWxlUGF0aCA9ICgwLCBfbG9hZGVyVXRpbHMucmVzb2x2ZVBhdGgpKGZpbGVQYXRoKTtcblxuICAgICAgICAgICAgaWYgKF9sb2FkZXJVdGlscy5pc0Jyb3dzZXIpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiBfbG9hZGVyVXRpbHMuZnMud3JpdGVGaWxlKGZpbGVQYXRoLCAoMCwgX2xvYWRlclV0aWxzLnRvQnVmZmVyKShhcnJheUJ1ZmZlck9yU3RyaW5nKSwge1xuICAgICAgICAgICAgICBmbGFnOiAndydcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgKDAsIF9sb2FkZXJVdGlscy5hc3NlcnQpKGZhbHNlKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSk7XG4gIH0pKTtcbiAgcmV0dXJuIF93cml0ZUZpbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVGaWxlU3luYyhmaWxlUGF0aCwgYXJyYXlCdWZmZXJPclN0cmluZywgb3B0aW9ucykge1xuICBmaWxlUGF0aCA9ICgwLCBfbG9hZGVyVXRpbHMucmVzb2x2ZVBhdGgpKGZpbGVQYXRoKTtcblxuICBpZiAoIV9sb2FkZXJVdGlscy5pc0Jyb3dzZXIpIHtcbiAgICBfbG9hZGVyVXRpbHMuZnMud3JpdGVGaWxlU3luYyhmaWxlUGF0aCwgKDAsIF9sb2FkZXJVdGlscy50b0J1ZmZlcikoYXJyYXlCdWZmZXJPclN0cmluZyksIHtcbiAgICAgIGZsYWc6ICd3J1xuICAgIH0pO1xuICB9XG5cbiAgKDAsIF9sb2FkZXJVdGlscy5hc3NlcnQpKGZhbHNlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdyaXRlLWZpbGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIEJyb3dzZXJGaWxlU3lzdGVtID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCcm93c2VyRmlsZVN5c3RlbShmaWxlcywgb3B0aW9ucykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEJyb3dzZXJGaWxlU3lzdGVtKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcIl9mZXRjaFwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiZmlsZXNcIiwge30pO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwibG93ZXJDYXNlRmlsZXNcIiwge30pO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwidXNlZEZpbGVzXCIsIHt9KTtcbiAgICB0aGlzLl9mZXRjaCA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZmV0Y2gpIHx8IGZldGNoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGZpbGUgPSBmaWxlc1tpXTtcbiAgICAgIHRoaXMuZmlsZXNbZmlsZS5uYW1lXSA9IGZpbGU7XG4gICAgICB0aGlzLmxvd2VyQ2FzZUZpbGVzW2ZpbGUubmFtZS50b0xvd2VyQ2FzZSgpXSA9IGZpbGU7XG4gICAgICB0aGlzLnVzZWRGaWxlc1tmaWxlLm5hbWVdID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5mZXRjaCA9IHRoaXMuZmV0Y2guYmluZCh0aGlzKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEJyb3dzZXJGaWxlU3lzdGVtLCBbe1xuICAgIGtleTogXCJmZXRjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2ZldGNoID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUocGF0aCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgZmlsZSwgaGVhZGVycywgcmFuZ2UsIGJ5dGVzLCBzdGFydCwgZW5kLCBkYXRhLCBfcmVzcG9uc2UsIHJlc3BvbnNlO1xuXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGlmICghcGF0aC5pbmNsdWRlcygnOi8vJykpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB0aGlzLl9mZXRjaChwYXRoLCBvcHRpb25zKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGZpbGUgPSB0aGlzLmZpbGVzW3BhdGhdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBuZXcgUmVzcG9uc2UocGF0aCwge1xuICAgICAgICAgICAgICAgICAgc3RhdHVzOiA0MDAsXG4gICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiAnTk9UIEZPVU5EJ1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgICAgICByYW5nZSA9IGhlYWRlcnMuZ2V0KCdSYW5nZScpO1xuICAgICAgICAgICAgICAgIGJ5dGVzID0gcmFuZ2UgJiYgL2J5dGVzPSgkMSktKCQyKS8uZXhlYyhyYW5nZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWJ5dGVzKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdGFydCA9IHBhcnNlSW50KGJ5dGVzWzFdKTtcbiAgICAgICAgICAgICAgICBlbmQgPSBwYXJzZUludChieXRlc1syXSk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEzO1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlLnNsaWNlKHN0YXJ0LCBlbmQpLmFycmF5QnVmZmVyKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICBkYXRhID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgICBfcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoZGF0YSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9yZXNwb25zZSwgJ3VybCcsIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXRoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBfcmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoZmlsZSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3BvbnNlLCAndXJsJywge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IHBhdGhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHJlc3BvbnNlKTtcblxuICAgICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBmZXRjaChfeCwgX3gyKSB7XG4gICAgICAgIHJldHVybiBfZmV0Y2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZldGNoO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcInJlYWRkaXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWFkZGlyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGRpcm5hbWUpIHtcbiAgICAgICAgdmFyIGZpbGVzLCBwYXRoO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgZmlsZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgIGZvciAocGF0aCBpbiB0aGlzLmZpbGVzKSB7XG4gICAgICAgICAgICAgICAgICBmaWxlcy5wdXNoKHBhdGgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIGZpbGVzKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gcmVhZGRpcihfeDMpIHtcbiAgICAgICAgcmV0dXJuIF9yZWFkZGlyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWFkZGlyO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcInN0YXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9zdGF0ID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGZpbGU7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBmaWxlID0gdGhpcy5maWxlc1twYXRoXTtcblxuICAgICAgICAgICAgICAgIGlmIChmaWxlKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocGF0aCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICAgIHNpemU6IGZpbGUuc2l6ZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTMsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBzdGF0KF94NCwgX3g1KSB7XG4gICAgICAgIHJldHVybiBfc3RhdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhdDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJ1bmxpbmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF91bmxpbmsgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQocGF0aCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZmlsZXNbcGF0aF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMubG93ZXJDYXNlRmlsZXNbcGF0aF07XG4gICAgICAgICAgICAgICAgdGhpcy51c2VkRmlsZXNbcGF0aF0gPSB0cnVlO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTQsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiB1bmxpbmsoX3g2KSB7XG4gICAgICAgIHJldHVybiBfdW5saW5rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmxpbms7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwib3BlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX29wZW4gPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTUocGF0aG5hbWUsIGZsYWdzLCBtb2RlKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDUpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCB0aGlzLmZpbGVzW3BhdGhuYW1lXSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIG9wZW4oX3g3LCBfeDgsIF94OSkge1xuICAgICAgICByZXR1cm4gX29wZW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9wZW47XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwicmVhZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlYWQgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTYoZmQsIGJ1ZmZlcikge1xuICAgICAgICB2YXIgb2Zmc2V0LFxuICAgICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgc3RhcnRQb3NpdGlvbixcbiAgICAgICAgICAgIGFycmF5QnVmZmVyLFxuICAgICAgICAgICAgX2FyZ3M2ID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gX2FyZ3M2Lmxlbmd0aCA+IDIgJiYgX2FyZ3M2WzJdICE9PSB1bmRlZmluZWQgPyBfYXJnczZbMl0gOiAwO1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IF9hcmdzNi5sZW5ndGggPiAzICYmIF9hcmdzNlszXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3M2WzNdIDogYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBfYXJnczYubGVuZ3RoID4gNCAmJiBfYXJnczZbNF0gIT09IHVuZGVmaW5lZCA/IF9hcmdzNls0XSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZmlsZSA9IGZkO1xuICAgICAgICAgICAgICAgIHN0YXJ0UG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZS5zbGljZShzdGFydFBvc2l0aW9uLCBzdGFydFBvc2l0aW9uICsgbGVuZ3RoKS5hcnJheUJ1ZmZlcigpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBhcnJheUJ1ZmZlciA9IF9jb250ZXh0Ni5zZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICAgIGJ5dGVzUmVhZDogbGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgYnVmZmVyOiBhcnJheUJ1ZmZlclxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTYpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiByZWFkKF94MTAsIF94MTEpIHtcbiAgICAgICAgcmV0dXJuIF9yZWFkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWFkO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfY2xvc2UgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTcoZmQpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTckKF9jb250ZXh0Nykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ny5wcmV2ID0gX2NvbnRleHQ3Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGNsb3NlKF94MTIpIHtcbiAgICAgICAgcmV0dXJuIF9jbG9zZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xvc2U7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEZpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEZpbGUocGF0aCwgdXNlZCkge1xuICAgICAgdmFyIGZpbGUgPSB0aGlzLmZpbGVzW3BhdGhdIHx8IHRoaXMubG93ZXJDYXNlRmlsZXNbcGF0aF07XG5cbiAgICAgIGlmIChmaWxlICYmIHVzZWQpIHtcbiAgICAgICAgdGhpcy51c2VkRmlsZXNbcGF0aF0gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmlsZTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEJyb3dzZXJGaWxlU3lzdGVtO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBCcm93c2VyRmlsZVN5c3RlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyb3dzZXItZmlsZXN5c3RlbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldEFycmF5QnVmZmVyT3JTdHJpbmdGcm9tRGF0YVN5bmMgPSBnZXRBcnJheUJ1ZmZlck9yU3RyaW5nRnJvbURhdGFTeW5jO1xuZXhwb3J0cy5nZXRBcnJheUJ1ZmZlck9yU3RyaW5nRnJvbURhdGEgPSBnZXRBcnJheUJ1ZmZlck9yU3RyaW5nRnJvbURhdGE7XG5leHBvcnRzLmdldEFzeW5jSXRlcmFibGVGcm9tRGF0YSA9IGdldEFzeW5jSXRlcmFibGVGcm9tRGF0YTtcbmV4cG9ydHMuZ2V0UmVhZGFibGVTdHJlYW0gPSBnZXRSZWFkYWJsZVN0cmVhbTtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfbG9hZGVyVXRpbHMgPSByZXF1aXJlKFwiQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzXCIpO1xuXG52YXIgX2lzVHlwZSA9IHJlcXVpcmUoXCIuLi8uLi9qYXZhc2NyaXB0LXV0aWxzL2lzLXR5cGVcIik7XG5cbnZhciBfbWFrZUl0ZXJhdG9yID0gcmVxdWlyZShcIi4uLy4uL2l0ZXJhdG9ycy9tYWtlLWl0ZXJhdG9yL21ha2UtaXRlcmF0b3JcIik7XG5cbnZhciBfcmVzcG9uc2VVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy9yZXNwb25zZS11dGlsc1wiKTtcblxudmFyIEVSUl9EQVRBID0gJ0Nhbm5vdCBjb252ZXJ0IHN1cHBsaWVkIGRhdGEgdHlwZSc7XG5cbmZ1bmN0aW9uIGdldEFycmF5QnVmZmVyT3JTdHJpbmdGcm9tRGF0YVN5bmMoZGF0YSwgbG9hZGVyLCBvcHRpb25zKSB7XG4gIGlmIChsb2FkZXIudGV4dCAmJiB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGlmICgoMCwgX2lzVHlwZS5pc0J1ZmZlcikoZGF0YSkpIHtcbiAgICBkYXRhID0gZGF0YS5idWZmZXI7XG4gIH1cblxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgdmFyIGFycmF5QnVmZmVyID0gZGF0YTtcblxuICAgIGlmIChsb2FkZXIudGV4dCAmJiAhbG9hZGVyLmJpbmFyeSkge1xuICAgICAgdmFyIHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGY4Jyk7XG4gICAgICByZXR1cm4gdGV4dERlY29kZXIuZGVjb2RlKGFycmF5QnVmZmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlCdWZmZXI7XG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgaWYgKGxvYWRlci50ZXh0ICYmICFsb2FkZXIuYmluYXJ5KSB7XG4gICAgICB2YXIgX3RleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGY4Jyk7XG5cbiAgICAgIHJldHVybiBfdGV4dERlY29kZXIuZGVjb2RlKGRhdGEpO1xuICAgIH1cblxuICAgIHZhciBfYXJyYXlCdWZmZXIgPSBkYXRhLmJ1ZmZlcjtcbiAgICB2YXIgYnl0ZUxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aCB8fCBkYXRhLmxlbmd0aDtcblxuICAgIGlmIChkYXRhLmJ5dGVPZmZzZXQgIT09IDAgfHwgYnl0ZUxlbmd0aCAhPT0gX2FycmF5QnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgIF9hcnJheUJ1ZmZlciA9IF9hcnJheUJ1ZmZlci5zbGljZShkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZU9mZnNldCArIGJ5dGVMZW5ndGgpO1xuICAgIH1cblxuICAgIHJldHVybiBfYXJyYXlCdWZmZXI7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoRVJSX0RBVEEpO1xufVxuXG5mdW5jdGlvbiBnZXRBcnJheUJ1ZmZlck9yU3RyaW5nRnJvbURhdGEoX3gsIF94MiwgX3gzKSB7XG4gIHJldHVybiBfZ2V0QXJyYXlCdWZmZXJPclN0cmluZ0Zyb21EYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRBcnJheUJ1ZmZlck9yU3RyaW5nRnJvbURhdGEoKSB7XG4gIF9nZXRBcnJheUJ1ZmZlck9yU3RyaW5nRnJvbURhdGEgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZShkYXRhLCBsb2FkZXIsIG9wdGlvbnMpIHtcbiAgICB2YXIgaXNBcnJheUJ1ZmZlciwgcmVzcG9uc2U7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpc0FycmF5QnVmZmVyID0gZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKTtcblxuICAgICAgICAgICAgaWYgKCEodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnIHx8IGlzQXJyYXlCdWZmZXIpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIGdldEFycmF5QnVmZmVyT3JTdHJpbmdGcm9tRGF0YVN5bmMoZGF0YSwgbG9hZGVyLCBvcHRpb25zKSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBpZiAoISgwLCBfaXNUeXBlLmlzQmxvYikoZGF0YSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA2O1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfcmVzcG9uc2VVdGlscy5tYWtlUmVzcG9uc2UpKGRhdGEpO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgZGF0YSA9IF9jb250ZXh0My5zZW50O1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgaWYgKCEoMCwgX2lzVHlwZS5pc1Jlc3BvbnNlKShkYXRhKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDIxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzcG9uc2UgPSBkYXRhO1xuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxMTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX3Jlc3BvbnNlVXRpbHMuY2hlY2tSZXNwb25zZSkocmVzcG9uc2UpO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIGlmICghbG9hZGVyLmJpbmFyeSkge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDE3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxNDtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIF9jb250ZXh0My50MCA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAyMDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuXG4gICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgIF9jb250ZXh0My50MCA9IF9jb250ZXh0My5zZW50O1xuXG4gICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0My50MCk7XG5cbiAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgaWYgKCgwLCBfaXNUeXBlLmlzUmVhZGFibGVTdHJlYW0pKGRhdGEpKSB7XG4gICAgICAgICAgICAgIGRhdGEgPSAoMCwgX21ha2VJdGVyYXRvci5tYWtlSXRlcmF0b3IpKGRhdGEsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoISgoMCwgX2lzVHlwZS5pc0l0ZXJhYmxlKShkYXRhKSB8fCAoMCwgX2lzVHlwZS5pc0FzeW5jSXRlcmFibGUpKGRhdGEpKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDI0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgKDAsIF9sb2FkZXJVdGlscy5jb25jYXRlbmF0ZUFycmF5QnVmZmVyc0FzeW5jKShkYXRhKSk7XG5cbiAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUl9EQVRBKTtcblxuICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEFycmF5QnVmZmVyT3JTdHJpbmdGcm9tRGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRBc3luY0l0ZXJhYmxlRnJvbURhdGEoX3g0LCBfeDUpIHtcbiAgcmV0dXJuIF9nZXRBc3luY0l0ZXJhYmxlRnJvbURhdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEFzeW5jSXRlcmFibGVGcm9tRGF0YSgpIHtcbiAgX2dldEFzeW5jSXRlcmFibGVGcm9tRGF0YSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMihkYXRhLCBvcHRpb25zKSB7XG4gICAgdmFyIHJlc3BvbnNlLCBib2R5O1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghKDAsIF9pc1R5cGUuaXNJdGVyYXRvcikoZGF0YSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgZGF0YSk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBpZiAoISgwLCBfaXNUeXBlLmlzUmVzcG9uc2UpKGRhdGEpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXNwb25zZSA9IGRhdGE7XG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDY7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9yZXNwb25zZVV0aWxzLmNoZWNrUmVzcG9uc2UpKHJlc3BvbnNlKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gODtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5ib2R5O1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgYm9keSA9IF9jb250ZXh0NC5zZW50O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgKDAsIF9tYWtlSXRlcmF0b3IubWFrZUl0ZXJhdG9yKShib2R5LCBvcHRpb25zKSk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgaWYgKCEoKDAsIF9pc1R5cGUuaXNCbG9iKShkYXRhKSB8fCAoMCwgX2lzVHlwZS5pc1JlYWRhYmxlU3RyZWFtKShkYXRhKSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsICgwLCBfbWFrZUl0ZXJhdG9yLm1ha2VJdGVyYXRvcikoZGF0YSwgb3B0aW9ucykpO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIGlmICghKDAsIF9pc1R5cGUuaXNBc3luY0l0ZXJhYmxlKShkYXRhKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDE0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgZGF0YVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSk7XG5cbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgZ2V0SXRlcmFibGVGcm9tRGF0YShkYXRhKSk7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0QXN5bmNJdGVyYWJsZUZyb21EYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldFJlYWRhYmxlU3RyZWFtKF94Nikge1xuICByZXR1cm4gX2dldFJlYWRhYmxlU3RyZWFtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRSZWFkYWJsZVN0cmVhbSgpIHtcbiAgX2dldFJlYWRhYmxlU3RyZWFtID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKGRhdGEpIHtcbiAgICB2YXIgcmVzcG9uc2U7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0NSkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCEoMCwgX2lzVHlwZS5pc1JlYWRhYmxlU3RyZWFtKShkYXRhKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCBkYXRhKTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGlmICghKDAsIF9pc1R5cGUuaXNSZXNwb25zZSkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgZGF0YS5ib2R5KTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNjtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX3Jlc3BvbnNlVXRpbHMubWFrZVJlc3BvbnNlKShkYXRhKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJlc3BvbnNlID0gX2NvbnRleHQ1LnNlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCByZXNwb25zZS5ib2R5KTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUzKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFJlYWRhYmxlU3RyZWFtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEl0ZXJhYmxlRnJvbURhdGEoZGF0YSkge1xuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gb25lQ2h1bmsoKSB7XG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBvbmVDaHVuayQoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIG9uZUNodW5rKTtcbiAgICB9KSgpO1xuICB9XG5cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIG9uZUNodW5rKCkge1xuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gb25lQ2h1bmskKF9jb250ZXh0Mikge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XG4gICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgb25lQ2h1bmspO1xuICAgIH0pKCk7XG4gIH1cblxuICBpZiAoKDAsIF9pc1R5cGUuaXNJdGVyYXRvcikoZGF0YSkpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGlmICgoMCwgX2lzVHlwZS5pc0l0ZXJhYmxlKShkYXRhKSkge1xuICAgIHJldHVybiBkYXRhW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihFUlJfREFUQSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtZGF0YS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldExvYWRlckNvbnRleHQgPSBnZXRMb2FkZXJDb250ZXh0O1xuZXhwb3J0cy5nZXRMb2FkZXJzRnJvbUNvbnRleHQgPSBnZXRMb2FkZXJzRnJvbUNvbnRleHQ7XG5cbnZhciBfdG9Db25zdW1hYmxlQXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheVwiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfb3B0aW9uVXRpbHMgPSByZXF1aXJlKFwiLi9vcHRpb24tdXRpbHNcIik7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBnZXRMb2FkZXJDb250ZXh0KGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgdmFyIHByZXZpb3VzQ29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcblxuICBpZiAocHJldmlvdXNDb250ZXh0KSB7XG4gICAgcmV0dXJuIHByZXZpb3VzQ29udGV4dDtcbiAgfVxuXG4gIHZhciByZXNvbHZlZENvbnRleHQgPSBfb2JqZWN0U3ByZWFkKHtcbiAgICBmZXRjaDogKDAsIF9vcHRpb25VdGlscy5nZXRGZXRjaEZ1bmN0aW9uKShvcHRpb25zLCBjb250ZXh0KVxuICB9LCBjb250ZXh0KTtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkocmVzb2x2ZWRDb250ZXh0LmxvYWRlcnMpKSB7XG4gICAgcmVzb2x2ZWRDb250ZXh0LmxvYWRlcnMgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHJlc29sdmVkQ29udGV4dDtcbn1cblxuZnVuY3Rpb24gZ2V0TG9hZGVyc0Zyb21Db250ZXh0KGxvYWRlcnMsIGNvbnRleHQpIHtcbiAgaWYgKCFjb250ZXh0ICYmIGxvYWRlcnMgJiYgIUFycmF5LmlzQXJyYXkobG9hZGVycykpIHtcbiAgICByZXR1cm4gbG9hZGVycztcbiAgfVxuXG4gIHZhciBjYW5kaWRhdGVMb2FkZXJzO1xuXG4gIGlmIChsb2FkZXJzKSB7XG4gICAgY2FuZGlkYXRlTG9hZGVycyA9IEFycmF5LmlzQXJyYXkobG9hZGVycykgPyBsb2FkZXJzIDogW2xvYWRlcnNdO1xuICB9XG5cbiAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5sb2FkZXJzKSB7XG4gICAgdmFyIGNvbnRleHRMb2FkZXJzID0gQXJyYXkuaXNBcnJheShjb250ZXh0LmxvYWRlcnMpID8gY29udGV4dC5sb2FkZXJzIDogW2NvbnRleHQubG9hZGVyc107XG4gICAgY2FuZGlkYXRlTG9hZGVycyA9IGNhbmRpZGF0ZUxvYWRlcnMgPyBbXS5jb25jYXQoKDAsIF90b0NvbnN1bWFibGVBcnJheTIuZGVmYXVsdCkoY2FuZGlkYXRlTG9hZGVycyksICgwLCBfdG9Db25zdW1hYmxlQXJyYXkyLmRlZmF1bHQpKGNvbnRleHRMb2FkZXJzKSkgOiBjb250ZXh0TG9hZGVycztcbiAgfVxuXG4gIHJldHVybiBjYW5kaWRhdGVMb2FkZXJzICYmIGNhbmRpZGF0ZUxvYWRlcnMubGVuZ3RoID8gY2FuZGlkYXRlTG9hZGVycyA6IG51bGw7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkZXItY29udGV4dC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkNvbnNvbGVMb2cgPSBleHBvcnRzLk51bGxMb2cgPSBleHBvcnRzLnByb2JlTG9nID0gdm9pZCAwO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX3Byb2JlID0gcmVxdWlyZShcInByb2JlLmdsXCIpO1xuXG52YXIgcHJvYmVMb2cgPSBuZXcgX3Byb2JlLkxvZyh7XG4gIGlkOiAnbG9hZGVycy5nbCdcbn0pO1xuZXhwb3J0cy5wcm9iZUxvZyA9IHByb2JlTG9nO1xuXG52YXIgTnVsbExvZyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTnVsbExvZygpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBOdWxsTG9nKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKE51bGxMb2csIFt7XG4gICAga2V5OiBcImxvZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2coKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge307XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluZm9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5mbygpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7fTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2FyblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3YXJuKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHt9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcnJvcigpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7fTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE51bGxMb2c7XG59KCk7XG5cbmV4cG9ydHMuTnVsbExvZyA9IE51bGxMb2c7XG5cbnZhciBDb25zb2xlTG9nID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb25zb2xlTG9nKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIENvbnNvbGVMb2cpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiY29uc29sZVwiLCB2b2lkIDApO1xuICAgIHRoaXMuY29uc29sZSA9IGNvbnNvbGU7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShDb25zb2xlTG9nLCBbe1xuICAgIGtleTogXCJsb2dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9nKCkge1xuICAgICAgdmFyIF90aGlzJGNvbnNvbGUkbG9nO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChfdGhpcyRjb25zb2xlJGxvZyA9IHRoaXMuY29uc29sZS5sb2cpLmJpbmQuYXBwbHkoX3RoaXMkY29uc29sZSRsb2csIFt0aGlzLmNvbnNvbGVdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluZm9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5mbygpIHtcbiAgICAgIHZhciBfdGhpcyRjb25zb2xlJGluZm87XG5cbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoX3RoaXMkY29uc29sZSRpbmZvID0gdGhpcy5jb25zb2xlLmluZm8pLmJpbmQuYXBwbHkoX3RoaXMkY29uc29sZSRpbmZvLCBbdGhpcy5jb25zb2xlXS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3YXJuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdhcm4oKSB7XG4gICAgICB2YXIgX3RoaXMkY29uc29sZSR3YXJuO1xuXG4gICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKF90aGlzJGNvbnNvbGUkd2FybiA9IHRoaXMuY29uc29sZS53YXJuKS5iaW5kLmFwcGx5KF90aGlzJGNvbnNvbGUkd2FybiwgW3RoaXMuY29uc29sZV0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXJyb3IoKSB7XG4gICAgICB2YXIgX3RoaXMkY29uc29sZSRlcnJvcjtcblxuICAgICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTRdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChfdGhpcyRjb25zb2xlJGVycm9yID0gdGhpcy5jb25zb2xlLmVycm9yKS5iaW5kLmFwcGx5KF90aGlzJGNvbnNvbGUkZXJyb3IsIFt0aGlzLmNvbnNvbGVdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDb25zb2xlTG9nO1xufSgpO1xuXG5leHBvcnRzLkNvbnNvbGVMb2cgPSBDb25zb2xlTG9nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nZ2Vycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmlzTG9hZGVyT2JqZWN0ID0gaXNMb2FkZXJPYmplY3Q7XG5leHBvcnRzLm5vcm1hbGl6ZUxvYWRlciA9IG5vcm1hbGl6ZUxvYWRlcjtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9sb2FkZXJVdGlscyA9IHJlcXVpcmUoXCJAbG9hZGVycy5nbC9sb2FkZXItdXRpbHNcIik7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBpc0xvYWRlck9iamVjdChsb2FkZXIpIHtcbiAgdmFyIF9sb2FkZXI7XG5cbiAgaWYgKCFsb2FkZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShsb2FkZXIpKSB7XG4gICAgbG9hZGVyID0gbG9hZGVyWzBdO1xuICB9XG5cbiAgdmFyIGhhc0V4dGVuc2lvbnMgPSBBcnJheS5pc0FycmF5KChfbG9hZGVyID0gbG9hZGVyKSA9PT0gbnVsbCB8fCBfbG9hZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbG9hZGVyLmV4dGVuc2lvbnMpO1xuICByZXR1cm4gaGFzRXh0ZW5zaW9ucztcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplTG9hZGVyKGxvYWRlcikge1xuICB2YXIgX2xvYWRlcjIsIF9sb2FkZXIzO1xuXG4gICgwLCBfbG9hZGVyVXRpbHMuYXNzZXJ0KShsb2FkZXIsICdudWxsIGxvYWRlcicpO1xuICAoMCwgX2xvYWRlclV0aWxzLmFzc2VydCkoaXNMb2FkZXJPYmplY3QobG9hZGVyKSwgJ2ludmFsaWQgbG9hZGVyJyk7XG4gIHZhciBvcHRpb25zO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGxvYWRlcikpIHtcbiAgICBvcHRpb25zID0gbG9hZGVyWzFdO1xuICAgIGxvYWRlciA9IGxvYWRlclswXTtcbiAgICBsb2FkZXIgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGxvYWRlciksIHt9LCB7XG4gICAgICBvcHRpb25zOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGxvYWRlci5vcHRpb25zKSwgb3B0aW9ucylcbiAgICB9KTtcbiAgfVxuXG4gIGlmICgoX2xvYWRlcjIgPSBsb2FkZXIpICE9PSBudWxsICYmIF9sb2FkZXIyICE9PSB2b2lkIDAgJiYgX2xvYWRlcjIucGFyc2VUZXh0U3luYyB8fCAoX2xvYWRlcjMgPSBsb2FkZXIpICE9PSBudWxsICYmIF9sb2FkZXIzICE9PSB2b2lkIDAgJiYgX2xvYWRlcjMucGFyc2VUZXh0KSB7XG4gICAgbG9hZGVyLnRleHQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKCFsb2FkZXIudGV4dCkge1xuICAgIGxvYWRlci5iaW5hcnkgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGxvYWRlcjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vcm1hbGl6ZS1sb2FkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlJFTU9WRURfTE9BREVSX09QVElPTlMgPSBleHBvcnRzLkRFRkFVTFRfTE9BREVSX09QVElPTlMgPSB2b2lkIDA7XG5cbnZhciBfbG9nZ2VycyA9IHJlcXVpcmUoXCIuL2xvZ2dlcnNcIik7XG5cbnZhciBERUZBVUxUX0xPQURFUl9PUFRJT05TID0ge1xuICBmZXRjaDogbnVsbCxcbiAgbWltZVR5cGU6IHVuZGVmaW5lZCxcbiAgbm90aHJvdzogZmFsc2UsXG4gIGxvZzogbmV3IF9sb2dnZXJzLkNvbnNvbGVMb2coKSxcbiAgQ0ROOiAnaHR0cHM6Ly91bnBrZy5jb20vQGxvYWRlcnMuZ2wnLFxuICB3b3JrZXI6IHRydWUsXG4gIG1heENvbmN1cnJlbmN5OiAzLFxuICBtYXhNb2JpbGVDb25jdXJyZW5jeTogMSxcbiAgcmV1c2VXb3JrZXJzOiB0cnVlLFxuICBfd29ya2VyVHlwZTogJycsXG4gIGxpbWl0OiAwLFxuICBfbGltaXRNQjogMCxcbiAgYmF0Y2hTaXplOiAnYXV0bycsXG4gIGJhdGNoRGVib3VuY2VNczogMCxcbiAgbWV0YWRhdGE6IGZhbHNlLFxuICB0cmFuc2Zvcm1zOiBbXVxufTtcbmV4cG9ydHMuREVGQVVMVF9MT0FERVJfT1BUSU9OUyA9IERFRkFVTFRfTE9BREVSX09QVElPTlM7XG52YXIgUkVNT1ZFRF9MT0FERVJfT1BUSU9OUyA9IHtcbiAgdGhyb3dzOiAnbm90aHJvdycsXG4gIGRhdGFUeXBlOiAnKG5vIGxvbmdlciB1c2VkKScsXG4gIHVyaTogJ2Jhc2VVcmknLFxuICBtZXRob2Q6ICdmZXRjaC5tZXRob2QnLFxuICBoZWFkZXJzOiAnZmV0Y2guaGVhZGVycycsXG4gIGJvZHk6ICdmZXRjaC5ib2R5JyxcbiAgbW9kZTogJ2ZldGNoLm1vZGUnLFxuICBjcmVkZW50aWFsczogJ2ZldGNoLmNyZWRlbnRpYWxzJyxcbiAgY2FjaGU6ICdmZXRjaC5jYWNoZScsXG4gIHJlZGlyZWN0OiAnZmV0Y2gucmVkaXJlY3QnLFxuICByZWZlcnJlcjogJ2ZldGNoLnJlZmVycmVyJyxcbiAgcmVmZXJyZXJQb2xpY3k6ICdmZXRjaC5yZWZlcnJlclBvbGljeScsXG4gIGludGVncml0eTogJ2ZldGNoLmludGVncml0eScsXG4gIGtlZXBhbGl2ZTogJ2ZldGNoLmtlZXBhbGl2ZScsXG4gIHNpZ25hbDogJ2ZldGNoLnNpZ25hbCdcbn07XG5leHBvcnRzLlJFTU9WRURfTE9BREVSX09QVElPTlMgPSBSRU1PVkVEX0xPQURFUl9PUFRJT05TO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3B0aW9uLWRlZmF1bHRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0R2xvYmFsTG9hZGVyU3RhdGUgPSBnZXRHbG9iYWxMb2FkZXJTdGF0ZTtcbmV4cG9ydHMuc2V0R2xvYmFsT3B0aW9ucyA9IHNldEdsb2JhbE9wdGlvbnM7XG5leHBvcnRzLm5vcm1hbGl6ZU9wdGlvbnMgPSBub3JtYWxpemVPcHRpb25zO1xuZXhwb3J0cy5nZXRGZXRjaEZ1bmN0aW9uID0gZ2V0RmV0Y2hGdW5jdGlvbjtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9sb2FkZXJVdGlscyA9IHJlcXVpcmUoXCJAbG9hZGVycy5nbC9sb2FkZXItdXRpbHNcIik7XG5cbnZhciBfaXNUeXBlID0gcmVxdWlyZShcIi4uLy4uL2phdmFzY3JpcHQtdXRpbHMvaXMtdHlwZVwiKTtcblxudmFyIF9mZXRjaEZpbGUgPSByZXF1aXJlKFwiLi4vZmV0Y2gvZmV0Y2gtZmlsZVwiKTtcblxudmFyIF9sb2dnZXJzID0gcmVxdWlyZShcIi4vbG9nZ2Vyc1wiKTtcblxudmFyIF9vcHRpb25EZWZhdWx0cyA9IHJlcXVpcmUoXCIuL29wdGlvbi1kZWZhdWx0c1wiKTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gZ2V0R2xvYmFsTG9hZGVyU3RhdGUoKSB7XG4gIF9sb2FkZXJVdGlscy5nbG9iYWwubG9hZGVycyA9IF9sb2FkZXJVdGlscy5nbG9iYWwubG9hZGVycyB8fCB7fTtcbiAgdmFyIGxvYWRlcnMgPSBfbG9hZGVyVXRpbHMuZ2xvYmFsLmxvYWRlcnM7XG4gIGxvYWRlcnMuX3N0YXRlID0gbG9hZGVycy5fc3RhdGUgfHwge307XG4gIHJldHVybiBsb2FkZXJzLl9zdGF0ZTtcbn1cblxudmFyIGdldEdsb2JhbExvYWRlck9wdGlvbnMgPSBmdW5jdGlvbiBnZXRHbG9iYWxMb2FkZXJPcHRpb25zKCkge1xuICB2YXIgc3RhdGUgPSBnZXRHbG9iYWxMb2FkZXJTdGF0ZSgpO1xuICBzdGF0ZS5nbG9iYWxPcHRpb25zID0gc3RhdGUuZ2xvYmFsT3B0aW9ucyB8fCBfb2JqZWN0U3ByZWFkKHt9LCBfb3B0aW9uRGVmYXVsdHMuREVGQVVMVF9MT0FERVJfT1BUSU9OUyk7XG4gIHJldHVybiBzdGF0ZS5nbG9iYWxPcHRpb25zO1xufTtcblxuZnVuY3Rpb24gc2V0R2xvYmFsT3B0aW9ucyhvcHRpb25zKSB7XG4gIHZhciBzdGF0ZSA9IGdldEdsb2JhbExvYWRlclN0YXRlKCk7XG4gIHZhciBnbG9iYWxPcHRpb25zID0gZ2V0R2xvYmFsTG9hZGVyT3B0aW9ucygpO1xuICBzdGF0ZS5nbG9iYWxPcHRpb25zID0gbm9ybWFsaXplT3B0aW9uc0ludGVybmFsKGdsb2JhbE9wdGlvbnMsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVPcHRpb25zKG9wdGlvbnMsIGxvYWRlciwgbG9hZGVycywgdXJsKSB7XG4gIGxvYWRlcnMgPSBsb2FkZXJzIHx8IFtdO1xuICBsb2FkZXJzID0gQXJyYXkuaXNBcnJheShsb2FkZXJzKSA/IGxvYWRlcnMgOiBbbG9hZGVyc107XG4gIHZhbGlkYXRlT3B0aW9ucyhvcHRpb25zLCBsb2FkZXJzKTtcbiAgcmV0dXJuIG5vcm1hbGl6ZU9wdGlvbnNJbnRlcm5hbChsb2FkZXIsIG9wdGlvbnMsIHVybCk7XG59XG5cbmZ1bmN0aW9uIGdldEZldGNoRnVuY3Rpb24ob3B0aW9ucywgY29udGV4dCkge1xuICB2YXIgZ2xvYmFsT3B0aW9ucyA9IGdldEdsb2JhbExvYWRlck9wdGlvbnMoKTtcbiAgdmFyIGZldGNoT3B0aW9ucyA9IG9wdGlvbnMgfHwgZ2xvYmFsT3B0aW9ucztcblxuICBpZiAodHlwZW9mIGZldGNoT3B0aW9ucy5mZXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmZXRjaE9wdGlvbnMuZmV0Y2g7XG4gIH1cblxuICBpZiAoKDAsIF9pc1R5cGUuaXNPYmplY3QpKGZldGNoT3B0aW9ucy5mZXRjaCkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHVybCkge1xuICAgICAgcmV0dXJuICgwLCBfZmV0Y2hGaWxlLmZldGNoRmlsZSkodXJsLCBmZXRjaE9wdGlvbnMpO1xuICAgIH07XG4gIH1cblxuICBpZiAoY29udGV4dCAhPT0gbnVsbCAmJiBjb250ZXh0ICE9PSB2b2lkIDAgJiYgY29udGV4dC5mZXRjaCkge1xuICAgIHJldHVybiBjb250ZXh0ID09PSBudWxsIHx8IGNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRleHQuZmV0Y2g7XG4gIH1cblxuICByZXR1cm4gX2ZldGNoRmlsZS5mZXRjaEZpbGU7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9ucyhvcHRpb25zLCBsb2FkZXJzKSB7XG4gIHZhbGlkYXRlT3B0aW9uc09iamVjdChvcHRpb25zLCBudWxsLCBfb3B0aW9uRGVmYXVsdHMuREVGQVVMVF9MT0FERVJfT1BUSU9OUywgX29wdGlvbkRlZmF1bHRzLlJFTU9WRURfTE9BREVSX09QVElPTlMsIGxvYWRlcnMpO1xuXG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihsb2FkZXJzKSxcbiAgICAgIF9zdGVwO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBsb2FkZXIgPSBfc3RlcC52YWx1ZTtcbiAgICAgIHZhciBpZE9wdGlvbnMgPSBvcHRpb25zICYmIG9wdGlvbnNbbG9hZGVyLmlkXSB8fCB7fTtcbiAgICAgIHZhciBsb2FkZXJPcHRpb25zID0gbG9hZGVyLm9wdGlvbnMgJiYgbG9hZGVyLm9wdGlvbnNbbG9hZGVyLmlkXSB8fCB7fTtcbiAgICAgIHZhciBkZXByZWNhdGVkT3B0aW9ucyA9IGxvYWRlci5kZXByZWNhdGVkT3B0aW9ucyAmJiBsb2FkZXIuZGVwcmVjYXRlZE9wdGlvbnNbbG9hZGVyLmlkXSB8fCB7fTtcbiAgICAgIHZhbGlkYXRlT3B0aW9uc09iamVjdChpZE9wdGlvbnMsIGxvYWRlci5pZCwgbG9hZGVyT3B0aW9ucywgZGVwcmVjYXRlZE9wdGlvbnMsIGxvYWRlcnMpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9uc09iamVjdChvcHRpb25zLCBpZCwgZGVmYXVsdE9wdGlvbnMsIGRlcHJlY2F0ZWRPcHRpb25zLCBsb2FkZXJzKSB7XG4gIHZhciBsb2FkZXJOYW1lID0gaWQgfHwgJ1RvcCBsZXZlbCc7XG4gIHZhciBwcmVmaXggPSBpZCA/IFwiXCIuY29uY2F0KGlkLCBcIi5cIikgOiAnJztcblxuICBmb3IgKHZhciBfa2V5IGluIG9wdGlvbnMpIHtcbiAgICB2YXIgaXNTdWJPcHRpb25zID0gIWlkICYmICgwLCBfaXNUeXBlLmlzT2JqZWN0KShvcHRpb25zW19rZXldKTtcbiAgICB2YXIgaXNCYXNlVXJpT3B0aW9uID0gX2tleSA9PT0gJ2Jhc2VVcmknICYmICFpZDtcbiAgICB2YXIgaXNXb3JrZXJVcmxPcHRpb24gPSBfa2V5ID09PSAnd29ya2VyVXJsJyAmJiBpZDtcblxuICAgIGlmICghKF9rZXkgaW4gZGVmYXVsdE9wdGlvbnMpICYmICFpc0Jhc2VVcmlPcHRpb24gJiYgIWlzV29ya2VyVXJsT3B0aW9uKSB7XG4gICAgICBpZiAoX2tleSBpbiBkZXByZWNhdGVkT3B0aW9ucykge1xuICAgICAgICBfbG9nZ2Vycy5wcm9iZUxvZy53YXJuKFwiXCIuY29uY2F0KGxvYWRlck5hbWUsIFwiIGxvYWRlciBvcHRpb24gJ1wiKS5jb25jYXQocHJlZml4KS5jb25jYXQoX2tleSwgXCInIG5vIGxvbmdlciBzdXBwb3J0ZWQsIHVzZSAnXCIpLmNvbmNhdChkZXByZWNhdGVkT3B0aW9uc1tfa2V5XSwgXCInXCIpKSgpO1xuICAgICAgfSBlbHNlIGlmICghaXNTdWJPcHRpb25zKSB7XG4gICAgICAgIHZhciBzdWdnZXN0aW9uID0gZmluZFNpbWlsYXJPcHRpb24oX2tleSwgbG9hZGVycyk7XG5cbiAgICAgICAgX2xvZ2dlcnMucHJvYmVMb2cud2FybihcIlwiLmNvbmNhdChsb2FkZXJOYW1lLCBcIiBsb2FkZXIgb3B0aW9uICdcIikuY29uY2F0KHByZWZpeCkuY29uY2F0KF9rZXksIFwiJyBub3QgcmVjb2duaXplZC4gXCIpLmNvbmNhdChzdWdnZXN0aW9uKSkoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFNpbWlsYXJPcHRpb24ob3B0aW9uS2V5LCBsb2FkZXJzKSB7XG4gIHZhciBsb3dlckNhc2VPcHRpb25LZXkgPSBvcHRpb25LZXkudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGJlc3RTdWdnZXN0aW9uID0gJyc7XG5cbiAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihsb2FkZXJzKSxcbiAgICAgIF9zdGVwMjtcblxuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgbG9hZGVyID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICBmb3IgKHZhciBfa2V5MiBpbiBsb2FkZXIub3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9uS2V5ID09PSBfa2V5Mikge1xuICAgICAgICAgIHJldHVybiBcIkRpZCB5b3UgbWVhbiAnXCIuY29uY2F0KGxvYWRlci5pZCwgXCIuXCIpLmNvbmNhdChfa2V5MiwgXCInP1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb3dlckNhc2VLZXkgPSBfa2V5Mi50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIHZhciBpc1BhcnRpYWxNYXRjaCA9IGxvd2VyQ2FzZU9wdGlvbktleS5zdGFydHNXaXRoKGxvd2VyQ2FzZUtleSkgfHwgbG93ZXJDYXNlS2V5LnN0YXJ0c1dpdGgobG93ZXJDYXNlT3B0aW9uS2V5KTtcblxuICAgICAgICBpZiAoaXNQYXJ0aWFsTWF0Y2gpIHtcbiAgICAgICAgICBiZXN0U3VnZ2VzdGlvbiA9IGJlc3RTdWdnZXN0aW9uIHx8IFwiRGlkIHlvdSBtZWFuICdcIi5jb25jYXQobG9hZGVyLmlkLCBcIi5cIikuY29uY2F0KF9rZXkyLCBcIic/XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IyLmYoKTtcbiAgfVxuXG4gIHJldHVybiBiZXN0U3VnZ2VzdGlvbjtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplT3B0aW9uc0ludGVybmFsKGxvYWRlciwgb3B0aW9ucywgdXJsKSB7XG4gIHZhciBsb2FkZXJEZWZhdWx0T3B0aW9ucyA9IGxvYWRlci5vcHRpb25zIHx8IHt9O1xuXG4gIHZhciBtZXJnZWRPcHRpb25zID0gX29iamVjdFNwcmVhZCh7fSwgbG9hZGVyRGVmYXVsdE9wdGlvbnMpO1xuXG4gIGFkZFVybE9wdGlvbnMobWVyZ2VkT3B0aW9ucywgdXJsKTtcblxuICBpZiAobWVyZ2VkT3B0aW9ucy5sb2cgPT09IG51bGwpIHtcbiAgICBtZXJnZWRPcHRpb25zLmxvZyA9IG5ldyBfbG9nZ2Vycy5OdWxsTG9nKCk7XG4gIH1cblxuICBtZXJnZU5lc3RlZEZpZWxkcyhtZXJnZWRPcHRpb25zLCBnZXRHbG9iYWxMb2FkZXJPcHRpb25zKCkpO1xuICBtZXJnZU5lc3RlZEZpZWxkcyhtZXJnZWRPcHRpb25zLCBvcHRpb25zKTtcbiAgcmV0dXJuIG1lcmdlZE9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIG1lcmdlTmVzdGVkRmllbGRzKG1lcmdlZE9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgX2tleTMgaW4gb3B0aW9ucykge1xuICAgIGlmIChfa2V5MyBpbiBvcHRpb25zKSB7XG4gICAgICB2YXIgdmFsdWUgPSBvcHRpb25zW19rZXkzXTtcblxuICAgICAgaWYgKCgwLCBfaXNUeXBlLmlzUHVyZU9iamVjdCkodmFsdWUpICYmICgwLCBfaXNUeXBlLmlzUHVyZU9iamVjdCkobWVyZ2VkT3B0aW9uc1tfa2V5M10pKSB7XG4gICAgICAgIG1lcmdlZE9wdGlvbnNbX2tleTNdID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBtZXJnZWRPcHRpb25zW19rZXkzXSksIG9wdGlvbnNbX2tleTNdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lcmdlZE9wdGlvbnNbX2tleTNdID0gb3B0aW9uc1tfa2V5M107XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFVybE9wdGlvbnMob3B0aW9ucywgdXJsKSB7XG4gIGlmICh1cmwgJiYgISgnYmFzZVVyaScgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLmJhc2VVcmkgPSB1cmw7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wdGlvbi11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBmZXRjaFByb2dyZXNzO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxuZnVuY3Rpb24gZmV0Y2hQcm9ncmVzcyhfeCwgX3gyKSB7XG4gIHJldHVybiBfZmV0Y2hQcm9ncmVzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZmV0Y2hQcm9ncmVzcygpIHtcbiAgX2ZldGNoUHJvZ3Jlc3MgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIocmVzcG9uc2UsIG9uUHJvZ3Jlc3MpIHtcbiAgICB2YXIgb25Eb25lLFxuICAgICAgICBvbkVycm9yLFxuICAgICAgICBib2R5LFxuICAgICAgICBjb250ZW50TGVuZ3RoLFxuICAgICAgICB0b3RhbEJ5dGVzLFxuICAgICAgICBwcm9ncmVzc1N0cmVhbSxcbiAgICAgICAgX2FyZ3MyID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIG9uRG9uZSA9IF9hcmdzMi5sZW5ndGggPiAyICYmIF9hcmdzMlsyXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3MyWzJdIDogZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICBvbkVycm9yID0gX2FyZ3MyLmxlbmd0aCA+IDMgJiYgX2FyZ3MyWzNdICE9PSB1bmRlZmluZWQgPyBfYXJnczJbM10gOiBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJlc3BvbnNlID0gX2NvbnRleHQyLnNlbnQ7XG5cbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCByZXNwb25zZSk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBib2R5ID0gcmVzcG9uc2UuYm9keTtcblxuICAgICAgICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHJlc3BvbnNlKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBjb250ZW50TGVuZ3RoID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtbGVuZ3RoJykgfHwgMDtcbiAgICAgICAgICAgIHRvdGFsQnl0ZXMgPSBjb250ZW50TGVuZ3RoICYmIHBhcnNlSW50KGNvbnRlbnRMZW5ndGgpO1xuXG4gICAgICAgICAgICBpZiAoY29udGVudExlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHJlc3BvbnNlKTtcblxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICBpZiAoISh0eXBlb2YgUmVhZGFibGVTdHJlYW0gPT09ICd1bmRlZmluZWQnIHx8ICFib2R5LmdldFJlYWRlcikpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHJlc3BvbnNlKTtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBwcm9ncmVzc1N0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlYWRlcjtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSBib2R5LmdldFJlYWRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWQoY29udHJvbGxlciwgcmVhZGVyLCAwLCB0b3RhbEJ5dGVzLCBvblByb2dyZXNzLCBvbkRvbmUsIG9uRXJyb3IpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlKTtcbiAgICAgICAgICAgICAgICB9KSkoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBuZXcgUmVzcG9uc2UocHJvZ3Jlc3NTdHJlYW0pKTtcblxuICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMik7XG4gIH0pKTtcbiAgcmV0dXJuIF9mZXRjaFByb2dyZXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHJlYWQoX3gzLCBfeDQsIF94NSwgX3g2LCBfeDcsIF94OCwgX3g5KSB7XG4gIHJldHVybiBfcmVhZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfcmVhZCgpIHtcbiAgX3JlYWQgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoY29udHJvbGxlciwgcmVhZGVyLCBsb2FkZWRCeXRlcywgdG90YWxCeXRlcywgb25Qcm9ncmVzcywgb25Eb25lLCBvbkVycm9yKSB7XG4gICAgdmFyIF95aWVsZCRyZWFkZXIkcmVhZCwgZG9uZSwgdmFsdWUsIHBlcmNlbnQ7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDA7XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQoKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIF95aWVsZCRyZWFkZXIkcmVhZCA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgZG9uZSA9IF95aWVsZCRyZWFkZXIkcmVhZC5kb25lO1xuICAgICAgICAgICAgdmFsdWUgPSBfeWllbGQkcmVhZGVyJHJlYWQudmFsdWU7XG5cbiAgICAgICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDEwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb25Eb25lKCk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBsb2FkZWRCeXRlcyArPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgcGVyY2VudCA9IE1hdGgucm91bmQobG9hZGVkQnl0ZXMgLyB0b3RhbEJ5dGVzICogMTAwKTtcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3MocGVyY2VudCwge1xuICAgICAgICAgICAgICBsb2FkZWRCeXRlczogbG9hZGVkQnl0ZXMsXG4gICAgICAgICAgICAgIHRvdGFsQnl0ZXM6IHRvdGFsQnl0ZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTY7XG4gICAgICAgICAgICByZXR1cm4gcmVhZChjb250cm9sbGVyLCByZWFkZXIsIGxvYWRlZEJ5dGVzLCB0b3RhbEJ5dGVzLCBvblByb2dyZXNzLCBvbkRvbmUsIG9uRXJyb3IpO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDE4O1xuICAgICAgICAgICAgX2NvbnRleHQzLnQwID0gX2NvbnRleHQzW1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKF9jb250ZXh0My50MCk7XG4gICAgICAgICAgICBvbkVycm9yKF9jb250ZXh0My50MCk7XG5cbiAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTMsIG51bGwsIFtbMCwgMThdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9yZWFkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZXRjaC1wcm9ncmVzcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucGFyc2VNSU1FVHlwZSA9IHBhcnNlTUlNRVR5cGU7XG5leHBvcnRzLnBhcnNlTUlNRVR5cGVGcm9tVVJMID0gcGFyc2VNSU1FVHlwZUZyb21VUkw7XG52YXIgREFUQV9VUkxfUEFUVEVSTiA9IC9eZGF0YTooWy1cXHcuXStcXC9bLVxcdy4rXSspKDt8LCkvO1xudmFyIE1JTUVfVFlQRV9QQVRURVJOID0gL14oWy1cXHcuXStcXC9bLVxcdy4rXSspLztcblxuZnVuY3Rpb24gcGFyc2VNSU1FVHlwZShtaW1lU3RyaW5nKSB7XG4gIHZhciBtYXRjaGVzID0gTUlNRV9UWVBFX1BBVFRFUk4uZXhlYyhtaW1lU3RyaW5nKTtcblxuICBpZiAobWF0Y2hlcykge1xuICAgIHJldHVybiBtYXRjaGVzWzFdO1xuICB9XG5cbiAgcmV0dXJuIG1pbWVTdHJpbmc7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTUlNRVR5cGVGcm9tVVJMKHVybCkge1xuICB2YXIgbWF0Y2hlcyA9IERBVEFfVVJMX1BBVFRFUk4uZXhlYyh1cmwpO1xuXG4gIGlmIChtYXRjaGVzKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNbMV07XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1taW1lLXR5cGUtdXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldFJlc291cmNlVXJsQW5kVHlwZSA9IGdldFJlc291cmNlVXJsQW5kVHlwZTtcbmV4cG9ydHMuZ2V0UmVzb3VyY2VDb250ZW50TGVuZ3RoID0gZ2V0UmVzb3VyY2VDb250ZW50TGVuZ3RoO1xuXG52YXIgX2lzVHlwZSA9IHJlcXVpcmUoXCIuLi8uLi9qYXZhc2NyaXB0LXV0aWxzL2lzLXR5cGVcIik7XG5cbnZhciBfbWltZVR5cGVVdGlscyA9IHJlcXVpcmUoXCIuL21pbWUtdHlwZS11dGlsc1wiKTtcblxudmFyIFFVRVJZX1NUUklOR19QQVRURVJOID0gL1xcPy4qLztcblxuZnVuY3Rpb24gZ2V0UmVzb3VyY2VVcmxBbmRUeXBlKHJlc291cmNlKSB7XG4gIGlmICgoMCwgX2lzVHlwZS5pc1Jlc3BvbnNlKShyZXNvdXJjZSkpIHtcbiAgICB2YXIgdXJsID0gc3RyaXBRdWVyeVN0cmluZyhyZXNvdXJjZS51cmwgfHwgJycpO1xuICAgIHZhciBjb250ZW50VHlwZUhlYWRlciA9IHJlc291cmNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSB8fCAnJztcbiAgICByZXR1cm4ge1xuICAgICAgdXJsOiB1cmwsXG4gICAgICB0eXBlOiAoMCwgX21pbWVUeXBlVXRpbHMucGFyc2VNSU1FVHlwZSkoY29udGVudFR5cGVIZWFkZXIpIHx8ICgwLCBfbWltZVR5cGVVdGlscy5wYXJzZU1JTUVUeXBlRnJvbVVSTCkodXJsKVxuICAgIH07XG4gIH1cblxuICBpZiAoKDAsIF9pc1R5cGUuaXNCbG9iKShyZXNvdXJjZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdXJsOiBzdHJpcFF1ZXJ5U3RyaW5nKHJlc291cmNlLm5hbWUgfHwgJycpLFxuICAgICAgdHlwZTogcmVzb3VyY2UudHlwZSB8fCAnJ1xuICAgIH07XG4gIH1cblxuICBpZiAodHlwZW9mIHJlc291cmNlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB7XG4gICAgICB1cmw6IHN0cmlwUXVlcnlTdHJpbmcocmVzb3VyY2UpLFxuICAgICAgdHlwZTogKDAsIF9taW1lVHlwZVV0aWxzLnBhcnNlTUlNRVR5cGVGcm9tVVJMKShyZXNvdXJjZSlcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB1cmw6ICcnLFxuICAgIHR5cGU6ICcnXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFJlc291cmNlQ29udGVudExlbmd0aChyZXNvdXJjZSkge1xuICBpZiAoKDAsIF9pc1R5cGUuaXNSZXNwb25zZSkocmVzb3VyY2UpKSB7XG4gICAgcmV0dXJuIHJlc291cmNlLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10gfHwgLTE7XG4gIH1cblxuICBpZiAoKDAsIF9pc1R5cGUuaXNCbG9iKShyZXNvdXJjZSkpIHtcbiAgICByZXR1cm4gcmVzb3VyY2Uuc2l6ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcmVzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHJlc291cmNlLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChyZXNvdXJjZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHJlc291cmNlLmJ5dGVMZW5ndGg7XG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHJlc291cmNlKSkge1xuICAgIHJldHVybiByZXNvdXJjZS5ieXRlTGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBzdHJpcFF1ZXJ5U3RyaW5nKHVybCkge1xuICByZXR1cm4gdXJsLnJlcGxhY2UoUVVFUllfU1RSSU5HX1BBVFRFUk4sICcnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc291cmNlLXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubWFrZVJlc3BvbnNlID0gbWFrZVJlc3BvbnNlO1xuZXhwb3J0cy5jaGVja1Jlc3BvbnNlID0gY2hlY2tSZXNwb25zZTtcbmV4cG9ydHMuY2hlY2tSZXNwb25zZVN5bmMgPSBjaGVja1Jlc3BvbnNlU3luYztcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfaXNUeXBlID0gcmVxdWlyZShcIi4uLy4uL2phdmFzY3JpcHQtdXRpbHMvaXMtdHlwZVwiKTtcblxudmFyIF9yZXNvdXJjZVV0aWxzID0gcmVxdWlyZShcIi4vcmVzb3VyY2UtdXRpbHNcIik7XG5cbmZ1bmN0aW9uIG1ha2VSZXNwb25zZShfeCkge1xuICByZXR1cm4gX21ha2VSZXNwb25zZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfbWFrZVJlc3BvbnNlKCkge1xuICBfbWFrZVJlc3BvbnNlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUocmVzb3VyY2UpIHtcbiAgICB2YXIgaGVhZGVycywgY29udGVudExlbmd0aCwgX2dldFJlc291cmNlVXJsQW5kVHlwLCB1cmwsIHR5cGUsIGluaXRpYWxEYXRhVXJsLCByZXNwb25zZTtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCEoMCwgX2lzVHlwZS5pc1Jlc3BvbnNlKShyZXNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHJlc291cmNlKTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgIGNvbnRlbnRMZW5ndGggPSAoMCwgX3Jlc291cmNlVXRpbHMuZ2V0UmVzb3VyY2VDb250ZW50TGVuZ3RoKShyZXNvdXJjZSk7XG5cbiAgICAgICAgICAgIGlmIChjb250ZW50TGVuZ3RoID49IDApIHtcbiAgICAgICAgICAgICAgaGVhZGVyc1snY29udGVudC1sZW5ndGgnXSA9IFN0cmluZyhjb250ZW50TGVuZ3RoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2dldFJlc291cmNlVXJsQW5kVHlwID0gKDAsIF9yZXNvdXJjZVV0aWxzLmdldFJlc291cmNlVXJsQW5kVHlwZSkocmVzb3VyY2UpLCB1cmwgPSBfZ2V0UmVzb3VyY2VVcmxBbmRUeXAudXJsLCB0eXBlID0gX2dldFJlc291cmNlVXJsQW5kVHlwLnR5cGU7XG5cbiAgICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAgIGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gdHlwZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgICByZXR1cm4gZ2V0SW5pdGlhbERhdGFVcmwocmVzb3VyY2UpO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgaW5pdGlhbERhdGFVcmwgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgICBpZiAoaW5pdGlhbERhdGFVcmwpIHtcbiAgICAgICAgICAgICAgaGVhZGVyc1sneC1maXJzdC1ieXRlcyddID0gaW5pdGlhbERhdGFVcmw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHJlc291cmNlID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHJlc291cmNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UocmVzb3VyY2UsIHtcbiAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzcG9uc2UsICd1cmwnLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiB1cmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCByZXNwb25zZSk7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlKTtcbiAgfSkpO1xuICByZXR1cm4gX21ha2VSZXNwb25zZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBjaGVja1Jlc3BvbnNlKF94Mikge1xuICByZXR1cm4gX2NoZWNrUmVzcG9uc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2NoZWNrUmVzcG9uc2UoKSB7XG4gIF9jaGVja1Jlc3BvbnNlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKHJlc3BvbnNlKSB7XG4gICAgdmFyIG1lc3NhZ2U7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiBnZXRSZXNwb25zZUVycm9yKHJlc3BvbnNlKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyKTtcbiAgfSkpO1xuICByZXR1cm4gX2NoZWNrUmVzcG9uc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tSZXNwb25zZVN5bmMocmVzcG9uc2UpIHtcbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIHZhciBtZXNzYWdlID0gXCJcIi5jb25jYXQocmVzcG9uc2Uuc3RhdHVzLCBcIiBcIikuY29uY2F0KHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuICAgIG1lc3NhZ2UgPSBtZXNzYWdlLmxlbmd0aCA+IDYwID8gXCJcIi5jb25jYXQobWVzc2FnZS5zbGljZSg2MCksIFwiLi4uXCIpIDogbWVzc2FnZTtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmVzcG9uc2VFcnJvcihfeDMpIHtcbiAgcmV0dXJuIF9nZXRSZXNwb25zZUVycm9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRSZXNwb25zZUVycm9yKCkge1xuICBfZ2V0UmVzcG9uc2VFcnJvciA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhyZXNwb25zZSkge1xuICAgIHZhciBtZXNzYWdlLCBjb250ZW50VHlwZSwgdGV4dDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJGYWlsZWQgdG8gZmV0Y2ggcmVzb3VyY2UgXCIuY29uY2F0KHJlc3BvbnNlLnVybCwgXCIgKFwiKS5jb25jYXQocmVzcG9uc2Uuc3RhdHVzLCBcIik6IFwiKTtcbiAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMTtcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpO1xuICAgICAgICAgICAgdGV4dCA9IHJlc3BvbnNlLnN0YXR1c1RleHQ7XG5cbiAgICAgICAgICAgIGlmICghY29udGVudFR5cGUuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDExO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQzLnQwID0gdGV4dDtcbiAgICAgICAgICAgIF9jb250ZXh0My50MSA9IFwiIFwiO1xuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA5O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIF9jb250ZXh0My50MiA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgdGV4dCA9IF9jb250ZXh0My50MCArPSBfY29udGV4dDMudDEuY29uY2F0LmNhbGwoX2NvbnRleHQzLnQxLCBfY29udGV4dDMudDIpO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gdGV4dDtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLmxlbmd0aCA+IDYwID8gXCJcIi5jb25jYXQobWVzc2FnZS5zbGljZSg2MCksIFwiLi4uXCIpIDogbWVzc2FnZTtcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDE1O1xuICAgICAgICAgICAgX2NvbnRleHQzLnQzID0gX2NvbnRleHQzW1wiY2F0Y2hcIl0oMSk7XG5cbiAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgbWVzc2FnZSk7XG5cbiAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTMsIG51bGwsIFtbMSwgMTVdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRSZXNwb25zZUVycm9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEluaXRpYWxEYXRhVXJsKF94NCkge1xuICByZXR1cm4gX2dldEluaXRpYWxEYXRhVXJsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRJbml0aWFsRGF0YVVybCgpIHtcbiAgX2dldEluaXRpYWxEYXRhVXJsID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KHJlc291cmNlKSB7XG4gICAgdmFyIElOSVRJQUxfREFUQV9MRU5HVEgsIGJsb2JTbGljZSwgc2xpY2UsIGJhc2U2NDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBJTklUSUFMX0RBVEFfTEVOR1RIID0gNTtcblxuICAgICAgICAgICAgaWYgKCEodHlwZW9mIHJlc291cmNlID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgXCJkYXRhOixcIi5jb25jYXQocmVzb3VyY2Uuc2xpY2UoMCwgSU5JVElBTF9EQVRBX0xFTkdUSCkpKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGlmICghKHJlc291cmNlIGluc3RhbmNlb2YgQmxvYikpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYmxvYlNsaWNlID0gcmVzb3VyY2Uuc2xpY2UoMCwgNSk7XG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDc7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBfZXZlbnQkdGFyZ2V0O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZXZlbnQgPT09IG51bGwgfHwgZXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfZXZlbnQkdGFyZ2V0ID0gZXZlbnQudGFyZ2V0KSA9PT0gbnVsbCB8fCBfZXZlbnQkdGFyZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXZlbnQkdGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYlNsaWNlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ0LnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgaWYgKCEocmVzb3VyY2UgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNsaWNlID0gcmVzb3VyY2Uuc2xpY2UoMCwgSU5JVElBTF9EQVRBX0xFTkdUSCk7XG4gICAgICAgICAgICBiYXNlNjQgPSBhcnJheUJ1ZmZlclRvQmFzZTY0KHNsaWNlKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIFwiZGF0YTpiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCkpO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIG51bGwpO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU0KTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEluaXRpYWxEYXRhVXJsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGFycmF5QnVmZmVyVG9CYXNlNjQoYnVmZmVyKSB7XG4gIHZhciBiaW5hcnkgPSAnJztcbiAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmJ5dGVMZW5ndGg7IGkrKykge1xuICAgIGJpbmFyeSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKTtcbiAgfVxuXG4gIHJldHVybiBidG9hKGJpbmFyeSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNwb25zZS11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLk51bGxMb2FkZXIgPSBleHBvcnRzLk51bGxXb3JrZXJMb2FkZXIgPSB2b2lkIDA7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2F3YWl0QXN5bmNHZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hd2FpdEFzeW5jR2VuZXJhdG9yXCIpKTtcblxudmFyIF93cmFwQXN5bmNHZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy93cmFwQXN5bmNHZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jSXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY0l0ZXJhdG9yXCIpKTtcblxudmFyIFZFUlNJT04gPSB0eXBlb2YgXCIzLjAuOVwiICE9PSAndW5kZWZpbmVkJyA/IFwiMy4wLjlcIiA6ICdsYXRlc3QnO1xudmFyIE51bGxXb3JrZXJMb2FkZXIgPSB7XG4gIG5hbWU6ICdOdWxsIGxvYWRlcicsXG4gIGlkOiAnbnVsbCcsXG4gIG1vZHVsZTogJ2NvcmUnLFxuICB2ZXJzaW9uOiBWRVJTSU9OLFxuICB3b3JrZXI6IHRydWUsXG4gIG1pbWVUeXBlczogWydhcHBsaWNhdGlvbi94LmVtcHR5J10sXG4gIGV4dGVuc2lvbnM6IFsnbnVsbCddLFxuICB0ZXN0czogW2Z1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1dLFxuICBvcHRpb25zOiB7XG4gICAgbnVsbDoge31cbiAgfVxufTtcbmV4cG9ydHMuTnVsbFdvcmtlckxvYWRlciA9IE51bGxXb3JrZXJMb2FkZXI7XG52YXIgTnVsbExvYWRlciA9IHtcbiAgbmFtZTogJ051bGwgbG9hZGVyJyxcbiAgaWQ6ICdudWxsJyxcbiAgbW9kdWxlOiAnY29yZScsXG4gIHZlcnNpb246IFZFUlNJT04sXG4gIG1pbWVUeXBlczogWydhcHBsaWNhdGlvbi94LmVtcHR5J10sXG4gIGV4dGVuc2lvbnM6IFsnbnVsbCddLFxuICBwYXJzZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcGFyc2UgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZShhcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgYXJyYXlCdWZmZXIpO1xuXG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBwYXJzZShfeDIpIHtcbiAgICAgIHJldHVybiBfcGFyc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2U7XG4gIH0oKSxcbiAgcGFyc2VTeW5jOiBmdW5jdGlvbiBwYXJzZVN5bmMoYXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gYXJyYXlCdWZmZXI7XG4gIH0sXG4gIHBhcnNlSW5CYXRjaGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9nZW5lcmF0b3IgPSAoMCwgX3dyYXBBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMihhc3luY0l0ZXJhdG9yKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiwgX2RpZEl0ZXJhdG9yRXJyb3IsIF9pdGVyYXRvckVycm9yLCBfaXRlcmF0b3IsIF9zdGVwLCBfdmFsdWUsIGJhdGNoO1xuXG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDI7XG4gICAgICAgICAgICAgIF9pdGVyYXRvciA9ICgwLCBfYXN5bmNJdGVyYXRvcjIuZGVmYXVsdCkoYXN5bmNJdGVyYXRvcik7XG5cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA2O1xuICAgICAgICAgICAgICByZXR1cm4gKDAsIF9hd2FpdEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShfaXRlcmF0b3IubmV4dCgpKTtcblxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBfc3RlcCA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gX3N0ZXAuZG9uZTtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgcmV0dXJuICgwLCBfYXdhaXRBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoX3N0ZXAudmFsdWUpO1xuXG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBfdmFsdWUgPSBfY29udGV4dDIuc2VudDtcblxuICAgICAgICAgICAgICBpZiAoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbikge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBiYXRjaCA9IF92YWx1ZTtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgcmV0dXJuIGJhdGNoO1xuXG4gICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA0O1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMjA7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IF9jb250ZXh0MltcImNhdGNoXCJdKDIpO1xuICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gX2NvbnRleHQyLnQwO1xuXG4gICAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDI0O1xuICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDI1O1xuXG4gICAgICAgICAgICAgIGlmICghKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyOTtcbiAgICAgICAgICAgICAgcmV0dXJuICgwLCBfYXdhaXRBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoX2l0ZXJhdG9yLnJldHVybigpKTtcblxuICAgICAgICAgICAgY2FzZSAyOTpcbiAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAyOTtcblxuICAgICAgICAgICAgICBpZiAoIV9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAzMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuXG4gICAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmZpbmlzaCgyOSk7XG5cbiAgICAgICAgICAgIGNhc2UgMzM6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuZmluaXNoKDI0KTtcblxuICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlMiwgbnVsbCwgW1syLCAyMCwgMjQsIDM0XSwgWzI1LCwgMjksIDMzXV0pO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRvcihfeCkge1xuICAgICAgcmV0dXJuIF9nZW5lcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9KCksXG4gIHRlc3RzOiBbZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfV0sXG4gIG9wdGlvbnM6IHtcbiAgICBudWxsOiB7fVxuICB9XG59O1xuZXhwb3J0cy5OdWxsTG9hZGVyID0gTnVsbExvYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW51bGwtbG9hZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuX3R5cGVjaGVja0NTVkxvYWRlciA9IGV4cG9ydHMuQ1NWTG9hZGVyID0gdm9pZCAwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX3R5cGVvZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX3NjaGVtYSA9IHJlcXVpcmUoXCJAbG9hZGVycy5nbC9zY2hlbWFcIik7XG5cbnZhciBfcGFwYXBhcnNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWJzL3BhcGFwYXJzZVwiKSk7XG5cbnZhciBfYXN5bmNJdGVyYXRvclN0cmVhbWVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvYXN5bmMtaXRlcmF0b3Itc3RyZWFtZXJcIikpO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIFZFUlNJT04gPSB0eXBlb2YgXCIzLjAuOVwiICE9PSAndW5kZWZpbmVkJyA/IFwiMy4wLjlcIiA6ICdsYXRlc3QnO1xudmFyIERFRkFVTFRfQ1NWX0xPQURFUl9PUFRJT05TID0ge1xuICBjc3Y6IHtcbiAgICBzaGFwZTogJ29iamVjdC1yb3ctdGFibGUnLFxuICAgIG9wdGltaXplTWVtb3J5VXNhZ2U6IGZhbHNlLFxuICAgIGhlYWRlcjogJ2F1dG8nLFxuICAgIGNvbHVtblByZWZpeDogJ2NvbHVtbicsXG4gICAgcXVvdGVDaGFyOiAnXCInLFxuICAgIGVzY2FwZUNoYXI6ICdcIicsXG4gICAgZHluYW1pY1R5cGluZzogdHJ1ZSxcbiAgICBjb21tZW50czogZmFsc2UsXG4gICAgc2tpcEVtcHR5TGluZXM6IHRydWUsXG4gICAgZGVsaW1pdGVyc1RvR3Vlc3M6IFsnLCcsICdcXHQnLCAnfCcsICc7J11cbiAgfVxufTtcbnZhciBDU1ZMb2FkZXIgPSB7XG4gIGlkOiAnY3N2JyxcbiAgbW9kdWxlOiAnY3N2JyxcbiAgbmFtZTogJ0NTVicsXG4gIHZlcnNpb246IFZFUlNJT04sXG4gIGV4dGVuc2lvbnM6IFsnY3N2J10sXG4gIG1pbWVUeXBlczogWyd0ZXh0L2NzdiddLFxuICBjYXRlZ29yeTogJ3RhYmxlJyxcbiAgcGFyc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3BhcnNlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoYXJyYXlCdWZmZXIsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHBhcnNlQ1NWKG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShhcnJheUJ1ZmZlciksIG9wdGlvbnMpKTtcblxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZSk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gcGFyc2UoX3gsIF94Mikge1xuICAgICAgcmV0dXJuIF9wYXJzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZTtcbiAgfSgpLFxuICBwYXJzZVRleHQ6IGZ1bmN0aW9uIHBhcnNlVGV4dCh0ZXh0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHBhcnNlQ1NWKHRleHQsIG9wdGlvbnMpO1xuICB9LFxuICBwYXJzZUluQmF0Y2hlczogcGFyc2VDU1ZJbkJhdGNoZXMsXG4gIG9wdGlvbnM6IERFRkFVTFRfQ1NWX0xPQURFUl9PUFRJT05TXG59O1xuZXhwb3J0cy5DU1ZMb2FkZXIgPSBDU1ZMb2FkZXI7XG5cbmZ1bmN0aW9uIHBhcnNlQ1NWKF94MywgX3g0KSB7XG4gIHJldHVybiBfcGFyc2VDU1YuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3BhcnNlQ1NWKCkge1xuICBfcGFyc2VDU1YgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoY3N2VGV4dCwgb3B0aW9ucykge1xuICAgIHZhciBjc3ZPcHRpb25zLCBmaXJzdFJvdywgaGVhZGVyLCBwYXJzZVdpdGhIZWFkZXIsIHBhcGFwYXJzZUNvbmZpZywgcmVzdWx0LCByb3dzLCBoZWFkZXJSb3c7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY3N2T3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgREVGQVVMVF9DU1ZfTE9BREVSX09QVElPTlMuY3N2KSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNzdik7XG4gICAgICAgICAgICBmaXJzdFJvdyA9IHJlYWRGaXJzdFJvdyhjc3ZUZXh0KTtcbiAgICAgICAgICAgIGhlYWRlciA9IGNzdk9wdGlvbnMuaGVhZGVyID09PSAnYXV0bycgPyBpc0hlYWRlclJvdyhmaXJzdFJvdykgOiBCb29sZWFuKGNzdk9wdGlvbnMuaGVhZGVyKTtcbiAgICAgICAgICAgIHBhcnNlV2l0aEhlYWRlciA9IGhlYWRlcjtcbiAgICAgICAgICAgIHBhcGFwYXJzZUNvbmZpZyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgY3N2T3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgICAgIGhlYWRlcjogcGFyc2VXaXRoSGVhZGVyLFxuICAgICAgICAgICAgICBkb3dubG9hZDogZmFsc2UsXG4gICAgICAgICAgICAgIHRyYW5zZm9ybUhlYWRlcjogcGFyc2VXaXRoSGVhZGVyID8gZHVwbGljYXRlQ29sdW1uVHJhbnNmb3JtZXIoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdWx0ID0gX3BhcGFwYXJzZS5kZWZhdWx0LnBhcnNlKGNzdlRleHQsIHBhcGFwYXJzZUNvbmZpZyk7XG4gICAgICAgICAgICByb3dzID0gcmVzdWx0LmRhdGE7XG4gICAgICAgICAgICBoZWFkZXJSb3cgPSByZXN1bHQubWV0YS5maWVsZHMgfHwgZ2VuZXJhdGVIZWFkZXIoY3N2T3B0aW9ucy5jb2x1bW5QcmVmaXgsIGZpcnN0Um93Lmxlbmd0aCk7XG4gICAgICAgICAgICBfY29udGV4dDIudDAgPSBjc3ZPcHRpb25zLnNoYXBlO1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSBfY29udGV4dDIudDAgPT09ICdvYmplY3Qtcm93LXRhYmxlJyA/IDExIDogX2NvbnRleHQyLnQwID09PSAnYXJyYXktcm93LXRhYmxlJyA/IDEzIDogMTU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICByb3dzID0gcm93cy5tYXAoZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShyb3cpID8gKDAsIF9zY2hlbWEuY29udmVydFRvT2JqZWN0Um93KShyb3csIGhlYWRlclJvdykgOiByb3c7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwiYnJlYWtcIiwgMTUpO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIHJvd3MgPSByb3dzLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHJvdykgPyByb3cgOiAoMCwgX3NjaGVtYS5jb252ZXJ0VG9BcnJheVJvdykocm93LCBoZWFkZXJSb3cpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcImJyZWFrXCIsIDE1KTtcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCByb3dzKTtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMik7XG4gIH0pKTtcbiAgcmV0dXJuIF9wYXJzZUNTVi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNTVkluQmF0Y2hlcyhhc3luY0l0ZXJhdG9yLCBvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucztcblxuICBvcHRpb25zID0gX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMuYmF0Y2hTaXplID09PSAnYXV0bycpIHtcbiAgICBvcHRpb25zLmJhdGNoU2l6ZSA9IDQwMDA7XG4gIH1cblxuICB2YXIgY3N2T3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgREVGQVVMVF9DU1ZfTE9BREVSX09QVElPTlMuY3N2KSwgKF9vcHRpb25zID0gb3B0aW9ucykgPT09IG51bGwgfHwgX29wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRpb25zLmNzdik7XG5cbiAgdmFyIGFzeW5jUXVldWUgPSBuZXcgX3NjaGVtYS5Bc3luY1F1ZXVlKCk7XG4gIHZhciBpc0ZpcnN0Um93ID0gdHJ1ZTtcbiAgdmFyIGhlYWRlclJvdyA9IG51bGw7XG4gIHZhciB0YWJsZUJhdGNoQnVpbGRlciA9IG51bGw7XG4gIHZhciBzY2hlbWEgPSBudWxsO1xuXG4gIHZhciBjb25maWcgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGNzdk9wdGlvbnMpLCB7fSwge1xuICAgIGhlYWRlcjogZmFsc2UsXG4gICAgZG93bmxvYWQ6IGZhbHNlLFxuICAgIGNodW5rU2l6ZTogMTAyNCAqIDEwMjQgKiA1LFxuICAgIHNraXBFbXB0eUxpbmVzOiBmYWxzZSxcbiAgICBzdGVwOiBmdW5jdGlvbiBzdGVwKHJlc3VsdHMpIHtcbiAgICAgIHZhciByb3cgPSByZXN1bHRzLmRhdGE7XG5cbiAgICAgIGlmIChjc3ZPcHRpb25zLnNraXBFbXB0eUxpbmVzKSB7XG4gICAgICAgIHZhciBjb2xsYXBzZWRSb3cgPSByb3cuZmxhdCgpLmpvaW4oJycpLnRyaW0oKTtcblxuICAgICAgICBpZiAoY29sbGFwc2VkUm93ID09PSAnJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgYnl0ZXNVc2VkID0gcmVzdWx0cy5tZXRhLmN1cnNvcjtcblxuICAgICAgaWYgKGlzRmlyc3RSb3cgJiYgIWhlYWRlclJvdykge1xuICAgICAgICB2YXIgaGVhZGVyID0gY3N2T3B0aW9ucy5oZWFkZXIgPT09ICdhdXRvJyA/IGlzSGVhZGVyUm93KHJvdykgOiBCb29sZWFuKGNzdk9wdGlvbnMuaGVhZGVyKTtcblxuICAgICAgICBpZiAoaGVhZGVyKSB7XG4gICAgICAgICAgaGVhZGVyUm93ID0gcm93Lm1hcChkdXBsaWNhdGVDb2x1bW5UcmFuc2Zvcm1lcigpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzRmlyc3RSb3cpIHtcbiAgICAgICAgaXNGaXJzdFJvdyA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghaGVhZGVyUm93KSB7XG4gICAgICAgICAgaGVhZGVyUm93ID0gZ2VuZXJhdGVIZWFkZXIoY3N2T3B0aW9ucy5jb2x1bW5QcmVmaXgsIHJvdy5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2NoZW1hID0gZGVkdWNlU2NoZW1hKHJvdywgaGVhZGVyUm93KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNzdk9wdGlvbnMub3B0aW1pemVNZW1vcnlVc2FnZSkge1xuICAgICAgICByb3cgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJvdykpO1xuICAgICAgfVxuXG4gICAgICB0YWJsZUJhdGNoQnVpbGRlciA9IHRhYmxlQmF0Y2hCdWlsZGVyIHx8IG5ldyBfc2NoZW1hLlRhYmxlQmF0Y2hCdWlsZGVyKHNjaGVtYSwgX29iamVjdFNwcmVhZCh7XG4gICAgICAgIHNoYXBlOiBjc3ZPcHRpb25zLnNoYXBlIHx8ICdhcnJheS1yb3ctdGFibGUnXG4gICAgICB9LCBvcHRpb25zKSk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRhYmxlQmF0Y2hCdWlsZGVyLmFkZFJvdyhyb3cpO1xuICAgICAgICB2YXIgYmF0Y2ggPSB0YWJsZUJhdGNoQnVpbGRlciAmJiB0YWJsZUJhdGNoQnVpbGRlci5nZXRGdWxsQmF0Y2goe1xuICAgICAgICAgIGJ5dGVzVXNlZDogYnl0ZXNVc2VkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChiYXRjaCkge1xuICAgICAgICAgIGFzeW5jUXVldWUuZW5xdWV1ZShiYXRjaCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFzeW5jUXVldWUuZW5xdWV1ZShlcnJvcik7XG4gICAgICB9XG4gICAgfSxcbiAgICBjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUocmVzdWx0cykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGJ5dGVzVXNlZCA9IHJlc3VsdHMubWV0YS5jdXJzb3I7XG4gICAgICAgIHZhciBiYXRjaCA9IHRhYmxlQmF0Y2hCdWlsZGVyICYmIHRhYmxlQmF0Y2hCdWlsZGVyLmdldEZpbmFsQmF0Y2goe1xuICAgICAgICAgIGJ5dGVzVXNlZDogYnl0ZXNVc2VkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChiYXRjaCkge1xuICAgICAgICAgIGFzeW5jUXVldWUuZW5xdWV1ZShiYXRjaCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGFzeW5jUXVldWUuZW5xdWV1ZShlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIGFzeW5jUXVldWUuY2xvc2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIF9wYXBhcGFyc2UuZGVmYXVsdC5wYXJzZShhc3luY0l0ZXJhdG9yLCBjb25maWcsIF9hc3luY0l0ZXJhdG9yU3RyZWFtZXIuZGVmYXVsdCk7XG5cbiAgcmV0dXJuIGFzeW5jUXVldWU7XG59XG5cbmZ1bmN0aW9uIGlzSGVhZGVyUm93KHJvdykge1xuICByZXR1cm4gcm93ICYmIHJvdy5ldmVyeShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRGaXJzdFJvdyhjc3ZUZXh0KSB7XG4gIHZhciByZXN1bHQgPSBfcGFwYXBhcnNlLmRlZmF1bHQucGFyc2UoY3N2VGV4dCwge1xuICAgIGRvd25sb2FkOiBmYWxzZSxcbiAgICBkeW5hbWljVHlwaW5nOiB0cnVlLFxuICAgIHByZXZpZXc6IDFcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdC5kYXRhWzBdO1xufVxuXG5mdW5jdGlvbiBkdXBsaWNhdGVDb2x1bW5UcmFuc2Zvcm1lcigpIHtcbiAgdmFyIG9ic2VydmVkQ29sdW1ucyA9IG5ldyBTZXQoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb2wpIHtcbiAgICB2YXIgY29sTmFtZSA9IGNvbDtcbiAgICB2YXIgY291bnRlciA9IDE7XG5cbiAgICB3aGlsZSAob2JzZXJ2ZWRDb2x1bW5zLmhhcyhjb2xOYW1lKSkge1xuICAgICAgY29sTmFtZSA9IFwiXCIuY29uY2F0KGNvbCwgXCIuXCIpLmNvbmNhdChjb3VudGVyKTtcbiAgICAgIGNvdW50ZXIrKztcbiAgICB9XG5cbiAgICBvYnNlcnZlZENvbHVtbnMuYWRkKGNvbE5hbWUpO1xuICAgIHJldHVybiBjb2xOYW1lO1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUhlYWRlcihjb2x1bW5QcmVmaXgpIHtcbiAgdmFyIGNvdW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICB2YXIgaGVhZGVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgIGhlYWRlcnMucHVzaChcIlwiLmNvbmNhdChjb2x1bW5QcmVmaXgpLmNvbmNhdChpICsgMSkpO1xuICB9XG5cbiAgcmV0dXJuIGhlYWRlcnM7XG59XG5cbmZ1bmN0aW9uIGRlZHVjZVNjaGVtYShyb3csIGhlYWRlclJvdykge1xuICB2YXIgc2NoZW1hID0gaGVhZGVyUm93ID8ge30gOiBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJvdy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb2x1bW5OYW1lID0gaGVhZGVyUm93ICYmIGhlYWRlclJvd1tpXSB8fCBpO1xuICAgIHZhciB2YWx1ZSA9IHJvd1tpXTtcblxuICAgIHN3aXRjaCAoKDAsIF90eXBlb2YyLmRlZmF1bHQpKHZhbHVlKSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICBzY2hlbWFbY29sdW1uTmFtZV0gPSB7XG4gICAgICAgICAgbmFtZTogU3RyaW5nKGNvbHVtbk5hbWUpLFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIHR5cGU6IEZsb2F0MzJBcnJheVxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHNjaGVtYVtjb2x1bW5OYW1lXSA9IHtcbiAgICAgICAgICBuYW1lOiBTdHJpbmcoY29sdW1uTmFtZSksXG4gICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgdHlwZTogQXJyYXlcbiAgICAgICAgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2NoZW1hO1xufVxuXG52YXIgX3R5cGVjaGVja0NTVkxvYWRlciA9IENTVkxvYWRlcjtcbmV4cG9ydHMuX3R5cGVjaGVja0NTVkxvYWRlciA9IF90eXBlY2hlY2tDU1ZMb2FkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jc3YtbG9hZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ1NWTG9hZGVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9jc3ZMb2FkZXIuQ1NWTG9hZGVyO1xuICB9XG59KTtcblxudmFyIF9jc3ZMb2FkZXIgPSByZXF1aXJlKFwiLi9jc3YtbG9hZGVyXCIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQXN5bmNJdGVyYXRvclN0cmVhbWVyO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY0l0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNJdGVyYXRvclwiKSk7XG5cbnZhciBfcGFwYXBhcnNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vbGlicy9wYXBhcGFyc2VcIikpO1xuXG52YXIgQ2h1bmtTdHJlYW1lciA9IF9wYXBhcGFyc2UuZGVmYXVsdC5DaHVua1N0cmVhbWVyO1xuXG5mdW5jdGlvbiBBc3luY0l0ZXJhdG9yU3RyZWFtZXIoY29uZmlnKSB7XG4gIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgQ2h1bmtTdHJlYW1lci5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gIHRoaXMudGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIodGhpcy5fY29uZmlnLmVuY29kaW5nKTtcblxuICB0aGlzLnN0cmVhbSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKGFzeW5jSXRlcmF0b3IpIHtcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uLCBfZGlkSXRlcmF0b3JFcnJvciwgX2l0ZXJhdG9yRXJyb3IsIF9pdGVyYXRvciwgX3N0ZXAsIF92YWx1ZSwgY2h1bms7XG5cbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICB0aGlzLl9pbnB1dCA9IGFzeW5jSXRlcmF0b3I7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxO1xuICAgICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDQ7XG4gICAgICAgICAgICAgIF9pdGVyYXRvciA9ICgwLCBfYXN5bmNJdGVyYXRvcjIuZGVmYXVsdCkoYXN5bmNJdGVyYXRvcik7XG5cbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDg7XG4gICAgICAgICAgICAgIHJldHVybiBfaXRlcmF0b3IubmV4dCgpO1xuXG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIF9zdGVwID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IF9zdGVwLmRvbmU7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgcmV0dXJuIF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICBfdmFsdWUgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgICAgIGlmIChfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY2h1bmsgPSBfdmFsdWU7XG4gICAgICAgICAgICAgIHRoaXMucGFyc2VDaHVuayh0aGlzLmdldFN0cmluZ0NodW5rKGNodW5rKSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyNTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyMTtcbiAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDQpO1xuICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gX2NvbnRleHQudDA7XG5cbiAgICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyNTtcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDI2O1xuXG4gICAgICAgICAgICAgIGlmICghKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMzA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMzA7XG4gICAgICAgICAgICAgIHJldHVybiBfaXRlcmF0b3IucmV0dXJuKCk7XG5cbiAgICAgICAgICAgIGNhc2UgMzA6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAzMDtcblxuICAgICAgICAgICAgICBpZiAoIV9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDMzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG5cbiAgICAgICAgICAgIGNhc2UgMzM6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5maW5pc2goMzApO1xuXG4gICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDI1KTtcblxuICAgICAgICAgICAgY2FzZSAzNTpcbiAgICAgICAgICAgICAgdGhpcy5fZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLnBhcnNlQ2h1bmsoJycpO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMzk7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnQxID0gX2NvbnRleHRbXCJjYXRjaFwiXSgxKTtcblxuICAgICAgICAgICAgICB0aGlzLl9zZW5kRXJyb3IoX2NvbnRleHQudDEpO1xuXG4gICAgICAgICAgICBjYXNlIDQyOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZSwgdGhpcywgW1sxLCAzOV0sIFs0LCAyMSwgMjUsIDM1XSwgWzI2LCwgMzAsIDM0XV0pO1xuICAgIH0pKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoX3gpIHtcbiAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSgpO1xuXG4gIHRoaXMuX25leHRDaHVuayA9IGZ1bmN0aW9uIG5leHRDaHVuaygpIHt9O1xuXG4gIHRoaXMuZ2V0U3RyaW5nQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICByZXR1cm4gdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJyA/IGNodW5rIDogdGhpcy50ZXh0RGVjb2Rlci5kZWNvZGUoY2h1bmssIHtcbiAgICAgIHN0cmVhbTogdHJ1ZVxuICAgIH0pO1xuICB9O1xufVxuXG5Bc3luY0l0ZXJhdG9yU3RyZWFtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDaHVua1N0cmVhbWVyLnByb3RvdHlwZSk7XG5Bc3luY0l0ZXJhdG9yU3RyZWFtZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXN5bmNJdGVyYXRvclN0cmVhbWVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXN5bmMtaXRlcmF0b3Itc3RyZWFtZXIuanMubWFwIiwiLy8gVGhpcyBpcyBhIGZvcmsgb2YgcGFwYXBhcnNlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWhvbHQvUGFwYVBhcnNlXG4vKiBAbGljZW5zZVxuUGFwYSBQYXJzZVxudjUuMC4wLWJldGEuMFxuaHR0cHM6Ly9naXRodWIuY29tL21ob2x0L1BhcGFQYXJzZVxuTGljZW5zZTogTUlUXG4qL1xuLy8gRk9SSyBTVU1NQVJZOlxuLy8gLSBBZG9wdCBFUzYgZXhwb3J0c1xuLy8gLSBJbXBsZW1lbnQgbmV3IEFzeW5jSXRlcmF0b3JTdHJlYW1lclxuLy8gLSBSZW1vdmUgbm9uIEFzeW5jIEl0ZXJhdG9yIHN0cmVhbWVycyAoY2FuIGFsbCBiZSBoYW5kbGVkIGJ5IG5ldyBzdHJlYW1lcilcbi8vIC0gUmVtb3ZlIHVudXNlZCBXb3JrZXIgc3VwcG9ydCAobG9hZGVycy5nbCB3b3JrZXIgc3lzdGVtIHVzZWQgaW5zdGVhZClcbi8vIC0gUmVtb3ZlIHVudXNlZCBqUXVlcnkgcGx1Z2luIHN1cHBvcnRcblxuLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIEB0cy1ub2NoZWNrXG52YXIgZ2xvYmFsID0gKGZ1bmN0aW9uKCkge1xuICAvLyBhbHRlcm5hdGl2ZSBtZXRob2QsIHNpbWlsYXIgdG8gYEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKClgXG4gIC8vIGJ1dCB3aXRob3V0IHVzaW5nIGBldmFsYCAod2hpY2ggaXMgZGlzYWJsZWQgd2hlblxuICAvLyB1c2luZyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSkuXG5cbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cbiAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGdsb2JhbDtcbiAgfVxuXG4gIC8vIFdoZW4gcnVubmluZyB0ZXN0cyBub25lIG9mIHRoZSBhYm92ZSBoYXZlIGJlZW4gZGVmaW5lZFxuICByZXR1cm4ge307XG59KSgpO1xuXG52YXIgSVNfUEFQQV9XT1JLRVIgPSBmYWxzZTtcblxudmFyIFBhcGEgPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gUGFwYTtcblBhcGEucGFyc2UgPSBDc3ZUb0pzb247XG5QYXBhLnVucGFyc2UgPSBKc29uVG9Dc3Y7XG5cblBhcGEuUkVDT1JEX1NFUCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMzApO1xuUGFwYS5VTklUX1NFUCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMzEpO1xuUGFwYS5CWVRFX09SREVSX01BUksgPSAnXFx1ZmVmZic7XG5QYXBhLkJBRF9ERUxJTUlURVJTID0gWydcXHInLCAnXFxuJywgJ1wiJywgUGFwYS5CWVRFX09SREVSX01BUktdO1xuUGFwYS5XT1JLRVJTX1NVUFBPUlRFRCA9IGZhbHNlOyAvLyAhSVNfV09SS0VSICYmICEhZ2xvYmFsLldvcmtlcjtcblBhcGEuTk9ERV9TVFJFQU1fSU5QVVQgPSAxO1xuXG4vLyBDb25maWd1cmFibGUgY2h1bmsgc2l6ZXMgZm9yIGxvY2FsIGFuZCByZW1vdGUgZmlsZXMsIHJlc3BlY3RpdmVseVxuUGFwYS5Mb2NhbENodW5rU2l6ZSA9IDEwMjQgKiAxMDI0ICogMTA7IC8vIDEwIE1CXG5QYXBhLlJlbW90ZUNodW5rU2l6ZSA9IDEwMjQgKiAxMDI0ICogNTsgLy8gNSBNQlxuUGFwYS5EZWZhdWx0RGVsaW1pdGVyID0gJywnOyAvLyBVc2VkIGlmIG5vdCBzcGVjaWZpZWQgYW5kIGRldGVjdGlvbiBmYWlsc1xuXG4vLyBFeHBvc2VkIGZvciB0ZXN0aW5nIGFuZCBkZXZlbG9wbWVudCBvbmx5XG5QYXBhLlBhcnNlciA9IFBhcnNlcjtcblBhcGEuUGFyc2VySGFuZGxlID0gUGFyc2VySGFuZGxlO1xuXG4vLyBCRUdJTiBGT1JLXG5QYXBhLkNodW5rU3RyZWFtZXIgPSBDaHVua1N0cmVhbWVyO1xuUGFwYS5TdHJpbmdTdHJlYW1lciA9IFN0cmluZ1N0cmVhbWVyO1xuLypcblBhcGEuTmV0d29ya1N0cmVhbWVyID0gTmV0d29ya1N0cmVhbWVyO1xuUGFwYS5GaWxlU3RyZWFtZXIgPSBGaWxlU3RyZWFtZXI7XG5QYXBhLlJlYWRhYmxlU3RyZWFtU3RyZWFtZXIgPSBSZWFkYWJsZVN0cmVhbVN0cmVhbWVyO1xuaWYgKHR5cGVvZiBQQVBBX0JST1dTRVJfQ09OVEVYVCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgUGFwYS5EdXBsZXhTdHJlYW1TdHJlYW1lciA9IER1cGxleFN0cmVhbVN0cmVhbWVyO1xufVxuKi9cbi8vIEVORCBGT1JLXG5cbi8vIEJFR0lOIEZPUktcbi8vIEFkZHMgYW4gYXJndW1lbnQgdG8gcGFwYS5wYXJzZVxuLy8gZnVuY3Rpb24gQ3N2VG9Kc29uKF9pbnB1dCwgX2NvbmZpZylcbmZ1bmN0aW9uIENzdlRvSnNvbihcbiAgX2lucHV0LFxuICBfY29uZmlnLFxuICBVc2VyRGVmaW5lZFN0cmVhbWVyIC8vIEJFR0lOIEZPUktcbikge1xuICBfY29uZmlnID0gX2NvbmZpZyB8fCB7fTtcbiAgdmFyIGR5bmFtaWNUeXBpbmcgPSBfY29uZmlnLmR5bmFtaWNUeXBpbmcgfHwgZmFsc2U7XG4gIGlmIChpc0Z1bmN0aW9uKGR5bmFtaWNUeXBpbmcpKSB7XG4gICAgX2NvbmZpZy5keW5hbWljVHlwaW5nRnVuY3Rpb24gPSBkeW5hbWljVHlwaW5nO1xuICAgIC8vIFdpbGwgYmUgZmlsbGVkIG9uIGZpcnN0IHJvdyBjYWxsXG4gICAgZHluYW1pY1R5cGluZyA9IHt9O1xuICB9XG4gIF9jb25maWcuZHluYW1pY1R5cGluZyA9IGR5bmFtaWNUeXBpbmc7XG5cbiAgX2NvbmZpZy50cmFuc2Zvcm0gPSBpc0Z1bmN0aW9uKF9jb25maWcudHJhbnNmb3JtKSA/IF9jb25maWcudHJhbnNmb3JtIDogZmFsc2U7XG5cbiAgaWYgKF9jb25maWcud29ya2VyICYmIFBhcGEuV09SS0VSU19TVVBQT1JURUQpIHtcbiAgICB2YXIgdyA9IG5ld1dvcmtlcigpO1xuXG4gICAgdy51c2VyU3RlcCA9IF9jb25maWcuc3RlcDtcbiAgICB3LnVzZXJDaHVuayA9IF9jb25maWcuY2h1bms7XG4gICAgdy51c2VyQ29tcGxldGUgPSBfY29uZmlnLmNvbXBsZXRlO1xuICAgIHcudXNlckVycm9yID0gX2NvbmZpZy5lcnJvcjtcblxuICAgIF9jb25maWcuc3RlcCA9IGlzRnVuY3Rpb24oX2NvbmZpZy5zdGVwKTtcbiAgICBfY29uZmlnLmNodW5rID0gaXNGdW5jdGlvbihfY29uZmlnLmNodW5rKTtcbiAgICBfY29uZmlnLmNvbXBsZXRlID0gaXNGdW5jdGlvbihfY29uZmlnLmNvbXBsZXRlKTtcbiAgICBfY29uZmlnLmVycm9yID0gaXNGdW5jdGlvbihfY29uZmlnLmVycm9yKTtcbiAgICBkZWxldGUgX2NvbmZpZy53b3JrZXI7IC8vIHByZXZlbnQgaW5maW5pdGUgbG9vcFxuXG4gICAgdy5wb3N0TWVzc2FnZSh7XG4gICAgICBpbnB1dDogX2lucHV0LFxuICAgICAgY29uZmlnOiBfY29uZmlnLFxuICAgICAgd29ya2VySWQ6IHcuaWRcbiAgICB9KTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzdHJlYW1lciA9IG51bGw7XG4gIC8qXG4gIGlmIChfaW5wdXQgPT09IFBhcGEuTk9ERV9TVFJFQU1fSU5QVVQgJiYgdHlwZW9mIFBBUEFfQlJPV1NFUl9DT05URVhUID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIGNyZWF0ZSBhIG5vZGUgRHVwbGV4IHN0cmVhbSBmb3IgdXNlXG4gICAgLy8gd2l0aCAucGlwZVxuICAgIHN0cmVhbWVyID0gbmV3IER1cGxleFN0cmVhbVN0cmVhbWVyKF9jb25maWcpO1xuICAgIHJldHVybiBzdHJlYW1lci5nZXRTdHJlYW0oKTtcbiAgfSBlbHNlXG4gICovXG4gIGlmICh0eXBlb2YgX2lucHV0ID09PSAnc3RyaW5nJykge1xuICAgIC8vIGlmIChfY29uZmlnLmRvd25sb2FkKSBzdHJlYW1lciA9IG5ldyBOZXR3b3JrU3RyZWFtZXIoX2NvbmZpZyk7XG4gICAgLy8gZWxzZVxuICAgIHN0cmVhbWVyID0gbmV3IFN0cmluZ1N0cmVhbWVyKF9jb25maWcpO1xuICB9XG4gIC8qXG4gIGVsc2UgaWYgKF9pbnB1dC5yZWFkYWJsZSA9PT0gdHJ1ZSAmJiBpc0Z1bmN0aW9uKF9pbnB1dC5yZWFkKSAmJiBpc0Z1bmN0aW9uKF9pbnB1dC5vbikpIHtcbiAgICBzdHJlYW1lciA9IG5ldyBSZWFkYWJsZVN0cmVhbVN0cmVhbWVyKF9jb25maWcpO1xuICB9IGVsc2UgaWYgKChnbG9iYWwuRmlsZSAmJiBfaW5wdXQgaW5zdGFuY2VvZiBGaWxlKSB8fCBfaW5wdXQgaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgLy8gLi4uU2FmYXJpLiAoc2VlIGlzc3VlICMxMDYpXG4gICAgc3RyZWFtZXIgPSBuZXcgRmlsZVN0cmVhbWVyKF9jb25maWcpO1xuICAqL1xuXG4gIC8vIEJFR0lOIEZPUktcbiAgaWYgKCFzdHJlYW1lcikge1xuICAgIHN0cmVhbWVyID0gbmV3IFVzZXJEZWZpbmVkU3RyZWFtZXIoX2NvbmZpZyk7XG4gIH1cbiAgLy8gRU5EIEZPUktcblxuICByZXR1cm4gc3RyZWFtZXIuc3RyZWFtKF9pbnB1dCk7XG59XG5cbmZ1bmN0aW9uIEpzb25Ub0NzdihfaW5wdXQsIF9jb25maWcpIHtcbiAgLy8gRGVmYXVsdCBjb25maWd1cmF0aW9uXG5cbiAgLyoqIHdoZXRoZXIgdG8gc3Vycm91bmQgZXZlcnkgZGF0dW0gd2l0aCBxdW90ZXMgKi9cbiAgdmFyIF9xdW90ZXMgPSBmYWxzZTtcblxuICAvKiogd2hldGhlciB0byB3cml0ZSBoZWFkZXJzICovXG4gIHZhciBfd3JpdGVIZWFkZXIgPSB0cnVlO1xuXG4gIC8qKiBkZWxpbWl0aW5nIGNoYXJhY3RlcihzKSAqL1xuICB2YXIgX2RlbGltaXRlciA9ICcsJztcblxuICAvKiogbmV3bGluZSBjaGFyYWN0ZXIocykgKi9cbiAgdmFyIF9uZXdsaW5lID0gJ1xcclxcbic7XG5cbiAgLyoqIHF1b3RlIGNoYXJhY3RlciAqL1xuICB2YXIgX3F1b3RlQ2hhciA9ICdcIic7XG5cbiAgLyoqIGVzY2FwZWQgcXVvdGUgY2hhcmFjdGVyLCBlaXRoZXIgXCJcIiBvciA8Y29uZmlnLmVzY2FwZUNoYXI+XCIgKi9cbiAgdmFyIF9lc2NhcGVkUXVvdGUgPSBfcXVvdGVDaGFyICsgX3F1b3RlQ2hhcjtcblxuICAvKiogd2hldGhlciB0byBza2lwIGVtcHR5IGxpbmVzICovXG4gIHZhciBfc2tpcEVtcHR5TGluZXMgPSBmYWxzZTtcblxuICAvKiogdGhlIGNvbHVtbnMgKGtleXMpIHdlIGV4cGVjdCB3aGVuIHdlIHVucGFyc2Ugb2JqZWN0cyAqL1xuICB2YXIgX2NvbHVtbnMgPSBudWxsO1xuXG4gIHVucGFja0NvbmZpZygpO1xuXG4gIHZhciBxdW90ZUNoYXJSZWdleCA9IG5ldyBSZWdFeHAoZXNjYXBlUmVnRXhwKF9xdW90ZUNoYXIpLCAnZycpO1xuXG4gIGlmICh0eXBlb2YgX2lucHV0ID09PSAnc3RyaW5nJykgX2lucHV0ID0gSlNPTi5wYXJzZShfaW5wdXQpO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KF9pbnB1dCkpIHtcbiAgICBpZiAoIV9pbnB1dC5sZW5ndGggfHwgQXJyYXkuaXNBcnJheShfaW5wdXRbMF0pKSByZXR1cm4gc2VyaWFsaXplKG51bGwsIF9pbnB1dCwgX3NraXBFbXB0eUxpbmVzKTtcbiAgICBlbHNlIGlmICh0eXBlb2YgX2lucHV0WzBdID09PSAnb2JqZWN0JylcbiAgICAgIHJldHVybiBzZXJpYWxpemUoX2NvbHVtbnMgfHwgb2JqZWN0S2V5cyhfaW5wdXRbMF0pLCBfaW5wdXQsIF9za2lwRW1wdHlMaW5lcyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIF9pbnB1dCA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAodHlwZW9mIF9pbnB1dC5kYXRhID09PSAnc3RyaW5nJykgX2lucHV0LmRhdGEgPSBKU09OLnBhcnNlKF9pbnB1dC5kYXRhKTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KF9pbnB1dC5kYXRhKSkge1xuICAgICAgaWYgKCFfaW5wdXQuZmllbGRzKSBfaW5wdXQuZmllbGRzID0gX2lucHV0Lm1ldGEgJiYgX2lucHV0Lm1ldGEuZmllbGRzO1xuXG4gICAgICBpZiAoIV9pbnB1dC5maWVsZHMpXG4gICAgICAgIF9pbnB1dC5maWVsZHMgPSBBcnJheS5pc0FycmF5KF9pbnB1dC5kYXRhWzBdKSA/IF9pbnB1dC5maWVsZHMgOiBvYmplY3RLZXlzKF9pbnB1dC5kYXRhWzBdKTtcblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KF9pbnB1dC5kYXRhWzBdKSAmJiB0eXBlb2YgX2lucHV0LmRhdGFbMF0gIT09ICdvYmplY3QnKVxuICAgICAgICBfaW5wdXQuZGF0YSA9IFtfaW5wdXQuZGF0YV07IC8vIGhhbmRsZXMgaW5wdXQgbGlrZSBbMSwyLDNdIG9yIFsnYXNkZiddXG4gICAgfVxuXG4gICAgcmV0dXJuIHNlcmlhbGl6ZShfaW5wdXQuZmllbGRzIHx8IFtdLCBfaW5wdXQuZGF0YSB8fCBbXSwgX3NraXBFbXB0eUxpbmVzKTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgKGFueSB2YWxpZCBwYXRocyBzaG91bGQgcmV0dXJuIGJlZm9yZSB0aGlzKVxuICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBzZXJpYWxpemUgdW5yZWNvZ25pemVkIGlucHV0Jyk7XG5cbiAgZnVuY3Rpb24gdW5wYWNrQ29uZmlnKCkge1xuICAgIGlmICh0eXBlb2YgX2NvbmZpZyAhPT0gJ29iamVjdCcpIHJldHVybjtcblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBfY29uZmlnLmRlbGltaXRlciA9PT0gJ3N0cmluZycgJiZcbiAgICAgICFQYXBhLkJBRF9ERUxJTUlURVJTLmZpbHRlcihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gX2NvbmZpZy5kZWxpbWl0ZXIuaW5kZXhPZih2YWx1ZSkgIT09IC0xO1xuICAgICAgfSkubGVuZ3RoXG4gICAgKSB7XG4gICAgICBfZGVsaW1pdGVyID0gX2NvbmZpZy5kZWxpbWl0ZXI7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBfY29uZmlnLnF1b3RlcyA9PT0gJ2Jvb2xlYW4nIHx8IEFycmF5LmlzQXJyYXkoX2NvbmZpZy5xdW90ZXMpKVxuICAgICAgX3F1b3RlcyA9IF9jb25maWcucXVvdGVzO1xuXG4gICAgaWYgKHR5cGVvZiBfY29uZmlnLnNraXBFbXB0eUxpbmVzID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIF9jb25maWcuc2tpcEVtcHR5TGluZXMgPT09ICdzdHJpbmcnKVxuICAgICAgX3NraXBFbXB0eUxpbmVzID0gX2NvbmZpZy5za2lwRW1wdHlMaW5lcztcblxuICAgIGlmICh0eXBlb2YgX2NvbmZpZy5uZXdsaW5lID09PSAnc3RyaW5nJykgX25ld2xpbmUgPSBfY29uZmlnLm5ld2xpbmU7XG5cbiAgICBpZiAodHlwZW9mIF9jb25maWcucXVvdGVDaGFyID09PSAnc3RyaW5nJykgX3F1b3RlQ2hhciA9IF9jb25maWcucXVvdGVDaGFyO1xuXG4gICAgaWYgKHR5cGVvZiBfY29uZmlnLmhlYWRlciA9PT0gJ2Jvb2xlYW4nKSBfd3JpdGVIZWFkZXIgPSBfY29uZmlnLmhlYWRlcjtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KF9jb25maWcuY29sdW1ucykpIHtcbiAgICAgIGlmIChfY29uZmlnLmNvbHVtbnMubGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbiBjb2x1bW5zIGlzIGVtcHR5Jyk7XG5cbiAgICAgIF9jb2x1bW5zID0gX2NvbmZpZy5jb2x1bW5zO1xuICAgIH1cblxuICAgIGlmIChfY29uZmlnLmVzY2FwZUNoYXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgX2VzY2FwZWRRdW90ZSA9IF9jb25maWcuZXNjYXBlQ2hhciArIF9xdW90ZUNoYXI7XG4gICAgfVxuICB9XG5cbiAgLyoqIFR1cm5zIGFuIG9iamVjdCdzIGtleXMgaW50byBhbiBhcnJheSAqL1xuICBmdW5jdGlvbiBvYmplY3RLZXlzKG9iaikge1xuICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JykgcmV0dXJuIFtdO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH1cblxuICAvKiogVGhlIGRvdWJsZSBmb3IgbG9vcCB0aGF0IGl0ZXJhdGVzIHRoZSBkYXRhIGFuZCB3cml0ZXMgb3V0IGEgQ1NWIHN0cmluZyBpbmNsdWRpbmcgaGVhZGVyIHJvdyAqL1xuICBmdW5jdGlvbiBzZXJpYWxpemUoZmllbGRzLCBkYXRhLCBza2lwRW1wdHlMaW5lcykge1xuICAgIHZhciBjc3YgPSAnJztcblxuICAgIGlmICh0eXBlb2YgZmllbGRzID09PSAnc3RyaW5nJykgZmllbGRzID0gSlNPTi5wYXJzZShmaWVsZHMpO1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuXG4gICAgdmFyIGhhc0hlYWRlciA9IEFycmF5LmlzQXJyYXkoZmllbGRzKSAmJiBmaWVsZHMubGVuZ3RoID4gMDtcbiAgICB2YXIgZGF0YUtleWVkQnlGaWVsZCA9ICFBcnJheS5pc0FycmF5KGRhdGFbMF0pO1xuXG4gICAgLy8gSWYgdGhlcmUgYSBoZWFkZXIgcm93LCB3cml0ZSBpdCBmaXJzdFxuICAgIGlmIChoYXNIZWFkZXIgJiYgX3dyaXRlSGVhZGVyKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSA+IDApIGNzdiArPSBfZGVsaW1pdGVyO1xuICAgICAgICBjc3YgKz0gc2FmZShmaWVsZHNbaV0sIGkpO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEubGVuZ3RoID4gMCkgY3N2ICs9IF9uZXdsaW5lO1xuICAgIH1cblxuICAgIC8vIFRoZW4gd3JpdGUgb3V0IHRoZSBkYXRhXG4gICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgZGF0YS5sZW5ndGg7IHJvdysrKSB7XG4gICAgICB2YXIgbWF4Q29sID0gaGFzSGVhZGVyID8gZmllbGRzLmxlbmd0aCA6IGRhdGFbcm93XS5sZW5ndGg7XG5cbiAgICAgIHZhciBlbXB0eUxpbmUgPSBmYWxzZTtcbiAgICAgIHZhciBudWxsTGluZSA9IGhhc0hlYWRlciA/IE9iamVjdC5rZXlzKGRhdGFbcm93XSkubGVuZ3RoID09PSAwIDogZGF0YVtyb3ddLmxlbmd0aCA9PT0gMDtcbiAgICAgIGlmIChza2lwRW1wdHlMaW5lcyAmJiAhaGFzSGVhZGVyKSB7XG4gICAgICAgIGVtcHR5TGluZSA9XG4gICAgICAgICAgc2tpcEVtcHR5TGluZXMgPT09ICdncmVlZHknXG4gICAgICAgICAgICA/IGRhdGFbcm93XS5qb2luKCcnKS50cmltKCkgPT09ICcnXG4gICAgICAgICAgICA6IGRhdGFbcm93XS5sZW5ndGggPT09IDEgJiYgZGF0YVtyb3ddWzBdLmxlbmd0aCA9PT0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChza2lwRW1wdHlMaW5lcyA9PT0gJ2dyZWVkeScgJiYgaGFzSGVhZGVyKSB7XG4gICAgICAgIHZhciBsaW5lID0gW107XG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgbWF4Q29sOyBjKyspIHtcbiAgICAgICAgICB2YXIgY3ggPSBkYXRhS2V5ZWRCeUZpZWxkID8gZmllbGRzW2NdIDogYztcbiAgICAgICAgICBsaW5lLnB1c2goZGF0YVtyb3ddW2N4XSk7XG4gICAgICAgIH1cbiAgICAgICAgZW1wdHlMaW5lID0gbGluZS5qb2luKCcnKS50cmltKCkgPT09ICcnO1xuICAgICAgfVxuICAgICAgaWYgKCFlbXB0eUxpbmUpIHtcbiAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbWF4Q29sOyBjb2wrKykge1xuICAgICAgICAgIGlmIChjb2wgPiAwICYmICFudWxsTGluZSkgY3N2ICs9IF9kZWxpbWl0ZXI7XG4gICAgICAgICAgdmFyIGNvbElkeCA9IGhhc0hlYWRlciAmJiBkYXRhS2V5ZWRCeUZpZWxkID8gZmllbGRzW2NvbF0gOiBjb2w7XG4gICAgICAgICAgY3N2ICs9IHNhZmUoZGF0YVtyb3ddW2NvbElkeF0sIGNvbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvdyA8IGRhdGEubGVuZ3RoIC0gMSAmJiAoIXNraXBFbXB0eUxpbmVzIHx8IChtYXhDb2wgPiAwICYmICFudWxsTGluZSkpKSB7XG4gICAgICAgICAgY3N2ICs9IF9uZXdsaW5lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjc3Y7XG4gIH1cblxuICAvKiogRW5jbG9zZXMgYSB2YWx1ZSBhcm91bmQgcXVvdGVzIGlmIG5lZWRlZCAobWFrZXMgYSB2YWx1ZSBzYWZlIGZvciBDU1YgaW5zZXJ0aW9uKSAqL1xuICBmdW5jdGlvbiBzYWZlKHN0ciwgY29sKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnIHx8IHN0ciA9PT0gbnVsbCkgcmV0dXJuICcnO1xuXG4gICAgaWYgKHN0ci5jb25zdHJ1Y3RvciA9PT0gRGF0ZSkgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0cikuc2xpY2UoMSwgMjUpO1xuXG4gICAgc3RyID0gc3RyLnRvU3RyaW5nKCkucmVwbGFjZShxdW90ZUNoYXJSZWdleCwgX2VzY2FwZWRRdW90ZSk7XG5cbiAgICB2YXIgbmVlZHNRdW90ZXMgPVxuICAgICAgKHR5cGVvZiBfcXVvdGVzID09PSAnYm9vbGVhbicgJiYgX3F1b3RlcykgfHxcbiAgICAgIChBcnJheS5pc0FycmF5KF9xdW90ZXMpICYmIF9xdW90ZXNbY29sXSkgfHxcbiAgICAgIGhhc0FueShzdHIsIFBhcGEuQkFEX0RFTElNSVRFUlMpIHx8XG4gICAgICBzdHIuaW5kZXhPZihfZGVsaW1pdGVyKSA+IC0xIHx8XG4gICAgICBzdHIuY2hhckF0KDApID09PSAnICcgfHxcbiAgICAgIHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIDEpID09PSAnICc7XG5cbiAgICByZXR1cm4gbmVlZHNRdW90ZXMgPyBfcXVvdGVDaGFyICsgc3RyICsgX3F1b3RlQ2hhciA6IHN0cjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0FueShzdHIsIHN1YnN0cmluZ3MpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnN0cmluZ3MubGVuZ3RoOyBpKyspIGlmIChzdHIuaW5kZXhPZihzdWJzdHJpbmdzW2ldKSA+IC0xKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqIENodW5rU3RyZWFtZXIgaXMgdGhlIGJhc2UgcHJvdG90eXBlIGZvciB2YXJpb3VzIHN0cmVhbWVyIGltcGxlbWVudGF0aW9ucy4gKi9cbmZ1bmN0aW9uIENodW5rU3RyZWFtZXIoY29uZmlnKSB7XG4gIHRoaXMuX2hhbmRsZSA9IG51bGw7XG4gIHRoaXMuX2ZpbmlzaGVkID0gZmFsc2U7XG4gIHRoaXMuX2NvbXBsZXRlZCA9IGZhbHNlO1xuICB0aGlzLl9pbnB1dCA9IG51bGw7XG4gIHRoaXMuX2Jhc2VJbmRleCA9IDA7XG4gIHRoaXMuX3BhcnRpYWxMaW5lID0gJyc7XG4gIHRoaXMuX3Jvd0NvdW50ID0gMDtcbiAgdGhpcy5fc3RhcnQgPSAwO1xuICB0aGlzLl9uZXh0Q2h1bmsgPSBudWxsO1xuICB0aGlzLmlzRmlyc3RDaHVuayA9IHRydWU7XG4gIHRoaXMuX2NvbXBsZXRlUmVzdWx0cyA9IHtcbiAgICBkYXRhOiBbXSxcbiAgICBlcnJvcnM6IFtdLFxuICAgIG1ldGE6IHt9XG4gIH07XG4gIHJlcGxhY2VDb25maWcuY2FsbCh0aGlzLCBjb25maWcpO1xuXG4gIHRoaXMucGFyc2VDaHVuayA9IGZ1bmN0aW9uKGNodW5rLCBpc0Zha2VDaHVuaykge1xuICAgIC8vIEZpcnN0IGNodW5rIHByZS1wcm9jZXNzaW5nXG4gICAgaWYgKHRoaXMuaXNGaXJzdENodW5rICYmIGlzRnVuY3Rpb24odGhpcy5fY29uZmlnLmJlZm9yZUZpcnN0Q2h1bmspKSB7XG4gICAgICB2YXIgbW9kaWZpZWRDaHVuayA9IHRoaXMuX2NvbmZpZy5iZWZvcmVGaXJzdENodW5rKGNodW5rKTtcbiAgICAgIGlmIChtb2RpZmllZENodW5rICE9PSB1bmRlZmluZWQpIGNodW5rID0gbW9kaWZpZWRDaHVuaztcbiAgICB9XG4gICAgdGhpcy5pc0ZpcnN0Q2h1bmsgPSBmYWxzZTtcblxuICAgIC8vIFJlam9pbiB0aGUgbGluZSB3ZSBsaWtlbHkganVzdCBzcGxpdCBpbiB0d28gYnkgY2h1bmtpbmcgdGhlIGZpbGVcbiAgICB2YXIgYWdncmVnYXRlID0gdGhpcy5fcGFydGlhbExpbmUgKyBjaHVuaztcbiAgICB0aGlzLl9wYXJ0aWFsTGluZSA9ICcnO1xuXG4gICAgdmFyIHJlc3VsdHMgPSB0aGlzLl9oYW5kbGUucGFyc2UoYWdncmVnYXRlLCB0aGlzLl9iYXNlSW5kZXgsICF0aGlzLl9maW5pc2hlZCk7XG5cbiAgICBpZiAodGhpcy5faGFuZGxlLnBhdXNlZCgpIHx8IHRoaXMuX2hhbmRsZS5hYm9ydGVkKCkpIHJldHVybjtcblxuICAgIHZhciBsYXN0SW5kZXggPSByZXN1bHRzLm1ldGEuY3Vyc29yO1xuXG4gICAgaWYgKCF0aGlzLl9maW5pc2hlZCkge1xuICAgICAgdGhpcy5fcGFydGlhbExpbmUgPSBhZ2dyZWdhdGUuc3Vic3RyaW5nKGxhc3RJbmRleCAtIHRoaXMuX2Jhc2VJbmRleCk7XG4gICAgICB0aGlzLl9iYXNlSW5kZXggPSBsYXN0SW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdHMgJiYgcmVzdWx0cy5kYXRhKSB0aGlzLl9yb3dDb3VudCArPSByZXN1bHRzLmRhdGEubGVuZ3RoO1xuXG4gICAgdmFyIGZpbmlzaGVkSW5jbHVkaW5nUHJldmlldyA9XG4gICAgICB0aGlzLl9maW5pc2hlZCB8fCAodGhpcy5fY29uZmlnLnByZXZpZXcgJiYgdGhpcy5fcm93Q291bnQgPj0gdGhpcy5fY29uZmlnLnByZXZpZXcpO1xuXG4gICAgaWYgKElTX1BBUEFfV09SS0VSKSB7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2Uoe1xuICAgICAgICByZXN1bHRzOiByZXN1bHRzLFxuICAgICAgICB3b3JrZXJJZDogUGFwYS5XT1JLRVJfSUQsXG4gICAgICAgIGZpbmlzaGVkOiBmaW5pc2hlZEluY2x1ZGluZ1ByZXZpZXdcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9jb25maWcuY2h1bmspICYmICFpc0Zha2VDaHVuaykge1xuICAgICAgdGhpcy5fY29uZmlnLmNodW5rKHJlc3VsdHMsIHRoaXMuX2hhbmRsZSk7XG4gICAgICBpZiAodGhpcy5faGFuZGxlLnBhdXNlZCgpIHx8IHRoaXMuX2hhbmRsZS5hYm9ydGVkKCkpIHJldHVybjtcbiAgICAgIHJlc3VsdHMgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jb21wbGV0ZVJlc3VsdHMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9jb25maWcuc3RlcCAmJiAhdGhpcy5fY29uZmlnLmNodW5rKSB7XG4gICAgICB0aGlzLl9jb21wbGV0ZVJlc3VsdHMuZGF0YSA9IHRoaXMuX2NvbXBsZXRlUmVzdWx0cy5kYXRhLmNvbmNhdChyZXN1bHRzLmRhdGEpO1xuICAgICAgdGhpcy5fY29tcGxldGVSZXN1bHRzLmVycm9ycyA9IHRoaXMuX2NvbXBsZXRlUmVzdWx0cy5lcnJvcnMuY29uY2F0KHJlc3VsdHMuZXJyb3JzKTtcbiAgICAgIHRoaXMuX2NvbXBsZXRlUmVzdWx0cy5tZXRhID0gcmVzdWx0cy5tZXRhO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICF0aGlzLl9jb21wbGV0ZWQgJiZcbiAgICAgIGZpbmlzaGVkSW5jbHVkaW5nUHJldmlldyAmJlxuICAgICAgaXNGdW5jdGlvbih0aGlzLl9jb25maWcuY29tcGxldGUpICYmXG4gICAgICAoIXJlc3VsdHMgfHwgIXJlc3VsdHMubWV0YS5hYm9ydGVkKVxuICAgICkge1xuICAgICAgdGhpcy5fY29uZmlnLmNvbXBsZXRlKHRoaXMuX2NvbXBsZXRlUmVzdWx0cywgdGhpcy5faW5wdXQpO1xuICAgICAgdGhpcy5fY29tcGxldGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIWZpbmlzaGVkSW5jbHVkaW5nUHJldmlldyAmJiAoIXJlc3VsdHMgfHwgIXJlc3VsdHMubWV0YS5wYXVzZWQpKSB0aGlzLl9uZXh0Q2h1bmsoKTtcblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIHRoaXMuX3NlbmRFcnJvciA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odGhpcy5fY29uZmlnLmVycm9yKSkgdGhpcy5fY29uZmlnLmVycm9yKGVycm9yKTtcbiAgICBlbHNlIGlmIChJU19QQVBBX1dPUktFUiAmJiB0aGlzLl9jb25maWcuZXJyb3IpIHtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHdvcmtlcklkOiBQYXBhLldPUktFUl9JRCxcbiAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICBmaW5pc2hlZDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiByZXBsYWNlQ29uZmlnKGNvbmZpZykge1xuICAgIC8vIERlZXAtY29weSB0aGUgY29uZmlnIHNvIHdlIGNhbiBlZGl0IGl0XG4gICAgdmFyIGNvbmZpZ0NvcHkgPSBjb3B5KGNvbmZpZyk7XG4gICAgY29uZmlnQ29weS5jaHVua1NpemUgPSBwYXJzZUludChjb25maWdDb3B5LmNodW5rU2l6ZSk7IC8vIHBhcnNlSW50IFZFUlkgaW1wb3J0YW50IHNvIHdlIGRvbid0IGNvbmNhdGVuYXRlIHN0cmluZ3MhXG4gICAgaWYgKCFjb25maWcuc3RlcCAmJiAhY29uZmlnLmNodW5rKSBjb25maWdDb3B5LmNodW5rU2l6ZSA9IG51bGw7IC8vIGRpc2FibGUgUmFuZ2UgaGVhZGVyIGlmIG5vdCBzdHJlYW1pbmc7IGJhZCB2YWx1ZXMgYnJlYWsgSUlTIC0gc2VlIGlzc3VlICMxOTZcbiAgICB0aGlzLl9oYW5kbGUgPSBuZXcgUGFyc2VySGFuZGxlKGNvbmZpZ0NvcHkpO1xuICAgIHRoaXMuX2hhbmRsZS5zdHJlYW1lciA9IHRoaXM7XG4gICAgdGhpcy5fY29uZmlnID0gY29uZmlnQ29weTsgLy8gcGVyc2lzdCB0aGUgY29weSB0byB0aGUgY2FsbGVyXG4gIH1cbn1cbmZ1bmN0aW9uIFN0cmluZ1N0cmVhbWVyKGNvbmZpZykge1xuICBjb25maWcgPSBjb25maWcgfHwge307XG4gIENodW5rU3RyZWFtZXIuY2FsbCh0aGlzLCBjb25maWcpO1xuXG4gIHZhciByZW1haW5pbmc7XG4gIHRoaXMuc3RyZWFtID0gZnVuY3Rpb24ocykge1xuICAgIHJlbWFpbmluZyA9IHM7XG4gICAgcmV0dXJuIHRoaXMuX25leHRDaHVuaygpO1xuICB9O1xuICB0aGlzLl9uZXh0Q2h1bmsgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fZmluaXNoZWQpIHJldHVybjtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuX2NvbmZpZy5jaHVua1NpemU7XG4gICAgdmFyIGNodW5rID0gc2l6ZSA/IHJlbWFpbmluZy5zdWJzdHIoMCwgc2l6ZSkgOiByZW1haW5pbmc7XG4gICAgcmVtYWluaW5nID0gc2l6ZSA/IHJlbWFpbmluZy5zdWJzdHIoc2l6ZSkgOiAnJztcbiAgICB0aGlzLl9maW5pc2hlZCA9ICFyZW1haW5pbmc7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VDaHVuayhjaHVuayk7XG4gIH07XG59XG5TdHJpbmdTdHJlYW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN0cmluZ1N0cmVhbWVyLnByb3RvdHlwZSk7XG5TdHJpbmdTdHJlYW1lci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdHJpbmdTdHJlYW1lcjtcblxuLy8gVXNlIG9uZSBQYXJzZXJIYW5kbGUgcGVyIGVudGlyZSBDU1YgZmlsZSBvciBzdHJpbmdcbmZ1bmN0aW9uIFBhcnNlckhhbmRsZShfY29uZmlnKSB7XG4gIC8vIE9uZSBnb2FsIGlzIHRvIG1pbmltaXplIHRoZSB1c2Ugb2YgcmVndWxhciBleHByZXNzaW9ucy4uLlxuICB2YXIgRkxPQVQgPSAvXlxccyotPyhcXGQqXFwuP1xcZCt8XFxkK1xcLj9cXGQqKShlWy0rXT9cXGQrKT9cXHMqJC9pO1xuICB2YXIgSVNPX0RBVEUgPSAvKFxcZHs0fS1bMDFdXFxkLVswLTNdXFxkVFswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkXFwuXFxkKyhbKy1dWzAtMl1cXGQ6WzAtNV1cXGR8WikpfChcXGR7NH0tWzAxXVxcZC1bMC0zXVxcZFRbMC0yXVxcZDpbMC01XVxcZDpbMC01XVxcZChbKy1dWzAtMl1cXGQ6WzAtNV1cXGR8WikpfChcXGR7NH0tWzAxXVxcZC1bMC0zXVxcZFRbMC0yXVxcZDpbMC01XVxcZChbKy1dWzAtMl1cXGQ6WzAtNV1cXGR8WikpLztcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBfc3RlcENvdW50ZXIgPSAwOyAvLyBOdW1iZXIgb2YgdGltZXMgc3RlcCB3YXMgY2FsbGVkIChudW1iZXIgb2Ygcm93cyBwYXJzZWQpXG4gIHZhciBfcm93Q291bnRlciA9IDA7IC8vIE51bWJlciBvZiByb3dzIHRoYXQgaGF2ZSBiZWVuIHBhcnNlZCBzbyBmYXJcbiAgdmFyIF9pbnB1dDsgLy8gVGhlIGlucHV0IGJlaW5nIHBhcnNlZFxuICB2YXIgX3BhcnNlcjsgLy8gVGhlIGNvcmUgcGFyc2VyIGJlaW5nIHVzZWRcbiAgdmFyIF9wYXVzZWQgPSBmYWxzZTsgLy8gV2hldGhlciB3ZSBhcmUgcGF1c2VkIG9yIG5vdFxuICB2YXIgX2Fib3J0ZWQgPSBmYWxzZTsgLy8gV2hldGhlciB0aGUgcGFyc2VyIGhhcyBhYm9ydGVkIG9yIG5vdFxuICB2YXIgX2RlbGltaXRlckVycm9yOyAvLyBUZW1wb3Jhcnkgc3RhdGUgYmV0d2VlbiBkZWxpbWl0ZXIgZGV0ZWN0aW9uIGFuZCBwcm9jZXNzaW5nIHJlc3VsdHNcbiAgdmFyIF9maWVsZHMgPSBbXTsgLy8gRmllbGRzIGFyZSBmcm9tIHRoZSBoZWFkZXIgcm93IG9mIHRoZSBpbnB1dCwgaWYgdGhlcmUgaXMgb25lXG4gIHZhciBfcmVzdWx0cyA9IHtcbiAgICAvLyBUaGUgbGFzdCByZXN1bHRzIHJldHVybmVkIGZyb20gdGhlIHBhcnNlclxuICAgIGRhdGE6IFtdLFxuICAgIGVycm9yczogW10sXG4gICAgbWV0YToge31cbiAgfTtcblxuICBpZiAoaXNGdW5jdGlvbihfY29uZmlnLnN0ZXApKSB7XG4gICAgdmFyIHVzZXJTdGVwID0gX2NvbmZpZy5zdGVwO1xuICAgIF9jb25maWcuc3RlcCA9IGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICAgIF9yZXN1bHRzID0gcmVzdWx0cztcblxuICAgICAgaWYgKG5lZWRzSGVhZGVyUm93KCkpIHByb2Nlc3NSZXN1bHRzKCk7XG4gICAgICAvLyBvbmx5IGNhbGwgdXNlcidzIHN0ZXAgZnVuY3Rpb24gYWZ0ZXIgaGVhZGVyIHJvd1xuICAgICAgZWxzZSB7XG4gICAgICAgIHByb2Nlc3NSZXN1bHRzKCk7XG5cbiAgICAgICAgLy8gSXQncyBwb3NzYmlsZSB0aGF0IHRoaXMgbGluZSB3YXMgZW1wdHkgYW5kIHRoZXJlJ3Mgbm8gcm93IGhlcmUgYWZ0ZXIgYWxsXG4gICAgICAgIGlmICghX3Jlc3VsdHMuZGF0YSB8fCBfcmVzdWx0cy5kYXRhLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICAgIF9zdGVwQ291bnRlciArPSByZXN1bHRzLmRhdGEubGVuZ3RoO1xuICAgICAgICBpZiAoX2NvbmZpZy5wcmV2aWV3ICYmIF9zdGVwQ291bnRlciA+IF9jb25maWcucHJldmlldykgX3BhcnNlci5hYm9ydCgpO1xuICAgICAgICBlbHNlIHVzZXJTdGVwKF9yZXN1bHRzLCBzZWxmKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBpbnB1dC4gTW9zdCB1c2VycyB3b24ndCBuZWVkLCBhbmQgc2hvdWxkbid0IG1lc3Mgd2l0aCwgdGhlIGJhc2VJbmRleFxuICAgKiBhbmQgaWdub3JlTGFzdFJvdyBwYXJhbWV0ZXJzLiBUaGV5IGFyZSB1c2VkIGJ5IHN0cmVhbWVycyAod3JhcHBlciBmdW5jdGlvbnMpXG4gICAqIHdoZW4gYW4gaW5wdXQgY29tZXMgaW4gbXVsdGlwbGUgY2h1bmtzLCBsaWtlIGZyb20gYSBmaWxlLlxuICAgKi9cbiAgdGhpcy5wYXJzZSA9IGZ1bmN0aW9uKGlucHV0LCBiYXNlSW5kZXgsIGlnbm9yZUxhc3RSb3cpIHtcbiAgICB2YXIgcXVvdGVDaGFyID0gX2NvbmZpZy5xdW90ZUNoYXIgfHwgJ1wiJztcbiAgICBpZiAoIV9jb25maWcubmV3bGluZSkgX2NvbmZpZy5uZXdsaW5lID0gZ3Vlc3NMaW5lRW5kaW5ncyhpbnB1dCwgcXVvdGVDaGFyKTtcblxuICAgIF9kZWxpbWl0ZXJFcnJvciA9IGZhbHNlO1xuICAgIGlmICghX2NvbmZpZy5kZWxpbWl0ZXIpIHtcbiAgICAgIHZhciBkZWxpbUd1ZXNzID0gZ3Vlc3NEZWxpbWl0ZXIoXG4gICAgICAgIGlucHV0LFxuICAgICAgICBfY29uZmlnLm5ld2xpbmUsXG4gICAgICAgIF9jb25maWcuc2tpcEVtcHR5TGluZXMsXG4gICAgICAgIF9jb25maWcuY29tbWVudHMsXG4gICAgICAgIF9jb25maWcuZGVsaW1pdGVyc1RvR3Vlc3NcbiAgICAgICk7XG4gICAgICBpZiAoZGVsaW1HdWVzcy5zdWNjZXNzZnVsKSBfY29uZmlnLmRlbGltaXRlciA9IGRlbGltR3Vlc3MuYmVzdERlbGltaXRlcjtcbiAgICAgIGVsc2Uge1xuICAgICAgICBfZGVsaW1pdGVyRXJyb3IgPSB0cnVlOyAvLyBhZGQgZXJyb3IgYWZ0ZXIgcGFyc2luZyAob3RoZXJ3aXNlIGl0IHdvdWxkIGJlIG92ZXJ3cml0dGVuKVxuICAgICAgICBfY29uZmlnLmRlbGltaXRlciA9IFBhcGEuRGVmYXVsdERlbGltaXRlcjtcbiAgICAgIH1cbiAgICAgIF9yZXN1bHRzLm1ldGEuZGVsaW1pdGVyID0gX2NvbmZpZy5kZWxpbWl0ZXI7XG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKF9jb25maWcuZGVsaW1pdGVyKSkge1xuICAgICAgX2NvbmZpZy5kZWxpbWl0ZXIgPSBfY29uZmlnLmRlbGltaXRlcihpbnB1dCk7XG4gICAgICBfcmVzdWx0cy5tZXRhLmRlbGltaXRlciA9IF9jb25maWcuZGVsaW1pdGVyO1xuICAgIH1cblxuICAgIHZhciBwYXJzZXJDb25maWcgPSBjb3B5KF9jb25maWcpO1xuICAgIGlmIChfY29uZmlnLnByZXZpZXcgJiYgX2NvbmZpZy5oZWFkZXIpIHBhcnNlckNvbmZpZy5wcmV2aWV3Kys7IC8vIHRvIGNvbXBlbnNhdGUgZm9yIGhlYWRlciByb3dcblxuICAgIF9pbnB1dCA9IGlucHV0O1xuICAgIF9wYXJzZXIgPSBuZXcgUGFyc2VyKHBhcnNlckNvbmZpZyk7XG4gICAgX3Jlc3VsdHMgPSBfcGFyc2VyLnBhcnNlKF9pbnB1dCwgYmFzZUluZGV4LCBpZ25vcmVMYXN0Um93KTtcbiAgICBwcm9jZXNzUmVzdWx0cygpO1xuICAgIHJldHVybiBfcGF1c2VkID8ge21ldGE6IHtwYXVzZWQ6IHRydWV9fSA6IF9yZXN1bHRzIHx8IHttZXRhOiB7cGF1c2VkOiBmYWxzZX19O1xuICB9O1xuXG4gIHRoaXMucGF1c2VkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF9wYXVzZWQ7XG4gIH07XG5cbiAgdGhpcy5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAgIF9wYXVzZWQgPSB0cnVlO1xuICAgIF9wYXJzZXIuYWJvcnQoKTtcbiAgICBfaW5wdXQgPSBfaW5wdXQuc3Vic3RyKF9wYXJzZXIuZ2V0Q2hhckluZGV4KCkpO1xuICB9O1xuXG4gIHRoaXMucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gICAgX3BhdXNlZCA9IGZhbHNlO1xuICAgIHNlbGYuc3RyZWFtZXIucGFyc2VDaHVuayhfaW5wdXQsIHRydWUpO1xuICB9O1xuXG4gIHRoaXMuYWJvcnRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfYWJvcnRlZDtcbiAgfTtcblxuICB0aGlzLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgX2Fib3J0ZWQgPSB0cnVlO1xuICAgIF9wYXJzZXIuYWJvcnQoKTtcbiAgICBfcmVzdWx0cy5tZXRhLmFib3J0ZWQgPSB0cnVlO1xuICAgIGlmIChpc0Z1bmN0aW9uKF9jb25maWcuY29tcGxldGUpKSBfY29uZmlnLmNvbXBsZXRlKF9yZXN1bHRzKTtcbiAgICBfaW5wdXQgPSAnJztcbiAgfTtcblxuICBmdW5jdGlvbiB0ZXN0RW1wdHlMaW5lKHMpIHtcbiAgICByZXR1cm4gX2NvbmZpZy5za2lwRW1wdHlMaW5lcyA9PT0gJ2dyZWVkeSdcbiAgICAgID8gcy5qb2luKCcnKS50cmltKCkgPT09ICcnXG4gICAgICA6IHMubGVuZ3RoID09PSAxICYmIHNbMF0ubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc1Jlc3VsdHMoKSB7XG4gICAgaWYgKF9yZXN1bHRzICYmIF9kZWxpbWl0ZXJFcnJvcikge1xuICAgICAgYWRkRXJyb3IoXG4gICAgICAgICdEZWxpbWl0ZXInLFxuICAgICAgICAnVW5kZXRlY3RhYmxlRGVsaW1pdGVyJyxcbiAgICAgICAgXCJVbmFibGUgdG8gYXV0by1kZXRlY3QgZGVsaW1pdGluZyBjaGFyYWN0ZXI7IGRlZmF1bHRlZCB0byAnXCIgKyBQYXBhLkRlZmF1bHREZWxpbWl0ZXIgKyBcIidcIlxuICAgICAgKTtcbiAgICAgIF9kZWxpbWl0ZXJFcnJvciA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChfY29uZmlnLnNraXBFbXB0eUxpbmVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9yZXN1bHRzLmRhdGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICh0ZXN0RW1wdHlMaW5lKF9yZXN1bHRzLmRhdGFbaV0pKSBfcmVzdWx0cy5kYXRhLnNwbGljZShpLS0sIDEpO1xuICAgIH1cblxuICAgIGlmIChuZWVkc0hlYWRlclJvdygpKSBmaWxsSGVhZGVyRmllbGRzKCk7XG5cbiAgICByZXR1cm4gYXBwbHlIZWFkZXJBbmREeW5hbWljVHlwaW5nQW5kVHJhbnNmb3JtYXRpb24oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5lZWRzSGVhZGVyUm93KCkge1xuICAgIHJldHVybiBfY29uZmlnLmhlYWRlciAmJiBfZmllbGRzLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbGxIZWFkZXJGaWVsZHMoKSB7XG4gICAgaWYgKCFfcmVzdWx0cykgcmV0dXJuO1xuXG4gICAgZnVuY3Rpb24gYWRkSGVkZXIoaGVhZGVyKSB7XG4gICAgICBpZiAoaXNGdW5jdGlvbihfY29uZmlnLnRyYW5zZm9ybUhlYWRlcikpIGhlYWRlciA9IF9jb25maWcudHJhbnNmb3JtSGVhZGVyKGhlYWRlcik7XG5cbiAgICAgIF9maWVsZHMucHVzaChoZWFkZXIpO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KF9yZXN1bHRzLmRhdGFbMF0pKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgbmVlZHNIZWFkZXJSb3coKSAmJiBpIDwgX3Jlc3VsdHMuZGF0YS5sZW5ndGg7IGkrKylcbiAgICAgICAgX3Jlc3VsdHMuZGF0YVtpXS5mb3JFYWNoKGFkZEhlZGVyKTtcblxuICAgICAgX3Jlc3VsdHMuZGF0YS5zcGxpY2UoMCwgMSk7XG4gICAgfVxuICAgIC8vIGlmIF9yZXN1bHRzLmRhdGFbMF0gaXMgbm90IGFuIGFycmF5LCB3ZSBhcmUgaW4gYSBzdGVwIHdoZXJlIF9yZXN1bHRzLmRhdGEgaXMgdGhlIHJvdy5cbiAgICBlbHNlIF9yZXN1bHRzLmRhdGEuZm9yRWFjaChhZGRIZWRlcik7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRBcHBseUR5bmFtaWNUeXBpbmcoZmllbGQpIHtcbiAgICAvLyBDYWNoZSBmdW5jdGlvbiB2YWx1ZXMgdG8gYXZvaWQgY2FsbGluZyBpdCBmb3IgZWFjaCByb3dcbiAgICBpZiAoX2NvbmZpZy5keW5hbWljVHlwaW5nRnVuY3Rpb24gJiYgX2NvbmZpZy5keW5hbWljVHlwaW5nW2ZpZWxkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBfY29uZmlnLmR5bmFtaWNUeXBpbmdbZmllbGRdID0gX2NvbmZpZy5keW5hbWljVHlwaW5nRnVuY3Rpb24oZmllbGQpO1xuICAgIH1cbiAgICByZXR1cm4gKF9jb25maWcuZHluYW1pY1R5cGluZ1tmaWVsZF0gfHwgX2NvbmZpZy5keW5hbWljVHlwaW5nKSA9PT0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRHluYW1pYyhmaWVsZCwgdmFsdWUpIHtcbiAgICBpZiAoc2hvdWxkQXBwbHlEeW5hbWljVHlwaW5nKGZpZWxkKSkge1xuICAgICAgaWYgKHZhbHVlID09PSAndHJ1ZScgfHwgdmFsdWUgPT09ICdUUlVFJykgcmV0dXJuIHRydWU7XG4gICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gJ2ZhbHNlJyB8fCB2YWx1ZSA9PT0gJ0ZBTFNFJykgcmV0dXJuIGZhbHNlO1xuICAgICAgZWxzZSBpZiAoRkxPQVQudGVzdCh2YWx1ZSkpIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgIGVsc2UgaWYgKElTT19EQVRFLnRlc3QodmFsdWUpKSByZXR1cm4gbmV3IERhdGUodmFsdWUpO1xuICAgICAgZWxzZSByZXR1cm4gdmFsdWUgPT09ICcnID8gbnVsbCA6IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseUhlYWRlckFuZER5bmFtaWNUeXBpbmdBbmRUcmFuc2Zvcm1hdGlvbigpIHtcbiAgICBpZiAoIV9yZXN1bHRzIHx8ICFfcmVzdWx0cy5kYXRhIHx8ICghX2NvbmZpZy5oZWFkZXIgJiYgIV9jb25maWcuZHluYW1pY1R5cGluZyAmJiAhX2NvbmZpZy50cmFuc2Zvcm0pKVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1Jvdyhyb3dTb3VyY2UsIGkpIHtcbiAgICAgIHZhciByb3cgPSBfY29uZmlnLmhlYWRlciA/IHt9IDogW107XG5cbiAgICAgIHZhciBqO1xuICAgICAgZm9yIChqID0gMDsgaiA8IHJvd1NvdXJjZS5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgZmllbGQgPSBqO1xuICAgICAgICB2YXIgdmFsdWUgPSByb3dTb3VyY2Vbal07XG5cbiAgICAgICAgaWYgKF9jb25maWcuaGVhZGVyKSBmaWVsZCA9IGogPj0gX2ZpZWxkcy5sZW5ndGggPyAnX19wYXJzZWRfZXh0cmEnIDogX2ZpZWxkc1tqXTtcblxuICAgICAgICBpZiAoX2NvbmZpZy50cmFuc2Zvcm0pIHZhbHVlID0gX2NvbmZpZy50cmFuc2Zvcm0odmFsdWUsIGZpZWxkKTtcblxuICAgICAgICB2YWx1ZSA9IHBhcnNlRHluYW1pYyhmaWVsZCwgdmFsdWUpO1xuXG4gICAgICAgIGlmIChmaWVsZCA9PT0gJ19fcGFyc2VkX2V4dHJhJykge1xuICAgICAgICAgIHJvd1tmaWVsZF0gPSByb3dbZmllbGRdIHx8IFtdO1xuICAgICAgICAgIHJvd1tmaWVsZF0ucHVzaCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSByb3dbZmllbGRdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChfY29uZmlnLmhlYWRlcikge1xuICAgICAgICBpZiAoaiA+IF9maWVsZHMubGVuZ3RoKVxuICAgICAgICAgIGFkZEVycm9yKFxuICAgICAgICAgICAgJ0ZpZWxkTWlzbWF0Y2gnLFxuICAgICAgICAgICAgJ1Rvb01hbnlGaWVsZHMnLFxuICAgICAgICAgICAgJ1RvbyBtYW55IGZpZWxkczogZXhwZWN0ZWQgJyArIF9maWVsZHMubGVuZ3RoICsgJyBmaWVsZHMgYnV0IHBhcnNlZCAnICsgaixcbiAgICAgICAgICAgIF9yb3dDb3VudGVyICsgaVxuICAgICAgICAgICk7XG4gICAgICAgIGVsc2UgaWYgKGogPCBfZmllbGRzLmxlbmd0aClcbiAgICAgICAgICBhZGRFcnJvcihcbiAgICAgICAgICAgICdGaWVsZE1pc21hdGNoJyxcbiAgICAgICAgICAgICdUb29GZXdGaWVsZHMnLFxuICAgICAgICAgICAgJ1RvbyBmZXcgZmllbGRzOiBleHBlY3RlZCAnICsgX2ZpZWxkcy5sZW5ndGggKyAnIGZpZWxkcyBidXQgcGFyc2VkICcgKyBqLFxuICAgICAgICAgICAgX3Jvd0NvdW50ZXIgKyBpXG4gICAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJvdztcbiAgICB9XG5cbiAgICB2YXIgaW5jcmVtZW50QnkgPSAxO1xuICAgIGlmICghX3Jlc3VsdHMuZGF0YVswXSB8fCBBcnJheS5pc0FycmF5KF9yZXN1bHRzLmRhdGFbMF0pKSB7XG4gICAgICBfcmVzdWx0cy5kYXRhID0gX3Jlc3VsdHMuZGF0YS5tYXAocHJvY2Vzc1Jvdyk7XG4gICAgICBpbmNyZW1lbnRCeSA9IF9yZXN1bHRzLmRhdGEubGVuZ3RoO1xuICAgIH0gZWxzZSBfcmVzdWx0cy5kYXRhID0gcHJvY2Vzc1JvdyhfcmVzdWx0cy5kYXRhLCAwKTtcblxuICAgIGlmIChfY29uZmlnLmhlYWRlciAmJiBfcmVzdWx0cy5tZXRhKSBfcmVzdWx0cy5tZXRhLmZpZWxkcyA9IF9maWVsZHM7XG5cbiAgICBfcm93Q291bnRlciArPSBpbmNyZW1lbnRCeTtcbiAgICByZXR1cm4gX3Jlc3VsdHM7XG4gIH1cblxuICBmdW5jdGlvbiBndWVzc0RlbGltaXRlcihpbnB1dCwgbmV3bGluZSwgc2tpcEVtcHR5TGluZXMsIGNvbW1lbnRzLCBkZWxpbWl0ZXJzVG9HdWVzcykge1xuICAgIHZhciBiZXN0RGVsaW0sIGJlc3REZWx0YSwgZmllbGRDb3VudFByZXZSb3c7XG5cbiAgICBkZWxpbWl0ZXJzVG9HdWVzcyA9IGRlbGltaXRlcnNUb0d1ZXNzIHx8IFsnLCcsICdcXHQnLCAnfCcsICc7JywgUGFwYS5SRUNPUkRfU0VQLCBQYXBhLlVOSVRfU0VQXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsaW1pdGVyc1RvR3Vlc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZWxpbSA9IGRlbGltaXRlcnNUb0d1ZXNzW2ldO1xuICAgICAgdmFyIGRlbHRhID0gMCxcbiAgICAgICAgYXZnRmllbGRDb3VudCA9IDAsXG4gICAgICAgIGVtcHR5TGluZXNDb3VudCA9IDA7XG4gICAgICBmaWVsZENvdW50UHJldlJvdyA9IHVuZGVmaW5lZDtcblxuICAgICAgdmFyIHByZXZpZXcgPSBuZXcgUGFyc2VyKHtcbiAgICAgICAgY29tbWVudHM6IGNvbW1lbnRzLFxuICAgICAgICBkZWxpbWl0ZXI6IGRlbGltLFxuICAgICAgICBuZXdsaW5lOiBuZXdsaW5lLFxuICAgICAgICBwcmV2aWV3OiAxMFxuICAgICAgfSkucGFyc2UoaW5wdXQpO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByZXZpZXcuZGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoc2tpcEVtcHR5TGluZXMgJiYgdGVzdEVtcHR5TGluZShwcmV2aWV3LmRhdGFbal0pKSB7XG4gICAgICAgICAgZW1wdHlMaW5lc0NvdW50Kys7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpZWxkQ291bnQgPSBwcmV2aWV3LmRhdGFbal0ubGVuZ3RoO1xuICAgICAgICBhdmdGaWVsZENvdW50ICs9IGZpZWxkQ291bnQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZENvdW50UHJldlJvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBmaWVsZENvdW50UHJldlJvdyA9IDA7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZmllbGRDb3VudCA+IDEpIHtcbiAgICAgICAgICBkZWx0YSArPSBNYXRoLmFicyhmaWVsZENvdW50IC0gZmllbGRDb3VudFByZXZSb3cpO1xuICAgICAgICAgIGZpZWxkQ291bnRQcmV2Um93ID0gZmllbGRDb3VudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocHJldmlldy5kYXRhLmxlbmd0aCA+IDApIGF2Z0ZpZWxkQ291bnQgLz0gcHJldmlldy5kYXRhLmxlbmd0aCAtIGVtcHR5TGluZXNDb3VudDtcblxuICAgICAgaWYgKCh0eXBlb2YgYmVzdERlbHRhID09PSAndW5kZWZpbmVkJyB8fCBkZWx0YSA+IGJlc3REZWx0YSkgJiYgYXZnRmllbGRDb3VudCA+IDEuOTkpIHtcbiAgICAgICAgYmVzdERlbHRhID0gZGVsdGE7XG4gICAgICAgIGJlc3REZWxpbSA9IGRlbGltO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9jb25maWcuZGVsaW1pdGVyID0gYmVzdERlbGltO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3NmdWw6ICEhYmVzdERlbGltLFxuICAgICAgYmVzdERlbGltaXRlcjogYmVzdERlbGltXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGd1ZXNzTGluZUVuZGluZ3MoaW5wdXQsIHF1b3RlQ2hhcikge1xuICAgIGlucHV0ID0gaW5wdXQuc3Vic3RyKDAsIDEwMjQgKiAxMDI0KTsgLy8gbWF4IGxlbmd0aCAxIE1CXG4gICAgLy8gUmVwbGFjZSBhbGwgdGhlIHRleHQgaW5zaWRlIHF1b3Rlc1xuICAgIHZhciByZSA9IG5ldyBSZWdFeHAoZXNjYXBlUmVnRXhwKHF1b3RlQ2hhcikgKyAnKFteXSo/KScgKyBlc2NhcGVSZWdFeHAocXVvdGVDaGFyKSwgJ2dtJyk7XG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKHJlLCAnJyk7XG5cbiAgICB2YXIgciA9IGlucHV0LnNwbGl0KCdcXHInKTtcblxuICAgIHZhciBuID0gaW5wdXQuc3BsaXQoJ1xcbicpO1xuXG4gICAgdmFyIG5BcHBlYXJzRmlyc3QgPSBuLmxlbmd0aCA+IDEgJiYgblswXS5sZW5ndGggPCByWzBdLmxlbmd0aDtcblxuICAgIGlmIChyLmxlbmd0aCA9PT0gMSB8fCBuQXBwZWFyc0ZpcnN0KSByZXR1cm4gJ1xcbic7XG5cbiAgICB2YXIgbnVtV2l0aE4gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgci5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJbaV1bMF0gPT09ICdcXG4nKSBudW1XaXRoTisrO1xuICAgIH1cblxuICAgIHJldHVybiBudW1XaXRoTiA+PSByLmxlbmd0aCAvIDIgPyAnXFxyXFxuJyA6ICdcXHInO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkRXJyb3IodHlwZSwgY29kZSwgbXNnLCByb3cpIHtcbiAgICBfcmVzdWx0cy5lcnJvcnMucHVzaCh7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgY29kZTogY29kZSxcbiAgICAgIG1lc3NhZ2U6IG1zZyxcbiAgICAgIHJvdzogcm93XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvR3VpZGUvUmVndWxhcl9FeHByZXNzaW9ucyAqL1xuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7IC8vICQmIG1lYW5zIHRoZSB3aG9sZSBtYXRjaGVkIHN0cmluZ1xufVxuXG4vKiogVGhlIGNvcmUgcGFyc2VyIGltcGxlbWVudHMgc3BlZWR5IGFuZCBjb3JyZWN0IENTViBwYXJzaW5nICovXG5mdW5jdGlvbiBQYXJzZXIoY29uZmlnKSB7XG4gIC8vIFVucGFjayB0aGUgY29uZmlnIG9iamVjdFxuICBjb25maWcgPSBjb25maWcgfHwge307XG4gIHZhciBkZWxpbSA9IGNvbmZpZy5kZWxpbWl0ZXI7XG4gIHZhciBuZXdsaW5lID0gY29uZmlnLm5ld2xpbmU7XG4gIHZhciBjb21tZW50cyA9IGNvbmZpZy5jb21tZW50cztcbiAgdmFyIHN0ZXAgPSBjb25maWcuc3RlcDtcbiAgdmFyIHByZXZpZXcgPSBjb25maWcucHJldmlldztcbiAgdmFyIGZhc3RNb2RlID0gY29uZmlnLmZhc3RNb2RlO1xuICB2YXIgcXVvdGVDaGFyO1xuICAvKiogQWxsb3dzIGZvciBubyBxdW90ZUNoYXIgYnkgc2V0dGluZyBxdW90ZUNoYXIgdG8gdW5kZWZpbmVkIGluIGNvbmZpZyAqL1xuICBpZiAoY29uZmlnLnF1b3RlQ2hhciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcXVvdGVDaGFyID0gJ1wiJztcbiAgfSBlbHNlIHtcbiAgICBxdW90ZUNoYXIgPSBjb25maWcucXVvdGVDaGFyO1xuICB9XG4gIHZhciBlc2NhcGVDaGFyID0gcXVvdGVDaGFyO1xuICBpZiAoY29uZmlnLmVzY2FwZUNoYXIgIT09IHVuZGVmaW5lZCkge1xuICAgIGVzY2FwZUNoYXIgPSBjb25maWcuZXNjYXBlQ2hhcjtcbiAgfVxuXG4gIC8vIERlbGltaXRlciBtdXN0IGJlIHZhbGlkXG4gIGlmICh0eXBlb2YgZGVsaW0gIT09ICdzdHJpbmcnIHx8IFBhcGEuQkFEX0RFTElNSVRFUlMuaW5kZXhPZihkZWxpbSkgPiAtMSkgZGVsaW0gPSAnLCc7XG5cbiAgLy8gQ29tbWVudCBjaGFyYWN0ZXIgbXVzdCBiZSB2YWxpZFxuICBpZiAoY29tbWVudHMgPT09IGRlbGltKSB0aHJvdyBuZXcgRXJyb3IoJ0NvbW1lbnQgY2hhcmFjdGVyIHNhbWUgYXMgZGVsaW1pdGVyJyk7XG4gIGVsc2UgaWYgKGNvbW1lbnRzID09PSB0cnVlKSBjb21tZW50cyA9ICcjJztcbiAgZWxzZSBpZiAodHlwZW9mIGNvbW1lbnRzICE9PSAnc3RyaW5nJyB8fCBQYXBhLkJBRF9ERUxJTUlURVJTLmluZGV4T2YoY29tbWVudHMpID4gLTEpXG4gICAgY29tbWVudHMgPSBmYWxzZTtcblxuICAvLyBOZXdsaW5lIG11c3QgYmUgdmFsaWQ6IFxcciwgXFxuLCBvciBcXHJcXG5cbiAgaWYgKG5ld2xpbmUgIT09ICdcXG4nICYmIG5ld2xpbmUgIT09ICdcXHInICYmIG5ld2xpbmUgIT09ICdcXHJcXG4nKSBuZXdsaW5lID0gJ1xcbic7XG5cbiAgLy8gV2UncmUgZ29ubmEgbmVlZCB0aGVzZSBhdCB0aGUgUGFyc2VyIHNjb3BlXG4gIHZhciBjdXJzb3IgPSAwO1xuICB2YXIgYWJvcnRlZCA9IGZhbHNlO1xuXG4gIHRoaXMucGFyc2UgPSBmdW5jdGlvbihpbnB1dCwgYmFzZUluZGV4LCBpZ25vcmVMYXN0Um93KSB7XG4gICAgLy8gRm9yIHNvbWUgcmVhc29uLCBpbiBDaHJvbWUsIHRoaXMgc3BlZWRzIHRoaW5ncyB1cCAoIT8pXG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBFcnJvcignSW5wdXQgbXVzdCBiZSBhIHN0cmluZycpO1xuXG4gICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBjb21wdXRlIHNvbWUgb2YgdGhlc2UgZXZlcnkgdGltZSBwYXJzZSgpIGlzIGNhbGxlZCxcbiAgICAvLyBidXQgaGF2aW5nIHRoZW0gaW4gYSBtb3JlIGxvY2FsIHNjb3BlIHNlZW1zIHRvIHBlcmZvcm0gYmV0dGVyXG4gICAgdmFyIGlucHV0TGVuID0gaW5wdXQubGVuZ3RoLFxuICAgICAgZGVsaW1MZW4gPSBkZWxpbS5sZW5ndGgsXG4gICAgICBuZXdsaW5lTGVuID0gbmV3bGluZS5sZW5ndGgsXG4gICAgICBjb21tZW50c0xlbiA9IGNvbW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgc3RlcElzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKHN0ZXApO1xuXG4gICAgLy8gRXN0YWJsaXNoIHN0YXJ0aW5nIHN0YXRlXG4gICAgY3Vyc29yID0gMDtcbiAgICB2YXIgZGF0YSA9IFtdLFxuICAgICAgZXJyb3JzID0gW10sXG4gICAgICByb3cgPSBbXSxcbiAgICAgIGxhc3RDdXJzb3IgPSAwO1xuXG4gICAgaWYgKCFpbnB1dCkgcmV0dXJuIHJldHVybmFibGUoKTtcblxuICAgIGlmIChmYXN0TW9kZSB8fCAoZmFzdE1vZGUgIT09IGZhbHNlICYmIGlucHV0LmluZGV4T2YocXVvdGVDaGFyKSA9PT0gLTEpKSB7XG4gICAgICB2YXIgcm93cyA9IGlucHV0LnNwbGl0KG5ld2xpbmUpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJvdyA9IHJvd3NbaV07XG4gICAgICAgIGN1cnNvciArPSByb3cubGVuZ3RoO1xuICAgICAgICBpZiAoaSAhPT0gcm93cy5sZW5ndGggLSAxKSBjdXJzb3IgKz0gbmV3bGluZS5sZW5ndGg7XG4gICAgICAgIGVsc2UgaWYgKGlnbm9yZUxhc3RSb3cpIHJldHVybiByZXR1cm5hYmxlKCk7XG4gICAgICAgIGlmIChjb21tZW50cyAmJiByb3cuc3Vic3RyKDAsIGNvbW1lbnRzTGVuKSA9PT0gY29tbWVudHMpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoc3RlcElzRnVuY3Rpb24pIHtcbiAgICAgICAgICBkYXRhID0gW107XG4gICAgICAgICAgcHVzaFJvdyhyb3cuc3BsaXQoZGVsaW0pKTtcbiAgICAgICAgICBkb1N0ZXAoKTtcbiAgICAgICAgICBpZiAoYWJvcnRlZCkgcmV0dXJuIHJldHVybmFibGUoKTtcbiAgICAgICAgfSBlbHNlIHB1c2hSb3cocm93LnNwbGl0KGRlbGltKSk7XG4gICAgICAgIGlmIChwcmV2aWV3ICYmIGkgPj0gcHJldmlldykge1xuICAgICAgICAgIGRhdGEgPSBkYXRhLnNsaWNlKDAsIHByZXZpZXcpO1xuICAgICAgICAgIHJldHVybiByZXR1cm5hYmxlKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0dXJuYWJsZSgpO1xuICAgIH1cblxuICAgIHZhciBuZXh0RGVsaW0gPSBpbnB1dC5pbmRleE9mKGRlbGltLCBjdXJzb3IpO1xuICAgIHZhciBuZXh0TmV3bGluZSA9IGlucHV0LmluZGV4T2YobmV3bGluZSwgY3Vyc29yKTtcbiAgICB2YXIgcXVvdGVDaGFyUmVnZXggPSBuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4cChlc2NhcGVDaGFyKSArIGVzY2FwZVJlZ0V4cChxdW90ZUNoYXIpLCAnZycpO1xuICAgIHZhciBxdW90ZVNlYXJjaDtcblxuICAgIC8vIFBhcnNlciBsb29wXG4gICAgZm9yICg7Oykge1xuICAgICAgLy8gRmllbGQgaGFzIG9wZW5pbmcgcXVvdGVcbiAgICAgIGlmIChpbnB1dFtjdXJzb3JdID09PSBxdW90ZUNoYXIpIHtcbiAgICAgICAgLy8gU3RhcnQgb3VyIHNlYXJjaCBmb3IgdGhlIGNsb3NpbmcgcXVvdGUgd2hlcmUgdGhlIGN1cnNvciBpc1xuICAgICAgICBxdW90ZVNlYXJjaCA9IGN1cnNvcjtcblxuICAgICAgICAvLyBTa2lwIHRoZSBvcGVuaW5nIHF1b3RlXG4gICAgICAgIGN1cnNvcisrO1xuXG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAvLyBGaW5kIGNsb3NpbmcgcXVvdGVcbiAgICAgICAgICBxdW90ZVNlYXJjaCA9IGlucHV0LmluZGV4T2YocXVvdGVDaGFyLCBxdW90ZVNlYXJjaCArIDEpO1xuXG4gICAgICAgICAgLy9ObyBvdGhlciBxdW90ZXMgYXJlIGZvdW5kIC0gbm8gb3RoZXIgZGVsaW1pdGVyc1xuICAgICAgICAgIGlmIChxdW90ZVNlYXJjaCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlmICghaWdub3JlTGFzdFJvdykge1xuICAgICAgICAgICAgICAvLyBObyBjbG9zaW5nIHF1b3RlLi4uIHdoYXQgYSBwaXR5XG4gICAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnUXVvdGVzJyxcbiAgICAgICAgICAgICAgICBjb2RlOiAnTWlzc2luZ1F1b3RlcycsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1F1b3RlZCBmaWVsZCB1bnRlcm1pbmF0ZWQnLFxuICAgICAgICAgICAgICAgIHJvdzogZGF0YS5sZW5ndGgsIC8vIHJvdyBoYXMgeWV0IHRvIGJlIGluc2VydGVkXG4gICAgICAgICAgICAgICAgaW5kZXg6IGN1cnNvclxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaW5pc2goKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDbG9zaW5nIHF1b3RlIGF0IEVPRlxuICAgICAgICAgIGlmIChxdW90ZVNlYXJjaCA9PT0gaW5wdXRMZW4gLSAxKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBpbnB1dC5zdWJzdHJpbmcoY3Vyc29yLCBxdW90ZVNlYXJjaCkucmVwbGFjZShxdW90ZUNoYXJSZWdleCwgcXVvdGVDaGFyKTtcbiAgICAgICAgICAgIHJldHVybiBmaW5pc2godmFsdWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHRoaXMgcXVvdGUgaXMgZXNjYXBlZCwgaXQncyBwYXJ0IG9mIHRoZSBkYXRhOyBza2lwIGl0XG4gICAgICAgICAgLy8gSWYgdGhlIHF1b3RlIGNoYXJhY3RlciBpcyB0aGUgZXNjYXBlIGNoYXJhY3RlciwgdGhlbiBjaGVjayBpZiB0aGUgbmV4dCBjaGFyYWN0ZXIgaXMgdGhlIGVzY2FwZSBjaGFyYWN0ZXJcbiAgICAgICAgICBpZiAocXVvdGVDaGFyID09PSBlc2NhcGVDaGFyICYmIGlucHV0W3F1b3RlU2VhcmNoICsgMV0gPT09IGVzY2FwZUNoYXIpIHtcbiAgICAgICAgICAgIHF1b3RlU2VhcmNoKys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGUgcXVvdGUgY2hhcmFjdGVyIGlzIG5vdCB0aGUgZXNjYXBlIGNoYXJhY3RlciwgdGhlbiBjaGVjayBpZiB0aGUgcHJldmlvdXMgY2hhcmFjdGVyIHdhcyB0aGUgZXNjYXBlIGNoYXJhY3RlclxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHF1b3RlQ2hhciAhPT0gZXNjYXBlQ2hhciAmJlxuICAgICAgICAgICAgcXVvdGVTZWFyY2ggIT09IDAgJiZcbiAgICAgICAgICAgIGlucHV0W3F1b3RlU2VhcmNoIC0gMV0gPT09IGVzY2FwZUNoYXJcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENoZWNrIHVwIHRvIG5leHREZWxpbSBvciBuZXh0TmV3bGluZSwgd2hpY2hldmVyIGlzIGNsb3Nlc3RcbiAgICAgICAgICB2YXIgY2hlY2tVcFRvID0gbmV4dE5ld2xpbmUgPT09IC0xID8gbmV4dERlbGltIDogTWF0aC5taW4obmV4dERlbGltLCBuZXh0TmV3bGluZSk7XG4gICAgICAgICAgdmFyIHNwYWNlc0JldHdlZW5RdW90ZUFuZERlbGltaXRlciA9IGV4dHJhU3BhY2VzKGNoZWNrVXBUbyk7XG5cbiAgICAgICAgICAvLyBDbG9zaW5nIHF1b3RlIGZvbGxvd2VkIGJ5IGRlbGltaXRlciBvciAndW5uZWNlc3Nhcnkgc3BhY2VzICsgZGVsaW1pdGVyJ1xuICAgICAgICAgIGlmIChpbnB1dFtxdW90ZVNlYXJjaCArIDEgKyBzcGFjZXNCZXR3ZWVuUXVvdGVBbmREZWxpbWl0ZXJdID09PSBkZWxpbSkge1xuICAgICAgICAgICAgcm93LnB1c2goaW5wdXQuc3Vic3RyaW5nKGN1cnNvciwgcXVvdGVTZWFyY2gpLnJlcGxhY2UocXVvdGVDaGFyUmVnZXgsIHF1b3RlQ2hhcikpO1xuICAgICAgICAgICAgY3Vyc29yID0gcXVvdGVTZWFyY2ggKyAxICsgc3BhY2VzQmV0d2VlblF1b3RlQW5kRGVsaW1pdGVyICsgZGVsaW1MZW47XG4gICAgICAgICAgICBuZXh0RGVsaW0gPSBpbnB1dC5pbmRleE9mKGRlbGltLCBjdXJzb3IpO1xuICAgICAgICAgICAgbmV4dE5ld2xpbmUgPSBpbnB1dC5pbmRleE9mKG5ld2xpbmUsIGN1cnNvcik7XG5cbiAgICAgICAgICAgIGlmIChzdGVwSXNGdW5jdGlvbikge1xuICAgICAgICAgICAgICBkb1N0ZXAoKTtcbiAgICAgICAgICAgICAgaWYgKGFib3J0ZWQpIHJldHVybiByZXR1cm5hYmxlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcmV2aWV3ICYmIGRhdGEubGVuZ3RoID49IHByZXZpZXcpIHJldHVybiByZXR1cm5hYmxlKHRydWUpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc3BhY2VzQmV0d2VlblF1b3RlQW5kTmV3TGluZSA9IGV4dHJhU3BhY2VzKG5leHROZXdsaW5lKTtcblxuICAgICAgICAgIC8vIENsb3NpbmcgcXVvdGUgZm9sbG93ZWQgYnkgbmV3bGluZSBvciAndW5uZWNlc3Nhcnkgc3BhY2VzICsgbmV3TGluZSdcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBpbnB1dC5zdWJzdHIocXVvdGVTZWFyY2ggKyAxICsgc3BhY2VzQmV0d2VlblF1b3RlQW5kTmV3TGluZSwgbmV3bGluZUxlbikgPT09IG5ld2xpbmVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJvdy5wdXNoKGlucHV0LnN1YnN0cmluZyhjdXJzb3IsIHF1b3RlU2VhcmNoKS5yZXBsYWNlKHF1b3RlQ2hhclJlZ2V4LCBxdW90ZUNoYXIpKTtcbiAgICAgICAgICAgIHNhdmVSb3cocXVvdGVTZWFyY2ggKyAxICsgc3BhY2VzQmV0d2VlblF1b3RlQW5kTmV3TGluZSArIG5ld2xpbmVMZW4pO1xuICAgICAgICAgICAgbmV4dERlbGltID0gaW5wdXQuaW5kZXhPZihkZWxpbSwgY3Vyc29yKTsgLy8gYmVjYXVzZSB3ZSBtYXkgaGF2ZSBza2lwcGVkIHRoZSBuZXh0RGVsaW0gaW4gdGhlIHF1b3RlZCBmaWVsZFxuXG4gICAgICAgICAgICBpZiAoc3RlcElzRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgZG9TdGVwKCk7XG4gICAgICAgICAgICAgIGlmIChhYm9ydGVkKSByZXR1cm4gcmV0dXJuYWJsZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJldmlldyAmJiBkYXRhLmxlbmd0aCA+PSBwcmV2aWV3KSByZXR1cm4gcmV0dXJuYWJsZSh0cnVlKTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ2hlY2tzIGZvciB2YWxpZCBjbG9zaW5nIHF1b3RlcyBhcmUgY29tcGxldGUgKGVzY2FwZWQgcXVvdGVzIG9yIHF1b3RlIGZvbGxvd2VkIGJ5IEVPRi9kZWxpbWl0ZXIvbmV3bGluZSkgLS0gYXNzdW1lIHRoZXNlIHF1b3RlcyBhcmUgcGFydCBvZiBhbiBpbnZhbGlkIHRleHQgc3RyaW5nXG4gICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ1F1b3RlcycsXG4gICAgICAgICAgICBjb2RlOiAnSW52YWxpZFF1b3RlcycsXG4gICAgICAgICAgICBtZXNzYWdlOiAnVHJhaWxpbmcgcXVvdGUgb24gcXVvdGVkIGZpZWxkIGlzIG1hbGZvcm1lZCcsXG4gICAgICAgICAgICByb3c6IGRhdGEubGVuZ3RoLCAvLyByb3cgaGFzIHlldCB0byBiZSBpbnNlcnRlZFxuICAgICAgICAgICAgaW5kZXg6IGN1cnNvclxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcXVvdGVTZWFyY2grKztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGVwSXNGdW5jdGlvbikge1xuICAgICAgICAgIGRvU3RlcCgpO1xuICAgICAgICAgIGlmIChhYm9ydGVkKSByZXR1cm4gcmV0dXJuYWJsZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXZpZXcgJiYgZGF0YS5sZW5ndGggPj0gcHJldmlldykgcmV0dXJuIHJldHVybmFibGUodHJ1ZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDb21tZW50IGZvdW5kIGF0IHN0YXJ0IG9mIG5ldyBsaW5lXG4gICAgICBpZiAoY29tbWVudHMgJiYgcm93Lmxlbmd0aCA9PT0gMCAmJiBpbnB1dC5zdWJzdHIoY3Vyc29yLCBjb21tZW50c0xlbikgPT09IGNvbW1lbnRzKSB7XG4gICAgICAgIGlmIChuZXh0TmV3bGluZSA9PT0gLTEpXG4gICAgICAgICAgLy8gQ29tbWVudCBlbmRzIGF0IEVPRlxuICAgICAgICAgIHJldHVybiByZXR1cm5hYmxlKCk7XG4gICAgICAgIGN1cnNvciA9IG5leHROZXdsaW5lICsgbmV3bGluZUxlbjtcbiAgICAgICAgbmV4dE5ld2xpbmUgPSBpbnB1dC5pbmRleE9mKG5ld2xpbmUsIGN1cnNvcik7XG4gICAgICAgIG5leHREZWxpbSA9IGlucHV0LmluZGV4T2YoZGVsaW0sIGN1cnNvcik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBOZXh0IGRlbGltaXRlciBjb21lcyBiZWZvcmUgbmV4dCBuZXdsaW5lLCBzbyB3ZSd2ZSByZWFjaGVkIGVuZCBvZiBmaWVsZFxuICAgICAgaWYgKG5leHREZWxpbSAhPT0gLTEgJiYgKG5leHREZWxpbSA8IG5leHROZXdsaW5lIHx8IG5leHROZXdsaW5lID09PSAtMSkpIHtcbiAgICAgICAgcm93LnB1c2goaW5wdXQuc3Vic3RyaW5nKGN1cnNvciwgbmV4dERlbGltKSk7XG4gICAgICAgIGN1cnNvciA9IG5leHREZWxpbSArIGRlbGltTGVuO1xuICAgICAgICBuZXh0RGVsaW0gPSBpbnB1dC5pbmRleE9mKGRlbGltLCBjdXJzb3IpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gRW5kIG9mIHJvd1xuICAgICAgaWYgKG5leHROZXdsaW5lICE9PSAtMSkge1xuICAgICAgICByb3cucHVzaChpbnB1dC5zdWJzdHJpbmcoY3Vyc29yLCBuZXh0TmV3bGluZSkpO1xuICAgICAgICBzYXZlUm93KG5leHROZXdsaW5lICsgbmV3bGluZUxlbik7XG5cbiAgICAgICAgaWYgKHN0ZXBJc0Z1bmN0aW9uKSB7XG4gICAgICAgICAgZG9TdGVwKCk7XG4gICAgICAgICAgaWYgKGFib3J0ZWQpIHJldHVybiByZXR1cm5hYmxlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJldmlldyAmJiBkYXRhLmxlbmd0aCA+PSBwcmV2aWV3KSByZXR1cm4gcmV0dXJuYWJsZSh0cnVlKTtcblxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbmlzaCgpO1xuXG4gICAgZnVuY3Rpb24gcHVzaFJvdyhyb3cpIHtcbiAgICAgIGRhdGEucHVzaChyb3cpO1xuICAgICAgbGFzdEN1cnNvciA9IGN1cnNvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjaGVja3MgaWYgdGhlcmUgYXJlIGV4dHJhIHNwYWNlcyBhZnRlciBjbG9zaW5nIHF1b3RlIGFuZCBnaXZlbiBpbmRleCB3aXRob3V0IGFueSB0ZXh0XG4gICAgICogaWYgWWVzLCByZXR1cm5zIHRoZSBudW1iZXIgb2Ygc3BhY2VzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXh0cmFTcGFjZXMoaW5kZXgpIHtcbiAgICAgIHZhciBzcGFjZUxlbmd0aCA9IDA7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHZhciB0ZXh0QmV0d2VlbkNsb3NpbmdRdW90ZUFuZEluZGV4ID0gaW5wdXQuc3Vic3RyaW5nKHF1b3RlU2VhcmNoICsgMSwgaW5kZXgpO1xuICAgICAgICBpZiAodGV4dEJldHdlZW5DbG9zaW5nUXVvdGVBbmRJbmRleCAmJiB0ZXh0QmV0d2VlbkNsb3NpbmdRdW90ZUFuZEluZGV4LnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICBzcGFjZUxlbmd0aCA9IHRleHRCZXR3ZWVuQ2xvc2luZ1F1b3RlQW5kSW5kZXgubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3BhY2VMZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwZW5kcyB0aGUgcmVtYWluaW5nIGlucHV0IGZyb20gY3Vyc29yIHRvIHRoZSBlbmQgaW50b1xuICAgICAqIHJvdywgc2F2ZXMgdGhlIHJvdywgY2FsbHMgc3RlcCwgYW5kIHJldHVybnMgdGhlIHJlc3VsdHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluaXNoKHZhbHVlKSB7XG4gICAgICBpZiAoaWdub3JlTGFzdFJvdykgcmV0dXJuIHJldHVybmFibGUoKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB2YWx1ZSA9IGlucHV0LnN1YnN0cihjdXJzb3IpO1xuICAgICAgcm93LnB1c2godmFsdWUpO1xuICAgICAgY3Vyc29yID0gaW5wdXRMZW47IC8vIGltcG9ydGFudCBpbiBjYXNlIHBhcnNpbmcgaXMgcGF1c2VkXG4gICAgICBwdXNoUm93KHJvdyk7XG4gICAgICBpZiAoc3RlcElzRnVuY3Rpb24pIGRvU3RlcCgpO1xuICAgICAgcmV0dXJuIHJldHVybmFibGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIHRoZSBjdXJyZW50IHJvdyB0byB0aGUgcmVzdWx0cy4gSXQgc2V0cyB0aGUgY3Vyc29yXG4gICAgICogdG8gbmV3Q3Vyc29yIGFuZCBmaW5kcyB0aGUgbmV4dE5ld2xpbmUuIFRoZSBjYWxsZXIgc2hvdWxkXG4gICAgICogdGFrZSBjYXJlIHRvIGV4ZWN1dGUgdXNlcidzIHN0ZXAgZnVuY3Rpb24gYW5kIGNoZWNrIGZvclxuICAgICAqIHByZXZpZXcgYW5kIGVuZCBwYXJzaW5nIGlmIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYXZlUm93KG5ld0N1cnNvcikge1xuICAgICAgY3Vyc29yID0gbmV3Q3Vyc29yO1xuICAgICAgcHVzaFJvdyhyb3cpO1xuICAgICAgcm93ID0gW107XG4gICAgICBuZXh0TmV3bGluZSA9IGlucHV0LmluZGV4T2YobmV3bGluZSwgY3Vyc29yKTtcbiAgICB9XG5cbiAgICAvKiogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgcmVzdWx0cywgZXJyb3JzLCBhbmQgbWV0YS4gKi9cbiAgICBmdW5jdGlvbiByZXR1cm5hYmxlKHN0b3BwZWQsIHN0ZXApIHtcbiAgICAgIHZhciBpc1N0ZXAgPSBzdGVwIHx8IGZhbHNlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogaXNTdGVwID8gZGF0YVswXSA6IGRhdGEsXG4gICAgICAgIGVycm9yczogZXJyb3JzLFxuICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgZGVsaW1pdGVyOiBkZWxpbSxcbiAgICAgICAgICBsaW5lYnJlYWs6IG5ld2xpbmUsXG4gICAgICAgICAgYWJvcnRlZDogYWJvcnRlZCxcbiAgICAgICAgICB0cnVuY2F0ZWQ6ICEhc3RvcHBlZCxcbiAgICAgICAgICBjdXJzb3I6IGxhc3RDdXJzb3IgKyAoYmFzZUluZGV4IHx8IDApXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqIEV4ZWN1dGVzIHRoZSB1c2VyJ3Mgc3RlcCBmdW5jdGlvbiBhbmQgcmVzZXRzIGRhdGEgJiBlcnJvcnMuICovXG4gICAgZnVuY3Rpb24gZG9TdGVwKCkge1xuICAgICAgc3RlcChyZXR1cm5hYmxlKHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgICAgZGF0YSA9IFtdO1xuICAgICAgZXJyb3JzID0gW107XG4gICAgfVxuICB9O1xuXG4gIC8qKiBTZXRzIHRoZSBhYm9ydCBmbGFnICovXG4gIHRoaXMuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgfTtcblxuICAvKiogR2V0cyB0aGUgY3Vyc29yIHBvc2l0aW9uICovXG4gIHRoaXMuZ2V0Q2hhckluZGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGN1cnNvcjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm90SW1wbGVtZW50ZWQoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkLicpO1xufVxuXG4vKiogTWFrZXMgYSBkZWVwIGNvcHkgb2YgYW4gYXJyYXkgb3Igb2JqZWN0IChtb3N0bHkpICovXG5mdW5jdGlvbiBjb3B5KG9iaikge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSByZXR1cm4gb2JqO1xuICB2YXIgY3B5ID0gQXJyYXkuaXNBcnJheShvYmopID8gW10gOiB7fTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikgY3B5W2tleV0gPSBjb3B5KG9ialtrZXldKTtcbiAgcmV0dXJuIGNweTtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbihmdW5jKSB7XG4gIHJldHVybiB0eXBlb2YgZnVuYyA9PT0gJ2Z1bmN0aW9uJztcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxudmFyIF90eXBlb2YgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhc3NlcnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2Fzc2VydC5hc3NlcnQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNCcm93c2VyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxzLmlzQnJvd3NlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1dvcmtlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2xvYmFscy5pc1dvcmtlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJub2RlVmVyc2lvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2xvYmFscy5ub2RlVmVyc2lvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzZWxmXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxzLnNlbGY7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwid2luZG93XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxzLndpbmRvdztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnbG9iYWxcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dsb2JhbHMuZ2xvYmFsO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRvY3VtZW50XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxzLmRvY3VtZW50O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZUxvYWRlcldvcmtlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfY3JlYXRlTG9hZGVyV29ya2VyLmNyZWF0ZUxvYWRlcldvcmtlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZVdpdGhXb3JrZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3BhcnNlV2l0aFdvcmtlci5wYXJzZVdpdGhXb3JrZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2FuUGFyc2VXaXRoV29ya2VyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9wYXJzZVdpdGhXb3JrZXIuY2FuUGFyc2VXaXRoV29ya2VyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlSlNPTlwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfcGFyc2VKc29uLnBhcnNlSlNPTjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b0FycmF5QnVmZmVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hcnJheUJ1ZmZlclV0aWxzLnRvQXJyYXlCdWZmZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2xpY2VBcnJheUJ1ZmZlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYXJyYXlCdWZmZXJVdGlscy5zbGljZUFycmF5QnVmZmVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hcnJheUJ1ZmZlclV0aWxzLmNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbmNhdGVuYXRlVHlwZWRBcnJheXNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2FycmF5QnVmZmVyVXRpbHMuY29uY2F0ZW5hdGVUeXBlZEFycmF5cztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb21wYXJlQXJyYXlCdWZmZXJzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hcnJheUJ1ZmZlclV0aWxzLmNvbXBhcmVBcnJheUJ1ZmZlcnM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFkVG9OQnl0ZXNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX21lbW9yeUNvcHlVdGlscy5wYWRUb05CeXRlcztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb3B5VG9BcnJheVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbWVtb3J5Q29weVV0aWxzLmNvcHlUb0FycmF5O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvcHlBcnJheUJ1ZmZlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbWVtb3J5Q29weVV0aWxzLmNvcHlBcnJheUJ1ZmZlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb3B5UGFkZGVkQXJyYXlCdWZmZXJUb0RhdGFWaWV3XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9iaW5hcnlDb3B5VXRpbHMuY29weVBhZGRlZEFycmF5QnVmZmVyVG9EYXRhVmlldztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb3B5UGFkZGVkU3RyaW5nVG9EYXRhVmlld1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYmluYXJ5Q29weVV0aWxzLmNvcHlQYWRkZWRTdHJpbmdUb0RhdGFWaWV3O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhZFN0cmluZ1RvQnl0ZUFsaWdubWVudFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZW5jb2RlVXRpbHMucGFkU3RyaW5nVG9CeXRlQWxpZ25tZW50O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvcHlTdHJpbmdUb0RhdGFWaWV3XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9lbmNvZGVVdGlscy5jb3B5U3RyaW5nVG9EYXRhVmlldztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb3B5QmluYXJ5VG9EYXRhVmlld1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZW5jb2RlVXRpbHMuY29weUJpbmFyeVRvRGF0YVZpZXc7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0Rmlyc3RDaGFyYWN0ZXJzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nZXRGaXJzdENoYXJhY3RlcnMuZ2V0Rmlyc3RDaGFyYWN0ZXJzO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldE1hZ2ljU3RyaW5nXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nZXRGaXJzdENoYXJhY3RlcnMuZ2V0TWFnaWNTdHJpbmc7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWFrZVRleHRFbmNvZGVySXRlcmF0b3JcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3RleHRJdGVyYXRvcnMubWFrZVRleHRFbmNvZGVySXRlcmF0b3I7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWFrZVRleHREZWNvZGVySXRlcmF0b3JcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3RleHRJdGVyYXRvcnMubWFrZVRleHREZWNvZGVySXRlcmF0b3I7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWFrZUxpbmVJdGVyYXRvclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdGV4dEl0ZXJhdG9ycy5tYWtlTGluZUl0ZXJhdG9yO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1ha2VOdW1iZXJlZExpbmVJdGVyYXRvclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdGV4dEl0ZXJhdG9ycy5tYWtlTnVtYmVyZWRMaW5lSXRlcmF0b3I7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZm9yRWFjaFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYXN5bmNJdGVyYXRpb24uZm9yRWFjaDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb25jYXRlbmF0ZUFycmF5QnVmZmVyc0FzeW5jXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hc3luY0l0ZXJhdGlvbi5jb25jYXRlbmF0ZUFycmF5QnVmZmVyc0FzeW5jO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RTY2hlZHVsZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3JlcXVlc3RTY2hlZHVsZXIuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzZXRQYXRoUHJlZml4XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9maWxlQWxpYXNlcy5zZXRQYXRoUHJlZml4O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFBhdGhQcmVmaXhcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ZpbGVBbGlhc2VzLmdldFBhdGhQcmVmaXg7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVzb2x2ZVBhdGhcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ZpbGVBbGlhc2VzLnJlc29sdmVQYXRoO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9hZGRBbGlhc2VzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9maWxlQWxpYXNlcy5hZGRBbGlhc2VzO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzQnVmZmVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9idWZmZXJVdGlscy5pc0J1ZmZlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b0J1ZmZlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYnVmZmVyVXRpbHMudG9CdWZmZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYnVmZmVyVG9BcnJheUJ1ZmZlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYnVmZmVyVXRpbHMuYnVmZmVyVG9BcnJheUJ1ZmZlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJKU09OTG9hZGVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9qc29uTG9hZGVyLkpTT05Mb2FkZXI7XG4gIH1cbn0pO1xuZXhwb3J0cy5mcyA9IGV4cG9ydHMucGF0aCA9IHZvaWQgMDtcblxudmFyIF9hc3NlcnQgPSByZXF1aXJlKFwiLi9saWIvZW52LXV0aWxzL2Fzc2VydFwiKTtcblxudmFyIF9nbG9iYWxzID0gcmVxdWlyZShcIi4vbGliL2Vudi11dGlscy9nbG9iYWxzXCIpO1xuXG52YXIgX2NyZWF0ZUxvYWRlcldvcmtlciA9IHJlcXVpcmUoXCIuL2xpYi93b3JrZXItbG9hZGVyLXV0aWxzL2NyZWF0ZS1sb2FkZXItd29ya2VyXCIpO1xuXG52YXIgX3BhcnNlV2l0aFdvcmtlciA9IHJlcXVpcmUoXCIuL2xpYi93b3JrZXItbG9hZGVyLXV0aWxzL3BhcnNlLXdpdGgtd29ya2VyXCIpO1xuXG52YXIgX3BhcnNlSnNvbiA9IHJlcXVpcmUoXCIuL2xpYi9wYXJzZXItdXRpbHMvcGFyc2UtanNvblwiKTtcblxudmFyIF9hcnJheUJ1ZmZlclV0aWxzID0gcmVxdWlyZShcIi4vbGliL2JpbmFyeS11dGlscy9hcnJheS1idWZmZXItdXRpbHNcIik7XG5cbnZhciBfbWVtb3J5Q29weVV0aWxzID0gcmVxdWlyZShcIi4vbGliL2JpbmFyeS11dGlscy9tZW1vcnktY29weS11dGlsc1wiKTtcblxudmFyIF9iaW5hcnlDb3B5VXRpbHMgPSByZXF1aXJlKFwiLi9saWIvYmluYXJ5LXV0aWxzL2JpbmFyeS1jb3B5LXV0aWxzXCIpO1xuXG52YXIgX2VuY29kZVV0aWxzID0gcmVxdWlyZShcIi4vbGliL2JpbmFyeS11dGlscy9lbmNvZGUtdXRpbHNcIik7XG5cbnZhciBfZ2V0Rmlyc3RDaGFyYWN0ZXJzID0gcmVxdWlyZShcIi4vbGliL2JpbmFyeS11dGlscy9nZXQtZmlyc3QtY2hhcmFjdGVyc1wiKTtcblxudmFyIF90ZXh0SXRlcmF0b3JzID0gcmVxdWlyZShcIi4vbGliL2l0ZXJhdG9ycy90ZXh0LWl0ZXJhdG9yc1wiKTtcblxudmFyIF9hc3luY0l0ZXJhdGlvbiA9IHJlcXVpcmUoXCIuL2xpYi9pdGVyYXRvcnMvYXN5bmMtaXRlcmF0aW9uXCIpO1xuXG52YXIgX3JlcXVlc3RTY2hlZHVsZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9yZXF1ZXN0LXV0aWxzL3JlcXVlc3Qtc2NoZWR1bGVyXCIpKTtcblxudmFyIHBhdGggPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9saWIvcGF0aC11dGlscy9wYXRoXCIpKTtcblxuZXhwb3J0cy5wYXRoID0gcGF0aDtcblxudmFyIF9maWxlQWxpYXNlcyA9IHJlcXVpcmUoXCIuL2xpYi9wYXRoLXV0aWxzL2ZpbGUtYWxpYXNlc1wiKTtcblxudmFyIGZzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbGliL25vZGUvZnNcIikpO1xuXG5leHBvcnRzLmZzID0gZnM7XG5cbnZhciBfYnVmZmVyVXRpbHMgPSByZXF1aXJlKFwiLi9saWIvYmluYXJ5LXV0aWxzL2J1ZmZlci11dGlsc1wiKTtcblxudmFyIF9qc29uTG9hZGVyID0gcmVxdWlyZShcIi4vanNvbi1sb2FkZXJcIik7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOyB9KShub2RlSW50ZXJvcCk7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqLCBub2RlSW50ZXJvcCkgeyBpZiAoIW5vZGVJbnRlcm9wICYmIG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuX3R5cGVjaGVja0pTT05Mb2FkZXIgPSBleHBvcnRzLkpTT05Mb2FkZXIgPSB2b2lkIDA7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgVkVSU0lPTiA9IHR5cGVvZiBcIjMuMC45XCIgIT09ICd1bmRlZmluZWQnID8gXCIzLjAuOVwiIDogJ2xhdGVzdCc7XG52YXIgSlNPTkxvYWRlciA9IHtcbiAgbmFtZTogJ0pTT04nLFxuICBpZDogJ2pzb24nLFxuICBtb2R1bGU6ICdqc29uJyxcbiAgdmVyc2lvbjogVkVSU0lPTixcbiAgZXh0ZW5zaW9uczogWydqc29uJywgJ2dlb2pzb24nXSxcbiAgbWltZVR5cGVzOiBbJ2FwcGxpY2F0aW9uL2pzb24nXSxcbiAgY2F0ZWdvcnk6ICdqc29uJyxcbiAgdGV4dDogdHJ1ZSxcbiAgcGFyc2VUZXh0U3luYzogcGFyc2VUZXh0U3luYyxcbiAgcGFyc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3BhcnNlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoYXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHBhcnNlVGV4dFN5bmMobmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGFycmF5QnVmZmVyKSkpO1xuXG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBwYXJzZShfeCkge1xuICAgICAgcmV0dXJuIF9wYXJzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZTtcbiAgfSgpLFxuICBvcHRpb25zOiB7fVxufTtcbmV4cG9ydHMuSlNPTkxvYWRlciA9IEpTT05Mb2FkZXI7XG5cbmZ1bmN0aW9uIHBhcnNlVGV4dFN5bmModGV4dCkge1xuICByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KTtcbn1cblxudmFyIF90eXBlY2hlY2tKU09OTG9hZGVyID0gSlNPTkxvYWRlcjtcbmV4cG9ydHMuX3R5cGVjaGVja0pTT05Mb2FkZXIgPSBfdHlwZWNoZWNrSlNPTkxvYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpzb24tbG9hZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxudmFyIF90eXBlb2YzID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy50b0FycmF5QnVmZmVyID0gdG9BcnJheUJ1ZmZlcjtcbmV4cG9ydHMuY29tcGFyZUFycmF5QnVmZmVycyA9IGNvbXBhcmVBcnJheUJ1ZmZlcnM7XG5leHBvcnRzLmNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzID0gY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnM7XG5leHBvcnRzLmNvbmNhdGVuYXRlVHlwZWRBcnJheXMgPSBjb25jYXRlbmF0ZVR5cGVkQXJyYXlzO1xuZXhwb3J0cy5zbGljZUFycmF5QnVmZmVyID0gc2xpY2VBcnJheUJ1ZmZlcjtcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG52YXIgbm9kZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuLi9ub2RlL2J1ZmZlci11dGlscy5ub2RlXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7IH0pKG5vZGVJbnRlcm9wKTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7IGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mMyhvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiB0b0FycmF5QnVmZmVyKGRhdGEpIHtcbiAgaWYgKG5vZGUudG9BcnJheUJ1ZmZlcikge1xuICAgIGRhdGEgPSBub2RlLnRvQXJyYXlCdWZmZXIoZGF0YSk7XG4gIH1cblxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIHZhciB0ZXh0ID0gZGF0YTtcbiAgICB2YXIgdWludDhBcnJheSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh0ZXh0KTtcbiAgICByZXR1cm4gdWludDhBcnJheS5idWZmZXI7XG4gIH1cblxuICBpZiAoZGF0YSAmJiAoMCwgX3R5cGVvZjIuZGVmYXVsdCkoZGF0YSkgPT09ICdvYmplY3QnICYmIGRhdGEuX3RvQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZGF0YS5fdG9BcnJheUJ1ZmZlcigpO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCd0b0FycmF5QnVmZmVyJyk7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVBcnJheUJ1ZmZlcnMoYXJyYXlCdWZmZXIxLCBhcnJheUJ1ZmZlcjIsIGJ5dGVMZW5ndGgpIHtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfHwgYXJyYXlCdWZmZXIxLmJ5dGVMZW5ndGg7XG5cbiAgaWYgKGFycmF5QnVmZmVyMS5ieXRlTGVuZ3RoIDwgYnl0ZUxlbmd0aCB8fCBhcnJheUJ1ZmZlcjIuYnl0ZUxlbmd0aCA8IGJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgYXJyYXkxID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIxKTtcbiAgdmFyIGFycmF5MiA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyMik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheTEubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzb3VyY2VzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHNvdXJjZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB2YXIgc291cmNlQXJyYXlzID0gc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZTIpIHtcbiAgICByZXR1cm4gc291cmNlMiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gbmV3IFVpbnQ4QXJyYXkoc291cmNlMikgOiBzb3VyY2UyO1xuICB9KTtcbiAgdmFyIGJ5dGVMZW5ndGggPSBzb3VyY2VBcnJheXMucmVkdWNlKGZ1bmN0aW9uIChsZW5ndGgsIHR5cGVkQXJyYXkpIHtcbiAgICByZXR1cm4gbGVuZ3RoICsgdHlwZWRBcnJheS5ieXRlTGVuZ3RoO1xuICB9LCAwKTtcbiAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGJ5dGVMZW5ndGgpO1xuICB2YXIgb2Zmc2V0ID0gMDtcblxuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoc291cmNlQXJyYXlzKSxcbiAgICAgIF9zdGVwO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBzb3VyY2VBcnJheSA9IF9zdGVwLnZhbHVlO1xuICAgICAgcmVzdWx0LnNldChzb3VyY2VBcnJheSwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSBzb3VyY2VBcnJheS5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdC5idWZmZXI7XG59XG5cbmZ1bmN0aW9uIGNvbmNhdGVuYXRlVHlwZWRBcnJheXMoKSB7XG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZWRBcnJheXMgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICB0eXBlZEFycmF5c1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG5cbiAgdmFyIGFycmF5cyA9IHR5cGVkQXJyYXlzO1xuICB2YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gYXJyYXlzICYmIGFycmF5cy5sZW5ndGggPiAxICYmIGFycmF5c1swXS5jb25zdHJ1Y3RvciB8fCBudWxsO1xuXG4gIGlmICghVHlwZWRBcnJheUNvbnN0cnVjdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcImNvbmNhdGVuYXRlVHlwZWRBcnJheXNcIiAtIGluY29ycmVjdCBxdWFudGl0eSBvZiBhcmd1bWVudHMgb3IgYXJndW1lbnRzIGhhdmUgaW5jb21wYXRpYmxlIGRhdGEgdHlwZXMnKTtcbiAgfVxuXG4gIHZhciBzdW1MZW5ndGggPSBhcnJheXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGFjYyArIHZhbHVlLmxlbmd0aDtcbiAgfSwgMCk7XG4gIHZhciByZXN1bHQgPSBuZXcgVHlwZWRBcnJheUNvbnN0cnVjdG9yKHN1bUxlbmd0aCk7XG4gIHZhciBvZmZzZXQgPSAwO1xuXG4gIGZvciAodmFyIF9pID0gMCwgX2FycmF5cyA9IGFycmF5czsgX2kgPCBfYXJyYXlzLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBhcnJheSA9IF9hcnJheXNbX2ldO1xuICAgIHJlc3VsdC5zZXQoYXJyYXksIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGFycmF5Lmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHNsaWNlQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgdmFyIHN1YkFycmF5ID0gYnl0ZUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpLnN1YmFycmF5KGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBieXRlTGVuZ3RoKSA6IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKS5zdWJhcnJheShieXRlT2Zmc2V0KTtcbiAgdmFyIGFycmF5Q29weSA9IG5ldyBVaW50OEFycmF5KHN1YkFycmF5KTtcbiAgcmV0dXJuIGFycmF5Q29weS5idWZmZXI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS1idWZmZXItdXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNvcHlQYWRkZWRBcnJheUJ1ZmZlclRvRGF0YVZpZXcgPSBjb3B5UGFkZGVkQXJyYXlCdWZmZXJUb0RhdGFWaWV3O1xuZXhwb3J0cy5jb3B5UGFkZGVkU3RyaW5nVG9EYXRhVmlldyA9IGNvcHlQYWRkZWRTdHJpbmdUb0RhdGFWaWV3O1xuXG52YXIgX21lbW9yeUNvcHlVdGlscyA9IHJlcXVpcmUoXCIuL21lbW9yeS1jb3B5LXV0aWxzXCIpO1xuXG5mdW5jdGlvbiBjb3B5UGFkZGVkQXJyYXlCdWZmZXJUb0RhdGFWaWV3KGRhdGFWaWV3LCBieXRlT2Zmc2V0LCBzb3VyY2VCdWZmZXIsIHBhZGRpbmcpIHtcbiAgdmFyIHBhZGRlZExlbmd0aCA9ICgwLCBfbWVtb3J5Q29weVV0aWxzLnBhZFRvTkJ5dGVzKShzb3VyY2VCdWZmZXIuYnl0ZUxlbmd0aCwgcGFkZGluZyk7XG4gIHZhciBwYWRMZW5ndGggPSBwYWRkZWRMZW5ndGggLSBzb3VyY2VCdWZmZXIuYnl0ZUxlbmd0aDtcblxuICBpZiAoZGF0YVZpZXcpIHtcbiAgICB2YXIgdGFyZ2V0QXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhVmlldy5idWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQgKyBieXRlT2Zmc2V0LCBzb3VyY2VCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgdmFyIHNvdXJjZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoc291cmNlQnVmZmVyKTtcbiAgICB0YXJnZXRBcnJheS5zZXQoc291cmNlQXJyYXkpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWRMZW5ndGg7ICsraSkge1xuICAgICAgZGF0YVZpZXcuc2V0VWludDgoYnl0ZU9mZnNldCArIHNvdXJjZUJ1ZmZlci5ieXRlTGVuZ3RoICsgaSwgMHgyMCk7XG4gICAgfVxuICB9XG5cbiAgYnl0ZU9mZnNldCArPSBwYWRkZWRMZW5ndGg7XG4gIHJldHVybiBieXRlT2Zmc2V0O1xufVxuXG5mdW5jdGlvbiBjb3B5UGFkZGVkU3RyaW5nVG9EYXRhVmlldyhkYXRhVmlldywgYnl0ZU9mZnNldCwgc3RyaW5nLCBwYWRkaW5nKSB7XG4gIHZhciB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICB2YXIgc3RyaW5nQnVmZmVyID0gdGV4dEVuY29kZXIuZW5jb2RlKHN0cmluZyk7XG4gIGJ5dGVPZmZzZXQgPSBjb3B5UGFkZGVkQXJyYXlCdWZmZXJUb0RhdGFWaWV3KGRhdGFWaWV3LCBieXRlT2Zmc2V0LCBzdHJpbmdCdWZmZXIsIHBhZGRpbmcpO1xuICByZXR1cm4gYnl0ZU9mZnNldDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpbmFyeS1jb3B5LXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxudmFyIF90eXBlb2YzID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5pc0J1ZmZlciA9IGlzQnVmZmVyO1xuZXhwb3J0cy50b0J1ZmZlciA9IHRvQnVmZmVyO1xuZXhwb3J0cy5idWZmZXJUb0FycmF5QnVmZmVyID0gYnVmZmVyVG9BcnJheUJ1ZmZlcjtcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG52YXIgbm9kZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuLi9ub2RlL2J1ZmZlci11dGlscy5ub2RlXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7IH0pKG5vZGVJbnRlcm9wKTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7IGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mMyhvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gaXNCdWZmZXIodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICYmICgwLCBfdHlwZW9mMi5kZWZhdWx0KSh2YWx1ZSkgPT09ICdvYmplY3QnICYmIHZhbHVlLmlzQnVmZmVyO1xufVxuXG5mdW5jdGlvbiB0b0J1ZmZlcihkYXRhKSB7XG4gIHJldHVybiBub2RlLnRvQnVmZmVyID8gbm9kZS50b0J1ZmZlcihkYXRhKSA6IGRhdGE7XG59XG5cbmZ1bmN0aW9uIGJ1ZmZlclRvQXJyYXlCdWZmZXIoZGF0YSkge1xuICBpZiAobm9kZS50b0FycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIG5vZGUudG9BcnJheUJ1ZmZlcihkYXRhKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVmZmVyLXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5wYWRTdHJpbmdUb0J5dGVBbGlnbm1lbnQgPSBwYWRTdHJpbmdUb0J5dGVBbGlnbm1lbnQ7XG5leHBvcnRzLmNvcHlTdHJpbmdUb0RhdGFWaWV3ID0gY29weVN0cmluZ1RvRGF0YVZpZXc7XG5leHBvcnRzLmNvcHlCaW5hcnlUb0RhdGFWaWV3ID0gY29weUJpbmFyeVRvRGF0YVZpZXc7XG5cbmZ1bmN0aW9uIHBhZFN0cmluZ1RvQnl0ZUFsaWdubWVudChzdHJpbmcsIGJ5dGVBbGlnbm1lbnQpIHtcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gIHZhciBwYWRkZWRMZW5ndGggPSBNYXRoLmNlaWwobGVuZ3RoIC8gYnl0ZUFsaWdubWVudCkgKiBieXRlQWxpZ25tZW50O1xuICB2YXIgcGFkZGluZyA9IHBhZGRlZExlbmd0aCAtIGxlbmd0aDtcbiAgdmFyIHdoaXRlc3BhY2UgPSAnJztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhZGRpbmc7ICsraSkge1xuICAgIHdoaXRlc3BhY2UgKz0gJyAnO1xuICB9XG5cbiAgcmV0dXJuIHN0cmluZyArIHdoaXRlc3BhY2U7XG59XG5cbmZ1bmN0aW9uIGNvcHlTdHJpbmdUb0RhdGFWaWV3KGRhdGFWaWV3LCBieXRlT2Zmc2V0LCBzdHJpbmcsIGJ5dGVMZW5ndGgpIHtcbiAgaWYgKGRhdGFWaWV3KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlTGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGFWaWV3LnNldFVpbnQ4KGJ5dGVPZmZzZXQgKyBpLCBzdHJpbmcuY2hhckNvZGVBdChpKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVPZmZzZXQgKyBieXRlTGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBjb3B5QmluYXJ5VG9EYXRhVmlldyhkYXRhVmlldywgYnl0ZU9mZnNldCwgYmluYXJ5LCBieXRlTGVuZ3RoKSB7XG4gIGlmIChkYXRhVmlldykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhVmlldy5zZXRVaW50OChieXRlT2Zmc2V0ICsgaSwgYmluYXJ5W2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZU9mZnNldCArIGJ5dGVMZW5ndGg7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbmNvZGUtdXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldEZpcnN0Q2hhcmFjdGVycyA9IGdldEZpcnN0Q2hhcmFjdGVycztcbmV4cG9ydHMuZ2V0TWFnaWNTdHJpbmcgPSBnZXRNYWdpY1N0cmluZztcblxuZnVuY3Rpb24gZ2V0Rmlyc3RDaGFyYWN0ZXJzKGRhdGEpIHtcbiAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogNTtcblxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRhdGEuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICByZXR1cm4gZ2V0TWFnaWNTdHJpbmcoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgYnl0ZU9mZnNldCA9IDA7XG4gICAgcmV0dXJuIGdldE1hZ2ljU3RyaW5nKGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldE1hZ2ljU3RyaW5nKGFycmF5QnVmZmVyLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGggPD0gYnl0ZU9mZnNldCArIGxlbmd0aCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG4gIHZhciBtYWdpYyA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBtYWdpYyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFWaWV3LmdldFVpbnQ4KGJ5dGVPZmZzZXQgKyBpKSk7XG4gIH1cblxuICByZXR1cm4gbWFnaWM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtZmlyc3QtY2hhcmFjdGVycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucGFkVG9OQnl0ZXMgPSBwYWRUb05CeXRlcztcbmV4cG9ydHMuY29weUFycmF5QnVmZmVyID0gY29weUFycmF5QnVmZmVyO1xuZXhwb3J0cy5jb3B5VG9BcnJheSA9IGNvcHlUb0FycmF5O1xuXG52YXIgX2Fzc2VydCA9IHJlcXVpcmUoXCIuLi9lbnYtdXRpbHMvYXNzZXJ0XCIpO1xuXG5mdW5jdGlvbiBwYWRUb05CeXRlcyhieXRlTGVuZ3RoLCBwYWRkaW5nKSB7XG4gICgwLCBfYXNzZXJ0LmFzc2VydCkoYnl0ZUxlbmd0aCA+PSAwKTtcbiAgKDAsIF9hc3NlcnQuYXNzZXJ0KShwYWRkaW5nID4gMCk7XG4gIHJldHVybiBieXRlTGVuZ3RoICsgKHBhZGRpbmcgLSAxKSAmIH4ocGFkZGluZyAtIDEpO1xufVxuXG5mdW5jdGlvbiBjb3B5QXJyYXlCdWZmZXIodGFyZ2V0QnVmZmVyLCBzb3VyY2VCdWZmZXIsIGJ5dGVPZmZzZXQpIHtcbiAgdmFyIGJ5dGVMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHNvdXJjZUJ1ZmZlci5ieXRlTGVuZ3RoO1xuICB2YXIgdGFyZ2V0QXJyYXkgPSBuZXcgVWludDhBcnJheSh0YXJnZXRCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICB2YXIgc291cmNlQXJyYXkgPSBuZXcgVWludDhBcnJheShzb3VyY2VCdWZmZXIpO1xuICB0YXJnZXRBcnJheS5zZXQoc291cmNlQXJyYXkpO1xuICByZXR1cm4gdGFyZ2V0QnVmZmVyO1xufVxuXG5mdW5jdGlvbiBjb3B5VG9BcnJheShzb3VyY2UsIHRhcmdldCwgdGFyZ2V0T2Zmc2V0KSB7XG4gIHZhciBzb3VyY2VBcnJheTtcblxuICBpZiAoc291cmNlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICBzb3VyY2VBcnJheSA9IG5ldyBVaW50OEFycmF5KHNvdXJjZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNyY0J5dGVPZmZzZXQgPSBzb3VyY2UuYnl0ZU9mZnNldDtcbiAgICB2YXIgc3JjQnl0ZUxlbmd0aCA9IHNvdXJjZS5ieXRlTGVuZ3RoO1xuICAgIHNvdXJjZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoc291cmNlLmJ1ZmZlciB8fCBzb3VyY2UuYXJyYXlCdWZmZXIsIHNyY0J5dGVPZmZzZXQsIHNyY0J5dGVMZW5ndGgpO1xuICB9XG5cbiAgdGFyZ2V0LnNldChzb3VyY2VBcnJheSwgdGFyZ2V0T2Zmc2V0KTtcbiAgcmV0dXJuIHRhcmdldE9mZnNldCArIHBhZFRvTkJ5dGVzKHNvdXJjZUFycmF5LmJ5dGVMZW5ndGgsIDQpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVtb3J5LWNvcHktdXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcblxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdsb2FkZXIgYXNzZXJ0aW9uIGZhaWxlZC4nKTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzZXJ0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubm9kZVZlcnNpb24gPSBleHBvcnRzLmlzV29ya2VyID0gZXhwb3J0cy5pc0Jyb3dzZXIgPSBleHBvcnRzLmRvY3VtZW50ID0gZXhwb3J0cy5nbG9iYWwgPSBleHBvcnRzLndpbmRvdyA9IGV4cG9ydHMuc2VsZiA9IHZvaWQgMDtcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG52YXIgZ2xvYmFscyA9IHtcbiAgc2VsZjogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYsXG4gIHdpbmRvdzogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LFxuICBnbG9iYWw6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbCxcbiAgZG9jdW1lbnQ6IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnRcbn07XG52YXIgc2VsZl8gPSBnbG9iYWxzLnNlbGYgfHwgZ2xvYmFscy53aW5kb3cgfHwgZ2xvYmFscy5nbG9iYWwgfHwge307XG5leHBvcnRzLnNlbGYgPSBzZWxmXztcbnZhciB3aW5kb3dfID0gZ2xvYmFscy53aW5kb3cgfHwgZ2xvYmFscy5zZWxmIHx8IGdsb2JhbHMuZ2xvYmFsIHx8IHt9O1xuZXhwb3J0cy53aW5kb3cgPSB3aW5kb3dfO1xudmFyIGdsb2JhbF8gPSBnbG9iYWxzLmdsb2JhbCB8fCBnbG9iYWxzLnNlbGYgfHwgZ2xvYmFscy53aW5kb3cgfHwge307XG5leHBvcnRzLmdsb2JhbCA9IGdsb2JhbF87XG52YXIgZG9jdW1lbnRfID0gZ2xvYmFscy5kb2N1bWVudCB8fCB7fTtcbmV4cG9ydHMuZG9jdW1lbnQgPSBkb2N1bWVudF87XG52YXIgaXNCcm93c2VyID0gKHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMi5kZWZhdWx0KShwcm9jZXNzKSkgIT09ICdvYmplY3QnIHx8IFN0cmluZyhwcm9jZXNzKSAhPT0gJ1tvYmplY3QgcHJvY2Vzc10nIHx8IHByb2Nlc3MuYnJvd3NlcjtcbmV4cG9ydHMuaXNCcm93c2VyID0gaXNCcm93c2VyO1xudmFyIGlzV29ya2VyID0gdHlwZW9mIGltcG9ydFNjcmlwdHMgPT09ICdmdW5jdGlvbic7XG5leHBvcnRzLmlzV29ya2VyID0gaXNXb3JrZXI7XG52YXIgbWF0Y2hlcyA9IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnZlcnNpb24gJiYgL3YoWzAtOV0qKS8uZXhlYyhwcm9jZXNzLnZlcnNpb24pO1xudmFyIG5vZGVWZXJzaW9uID0gbWF0Y2hlcyAmJiBwYXJzZUZsb2F0KG1hdGNoZXNbMV0pIHx8IDA7XG5leHBvcnRzLm5vZGVWZXJzaW9uID0gbm9kZVZlcnNpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nbG9iYWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZm9yRWFjaCA9IGZvckVhY2g7XG5leHBvcnRzLmNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzQXN5bmMgPSBjb25jYXRlbmF0ZUFycmF5QnVmZmVyc0FzeW5jO1xuZXhwb3J0cy5jb25jYXRlbmF0ZVN0cmluZ3NBc3luYyA9IGNvbmNhdGVuYXRlU3RyaW5nc0FzeW5jO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY0l0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNJdGVyYXRvclwiKSk7XG5cbnZhciBfYXJyYXlCdWZmZXJVdGlscyA9IHJlcXVpcmUoXCIuLi9iaW5hcnktdXRpbHMvYXJyYXktYnVmZmVyLXV0aWxzXCIpO1xuXG5mdW5jdGlvbiBmb3JFYWNoKF94LCBfeDIpIHtcbiAgcmV0dXJuIF9mb3JFYWNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9mb3JFYWNoKCkge1xuICBfZm9yRWFjaCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKGl0ZXJhdG9yLCB2aXNpdG9yKSB7XG4gICAgdmFyIF95aWVsZCRpdGVyYXRvciRuZXh0LCBkb25lLCB2YWx1ZSwgY2FuY2VsO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoIXRydWUpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3IubmV4dCgpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgX3lpZWxkJGl0ZXJhdG9yJG5leHQgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgZG9uZSA9IF95aWVsZCRpdGVyYXRvciRuZXh0LmRvbmU7XG4gICAgICAgICAgICB2YWx1ZSA9IF95aWVsZCRpdGVyYXRvciRuZXh0LnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIik7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBjYW5jZWwgPSB2aXNpdG9yKHZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKCFjYW5jZWwpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9mb3JFYWNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzQXN5bmMoX3gzKSB7XG4gIHJldHVybiBfY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnNBc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnNBc3luYygpIHtcbiAgX2NvbmNhdGVuYXRlQXJyYXlCdWZmZXJzQXN5bmMgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoYXN5bmNJdGVyYXRvcikge1xuICAgIHZhciBhcnJheUJ1ZmZlcnMsIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24sIF9kaWRJdGVyYXRvckVycm9yLCBfaXRlcmF0b3JFcnJvciwgX2l0ZXJhdG9yLCBfc3RlcCwgX3ZhbHVlLCBjaHVuaztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGFycmF5QnVmZmVycyA9IFtdO1xuICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAzO1xuICAgICAgICAgICAgX2l0ZXJhdG9yID0gKDAsIF9hc3luY0l0ZXJhdG9yMi5kZWZhdWx0KShhc3luY0l0ZXJhdG9yKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNztcbiAgICAgICAgICAgIHJldHVybiBfaXRlcmF0b3IubmV4dCgpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgX3N0ZXAgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSBfc3RlcC5kb25lO1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMTtcbiAgICAgICAgICAgIHJldHVybiBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBfdmFsdWUgPSBfY29udGV4dDIuc2VudDtcblxuICAgICAgICAgICAgaWYgKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24pIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNodW5rID0gX3ZhbHVlO1xuICAgICAgICAgICAgYXJyYXlCdWZmZXJzLnB1c2goY2h1bmspO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA1O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyNDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMjA7XG4gICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDJbXCJjYXRjaFwiXSgzKTtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gX2NvbnRleHQyLnQwO1xuXG4gICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMjQ7XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDI1O1xuXG4gICAgICAgICAgICBpZiAoISghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI5O1xuICAgICAgICAgICAgcmV0dXJuIF9pdGVyYXRvci5yZXR1cm4oKTtcblxuICAgICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDI5O1xuXG4gICAgICAgICAgICBpZiAoIV9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMzI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcblxuICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmZpbmlzaCgyOSk7XG5cbiAgICAgICAgICBjYXNlIDMzOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5maW5pc2goMjQpO1xuXG4gICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIF9hcnJheUJ1ZmZlclV0aWxzLmNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzLmFwcGx5KHZvaWQgMCwgYXJyYXlCdWZmZXJzKSk7XG5cbiAgICAgICAgICBjYXNlIDM1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIsIG51bGwsIFtbMywgMjAsIDI0LCAzNF0sIFsyNSwsIDI5LCAzM11dKTtcbiAgfSkpO1xuICByZXR1cm4gX2NvbmNhdGVuYXRlQXJyYXlCdWZmZXJzQXN5bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gY29uY2F0ZW5hdGVTdHJpbmdzQXN5bmMoX3g0KSB7XG4gIHJldHVybiBfY29uY2F0ZW5hdGVTdHJpbmdzQXN5bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2NvbmNhdGVuYXRlU3RyaW5nc0FzeW5jKCkge1xuICBfY29uY2F0ZW5hdGVTdHJpbmdzQXN5bmMgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoYXN5bmNJdGVyYXRvcikge1xuICAgIHZhciBzdHJpbmdzLCBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiwgX2RpZEl0ZXJhdG9yRXJyb3IyLCBfaXRlcmF0b3JFcnJvcjIsIF9pdGVyYXRvcjIsIF9zdGVwMiwgX3ZhbHVlMiwgY2h1bms7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBzdHJpbmdzID0gW107XG4gICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMztcbiAgICAgICAgICAgIF9pdGVyYXRvcjIgPSAoMCwgX2FzeW5jSXRlcmF0b3IyLmRlZmF1bHQpKGFzeW5jSXRlcmF0b3IpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA3O1xuICAgICAgICAgICAgcmV0dXJuIF9pdGVyYXRvcjIubmV4dCgpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgX3N0ZXAyID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IF9zdGVwMi5kb25lO1xuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxMTtcbiAgICAgICAgICAgIHJldHVybiBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgX3ZhbHVlMiA9IF9jb250ZXh0My5zZW50O1xuXG4gICAgICAgICAgICBpZiAoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNodW5rID0gX3ZhbHVlMjtcbiAgICAgICAgICAgIHN0cmluZ3MucHVzaChjaHVuayk7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA1O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAyNDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMjA7XG4gICAgICAgICAgICBfY29udGV4dDMudDAgPSBfY29udGV4dDNbXCJjYXRjaFwiXSgzKTtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjIgPSBfY29udGV4dDMudDA7XG5cbiAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAyNDtcbiAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMjU7XG5cbiAgICAgICAgICAgIGlmICghKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybiAhPSBudWxsKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDI5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAyOTtcbiAgICAgICAgICAgIHJldHVybiBfaXRlcmF0b3IyLnJldHVybigpO1xuXG4gICAgICAgICAgY2FzZSAyOTpcbiAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMjk7XG5cbiAgICAgICAgICAgIGlmICghX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMzI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG5cbiAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5maW5pc2goMjkpO1xuXG4gICAgICAgICAgY2FzZSAzMzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuZmluaXNoKDI0KTtcblxuICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBzdHJpbmdzLmpvaW4oJycpKTtcblxuICAgICAgICAgIGNhc2UgMzU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMywgbnVsbCwgW1szLCAyMCwgMjQsIDM0XSwgWzI1LCwgMjksIDMzXV0pO1xuICB9KSk7XG4gIHJldHVybiBfY29uY2F0ZW5hdGVTdHJpbmdzQXN5bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzeW5jLWl0ZXJhdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm1ha2VUZXh0RGVjb2Rlckl0ZXJhdG9yID0gbWFrZVRleHREZWNvZGVySXRlcmF0b3I7XG5leHBvcnRzLm1ha2VUZXh0RW5jb2Rlckl0ZXJhdG9yID0gbWFrZVRleHRFbmNvZGVySXRlcmF0b3I7XG5leHBvcnRzLm1ha2VMaW5lSXRlcmF0b3IgPSBtYWtlTGluZUl0ZXJhdG9yO1xuZXhwb3J0cy5tYWtlTnVtYmVyZWRMaW5lSXRlcmF0b3IgPSBtYWtlTnVtYmVyZWRMaW5lSXRlcmF0b3I7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXdhaXRBc3luY0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2F3YWl0QXN5bmNHZW5lcmF0b3JcIikpO1xuXG52YXIgX3dyYXBBc3luY0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3dyYXBBc3luY0dlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNJdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jSXRlcmF0b3JcIikpO1xuXG5mdW5jdGlvbiBtYWtlVGV4dERlY29kZXJJdGVyYXRvcihfeCkge1xuICByZXR1cm4gX21ha2VUZXh0RGVjb2Rlckl0ZXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9tYWtlVGV4dERlY29kZXJJdGVyYXRvcigpIHtcbiAgX21ha2VUZXh0RGVjb2Rlckl0ZXJhdG9yID0gKDAsIF93cmFwQXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZShhcnJheUJ1ZmZlckl0ZXJhdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMsXG4gICAgICAgIHRleHREZWNvZGVyLFxuICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uLFxuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcixcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IsXG4gICAgICAgIF9pdGVyYXRvcixcbiAgICAgICAgX3N0ZXAsXG4gICAgICAgIF92YWx1ZSxcbiAgICAgICAgYXJyYXlCdWZmZXIsXG4gICAgICAgIF9hcmdzID0gYXJndW1lbnRzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBvcHRpb25zID0gX2FyZ3MubGVuZ3RoID4gMSAmJiBfYXJnc1sxXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3NbMV0gOiB7fTtcbiAgICAgICAgICAgIHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gNDtcbiAgICAgICAgICAgIF9pdGVyYXRvciA9ICgwLCBfYXN5bmNJdGVyYXRvcjIuZGVmYXVsdCkoYXJyYXlCdWZmZXJJdGVyYXRvcik7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gODtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2F3YWl0QXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKF9pdGVyYXRvci5uZXh0KCkpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgX3N0ZXAgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IF9zdGVwLmRvbmU7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTI7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9hd2FpdEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShfc3RlcC52YWx1ZSk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgX3ZhbHVlID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgaWYgKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24pIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXJyYXlCdWZmZXIgPSBfdmFsdWU7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTc7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGFycmF5QnVmZmVyID09PSAnc3RyaW5nJyA/IGFycmF5QnVmZmVyIDogdGV4dERlY29kZXIuZGVjb2RlKGFycmF5QnVmZmVyLCB7XG4gICAgICAgICAgICAgIHN0cmVhbTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyNjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyMjtcbiAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSg0KTtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gX2NvbnRleHQudDA7XG5cbiAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDI2O1xuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDI3O1xuXG4gICAgICAgICAgICBpZiAoISghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzMTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2F3YWl0QXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKF9pdGVyYXRvci5yZXR1cm4oKSk7XG5cbiAgICAgICAgICBjYXNlIDMxOlxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDMxO1xuXG4gICAgICAgICAgICBpZiAoIV9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuXG4gICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5maW5pc2goMzEpO1xuXG4gICAgICAgICAgY2FzZSAzNTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5maW5pc2goMjYpO1xuXG4gICAgICAgICAgY2FzZSAzNjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSwgbnVsbCwgW1s0LCAyMiwgMjYsIDM2XSwgWzI3LCwgMzEsIDM1XV0pO1xuICB9KSk7XG4gIHJldHVybiBfbWFrZVRleHREZWNvZGVySXRlcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gbWFrZVRleHRFbmNvZGVySXRlcmF0b3IoX3gyKSB7XG4gIHJldHVybiBfbWFrZVRleHRFbmNvZGVySXRlcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX21ha2VUZXh0RW5jb2Rlckl0ZXJhdG9yKCkge1xuICBfbWFrZVRleHRFbmNvZGVySXRlcmF0b3IgPSAoMCwgX3dyYXBBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMih0ZXh0SXRlcmF0b3IpIHtcbiAgICB2YXIgdGV4dEVuY29kZXIsIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yLCBfZGlkSXRlcmF0b3JFcnJvcjIsIF9pdGVyYXRvckVycm9yMiwgX2l0ZXJhdG9yMiwgX3N0ZXAyLCBfdmFsdWUyLCB0ZXh0O1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlO1xuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAzO1xuICAgICAgICAgICAgX2l0ZXJhdG9yMiA9ICgwLCBfYXN5bmNJdGVyYXRvcjIuZGVmYXVsdCkodGV4dEl0ZXJhdG9yKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNztcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2F3YWl0QXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKF9pdGVyYXRvcjIubmV4dCgpKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIF9zdGVwMiA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSBfc3RlcDIuZG9uZTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTE7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9hd2FpdEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShfc3RlcDIudmFsdWUpO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIF92YWx1ZTIgPSBfY29udGV4dDIuc2VudDtcblxuICAgICAgICAgICAgaWYgKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0ZXh0ID0gX3ZhbHVlMjtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTY7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHRleHQgPT09ICdzdHJpbmcnID8gdGV4dEVuY29kZXIuZW5jb2RlKHRleHQpIDogdGV4dDtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI1O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAyMTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IF9jb250ZXh0MltcImNhdGNoXCJdKDMpO1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICAgICAgICAgIF9pdGVyYXRvckVycm9yMiA9IF9jb250ZXh0Mi50MDtcblxuICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDI1O1xuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAyNjtcblxuICAgICAgICAgICAgaWYgKCEoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuICE9IG51bGwpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMzA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDMwO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfYXdhaXRBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoX2l0ZXJhdG9yMi5yZXR1cm4oKSk7XG5cbiAgICAgICAgICBjYXNlIDMwOlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAzMDtcblxuICAgICAgICAgICAgaWYgKCFfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAzMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjtcblxuICAgICAgICAgIGNhc2UgMzM6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmZpbmlzaCgzMCk7XG5cbiAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5maW5pc2goMjUpO1xuXG4gICAgICAgICAgY2FzZSAzNTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyLCBudWxsLCBbWzMsIDIxLCAyNSwgMzVdLCBbMjYsLCAzMCwgMzRdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9tYWtlVGV4dEVuY29kZXJJdGVyYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBtYWtlTGluZUl0ZXJhdG9yKF94Mykge1xuICByZXR1cm4gX21ha2VMaW5lSXRlcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX21ha2VMaW5lSXRlcmF0b3IoKSB7XG4gIF9tYWtlTGluZUl0ZXJhdG9yID0gKDAsIF93cmFwQXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTModGV4dEl0ZXJhdG9yKSB7XG4gICAgdmFyIHByZXZpb3VzLCBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMywgX2RpZEl0ZXJhdG9yRXJyb3IzLCBfaXRlcmF0b3JFcnJvcjMsIF9pdGVyYXRvcjMsIF9zdGVwMywgX3ZhbHVlMywgdGV4dENodW5rLCBlb2xJbmRleCwgbGluZTtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHByZXZpb3VzID0gJyc7XG4gICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWU7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjMgPSBmYWxzZTtcbiAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMztcbiAgICAgICAgICAgIF9pdGVyYXRvcjMgPSAoMCwgX2FzeW5jSXRlcmF0b3IyLmRlZmF1bHQpKHRleHRJdGVyYXRvcik7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDc7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9hd2FpdEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShfaXRlcmF0b3IzLm5leHQoKSk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBfc3RlcDMgPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gX3N0ZXAzLmRvbmU7XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDExO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfYXdhaXRBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoX3N0ZXAzLnZhbHVlKTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBfdmFsdWUzID0gX2NvbnRleHQzLnNlbnQ7XG5cbiAgICAgICAgICAgIGlmIChfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMykge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDI2O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGV4dENodW5rID0gX3ZhbHVlMztcbiAgICAgICAgICAgIHByZXZpb3VzICs9IHRleHRDaHVuaztcbiAgICAgICAgICAgIGVvbEluZGV4ID0gdm9pZCAwO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIGlmICghKChlb2xJbmRleCA9IHByZXZpb3VzLmluZGV4T2YoJ1xcbicpKSA+PSAwKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDIzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGluZSA9IHByZXZpb3VzLnNsaWNlKDAsIGVvbEluZGV4ICsgMSk7XG4gICAgICAgICAgICBwcmV2aW91cyA9IHByZXZpb3VzLnNsaWNlKGVvbEluZGV4ICsgMSk7XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDIxO1xuICAgICAgICAgICAgcmV0dXJuIGxpbmU7XG5cbiAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxNjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTtcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMzI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjg6XG4gICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDI4O1xuICAgICAgICAgICAgX2NvbnRleHQzLnQwID0gX2NvbnRleHQzW1wiY2F0Y2hcIl0oMyk7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjMgPSB0cnVlO1xuICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IzID0gX2NvbnRleHQzLnQwO1xuXG4gICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMzI7XG4gICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDMzO1xuXG4gICAgICAgICAgICBpZiAoISghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4gIT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAzNztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMzc7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9hd2FpdEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShfaXRlcmF0b3IzLnJldHVybigpKTtcblxuICAgICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDM3O1xuXG4gICAgICAgICAgICBpZiAoIV9kaWRJdGVyYXRvckVycm9yMykge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDQwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IzO1xuXG4gICAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuZmluaXNoKDM3KTtcblxuICAgICAgICAgIGNhc2UgNDE6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmZpbmlzaCgzMik7XG5cbiAgICAgICAgICBjYXNlIDQyOlxuICAgICAgICAgICAgaWYgKCEocHJldmlvdXMubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA0NTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNDU7XG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXM7XG5cbiAgICAgICAgICBjYXNlIDQ1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTMsIG51bGwsIFtbMywgMjgsIDMyLCA0Ml0sIFszMywsIDM3LCA0MV1dKTtcbiAgfSkpO1xuICByZXR1cm4gX21ha2VMaW5lSXRlcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gbWFrZU51bWJlcmVkTGluZUl0ZXJhdG9yKF94NCkge1xuICByZXR1cm4gX21ha2VOdW1iZXJlZExpbmVJdGVyYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfbWFrZU51bWJlcmVkTGluZUl0ZXJhdG9yKCkge1xuICBfbWFrZU51bWJlcmVkTGluZUl0ZXJhdG9yID0gKDAsIF93cmFwQXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQobGluZUl0ZXJhdG9yKSB7XG4gICAgdmFyIGNvdW50ZXIsIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240LCBfZGlkSXRlcmF0b3JFcnJvcjQsIF9pdGVyYXRvckVycm9yNCwgX2l0ZXJhdG9yNCwgX3N0ZXA0LCBfdmFsdWU0LCBsaW5lO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY291bnRlciA9IDE7XG4gICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWU7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjQgPSBmYWxzZTtcbiAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gMztcbiAgICAgICAgICAgIF9pdGVyYXRvcjQgPSAoMCwgX2FzeW5jSXRlcmF0b3IyLmRlZmF1bHQpKGxpbmVJdGVyYXRvcik7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDc7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9hd2FpdEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShfaXRlcmF0b3I0Lm5leHQoKSk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBfc3RlcDQgPSBfY29udGV4dDQuc2VudDtcbiAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gX3N0ZXA0LmRvbmU7XG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDExO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfYXdhaXRBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoX3N0ZXA0LnZhbHVlKTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBfdmFsdWU0ID0gX2NvbnRleHQ0LnNlbnQ7XG5cbiAgICAgICAgICAgIGlmIChfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCkge1xuICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDIwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGluZSA9IF92YWx1ZTQ7XG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDE2O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgY291bnRlcjogY291bnRlcixcbiAgICAgICAgICAgICAgbGluZTogbGluZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBjb3VudGVyKys7XG5cbiAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSB0cnVlO1xuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA1O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAyNjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gMjI7XG4gICAgICAgICAgICBfY29udGV4dDQudDAgPSBfY29udGV4dDRbXCJjYXRjaFwiXSgzKTtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yNCA9IHRydWU7XG4gICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjQgPSBfY29udGV4dDQudDA7XG5cbiAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgICAgX2NvbnRleHQ0LnByZXYgPSAyNjtcbiAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gMjc7XG5cbiAgICAgICAgICAgIGlmICghKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCAmJiBfaXRlcmF0b3I0LnJldHVybiAhPSBudWxsKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDMxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAzMTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2F3YWl0QXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKF9pdGVyYXRvcjQucmV0dXJuKCkpO1xuXG4gICAgICAgICAgY2FzZSAzMTpcbiAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gMzE7XG5cbiAgICAgICAgICAgIGlmICghX2RpZEl0ZXJhdG9yRXJyb3I0KSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMzQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjQ7XG5cbiAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5maW5pc2goMzEpO1xuXG4gICAgICAgICAgY2FzZSAzNTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuZmluaXNoKDI2KTtcblxuICAgICAgICAgIGNhc2UgMzY6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNCwgbnVsbCwgW1szLCAyMiwgMjYsIDM2XSwgWzI3LCwgMzEsIDM1XV0pO1xuICB9KSk7XG4gIHJldHVybiBfbWFrZU51bWJlcmVkTGluZUl0ZXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXh0LWl0ZXJhdG9ycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucGFyc2VKU09OID0gcGFyc2VKU09OO1xuXG52YXIgX2dldEZpcnN0Q2hhcmFjdGVycyA9IHJlcXVpcmUoXCIuLi9iaW5hcnktdXRpbHMvZ2V0LWZpcnN0LWNoYXJhY3RlcnNcIik7XG5cbmZ1bmN0aW9uIHBhcnNlSlNPTihzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdHJpbmcpO1xuICB9IGNhdGNoIChfKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIEpTT04gZnJvbSBkYXRhIHN0YXJ0aW5nIHdpdGggXFxcIlwiLmNvbmNhdCgoMCwgX2dldEZpcnN0Q2hhcmFjdGVycy5nZXRGaXJzdENoYXJhY3RlcnMpKHN0cmluZyksIFwiXFxcIlwiKSk7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlLWpzb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnNldFBhdGhQcmVmaXggPSBzZXRQYXRoUHJlZml4O1xuZXhwb3J0cy5nZXRQYXRoUHJlZml4ID0gZ2V0UGF0aFByZWZpeDtcbmV4cG9ydHMuYWRkQWxpYXNlcyA9IGFkZEFsaWFzZXM7XG5leHBvcnRzLnJlc29sdmVQYXRoID0gcmVzb2x2ZVBhdGg7XG52YXIgcGF0aFByZWZpeCA9ICcnO1xudmFyIGZpbGVBbGlhc2VzID0ge307XG5cbmZ1bmN0aW9uIHNldFBhdGhQcmVmaXgocHJlZml4KSB7XG4gIHBhdGhQcmVmaXggPSBwcmVmaXg7XG59XG5cbmZ1bmN0aW9uIGdldFBhdGhQcmVmaXgoKSB7XG4gIHJldHVybiBwYXRoUHJlZml4O1xufVxuXG5mdW5jdGlvbiBhZGRBbGlhc2VzKGFsaWFzZXMpIHtcbiAgT2JqZWN0LmFzc2lnbihmaWxlQWxpYXNlcywgYWxpYXNlcyk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVQYXRoKGZpbGVuYW1lKSB7XG4gIGZvciAodmFyIGFsaWFzIGluIGZpbGVBbGlhc2VzKSB7XG4gICAgaWYgKGZpbGVuYW1lLnN0YXJ0c1dpdGgoYWxpYXMpKSB7XG4gICAgICB2YXIgcmVwbGFjZW1lbnQgPSBmaWxlQWxpYXNlc1thbGlhc107XG4gICAgICBmaWxlbmFtZSA9IGZpbGVuYW1lLnJlcGxhY2UoYWxpYXMsIHJlcGxhY2VtZW50KTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWZpbGVuYW1lLnN0YXJ0c1dpdGgoJ2h0dHA6Ly8nKSAmJiAhZmlsZW5hbWUuc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSkge1xuICAgIGZpbGVuYW1lID0gXCJcIi5jb25jYXQocGF0aFByZWZpeCkuY29uY2F0KGZpbGVuYW1lKTtcbiAgfVxuXG4gIHJldHVybiBmaWxlbmFtZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbGUtYWxpYXNlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGlybmFtZSA9IGRpcm5hbWU7XG5leHBvcnRzLmpvaW4gPSBqb2luO1xuXG5mdW5jdGlvbiBkaXJuYW1lKHVybCkge1xuICB2YXIgc2xhc2hJbmRleCA9IHVybCAmJiB1cmwubGFzdEluZGV4T2YoJy8nKTtcbiAgcmV0dXJuIHNsYXNoSW5kZXggPj0gMCA/IHVybC5zdWJzdHIoMCwgc2xhc2hJbmRleCkgOiAnJztcbn1cblxuZnVuY3Rpb24gam9pbigpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBhcnRzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHBhcnRzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgdmFyIHNlcGFyYXRvciA9ICcvJztcbiAgcGFydHMgPSBwYXJ0cy5tYXAoZnVuY3Rpb24gKHBhcnQsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4KSB7XG4gICAgICBwYXJ0ID0gcGFydC5yZXBsYWNlKG5ldyBSZWdFeHAoXCJeXCIuY29uY2F0KHNlcGFyYXRvcikpLCAnJyk7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ICE9PSBwYXJ0cy5sZW5ndGggLSAxKSB7XG4gICAgICBwYXJ0ID0gcGFydC5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcIi5jb25jYXQoc2VwYXJhdG9yLCBcIiRcIikpLCAnJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnQ7XG4gIH0pO1xuICByZXR1cm4gcGFydHMuam9pbihzZXBhcmF0b3IpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfc3RhdHMgPSByZXF1aXJlKFwiQHByb2JlLmdsL3N0YXRzXCIpO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIFNUQVRfUVVFVUVEX1JFUVVFU1RTID0gJ1F1ZXVlZCBSZXF1ZXN0cyc7XG52YXIgU1RBVF9BQ1RJVkVfUkVRVUVTVFMgPSAnQWN0aXZlIFJlcXVlc3RzJztcbnZhciBTVEFUX0NBTkNFTExFRF9SRVFVRVNUUyA9ICdDYW5jZWxsZWQgUmVxdWVzdHMnO1xudmFyIFNUQVRfUVVFVUVEX1JFUVVFU1RTX0VWRVIgPSAnUXVldWVkIFJlcXVlc3RzIEV2ZXInO1xudmFyIFNUQVRfQUNUSVZFX1JFUVVFU1RTX0VWRVIgPSAnQWN0aXZlIFJlcXVlc3RzIEV2ZXInO1xudmFyIERFRkFVTFRfUFJPUFMgPSB7XG4gIGlkOiAncmVxdWVzdC1zY2hlZHVsZXInLFxuICB0aHJvdHRsZVJlcXVlc3RzOiB0cnVlLFxuICBtYXhSZXF1ZXN0czogNlxufTtcblxudmFyIFJlcXVlc3RTY2hlZHVsZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlcXVlc3RTY2hlZHVsZXIoKSB7XG4gICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBSZXF1ZXN0U2NoZWR1bGVyKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcInByb3BzXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJzdGF0c1wiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiYWN0aXZlUmVxdWVzdENvdW50XCIsIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwicmVxdWVzdFF1ZXVlXCIsIFtdKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcInJlcXVlc3RNYXBcIiwgbmV3IE1hcCgpKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcImRlZmVycmVkVXBkYXRlXCIsIG51bGwpO1xuICAgIHRoaXMucHJvcHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIERFRkFVTFRfUFJPUFMpLCBwcm9wcyk7XG4gICAgdGhpcy5zdGF0cyA9IG5ldyBfc3RhdHMuU3RhdHMoe1xuICAgICAgaWQ6IHRoaXMucHJvcHMuaWRcbiAgICB9KTtcbiAgICB0aGlzLnN0YXRzLmdldChTVEFUX1FVRVVFRF9SRVFVRVNUUyk7XG4gICAgdGhpcy5zdGF0cy5nZXQoU1RBVF9BQ1RJVkVfUkVRVUVTVFMpO1xuICAgIHRoaXMuc3RhdHMuZ2V0KFNUQVRfQ0FOQ0VMTEVEX1JFUVVFU1RTKTtcbiAgICB0aGlzLnN0YXRzLmdldChTVEFUX1FVRVVFRF9SRVFVRVNUU19FVkVSKTtcbiAgICB0aGlzLnN0YXRzLmdldChTVEFUX0FDVElWRV9SRVFVRVNUU19FVkVSKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKFJlcXVlc3RTY2hlZHVsZXIsIFt7XG4gICAga2V5OiBcInNjaGVkdWxlUmVxdWVzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY2hlZHVsZVJlcXVlc3QoaGFuZGxlKSB7XG4gICAgICB2YXIgZ2V0UHJpb3JpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9O1xuXG4gICAgICBpZiAoIXRoaXMucHJvcHMudGhyb3R0bGVSZXF1ZXN0cykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICBkb25lOiBmdW5jdGlvbiBkb25lKCkge31cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnJlcXVlc3RNYXAuaGFzKGhhbmRsZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdE1hcC5nZXQoaGFuZGxlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlcXVlc3QgPSB7XG4gICAgICAgIGhhbmRsZTogaGFuZGxlLFxuICAgICAgICBwcmlvcml0eTogMCxcbiAgICAgICAgZ2V0UHJpb3JpdHk6IGdldFByaW9yaXR5XG4gICAgICB9O1xuICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICByZXF1ZXN0LnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5yZXF1ZXN0UXVldWUucHVzaChyZXF1ZXN0KTtcbiAgICAgIHRoaXMucmVxdWVzdE1hcC5zZXQoaGFuZGxlLCBwcm9taXNlKTtcblxuICAgICAgdGhpcy5faXNzdWVOZXdSZXF1ZXN0cygpO1xuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2lzc3VlUmVxdWVzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNzdWVSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBoYW5kbGUgPSByZXF1ZXN0LmhhbmRsZSxcbiAgICAgICAgICByZXNvbHZlID0gcmVxdWVzdC5yZXNvbHZlO1xuICAgICAgdmFyIGlzRG9uZSA9IGZhbHNlO1xuXG4gICAgICB2YXIgZG9uZSA9IGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICAgIGlmICghaXNEb25lKSB7XG4gICAgICAgICAgaXNEb25lID0gdHJ1ZTtcblxuICAgICAgICAgIF90aGlzLnJlcXVlc3RNYXAuZGVsZXRlKGhhbmRsZSk7XG5cbiAgICAgICAgICBfdGhpcy5hY3RpdmVSZXF1ZXN0Q291bnQtLTtcblxuICAgICAgICAgIF90aGlzLl9pc3N1ZU5ld1JlcXVlc3RzKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYWN0aXZlUmVxdWVzdENvdW50Kys7XG4gICAgICByZXR1cm4gcmVzb2x2ZSA/IHJlc29sdmUoe1xuICAgICAgICBkb25lOiBkb25lXG4gICAgICB9KSA6IFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIGRvbmU6IGRvbmVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaXNzdWVOZXdSZXF1ZXN0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNzdWVOZXdSZXF1ZXN0cygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMuZGVmZXJyZWRVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5kZWZlcnJlZFVwZGF0ZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIuX2lzc3VlTmV3UmVxdWVzdHNBc3luYygpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2lzc3VlTmV3UmVxdWVzdHNBc3luY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNzdWVOZXdSZXF1ZXN0c0FzeW5jKCkge1xuICAgICAgdGhpcy5kZWZlcnJlZFVwZGF0ZSA9IG51bGw7XG4gICAgICB2YXIgZnJlZVNsb3RzID0gTWF0aC5tYXgodGhpcy5wcm9wcy5tYXhSZXF1ZXN0cyAtIHRoaXMuYWN0aXZlUmVxdWVzdENvdW50LCAwKTtcblxuICAgICAgaWYgKGZyZWVTbG90cyA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3VwZGF0ZUFsbFJlcXVlc3RzKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJlZVNsb3RzOyArK2kpIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSB0aGlzLnJlcXVlc3RRdWV1ZS5zaGlmdCgpO1xuXG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgdGhpcy5faXNzdWVSZXF1ZXN0KHJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVBbGxSZXF1ZXN0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlQWxsUmVxdWVzdHMoKSB7XG4gICAgICB2YXIgcmVxdWVzdFF1ZXVlID0gdGhpcy5yZXF1ZXN0UXVldWU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVxdWVzdFF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gcmVxdWVzdFF1ZXVlW2ldO1xuXG4gICAgICAgIGlmICghdGhpcy5fdXBkYXRlUmVxdWVzdChyZXF1ZXN0KSkge1xuICAgICAgICAgIHJlcXVlc3RRdWV1ZS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0TWFwLmRlbGV0ZShyZXF1ZXN0LmhhbmRsZSk7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3RRdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlUmVxdWVzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlUmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgICByZXF1ZXN0LnByaW9yaXR5ID0gcmVxdWVzdC5nZXRQcmlvcml0eShyZXF1ZXN0LmhhbmRsZSk7XG5cbiAgICAgIGlmIChyZXF1ZXN0LnByaW9yaXR5IDwgMCkge1xuICAgICAgICByZXF1ZXN0LnJlc29sdmUobnVsbCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBSZXF1ZXN0U2NoZWR1bGVyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSZXF1ZXN0U2NoZWR1bGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWVzdC1zY2hlZHVsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jcmVhdGVMb2FkZXJXb3JrZXIgPSBjcmVhdGVMb2FkZXJXb3JrZXI7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX3dvcmtlclV0aWxzID0gcmVxdWlyZShcIkBsb2FkZXJzLmdsL3dvcmtlci11dGlsc1wiKTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciByZXF1ZXN0SWQgPSAwO1xuXG5mdW5jdGlvbiBjcmVhdGVMb2FkZXJXb3JrZXIobG9hZGVyKSB7XG4gIGlmICh0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBfd29ya2VyVXRpbHMuV29ya2VyQm9keS5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZSh0eXBlLCBwYXlsb2FkKSB7XG4gICAgICB2YXIgaW5wdXQsIF9wYXlsb2FkJG9wdGlvbnMsIG9wdGlvbnMsIHJlc3VsdCwgbWVzc2FnZTtcblxuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gdHlwZTtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IF9jb250ZXh0LnQwID09PSAncHJvY2VzcycgPyAzIDogMTY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAzO1xuICAgICAgICAgICAgICBpbnB1dCA9IHBheWxvYWQuaW5wdXQsIF9wYXlsb2FkJG9wdGlvbnMgPSBwYXlsb2FkLm9wdGlvbnMsIG9wdGlvbnMgPSBfcGF5bG9hZCRvcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9wYXlsb2FkJG9wdGlvbnM7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3O1xuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VEYXRhKHtcbiAgICAgICAgICAgICAgICBsb2FkZXI6IGxvYWRlcixcbiAgICAgICAgICAgICAgICBhcnJheUJ1ZmZlcjogaW5wdXQsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgICBwYXJzZTogcGFyc2VPbk1haW5UaHJlYWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgICAgX3dvcmtlclV0aWxzLldvcmtlckJvZHkucG9zdE1lc3NhZ2UoJ2RvbmUnLCB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHRcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE1O1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDExO1xuICAgICAgICAgICAgICBfY29udGV4dC50MSA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMyk7XG4gICAgICAgICAgICAgIG1lc3NhZ2UgPSBfY29udGV4dC50MSBpbnN0YW5jZW9mIEVycm9yID8gX2NvbnRleHQudDEubWVzc2FnZSA6ICcnO1xuXG4gICAgICAgICAgICAgIF93b3JrZXJVdGlscy5Xb3JrZXJCb2R5LnBvc3RNZXNzYWdlKCdlcnJvcicsIHtcbiAgICAgICAgICAgICAgICBlcnJvcjogbWVzc2FnZVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcImJyZWFrXCIsIDE2KTtcblxuICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbMywgMTFdXSk7XG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChfeCwgX3gyKSB7XG4gICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0oKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VPbk1haW5UaHJlYWQoYXJyYXlCdWZmZXIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgaWQgPSByZXF1ZXN0SWQrKztcblxuICAgIHZhciBvbk1lc3NhZ2UgPSBmdW5jdGlvbiBvbk1lc3NhZ2UodHlwZSwgcGF5bG9hZCkge1xuICAgICAgaWYgKHBheWxvYWQuaWQgIT09IGlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2RvbmUnOlxuICAgICAgICAgIF93b3JrZXJVdGlscy5Xb3JrZXJCb2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIob25NZXNzYWdlKTtcblxuICAgICAgICAgIHJlc29sdmUocGF5bG9hZC5yZXN1bHQpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICBfd29ya2VyVXRpbHMuV29ya2VyQm9keS5yZW1vdmVFdmVudExpc3RlbmVyKG9uTWVzc2FnZSk7XG5cbiAgICAgICAgICByZWplY3QocGF5bG9hZC5lcnJvcik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3dvcmtlclV0aWxzLldvcmtlckJvZHkuYWRkRXZlbnRMaXN0ZW5lcihvbk1lc3NhZ2UpO1xuXG4gICAgdmFyIHBheWxvYWQgPSB7XG4gICAgICBpZDogaWQsXG4gICAgICBpbnB1dDogYXJyYXlCdWZmZXIsXG4gICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgfTtcblxuICAgIF93b3JrZXJVdGlscy5Xb3JrZXJCb2R5LnBvc3RNZXNzYWdlKCdwcm9jZXNzJywgcGF5bG9hZCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwYXJzZURhdGEoX3gzKSB7XG4gIHJldHVybiBfcGFyc2VEYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9wYXJzZURhdGEoKSB7XG4gIF9wYXJzZURhdGEgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoX3JlZjIpIHtcbiAgICB2YXIgbG9hZGVyLCBhcnJheUJ1ZmZlciwgb3B0aW9ucywgY29udGV4dCwgZGF0YSwgcGFyc2VyLCB0ZXh0RGVjb2RlcjtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBsb2FkZXIgPSBfcmVmMi5sb2FkZXIsIGFycmF5QnVmZmVyID0gX3JlZjIuYXJyYXlCdWZmZXIsIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zLCBjb250ZXh0ID0gX3JlZjIuY29udGV4dDtcblxuICAgICAgICAgICAgaWYgKCEobG9hZGVyLnBhcnNlU3luYyB8fCBsb2FkZXIucGFyc2UpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGEgPSBhcnJheUJ1ZmZlcjtcbiAgICAgICAgICAgIHBhcnNlciA9IGxvYWRlci5wYXJzZVN5bmMgfHwgbG9hZGVyLnBhcnNlO1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgaWYgKCFsb2FkZXIucGFyc2VUZXh0U3luYykge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAgICAgICAgIGRhdGEgPSB0ZXh0RGVjb2Rlci5kZWNvZGUoYXJyYXlCdWZmZXIpO1xuICAgICAgICAgICAgcGFyc2VyID0gbG9hZGVyLnBhcnNlVGV4dFN5bmM7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEzO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGxvYWQgZGF0YSB3aXRoIFwiLmNvbmNhdChsb2FkZXIubmFtZSwgXCIgbG9hZGVyXCIpKTtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBvcHRpb25zID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgICAgICAgbW9kdWxlczogbG9hZGVyICYmIGxvYWRlci5vcHRpb25zICYmIGxvYWRlci5vcHRpb25zLm1vZHVsZXMgfHwge30sXG4gICAgICAgICAgICAgIHdvcmtlcjogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNjtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZXIoZGF0YSwgX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIGNvbnRleHQsIGxvYWRlcik7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQyLnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyKTtcbiAgfSkpO1xuICByZXR1cm4gX3BhcnNlRGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlLWxvYWRlci13b3JrZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jYW5QYXJzZVdpdGhXb3JrZXIgPSBjYW5QYXJzZVdpdGhXb3JrZXI7XG5leHBvcnRzLnBhcnNlV2l0aFdvcmtlciA9IHBhcnNlV2l0aFdvcmtlcjtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfd29ya2VyVXRpbHMgPSByZXF1aXJlKFwiQGxvYWRlcnMuZ2wvd29ya2VyLXV0aWxzXCIpO1xuXG5mdW5jdGlvbiBjYW5QYXJzZVdpdGhXb3JrZXIobG9hZGVyLCBvcHRpb25zKSB7XG4gIGlmICghX3dvcmtlclV0aWxzLldvcmtlckZhcm0uaXNTdXBwb3J0ZWQoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBsb2FkZXIud29ya2VyICYmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMud29ya2VyKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VXaXRoV29ya2VyKF94LCBfeDIsIF94MywgX3g0LCBfeDUpIHtcbiAgcmV0dXJuIF9wYXJzZVdpdGhXb3JrZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3BhcnNlV2l0aFdvcmtlcigpIHtcbiAgX3BhcnNlV2l0aFdvcmtlciA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKGxvYWRlciwgZGF0YSwgb3B0aW9ucywgY29udGV4dCwgcGFyc2VPbk1haW5UaHJlYWQpIHtcbiAgICB2YXIgbmFtZSwgdXJsLCB3b3JrZXJGYXJtLCB3b3JrZXJQb29sLCBqb2IsIHJlc3VsdDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIG5hbWUgPSBsb2FkZXIuaWQ7XG4gICAgICAgICAgICB1cmwgPSAoMCwgX3dvcmtlclV0aWxzLmdldFdvcmtlclVSTCkobG9hZGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHdvcmtlckZhcm0gPSBfd29ya2VyVXRpbHMuV29ya2VyRmFybS5nZXRXb3JrZXJGYXJtKG9wdGlvbnMpO1xuICAgICAgICAgICAgd29ya2VyUG9vbCA9IHdvcmtlckZhcm0uZ2V0V29ya2VyUG9vbCh7XG4gICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpKTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3O1xuICAgICAgICAgICAgcmV0dXJuIHdvcmtlclBvb2wuc3RhcnRKb2IoJ3Byb2Nlc3Mtb24td29ya2VyJywgb25NZXNzYWdlLmJpbmQobnVsbCwgcGFyc2VPbk1haW5UaHJlYWQpKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGpvYiA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICBqb2IucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MnLCB7XG4gICAgICAgICAgICAgIGlucHV0OiBkYXRhLFxuICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgIHJldHVybiBqb2IucmVzdWx0O1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcblxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0LnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9wYXJzZVdpdGhXb3JrZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gb25NZXNzYWdlKF94NiwgX3g3LCBfeDgsIF94OSkge1xuICByZXR1cm4gX29uTWVzc2FnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfb25NZXNzYWdlKCkge1xuICBfb25NZXNzYWdlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKHBhcnNlT25NYWluVGhyZWFkLCBqb2IsIHR5cGUsIHBheWxvYWQpIHtcbiAgICB2YXIgaWQsIGlucHV0LCBvcHRpb25zLCByZXN1bHQsIG1lc3NhZ2U7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gdHlwZTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gX2NvbnRleHQyLnQwID09PSAnZG9uZScgPyAzIDogX2NvbnRleHQyLnQwID09PSAnZXJyb3InID8gNSA6IF9jb250ZXh0Mi50MCA9PT0gJ3Byb2Nlc3MnID8gNyA6IDIwO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBqb2IuZG9uZShwYXlsb2FkKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwiYnJlYWtcIiwgMjEpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgam9iLmVycm9yKHBheWxvYWQuZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJicmVha1wiLCAyMSk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBpZCA9IHBheWxvYWQuaWQsIGlucHV0ID0gcGF5bG9hZC5pbnB1dCwgb3B0aW9ucyA9IHBheWxvYWQub3B0aW9ucztcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gODtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTE7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VPbk1haW5UaHJlYWQoaW5wdXQsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgam9iLnBvc3RNZXNzYWdlKCdkb25lJywge1xuICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDE1O1xuICAgICAgICAgICAgX2NvbnRleHQyLnQxID0gX2NvbnRleHQyW1wiY2F0Y2hcIl0oOCk7XG4gICAgICAgICAgICBtZXNzYWdlID0gX2NvbnRleHQyLnQxIGluc3RhbmNlb2YgRXJyb3IgPyBfY29udGV4dDIudDEubWVzc2FnZSA6ICd1bmtub3duIGVycm9yJztcbiAgICAgICAgICAgIGpvYi5wb3N0TWVzc2FnZSgnZXJyb3InLCB7XG4gICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgZXJyb3I6IG1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwiYnJlYWtcIiwgMjEpO1xuXG4gICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcInBhcnNlLXdpdGgtd29ya2VyIHVua25vd24gbWVzc2FnZSBcIi5jb25jYXQodHlwZSkpO1xuXG4gICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyLCBudWxsLCBbWzgsIDE1XV0pO1xuICB9KSk7XG4gIHJldHVybiBfb25NZXNzYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZS13aXRoLXdvcmtlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0TWVzaFNpemUgPSBnZXRNZXNoU2l6ZTtcbmV4cG9ydHMuZ2V0TWVzaEJvdW5kaW5nQm94ID0gZ2V0TWVzaEJvdW5kaW5nQm94O1xuXG5mdW5jdGlvbiBnZXRNZXNoU2l6ZShhdHRyaWJ1dGVzKSB7XG4gIHZhciBzaXplID0gMDtcblxuICBmb3IgKHZhciBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcblxuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYXR0cmlidXRlKSkge1xuICAgICAgc2l6ZSArPSBhdHRyaWJ1dGUuYnl0ZUxlbmd0aCAqIGF0dHJpYnV0ZS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2l6ZTtcbn1cblxuZnVuY3Rpb24gZ2V0TWVzaEJvdW5kaW5nQm94KGF0dHJpYnV0ZXMpIHtcbiAgdmFyIG1pblggPSBJbmZpbml0eTtcbiAgdmFyIG1pblkgPSBJbmZpbml0eTtcbiAgdmFyIG1pblogPSBJbmZpbml0eTtcbiAgdmFyIG1heFggPSAtSW5maW5pdHk7XG4gIHZhciBtYXhZID0gLUluZmluaXR5O1xuICB2YXIgbWF4WiA9IC1JbmZpbml0eTtcbiAgdmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMuUE9TSVRJT04gPyBhdHRyaWJ1dGVzLlBPU0lUSU9OLnZhbHVlIDogW107XG4gIHZhciBsZW4gPSBwb3NpdGlvbnMgJiYgcG9zaXRpb25zLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAzKSB7XG4gICAgdmFyIHggPSBwb3NpdGlvbnNbaV07XG4gICAgdmFyIHkgPSBwb3NpdGlvbnNbaSArIDFdO1xuICAgIHZhciB6ID0gcG9zaXRpb25zW2kgKyAyXTtcbiAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcbiAgICBtaW5aID0geiA8IG1pblogPyB6IDogbWluWjtcbiAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcbiAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcbiAgICBtYXhaID0geiA+IG1heFogPyB6IDogbWF4WjtcbiAgfVxuXG4gIHJldHVybiBbW21pblgsIG1pblksIG1pblpdLCBbbWF4WCwgbWF4WSwgbWF4Wl1dO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVzaC11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUYWJsZUJhdGNoQnVpbGRlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdGFibGVCYXRjaEJ1aWxkZXIuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSb3dUYWJsZUJhdGNoQWdncmVnYXRvclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfcm93VGFibGVCYXRjaEFnZ3JlZ2F0b3IuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb2x1bW5hclRhYmxlQmF0Y2hBZ2dyZWdhdG9yXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9jb2x1bW5hclRhYmxlQmF0Y2hBZ2dyZWdhdG9yLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29udmVydFRvT2JqZWN0Um93XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9yb3dVdGlscy5jb252ZXJ0VG9PYmplY3RSb3c7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29udmVydFRvQXJyYXlSb3dcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3Jvd1V0aWxzLmNvbnZlcnRUb0FycmF5Um93O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldE1lc2hTaXplXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9tZXNoVXRpbHMuZ2V0TWVzaFNpemU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0TWVzaEJvdW5kaW5nQm94XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9tZXNoVXRpbHMuZ2V0TWVzaEJvdW5kaW5nQm94O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNjaGVtYVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLlNjaGVtYTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGaWVsZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLkZpZWxkO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRhdGFUeXBlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuRGF0YVR5cGU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTnVsbFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLk51bGw7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmluYXJ5XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuQmluYXJ5O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJvb2xcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5Cb29sO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLkludDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnQ4XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuSW50ODtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnQxNlwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLkludDE2O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludDMyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuSW50MzI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW50NjRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5JbnQ2NDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVaW50OFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLlVpbnQ4O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVpbnQxNlwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLlVpbnQxNjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVaW50MzJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5VaW50MzI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVWludDY0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuVWludDY0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZsb2F0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuRmxvYXQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmxvYXQxNlwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLkZsb2F0MTY7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmxvYXQzMlwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLkZsb2F0MzI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmxvYXQ2NFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLkZsb2F0NjQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVXRmOFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLlV0Zjg7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGF0ZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLkRhdGU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGF0ZURheVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLkRhdGVEYXk7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGF0ZU1pbGxpc2Vjb25kXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuRGF0ZU1pbGxpc2Vjb25kO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRpbWVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5UaW1lO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRpbWVNaWxsaXNlY29uZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLlRpbWVNaWxsaXNlY29uZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUaW1lU2Vjb25kXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuVGltZVNlY29uZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUaW1lc3RhbXBcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5UaW1lc3RhbXA7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGltZXN0YW1wU2Vjb25kXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuVGltZXN0YW1wU2Vjb25kO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRpbWVzdGFtcE1pbGxpc2Vjb25kXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuVGltZXN0YW1wTWlsbGlzZWNvbmQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGltZXN0YW1wTWljcm9zZWNvbmRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5UaW1lc3RhbXBNaWNyb3NlY29uZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUaW1lc3RhbXBOYW5vc2Vjb25kXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuVGltZXN0YW1wTmFub3NlY29uZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnRlcnZhbFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLkludGVydmFsO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludGVydmFsRGF5VGltZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLkludGVydmFsRGF5VGltZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnRlcnZhbFllYXJNb250aFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLkludGVydmFsWWVhck1vbnRoO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZpeGVkU2l6ZUxpc3RcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5GaXhlZFNpemVMaXN0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZHVjZVRhYmxlU2NoZW1hXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9kZWR1Y2VUYWJsZVNjaGVtYS5kZWR1Y2VUYWJsZVNjaGVtYTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRUeXBlSW5mb1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2V0VHlwZUluZm8uZ2V0VHlwZUluZm87XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0QXJyb3dUeXBlRnJvbVR5cGVkQXJyYXlcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGVVdGlscy5nZXRBcnJvd1R5cGVGcm9tVHlwZWRBcnJheTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBc3luY1F1ZXVlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hc3luY1F1ZXVlLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX3RhYmxlQmF0Y2hCdWlsZGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvdGFibGUvdGFibGUtYmF0Y2gtYnVpbGRlclwiKSk7XG5cbnZhciBfcm93VGFibGVCYXRjaEFnZ3JlZ2F0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi90YWJsZS9yb3ctdGFibGUtYmF0Y2gtYWdncmVnYXRvclwiKSk7XG5cbnZhciBfY29sdW1uYXJUYWJsZUJhdGNoQWdncmVnYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL3RhYmxlL2NvbHVtbmFyLXRhYmxlLWJhdGNoLWFnZ3JlZ2F0b3JcIikpO1xuXG52YXIgX3Jvd1V0aWxzID0gcmVxdWlyZShcIi4vbGliL3V0aWxzL3Jvdy11dGlsc1wiKTtcblxudmFyIF9tZXNoVXRpbHMgPSByZXF1aXJlKFwiLi9jYXRlZ29yeS9tZXNoL21lc2gtdXRpbHNcIik7XG5cbnZhciBfc2NoZW1hID0gcmVxdWlyZShcIi4vbGliL3NjaGVtYVwiKTtcblxudmFyIF9kZWR1Y2VUYWJsZVNjaGVtYSA9IHJlcXVpcmUoXCIuL2xpYi9zY2hlbWEtdXRpbHMvZGVkdWNlLXRhYmxlLXNjaGVtYVwiKTtcblxudmFyIF9nZXRUeXBlSW5mbyA9IHJlcXVpcmUoXCIuL2xpYi9zY2hlbWEtdXRpbHMvZ2V0LXR5cGUtaW5mb1wiKTtcblxudmFyIF90eXBlVXRpbHMgPSByZXF1aXJlKFwiLi9saWIvc2NoZW1hLXV0aWxzL3R5cGUtdXRpbHNcIik7XG5cbnZhciBfYXN5bmNRdWV1ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL3V0aWxzL2FzeW5jLXF1ZXVlXCIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWR1Y2VUYWJsZVNjaGVtYSA9IGRlZHVjZVRhYmxlU2NoZW1hO1xuXG5mdW5jdGlvbiBkZWR1Y2VUYWJsZVNjaGVtYSh0YWJsZSwgc2NoZW1hKSB7XG4gIHZhciBkZWR1Y2VkU2NoZW1hID0gQXJyYXkuaXNBcnJheSh0YWJsZSkgPyBkZWR1Y2VTY2hlbWFGb3JSb3dUYWJsZSh0YWJsZSkgOiBkZWR1Y2VTY2hlbWFGb3JDb2x1bW5hclRhYmxlKHRhYmxlKTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZGVkdWNlZFNjaGVtYSwgc2NoZW1hKTtcbn1cblxuZnVuY3Rpb24gZGVkdWNlU2NoZW1hRm9yQ29sdW1uYXJUYWJsZShjb2x1bW5hclRhYmxlKSB7XG4gIHZhciBzY2hlbWEgPSB7fTtcblxuICBmb3IgKHZhciBmaWVsZCBpbiBjb2x1bW5hclRhYmxlKSB7XG4gICAgdmFyIGNvbHVtbiA9IGNvbHVtbmFyVGFibGVbZmllbGRdO1xuXG4gICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhjb2x1bW4pKSB7XG4gICAgICBzY2hlbWFbZmllbGRdID0gY29sdW1uLmNvbnN0cnVjdG9yO1xuICAgIH0gZWxzZSBpZiAoY29sdW1uLmxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gY29sdW1uWzBdO1xuICAgICAgc2NoZW1hW2ZpZWxkXSA9IGRlZHVjZVR5cGVGcm9tVmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIHNjaGVtYVtmaWVsZF0gPSBzY2hlbWFbZmllbGRdIHx8IG51bGw7XG4gIH1cblxuICByZXR1cm4gc2NoZW1hO1xufVxuXG5mdW5jdGlvbiBkZWR1Y2VTY2hlbWFGb3JSb3dUYWJsZShyb3dUYWJsZSkge1xuICB2YXIgc2NoZW1hID0ge307XG5cbiAgaWYgKHJvd1RhYmxlLmxlbmd0aCkge1xuICAgIHZhciByb3cgPSByb3dUYWJsZVswXTtcblxuICAgIGZvciAodmFyIGZpZWxkIGluIHJvdykge1xuICAgICAgdmFyIHZhbHVlID0gcm93W2ZpZWxkXTtcbiAgICAgIHNjaGVtYVtmaWVsZF0gPSBkZWR1Y2VUeXBlRnJvbVZhbHVlKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2NoZW1hO1xufVxuXG5mdW5jdGlvbiBkZWR1Y2VUeXBlRnJvbVZhbHVlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gRGF0ZTtcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgIHJldHVybiBGbG9hdDMyQXJyYXk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBTdHJpbmc7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZHVjZS10YWJsZS1zY2hlbWEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldFR5cGVJbmZvID0gZ2V0VHlwZUluZm87XG5cbnZhciBfc2NoZW1hID0gcmVxdWlyZShcIi4uL3NjaGVtYVwiKTtcblxuZnVuY3Rpb24gZ2V0VHlwZUluZm8oYXJyb3dUeXBlTGlrZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGVJZDogYXJyb3dUeXBlTGlrZS50eXBlSWQsXG4gICAgQXJyYXlUeXBlOiBhcnJvd1R5cGVMaWtlLkFycmF5VHlwZSxcbiAgICB0eXBlTmFtZTogYXJyb3dUeXBlTGlrZS50b1N0cmluZygpLFxuICAgIHR5cGVFbnVtTmFtZTogZ2V0VHlwZUtleShhcnJvd1R5cGVMaWtlLnR5cGVJZCksXG4gICAgcHJlY2lzaW9uOiBhcnJvd1R5cGVMaWtlLnByZWNpc2lvblxuICB9O1xufVxuXG52YXIgUmV2ZXJzZVR5cGUgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXRUeXBlS2V5KHR5cGVLZXkpIHtcbiAgaWYgKCFSZXZlcnNlVHlwZSkge1xuICAgIFJldmVyc2VUeXBlID0ge307XG5cbiAgICBmb3IgKHZhciBfa2V5IGluIF9zY2hlbWEuVHlwZSkge1xuICAgICAgUmV2ZXJzZVR5cGVbX3NjaGVtYS5UeXBlW19rZXldXSA9IF9rZXk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFJldmVyc2VUeXBlW3R5cGVLZXldO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LXR5cGUtaW5mby5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0QXJyb3dUeXBlRnJvbVR5cGVkQXJyYXkgPSBnZXRBcnJvd1R5cGVGcm9tVHlwZWRBcnJheTtcblxudmFyIF9zY2hlbWEgPSByZXF1aXJlKFwiLi4vc2NoZW1hXCIpO1xuXG5mdW5jdGlvbiBnZXRBcnJvd1R5cGVGcm9tVHlwZWRBcnJheShhcnJheSkge1xuICBzd2l0Y2ggKGFycmF5LmNvbnN0cnVjdG9yKSB7XG4gICAgY2FzZSBJbnQ4QXJyYXk6XG4gICAgICByZXR1cm4gbmV3IF9zY2hlbWEuSW50OCgpO1xuXG4gICAgY2FzZSBVaW50OEFycmF5OlxuICAgICAgcmV0dXJuIG5ldyBfc2NoZW1hLlVpbnQ4KCk7XG5cbiAgICBjYXNlIEludDE2QXJyYXk6XG4gICAgICByZXR1cm4gbmV3IF9zY2hlbWEuSW50MTYoKTtcblxuICAgIGNhc2UgVWludDE2QXJyYXk6XG4gICAgICByZXR1cm4gbmV3IF9zY2hlbWEuVWludDE2KCk7XG5cbiAgICBjYXNlIEludDMyQXJyYXk6XG4gICAgICByZXR1cm4gbmV3IF9zY2hlbWEuSW50MzIoKTtcblxuICAgIGNhc2UgVWludDMyQXJyYXk6XG4gICAgICByZXR1cm4gbmV3IF9zY2hlbWEuVWludDMyKCk7XG5cbiAgICBjYXNlIEZsb2F0MzJBcnJheTpcbiAgICAgIHJldHVybiBuZXcgX3NjaGVtYS5GbG9hdDMyKCk7XG5cbiAgICBjYXNlIEZsb2F0NjRBcnJheTpcbiAgICAgIHJldHVybiBuZXcgX3NjaGVtYS5GbG9hdDY0KCk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheSB0eXBlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZS11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuVHlwZSA9IHZvaWQgMDtcbnZhciBUeXBlO1xuZXhwb3J0cy5UeXBlID0gVHlwZTtcblxuKGZ1bmN0aW9uIChUeXBlKSB7XG4gIFR5cGVbVHlwZVtcIk5PTkVcIl0gPSAwXSA9IFwiTk9ORVwiO1xuICBUeXBlW1R5cGVbXCJOdWxsXCJdID0gMV0gPSBcIk51bGxcIjtcbiAgVHlwZVtUeXBlW1wiSW50XCJdID0gMl0gPSBcIkludFwiO1xuICBUeXBlW1R5cGVbXCJGbG9hdFwiXSA9IDNdID0gXCJGbG9hdFwiO1xuICBUeXBlW1R5cGVbXCJCaW5hcnlcIl0gPSA0XSA9IFwiQmluYXJ5XCI7XG4gIFR5cGVbVHlwZVtcIlV0ZjhcIl0gPSA1XSA9IFwiVXRmOFwiO1xuICBUeXBlW1R5cGVbXCJCb29sXCJdID0gNl0gPSBcIkJvb2xcIjtcbiAgVHlwZVtUeXBlW1wiRGVjaW1hbFwiXSA9IDddID0gXCJEZWNpbWFsXCI7XG4gIFR5cGVbVHlwZVtcIkRhdGVcIl0gPSA4XSA9IFwiRGF0ZVwiO1xuICBUeXBlW1R5cGVbXCJUaW1lXCJdID0gOV0gPSBcIlRpbWVcIjtcbiAgVHlwZVtUeXBlW1wiVGltZXN0YW1wXCJdID0gMTBdID0gXCJUaW1lc3RhbXBcIjtcbiAgVHlwZVtUeXBlW1wiSW50ZXJ2YWxcIl0gPSAxMV0gPSBcIkludGVydmFsXCI7XG4gIFR5cGVbVHlwZVtcIkxpc3RcIl0gPSAxMl0gPSBcIkxpc3RcIjtcbiAgVHlwZVtUeXBlW1wiU3RydWN0XCJdID0gMTNdID0gXCJTdHJ1Y3RcIjtcbiAgVHlwZVtUeXBlW1wiVW5pb25cIl0gPSAxNF0gPSBcIlVuaW9uXCI7XG4gIFR5cGVbVHlwZVtcIkZpeGVkU2l6ZUJpbmFyeVwiXSA9IDE1XSA9IFwiRml4ZWRTaXplQmluYXJ5XCI7XG4gIFR5cGVbVHlwZVtcIkZpeGVkU2l6ZUxpc3RcIl0gPSAxNl0gPSBcIkZpeGVkU2l6ZUxpc3RcIjtcbiAgVHlwZVtUeXBlW1wiTWFwXCJdID0gMTddID0gXCJNYXBcIjtcbiAgVHlwZVtUeXBlW1wiRGljdGlvbmFyeVwiXSA9IC0xXSA9IFwiRGljdGlvbmFyeVwiO1xuICBUeXBlW1R5cGVbXCJJbnQ4XCJdID0gLTJdID0gXCJJbnQ4XCI7XG4gIFR5cGVbVHlwZVtcIkludDE2XCJdID0gLTNdID0gXCJJbnQxNlwiO1xuICBUeXBlW1R5cGVbXCJJbnQzMlwiXSA9IC00XSA9IFwiSW50MzJcIjtcbiAgVHlwZVtUeXBlW1wiSW50NjRcIl0gPSAtNV0gPSBcIkludDY0XCI7XG4gIFR5cGVbVHlwZVtcIlVpbnQ4XCJdID0gLTZdID0gXCJVaW50OFwiO1xuICBUeXBlW1R5cGVbXCJVaW50MTZcIl0gPSAtN10gPSBcIlVpbnQxNlwiO1xuICBUeXBlW1R5cGVbXCJVaW50MzJcIl0gPSAtOF0gPSBcIlVpbnQzMlwiO1xuICBUeXBlW1R5cGVbXCJVaW50NjRcIl0gPSAtOV0gPSBcIlVpbnQ2NFwiO1xuICBUeXBlW1R5cGVbXCJGbG9hdDE2XCJdID0gLTEwXSA9IFwiRmxvYXQxNlwiO1xuICBUeXBlW1R5cGVbXCJGbG9hdDMyXCJdID0gLTExXSA9IFwiRmxvYXQzMlwiO1xuICBUeXBlW1R5cGVbXCJGbG9hdDY0XCJdID0gLTEyXSA9IFwiRmxvYXQ2NFwiO1xuICBUeXBlW1R5cGVbXCJEYXRlRGF5XCJdID0gLTEzXSA9IFwiRGF0ZURheVwiO1xuICBUeXBlW1R5cGVbXCJEYXRlTWlsbGlzZWNvbmRcIl0gPSAtMTRdID0gXCJEYXRlTWlsbGlzZWNvbmRcIjtcbiAgVHlwZVtUeXBlW1wiVGltZXN0YW1wU2Vjb25kXCJdID0gLTE1XSA9IFwiVGltZXN0YW1wU2Vjb25kXCI7XG4gIFR5cGVbVHlwZVtcIlRpbWVzdGFtcE1pbGxpc2Vjb25kXCJdID0gLTE2XSA9IFwiVGltZXN0YW1wTWlsbGlzZWNvbmRcIjtcbiAgVHlwZVtUeXBlW1wiVGltZXN0YW1wTWljcm9zZWNvbmRcIl0gPSAtMTddID0gXCJUaW1lc3RhbXBNaWNyb3NlY29uZFwiO1xuICBUeXBlW1R5cGVbXCJUaW1lc3RhbXBOYW5vc2Vjb25kXCJdID0gLTE4XSA9IFwiVGltZXN0YW1wTmFub3NlY29uZFwiO1xuICBUeXBlW1R5cGVbXCJUaW1lU2Vjb25kXCJdID0gLTE5XSA9IFwiVGltZVNlY29uZFwiO1xuICBUeXBlW1R5cGVbXCJUaW1lTWlsbGlzZWNvbmRcIl0gPSAtMjBdID0gXCJUaW1lTWlsbGlzZWNvbmRcIjtcbiAgVHlwZVtUeXBlW1wiVGltZU1pY3Jvc2Vjb25kXCJdID0gLTIxXSA9IFwiVGltZU1pY3Jvc2Vjb25kXCI7XG4gIFR5cGVbVHlwZVtcIlRpbWVOYW5vc2Vjb25kXCJdID0gLTIyXSA9IFwiVGltZU5hbm9zZWNvbmRcIjtcbiAgVHlwZVtUeXBlW1wiRGVuc2VVbmlvblwiXSA9IC0yM10gPSBcIkRlbnNlVW5pb25cIjtcbiAgVHlwZVtUeXBlW1wiU3BhcnNlVW5pb25cIl0gPSAtMjRdID0gXCJTcGFyc2VVbmlvblwiO1xuICBUeXBlW1R5cGVbXCJJbnRlcnZhbERheVRpbWVcIl0gPSAtMjVdID0gXCJJbnRlcnZhbERheVRpbWVcIjtcbiAgVHlwZVtUeXBlW1wiSW50ZXJ2YWxZZWFyTW9udGhcIl0gPSAtMjZdID0gXCJJbnRlcnZhbFllYXJNb250aFwiO1xufSkoVHlwZSB8fCAoZXhwb3J0cy5UeXBlID0gVHlwZSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnVtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIEZpZWxkID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGaWVsZChuYW1lLCB0eXBlKSB7XG4gICAgdmFyIG51bGxhYmxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICB2YXIgbWV0YWRhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG5ldyBNYXAoKTtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBGaWVsZCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJuYW1lXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJ0eXBlXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJudWxsYWJsZVwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwibWV0YWRhdGFcIiwgdm9pZCAwKTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5udWxsYWJsZSA9IG51bGxhYmxlO1xuICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEZpZWxkLCBbe1xuICAgIGtleTogXCJ0eXBlSWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUgJiYgdGhpcy50eXBlLnR5cGVJZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICByZXR1cm4gbmV3IEZpZWxkKHRoaXMubmFtZSwgdGhpcy50eXBlLCB0aGlzLm51bGxhYmxlLCB0aGlzLm1ldGFkYXRhKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcGFyZVRvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVUbyhvdGhlcikge1xuICAgICAgcmV0dXJuIHRoaXMubmFtZSA9PT0gb3RoZXIubmFtZSAmJiB0aGlzLnR5cGUgPT09IG90aGVyLnR5cGUgJiYgdGhpcy5udWxsYWJsZSA9PT0gb3RoZXIubnVsbGFibGUgJiYgdGhpcy5tZXRhZGF0YSA9PT0gb3RoZXIubWV0YWRhdGE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMudHlwZSkuY29uY2F0KHRoaXMubnVsbGFibGUgPyAnLCBudWxsYWJsZScgOiAnJykuY29uY2F0KHRoaXMubWV0YWRhdGEgPyBcIiwgbWV0YWRhdGE6IFwiLmNvbmNhdCh0aGlzLm1ldGFkYXRhKSA6ICcnKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEZpZWxkO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBGaWVsZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpZWxkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF90b0NvbnN1bWFibGVBcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5XCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9hc3NlcnQgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvYXNzZXJ0XCIpO1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbnZhciBTY2hlbWEgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNjaGVtYShmaWVsZHMsIG1ldGFkYXRhKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgU2NoZW1hKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcImZpZWxkc1wiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwibWV0YWRhdGFcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2Fzc2VydC5hc3NlcnQpKEFycmF5LmlzQXJyYXkoZmllbGRzKSk7XG4gICAgY2hlY2tOYW1lcyhmaWVsZHMpO1xuICAgIHRoaXMuZmllbGRzID0gZmllbGRzO1xuICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YSB8fCBuZXcgTWFwKCk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShTY2hlbWEsIFt7XG4gICAga2V5OiBcImNvbXBhcmVUb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICAgIGlmICh0aGlzLm1ldGFkYXRhICE9PSBvdGhlci5tZXRhZGF0YSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmZpZWxkcy5sZW5ndGggIT09IG90aGVyLmZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmllbGRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICghdGhpcy5maWVsZHNbaV0uY29tcGFyZVRvKG90aGVyLmZpZWxkc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlbGVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3QoKSB7XG4gICAgICB2YXIgbmFtZU1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBjb2x1bW5OYW1lcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgY29sdW1uTmFtZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9pID0gMCwgX2NvbHVtbk5hbWVzID0gY29sdW1uTmFtZXM7IF9pIDwgX2NvbHVtbk5hbWVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgbmFtZSA9IF9jb2x1bW5OYW1lc1tfaV07XG4gICAgICAgIG5hbWVNYXBbbmFtZV0gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VsZWN0ZWRGaWVsZHMgPSB0aGlzLmZpZWxkcy5maWx0ZXIoZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIHJldHVybiBuYW1lTWFwW2ZpZWxkLm5hbWVdO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFNjaGVtYShzZWxlY3RlZEZpZWxkcywgdGhpcy5tZXRhZGF0YSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlbGVjdEF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdEF0KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBjb2x1bW5JbmRpY2VzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGNvbHVtbkluZGljZXNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlbGVjdGVkRmllbGRzID0gY29sdW1uSW5kaWNlcy5tYXAoZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5maWVsZHNbaW5kZXhdO1xuICAgICAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgcmV0dXJuIG5ldyBTY2hlbWEoc2VsZWN0ZWRGaWVsZHMsIHRoaXMubWV0YWRhdGEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhc3NpZ25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXNzaWduKHNjaGVtYU9yRmllbGRzKSB7XG4gICAgICB2YXIgZmllbGRzO1xuICAgICAgdmFyIG1ldGFkYXRhID0gdGhpcy5tZXRhZGF0YTtcblxuICAgICAgaWYgKHNjaGVtYU9yRmllbGRzIGluc3RhbmNlb2YgU2NoZW1hKSB7XG4gICAgICAgIHZhciBvdGhlclNjaGVtYSA9IHNjaGVtYU9yRmllbGRzO1xuICAgICAgICBmaWVsZHMgPSBvdGhlclNjaGVtYS5maWVsZHM7XG4gICAgICAgIG1ldGFkYXRhID0gbWVyZ2VNYXBzKG1lcmdlTWFwcyhuZXcgTWFwKCksIHRoaXMubWV0YWRhdGEpLCBvdGhlclNjaGVtYS5tZXRhZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaWVsZHMgPSBzY2hlbWFPckZpZWxkcztcbiAgICAgIH1cblxuICAgICAgdmFyIGZpZWxkTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuZmllbGRzKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgZmllbGQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBmaWVsZE1hcFtmaWVsZC5uYW1lXSA9IGZpZWxkO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZmllbGRzKSxcbiAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9maWVsZCA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICBmaWVsZE1hcFtfZmllbGQubmFtZV0gPSBfZmllbGQ7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWVyZ2VkRmllbGRzID0gT2JqZWN0LnZhbHVlcyhmaWVsZE1hcCk7XG4gICAgICByZXR1cm4gbmV3IFNjaGVtYShtZXJnZWRGaWVsZHMsIG1ldGFkYXRhKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFNjaGVtYTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gU2NoZW1hO1xuXG5mdW5jdGlvbiBjaGVja05hbWVzKGZpZWxkcykge1xuICB2YXIgdXNlZE5hbWVzID0ge307XG5cbiAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihmaWVsZHMpLFxuICAgICAgX3N0ZXAzO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBmaWVsZCA9IF9zdGVwMy52YWx1ZTtcblxuICAgICAgaWYgKHVzZWROYW1lc1tmaWVsZC5uYW1lXSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1NjaGVtYTogZHVwbGljYXRlZCBmaWVsZCBuYW1lJywgZmllbGQubmFtZSwgZmllbGQpO1xuICAgICAgfVxuXG4gICAgICB1c2VkTmFtZXNbZmllbGQubmFtZV0gPSB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yMy5mKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VNYXBzKG0xLCBtMikge1xuICByZXR1cm4gbmV3IE1hcChbXS5jb25jYXQoKDAsIF90b0NvbnN1bWFibGVBcnJheTIuZGVmYXVsdCkobTEgfHwgbmV3IE1hcCgpKSwgKDAsIF90b0NvbnN1bWFibGVBcnJheTIuZGVmYXVsdCkobTIgfHwgbmV3IE1hcCgpKSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NoZW1hLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2VudW0uVHlwZTtcbiAgfVxufSk7XG5leHBvcnRzLkZpeGVkU2l6ZUxpc3QgPSBleHBvcnRzLkludGVydmFsWWVhck1vbnRoID0gZXhwb3J0cy5JbnRlcnZhbERheVRpbWUgPSBleHBvcnRzLkludGVydmFsID0gZXhwb3J0cy5UaW1lc3RhbXBOYW5vc2Vjb25kID0gZXhwb3J0cy5UaW1lc3RhbXBNaWNyb3NlY29uZCA9IGV4cG9ydHMuVGltZXN0YW1wTWlsbGlzZWNvbmQgPSBleHBvcnRzLlRpbWVzdGFtcFNlY29uZCA9IGV4cG9ydHMuVGltZXN0YW1wID0gZXhwb3J0cy5UaW1lTWlsbGlzZWNvbmQgPSBleHBvcnRzLlRpbWVTZWNvbmQgPSBleHBvcnRzLlRpbWUgPSBleHBvcnRzLkRhdGVNaWxsaXNlY29uZCA9IGV4cG9ydHMuRGF0ZURheSA9IGV4cG9ydHMuRGF0ZSA9IGV4cG9ydHMuVXRmOCA9IGV4cG9ydHMuQmluYXJ5ID0gZXhwb3J0cy5GbG9hdDY0ID0gZXhwb3J0cy5GbG9hdDMyID0gZXhwb3J0cy5GbG9hdDE2ID0gZXhwb3J0cy5GbG9hdCA9IGV4cG9ydHMuVWludDY0ID0gZXhwb3J0cy5VaW50MzIgPSBleHBvcnRzLlVpbnQxNiA9IGV4cG9ydHMuVWludDggPSBleHBvcnRzLkludDY0ID0gZXhwb3J0cy5JbnQzMiA9IGV4cG9ydHMuSW50MTYgPSBleHBvcnRzLkludDggPSBleHBvcnRzLkludCA9IGV4cG9ydHMuQm9vbCA9IGV4cG9ydHMuTnVsbCA9IGV4cG9ydHMuRGF0YVR5cGUgPSB2b2lkIDA7XG5cbnZhciBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXNzZXJ0VGhpc0luaXRpYWxpemVkXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfZW51bSA9IHJlcXVpcmUoXCIuL2VudW1cIik7XG5cbnZhciBfU3ltYm9sJHRvU3RyaW5nVGFnLCBfU3ltYm9sJHRvU3RyaW5nVGFnMiwgX1N5bWJvbCR0b1N0cmluZ1RhZzMsIF9TeW1ib2wkdG9TdHJpbmdUYWc0LCBfU3ltYm9sJHRvU3RyaW5nVGFnNSwgX1N5bWJvbCR0b1N0cmluZ1RhZzYsIF9TeW1ib2wkdG9TdHJpbmdUYWc3O1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIuZGVmYXVsdCkodGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIERhdGFUeXBlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEYXRhVHlwZSgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBEYXRhVHlwZSk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShEYXRhVHlwZSwgW3tcbiAgICBrZXk6IFwidHlwZUlkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2VudW0uVHlwZS5OT05FO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wYXJlVG9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVRvKG90aGVyKSB7XG4gICAgICByZXR1cm4gdGhpcyA9PT0gb3RoZXI7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiaXNOdWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzTnVsbCh4KSB7XG4gICAgICByZXR1cm4geCAmJiB4LnR5cGVJZCA9PT0gX2VudW0uVHlwZS5OdWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0ludCh4KSB7XG4gICAgICByZXR1cm4geCAmJiB4LnR5cGVJZCA9PT0gX2VudW0uVHlwZS5JbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzRmxvYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNGbG9hdCh4KSB7XG4gICAgICByZXR1cm4geCAmJiB4LnR5cGVJZCA9PT0gX2VudW0uVHlwZS5GbG9hdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNCaW5hcnlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNCaW5hcnkoeCkge1xuICAgICAgcmV0dXJuIHggJiYgeC50eXBlSWQgPT09IF9lbnVtLlR5cGUuQmluYXJ5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1V0ZjhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNVdGY4KHgpIHtcbiAgICAgIHJldHVybiB4ICYmIHgudHlwZUlkID09PSBfZW51bS5UeXBlLlV0Zjg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzQm9vbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0Jvb2woeCkge1xuICAgICAgcmV0dXJuIHggJiYgeC50eXBlSWQgPT09IF9lbnVtLlR5cGUuQm9vbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNEZWNpbWFsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRGVjaW1hbCh4KSB7XG4gICAgICByZXR1cm4geCAmJiB4LnR5cGVJZCA9PT0gX2VudW0uVHlwZS5EZWNpbWFsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNEYXRlKHgpIHtcbiAgICAgIHJldHVybiB4ICYmIHgudHlwZUlkID09PSBfZW51bS5UeXBlLkRhdGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzVGltZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1RpbWUoeCkge1xuICAgICAgcmV0dXJuIHggJiYgeC50eXBlSWQgPT09IF9lbnVtLlR5cGUuVGltZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNUaW1lc3RhbXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNUaW1lc3RhbXAoeCkge1xuICAgICAgcmV0dXJuIHggJiYgeC50eXBlSWQgPT09IF9lbnVtLlR5cGUuVGltZXN0YW1wO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0ludGVydmFsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzSW50ZXJ2YWwoeCkge1xuICAgICAgcmV0dXJuIHggJiYgeC50eXBlSWQgPT09IF9lbnVtLlR5cGUuSW50ZXJ2YWw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzTGlzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0xpc3QoeCkge1xuICAgICAgcmV0dXJuIHggJiYgeC50eXBlSWQgPT09IF9lbnVtLlR5cGUuTGlzdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNTdHJ1Y3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNTdHJ1Y3QoeCkge1xuICAgICAgcmV0dXJuIHggJiYgeC50eXBlSWQgPT09IF9lbnVtLlR5cGUuU3RydWN0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1VuaW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzVW5pb24oeCkge1xuICAgICAgcmV0dXJuIHggJiYgeC50eXBlSWQgPT09IF9lbnVtLlR5cGUuVW5pb247XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzRml4ZWRTaXplQmluYXJ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRml4ZWRTaXplQmluYXJ5KHgpIHtcbiAgICAgIHJldHVybiB4ICYmIHgudHlwZUlkID09PSBfZW51bS5UeXBlLkZpeGVkU2l6ZUJpbmFyeTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNGaXhlZFNpemVMaXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRml4ZWRTaXplTGlzdCh4KSB7XG4gICAgICByZXR1cm4geCAmJiB4LnR5cGVJZCA9PT0gX2VudW0uVHlwZS5GaXhlZFNpemVMaXN0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc01hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc01hcCh4KSB7XG4gICAgICByZXR1cm4geCAmJiB4LnR5cGVJZCA9PT0gX2VudW0uVHlwZS5NYXA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzRGljdGlvbmFyeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0RpY3Rpb25hcnkoeCkge1xuICAgICAgcmV0dXJuIHggJiYgeC50eXBlSWQgPT09IF9lbnVtLlR5cGUuRGljdGlvbmFyeTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIERhdGFUeXBlO1xufSgpO1xuXG5leHBvcnRzLkRhdGFUeXBlID0gRGF0YVR5cGU7XG5cbnZhciBOdWxsID0gZnVuY3Rpb24gKF9EYXRhVHlwZSkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShOdWxsLCBfRGF0YVR5cGUpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoTnVsbCk7XG5cbiAgZnVuY3Rpb24gTnVsbCgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBOdWxsKTtcbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShOdWxsLCBbe1xuICAgIGtleTogXCJ0eXBlSWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfZW51bS5UeXBlLk51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBTeW1ib2wudG9TdHJpbmdUYWcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ051bGwnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAnTnVsbCc7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOdWxsO1xufShEYXRhVHlwZSk7XG5cbmV4cG9ydHMuTnVsbCA9IE51bGw7XG5cbnZhciBCb29sID0gZnVuY3Rpb24gKF9EYXRhVHlwZTIpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoQm9vbCwgX0RhdGFUeXBlMik7XG5cbiAgdmFyIF9zdXBlcjIgPSBfY3JlYXRlU3VwZXIoQm9vbCk7XG5cbiAgZnVuY3Rpb24gQm9vbCgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBCb29sKTtcbiAgICByZXR1cm4gX3N1cGVyMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoQm9vbCwgW3tcbiAgICBrZXk6IFwidHlwZUlkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2VudW0uVHlwZS5Cb29sO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogU3ltYm9sLnRvU3RyaW5nVGFnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICdCb29sJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ0Jvb2wnO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQm9vbDtcbn0oRGF0YVR5cGUpO1xuXG5leHBvcnRzLkJvb2wgPSBCb29sO1xuX1N5bWJvbCR0b1N0cmluZ1RhZyA9IFN5bWJvbC50b1N0cmluZ1RhZztcblxudmFyIEludCA9IGZ1bmN0aW9uIChfRGF0YVR5cGUzKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEludCwgX0RhdGFUeXBlMyk7XG5cbiAgdmFyIF9zdXBlcjMgPSBfY3JlYXRlU3VwZXIoSW50KTtcblxuICBmdW5jdGlvbiBJbnQoaXNTaWduZWQsIGJpdFdpZHRoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgSW50KTtcbiAgICBfdGhpcyA9IF9zdXBlcjMuY2FsbCh0aGlzKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXMpLCBcImlzU2lnbmVkXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzKSwgXCJiaXRXaWR0aFwiLCB2b2lkIDApO1xuICAgIF90aGlzLmlzU2lnbmVkID0gaXNTaWduZWQ7XG4gICAgX3RoaXMuYml0V2lkdGggPSBiaXRXaWR0aDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShJbnQsIFt7XG4gICAga2V5OiBcInR5cGVJZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9lbnVtLlR5cGUuSW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogX1N5bWJvbCR0b1N0cmluZ1RhZyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnSW50JztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5pc1NpZ25lZCA/ICdJJyA6ICdVaScsIFwibnRcIikuY29uY2F0KHRoaXMuYml0V2lkdGgpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gSW50O1xufShEYXRhVHlwZSk7XG5cbmV4cG9ydHMuSW50ID0gSW50O1xuXG52YXIgSW50OCA9IGZ1bmN0aW9uIChfSW50KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEludDgsIF9JbnQpO1xuXG4gIHZhciBfc3VwZXI0ID0gX2NyZWF0ZVN1cGVyKEludDgpO1xuXG4gIGZ1bmN0aW9uIEludDgoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgSW50OCk7XG4gICAgcmV0dXJuIF9zdXBlcjQuY2FsbCh0aGlzLCB0cnVlLCA4KTtcbiAgfVxuXG4gIHJldHVybiBJbnQ4O1xufShJbnQpO1xuXG5leHBvcnRzLkludDggPSBJbnQ4O1xuXG52YXIgSW50MTYgPSBmdW5jdGlvbiAoX0ludDIpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoSW50MTYsIF9JbnQyKTtcblxuICB2YXIgX3N1cGVyNSA9IF9jcmVhdGVTdXBlcihJbnQxNik7XG5cbiAgZnVuY3Rpb24gSW50MTYoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgSW50MTYpO1xuICAgIHJldHVybiBfc3VwZXI1LmNhbGwodGhpcywgdHJ1ZSwgMTYpO1xuICB9XG5cbiAgcmV0dXJuIEludDE2O1xufShJbnQpO1xuXG5leHBvcnRzLkludDE2ID0gSW50MTY7XG5cbnZhciBJbnQzMiA9IGZ1bmN0aW9uIChfSW50Mykge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShJbnQzMiwgX0ludDMpO1xuXG4gIHZhciBfc3VwZXI2ID0gX2NyZWF0ZVN1cGVyKEludDMyKTtcblxuICBmdW5jdGlvbiBJbnQzMigpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBJbnQzMik7XG4gICAgcmV0dXJuIF9zdXBlcjYuY2FsbCh0aGlzLCB0cnVlLCAzMik7XG4gIH1cblxuICByZXR1cm4gSW50MzI7XG59KEludCk7XG5cbmV4cG9ydHMuSW50MzIgPSBJbnQzMjtcblxudmFyIEludDY0ID0gZnVuY3Rpb24gKF9JbnQ0KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEludDY0LCBfSW50NCk7XG5cbiAgdmFyIF9zdXBlcjcgPSBfY3JlYXRlU3VwZXIoSW50NjQpO1xuXG4gIGZ1bmN0aW9uIEludDY0KCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEludDY0KTtcbiAgICByZXR1cm4gX3N1cGVyNy5jYWxsKHRoaXMsIHRydWUsIDY0KTtcbiAgfVxuXG4gIHJldHVybiBJbnQ2NDtcbn0oSW50KTtcblxuZXhwb3J0cy5JbnQ2NCA9IEludDY0O1xuXG52YXIgVWludDggPSBmdW5jdGlvbiAoX0ludDUpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoVWludDgsIF9JbnQ1KTtcblxuICB2YXIgX3N1cGVyOCA9IF9jcmVhdGVTdXBlcihVaW50OCk7XG5cbiAgZnVuY3Rpb24gVWludDgoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgVWludDgpO1xuICAgIHJldHVybiBfc3VwZXI4LmNhbGwodGhpcywgZmFsc2UsIDgpO1xuICB9XG5cbiAgcmV0dXJuIFVpbnQ4O1xufShJbnQpO1xuXG5leHBvcnRzLlVpbnQ4ID0gVWludDg7XG5cbnZhciBVaW50MTYgPSBmdW5jdGlvbiAoX0ludDYpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoVWludDE2LCBfSW50Nik7XG5cbiAgdmFyIF9zdXBlcjkgPSBfY3JlYXRlU3VwZXIoVWludDE2KTtcblxuICBmdW5jdGlvbiBVaW50MTYoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgVWludDE2KTtcbiAgICByZXR1cm4gX3N1cGVyOS5jYWxsKHRoaXMsIGZhbHNlLCAxNik7XG4gIH1cblxuICByZXR1cm4gVWludDE2O1xufShJbnQpO1xuXG5leHBvcnRzLlVpbnQxNiA9IFVpbnQxNjtcblxudmFyIFVpbnQzMiA9IGZ1bmN0aW9uIChfSW50Nykge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShVaW50MzIsIF9JbnQ3KTtcblxuICB2YXIgX3N1cGVyMTAgPSBfY3JlYXRlU3VwZXIoVWludDMyKTtcblxuICBmdW5jdGlvbiBVaW50MzIoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgVWludDMyKTtcbiAgICByZXR1cm4gX3N1cGVyMTAuY2FsbCh0aGlzLCBmYWxzZSwgMzIpO1xuICB9XG5cbiAgcmV0dXJuIFVpbnQzMjtcbn0oSW50KTtcblxuZXhwb3J0cy5VaW50MzIgPSBVaW50MzI7XG5cbnZhciBVaW50NjQgPSBmdW5jdGlvbiAoX0ludDgpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoVWludDY0LCBfSW50OCk7XG5cbiAgdmFyIF9zdXBlcjExID0gX2NyZWF0ZVN1cGVyKFVpbnQ2NCk7XG5cbiAgZnVuY3Rpb24gVWludDY0KCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFVpbnQ2NCk7XG4gICAgcmV0dXJuIF9zdXBlcjExLmNhbGwodGhpcywgZmFsc2UsIDY0KTtcbiAgfVxuXG4gIHJldHVybiBVaW50NjQ7XG59KEludCk7XG5cbmV4cG9ydHMuVWludDY0ID0gVWludDY0O1xudmFyIFByZWNpc2lvbiA9IHtcbiAgSEFMRjogMTYsXG4gIFNJTkdMRTogMzIsXG4gIERPVUJMRTogNjRcbn07XG5fU3ltYm9sJHRvU3RyaW5nVGFnMiA9IFN5bWJvbC50b1N0cmluZ1RhZztcblxudmFyIEZsb2F0ID0gZnVuY3Rpb24gKF9EYXRhVHlwZTQpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoRmxvYXQsIF9EYXRhVHlwZTQpO1xuXG4gIHZhciBfc3VwZXIxMiA9IF9jcmVhdGVTdXBlcihGbG9hdCk7XG5cbiAgZnVuY3Rpb24gRmxvYXQocHJlY2lzaW9uKSB7XG4gICAgdmFyIF90aGlzMjtcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEZsb2F0KTtcbiAgICBfdGhpczIgPSBfc3VwZXIxMi5jYWxsKHRoaXMpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczIpLCBcInByZWNpc2lvblwiLCB2b2lkIDApO1xuICAgIF90aGlzMi5wcmVjaXNpb24gPSBwcmVjaXNpb247XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEZsb2F0LCBbe1xuICAgIGtleTogXCJ0eXBlSWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfZW51bS5UeXBlLkZsb2F0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogX1N5bWJvbCR0b1N0cmluZ1RhZzIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ0Zsb2F0JztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCJGbG9hdFwiLmNvbmNhdCh0aGlzLnByZWNpc2lvbik7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBGbG9hdDtcbn0oRGF0YVR5cGUpO1xuXG5leHBvcnRzLkZsb2F0ID0gRmxvYXQ7XG5cbnZhciBGbG9hdDE2ID0gZnVuY3Rpb24gKF9GbG9hdCkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShGbG9hdDE2LCBfRmxvYXQpO1xuXG4gIHZhciBfc3VwZXIxMyA9IF9jcmVhdGVTdXBlcihGbG9hdDE2KTtcblxuICBmdW5jdGlvbiBGbG9hdDE2KCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEZsb2F0MTYpO1xuICAgIHJldHVybiBfc3VwZXIxMy5jYWxsKHRoaXMsIFByZWNpc2lvbi5IQUxGKTtcbiAgfVxuXG4gIHJldHVybiBGbG9hdDE2O1xufShGbG9hdCk7XG5cbmV4cG9ydHMuRmxvYXQxNiA9IEZsb2F0MTY7XG5cbnZhciBGbG9hdDMyID0gZnVuY3Rpb24gKF9GbG9hdDIpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoRmxvYXQzMiwgX0Zsb2F0Mik7XG5cbiAgdmFyIF9zdXBlcjE0ID0gX2NyZWF0ZVN1cGVyKEZsb2F0MzIpO1xuXG4gIGZ1bmN0aW9uIEZsb2F0MzIoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgRmxvYXQzMik7XG4gICAgcmV0dXJuIF9zdXBlcjE0LmNhbGwodGhpcywgUHJlY2lzaW9uLlNJTkdMRSk7XG4gIH1cblxuICByZXR1cm4gRmxvYXQzMjtcbn0oRmxvYXQpO1xuXG5leHBvcnRzLkZsb2F0MzIgPSBGbG9hdDMyO1xuXG52YXIgRmxvYXQ2NCA9IGZ1bmN0aW9uIChfRmxvYXQzKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEZsb2F0NjQsIF9GbG9hdDMpO1xuXG4gIHZhciBfc3VwZXIxNSA9IF9jcmVhdGVTdXBlcihGbG9hdDY0KTtcblxuICBmdW5jdGlvbiBGbG9hdDY0KCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEZsb2F0NjQpO1xuICAgIHJldHVybiBfc3VwZXIxNS5jYWxsKHRoaXMsIFByZWNpc2lvbi5ET1VCTEUpO1xuICB9XG5cbiAgcmV0dXJuIEZsb2F0NjQ7XG59KEZsb2F0KTtcblxuZXhwb3J0cy5GbG9hdDY0ID0gRmxvYXQ2NDtcblxudmFyIEJpbmFyeSA9IGZ1bmN0aW9uIChfRGF0YVR5cGU1KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEJpbmFyeSwgX0RhdGFUeXBlNSk7XG5cbiAgdmFyIF9zdXBlcjE2ID0gX2NyZWF0ZVN1cGVyKEJpbmFyeSk7XG5cbiAgZnVuY3Rpb24gQmluYXJ5KCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEJpbmFyeSk7XG4gICAgcmV0dXJuIF9zdXBlcjE2LmNhbGwodGhpcyk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShCaW5hcnksIFt7XG4gICAga2V5OiBcInR5cGVJZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9lbnVtLlR5cGUuQmluYXJ5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAnQmluYXJ5JztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFN5bWJvbC50b1N0cmluZ1RhZyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnQmluYXJ5JztcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEJpbmFyeTtcbn0oRGF0YVR5cGUpO1xuXG5leHBvcnRzLkJpbmFyeSA9IEJpbmFyeTtcblxudmFyIFV0ZjggPSBmdW5jdGlvbiAoX0RhdGFUeXBlNikge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShVdGY4LCBfRGF0YVR5cGU2KTtcblxuICB2YXIgX3N1cGVyMTcgPSBfY3JlYXRlU3VwZXIoVXRmOCk7XG5cbiAgZnVuY3Rpb24gVXRmOCgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBVdGY4KTtcbiAgICByZXR1cm4gX3N1cGVyMTcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKFV0ZjgsIFt7XG4gICAga2V5OiBcInR5cGVJZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9lbnVtLlR5cGUuVXRmODtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFN5bWJvbC50b1N0cmluZ1RhZyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnVXRmOCc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICdVdGY4JztcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFV0Zjg7XG59KERhdGFUeXBlKTtcblxuZXhwb3J0cy5VdGY4ID0gVXRmODtcbnZhciBEYXRlVW5pdCA9IHtcbiAgREFZOiAwLFxuICBNSUxMSVNFQ09ORDogMVxufTtcbl9TeW1ib2wkdG9TdHJpbmdUYWczID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xuXG52YXIgRGF0ZSA9IGZ1bmN0aW9uIChfRGF0YVR5cGU3KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKERhdGUsIF9EYXRhVHlwZTcpO1xuXG4gIHZhciBfc3VwZXIxOCA9IF9jcmVhdGVTdXBlcihEYXRlKTtcblxuICBmdW5jdGlvbiBEYXRlKHVuaXQpIHtcbiAgICB2YXIgX3RoaXMzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgRGF0ZSk7XG4gICAgX3RoaXMzID0gX3N1cGVyMTguY2FsbCh0aGlzKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXMzKSwgXCJ1bml0XCIsIHZvaWQgMCk7XG4gICAgX3RoaXMzLnVuaXQgPSB1bml0O1xuICAgIHJldHVybiBfdGhpczM7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShEYXRlLCBbe1xuICAgIGtleTogXCJ0eXBlSWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfZW51bS5UeXBlLkRhdGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBfU3ltYm9sJHRvU3RyaW5nVGFnMyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnRGF0ZSc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIFwiRGF0ZVwiLmNvbmNhdCgodGhpcy51bml0ICsgMSkgKiAzMiwgXCI8XCIpLmNvbmNhdChEYXRlVW5pdFt0aGlzLnVuaXRdLCBcIj5cIik7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBEYXRlO1xufShEYXRhVHlwZSk7XG5cbmV4cG9ydHMuRGF0ZSA9IERhdGU7XG5cbnZhciBEYXRlRGF5ID0gZnVuY3Rpb24gKF9EYXRlKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKERhdGVEYXksIF9EYXRlKTtcblxuICB2YXIgX3N1cGVyMTkgPSBfY3JlYXRlU3VwZXIoRGF0ZURheSk7XG5cbiAgZnVuY3Rpb24gRGF0ZURheSgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBEYXRlRGF5KTtcbiAgICByZXR1cm4gX3N1cGVyMTkuY2FsbCh0aGlzLCBEYXRlVW5pdC5EQVkpO1xuICB9XG5cbiAgcmV0dXJuIERhdGVEYXk7XG59KERhdGUpO1xuXG5leHBvcnRzLkRhdGVEYXkgPSBEYXRlRGF5O1xuXG52YXIgRGF0ZU1pbGxpc2Vjb25kID0gZnVuY3Rpb24gKF9EYXRlMikge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShEYXRlTWlsbGlzZWNvbmQsIF9EYXRlMik7XG5cbiAgdmFyIF9zdXBlcjIwID0gX2NyZWF0ZVN1cGVyKERhdGVNaWxsaXNlY29uZCk7XG5cbiAgZnVuY3Rpb24gRGF0ZU1pbGxpc2Vjb25kKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIERhdGVNaWxsaXNlY29uZCk7XG4gICAgcmV0dXJuIF9zdXBlcjIwLmNhbGwodGhpcywgRGF0ZVVuaXQuTUlMTElTRUNPTkQpO1xuICB9XG5cbiAgcmV0dXJuIERhdGVNaWxsaXNlY29uZDtcbn0oRGF0ZSk7XG5cbmV4cG9ydHMuRGF0ZU1pbGxpc2Vjb25kID0gRGF0ZU1pbGxpc2Vjb25kO1xudmFyIFRpbWVVbml0ID0ge1xuICBTRUNPTkQ6IDEsXG4gIE1JTExJU0VDT05EOiAxZTMsXG4gIE1JQ1JPU0VDT05EOiAxZTYsXG4gIE5BTk9TRUNPTkQ6IDFlOVxufTtcbl9TeW1ib2wkdG9TdHJpbmdUYWc0ID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xuXG52YXIgVGltZSA9IGZ1bmN0aW9uIChfRGF0YVR5cGU4KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKFRpbWUsIF9EYXRhVHlwZTgpO1xuXG4gIHZhciBfc3VwZXIyMSA9IF9jcmVhdGVTdXBlcihUaW1lKTtcblxuICBmdW5jdGlvbiBUaW1lKHVuaXQsIGJpdFdpZHRoKSB7XG4gICAgdmFyIF90aGlzNDtcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFRpbWUpO1xuICAgIF90aGlzNCA9IF9zdXBlcjIxLmNhbGwodGhpcyk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzNCksIFwidW5pdFwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczQpLCBcImJpdFdpZHRoXCIsIHZvaWQgMCk7XG4gICAgX3RoaXM0LnVuaXQgPSB1bml0O1xuICAgIF90aGlzNC5iaXRXaWR0aCA9IGJpdFdpZHRoO1xuICAgIHJldHVybiBfdGhpczQ7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShUaW1lLCBbe1xuICAgIGtleTogXCJ0eXBlSWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfZW51bS5UeXBlLlRpbWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIFwiVGltZVwiLmNvbmNhdCh0aGlzLmJpdFdpZHRoLCBcIjxcIikuY29uY2F0KFRpbWVVbml0W3RoaXMudW5pdF0sIFwiPlwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IF9TeW1ib2wkdG9TdHJpbmdUYWc0LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICdUaW1lJztcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFRpbWU7XG59KERhdGFUeXBlKTtcblxuZXhwb3J0cy5UaW1lID0gVGltZTtcblxudmFyIFRpbWVTZWNvbmQgPSBmdW5jdGlvbiAoX1RpbWUpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoVGltZVNlY29uZCwgX1RpbWUpO1xuXG4gIHZhciBfc3VwZXIyMiA9IF9jcmVhdGVTdXBlcihUaW1lU2Vjb25kKTtcblxuICBmdW5jdGlvbiBUaW1lU2Vjb25kKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFRpbWVTZWNvbmQpO1xuICAgIHJldHVybiBfc3VwZXIyMi5jYWxsKHRoaXMsIFRpbWVVbml0LlNFQ09ORCwgMzIpO1xuICB9XG5cbiAgcmV0dXJuIFRpbWVTZWNvbmQ7XG59KFRpbWUpO1xuXG5leHBvcnRzLlRpbWVTZWNvbmQgPSBUaW1lU2Vjb25kO1xuXG52YXIgVGltZU1pbGxpc2Vjb25kID0gZnVuY3Rpb24gKF9UaW1lMikge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShUaW1lTWlsbGlzZWNvbmQsIF9UaW1lMik7XG5cbiAgdmFyIF9zdXBlcjIzID0gX2NyZWF0ZVN1cGVyKFRpbWVNaWxsaXNlY29uZCk7XG5cbiAgZnVuY3Rpb24gVGltZU1pbGxpc2Vjb25kKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFRpbWVNaWxsaXNlY29uZCk7XG4gICAgcmV0dXJuIF9zdXBlcjIzLmNhbGwodGhpcywgVGltZVVuaXQuTUlMTElTRUNPTkQsIDMyKTtcbiAgfVxuXG4gIHJldHVybiBUaW1lTWlsbGlzZWNvbmQ7XG59KFRpbWUpO1xuXG5leHBvcnRzLlRpbWVNaWxsaXNlY29uZCA9IFRpbWVNaWxsaXNlY29uZDtcbl9TeW1ib2wkdG9TdHJpbmdUYWc1ID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xuXG52YXIgVGltZXN0YW1wID0gZnVuY3Rpb24gKF9EYXRhVHlwZTkpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoVGltZXN0YW1wLCBfRGF0YVR5cGU5KTtcblxuICB2YXIgX3N1cGVyMjQgPSBfY3JlYXRlU3VwZXIoVGltZXN0YW1wKTtcblxuICBmdW5jdGlvbiBUaW1lc3RhbXAodW5pdCkge1xuICAgIHZhciBfdGhpczU7XG5cbiAgICB2YXIgdGltZXpvbmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgVGltZXN0YW1wKTtcbiAgICBfdGhpczUgPSBfc3VwZXIyNC5jYWxsKHRoaXMpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczUpLCBcInVuaXRcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXM1KSwgXCJ0aW1lem9uZVwiLCB2b2lkIDApO1xuICAgIF90aGlzNS51bml0ID0gdW5pdDtcbiAgICBfdGhpczUudGltZXpvbmUgPSB0aW1lem9uZTtcbiAgICByZXR1cm4gX3RoaXM1O1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoVGltZXN0YW1wLCBbe1xuICAgIGtleTogXCJ0eXBlSWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfZW51bS5UeXBlLlRpbWVzdGFtcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IF9TeW1ib2wkdG9TdHJpbmdUYWc1LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICdUaW1lc3RhbXAnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcIlRpbWVzdGFtcDxcIi5jb25jYXQoVGltZVVuaXRbdGhpcy51bml0XSkuY29uY2F0KHRoaXMudGltZXpvbmUgPyBcIiwgXCIuY29uY2F0KHRoaXMudGltZXpvbmUpIDogJycsIFwiPlwiKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFRpbWVzdGFtcDtcbn0oRGF0YVR5cGUpO1xuXG5leHBvcnRzLlRpbWVzdGFtcCA9IFRpbWVzdGFtcDtcblxudmFyIFRpbWVzdGFtcFNlY29uZCA9IGZ1bmN0aW9uIChfVGltZXN0YW1wKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKFRpbWVzdGFtcFNlY29uZCwgX1RpbWVzdGFtcCk7XG5cbiAgdmFyIF9zdXBlcjI1ID0gX2NyZWF0ZVN1cGVyKFRpbWVzdGFtcFNlY29uZCk7XG5cbiAgZnVuY3Rpb24gVGltZXN0YW1wU2Vjb25kKCkge1xuICAgIHZhciB0aW1lem9uZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBUaW1lc3RhbXBTZWNvbmQpO1xuICAgIHJldHVybiBfc3VwZXIyNS5jYWxsKHRoaXMsIFRpbWVVbml0LlNFQ09ORCwgdGltZXpvbmUpO1xuICB9XG5cbiAgcmV0dXJuIFRpbWVzdGFtcFNlY29uZDtcbn0oVGltZXN0YW1wKTtcblxuZXhwb3J0cy5UaW1lc3RhbXBTZWNvbmQgPSBUaW1lc3RhbXBTZWNvbmQ7XG5cbnZhciBUaW1lc3RhbXBNaWxsaXNlY29uZCA9IGZ1bmN0aW9uIChfVGltZXN0YW1wMikge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShUaW1lc3RhbXBNaWxsaXNlY29uZCwgX1RpbWVzdGFtcDIpO1xuXG4gIHZhciBfc3VwZXIyNiA9IF9jcmVhdGVTdXBlcihUaW1lc3RhbXBNaWxsaXNlY29uZCk7XG5cbiAgZnVuY3Rpb24gVGltZXN0YW1wTWlsbGlzZWNvbmQoKSB7XG4gICAgdmFyIHRpbWV6b25lID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFRpbWVzdGFtcE1pbGxpc2Vjb25kKTtcbiAgICByZXR1cm4gX3N1cGVyMjYuY2FsbCh0aGlzLCBUaW1lVW5pdC5NSUxMSVNFQ09ORCwgdGltZXpvbmUpO1xuICB9XG5cbiAgcmV0dXJuIFRpbWVzdGFtcE1pbGxpc2Vjb25kO1xufShUaW1lc3RhbXApO1xuXG5leHBvcnRzLlRpbWVzdGFtcE1pbGxpc2Vjb25kID0gVGltZXN0YW1wTWlsbGlzZWNvbmQ7XG5cbnZhciBUaW1lc3RhbXBNaWNyb3NlY29uZCA9IGZ1bmN0aW9uIChfVGltZXN0YW1wMykge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShUaW1lc3RhbXBNaWNyb3NlY29uZCwgX1RpbWVzdGFtcDMpO1xuXG4gIHZhciBfc3VwZXIyNyA9IF9jcmVhdGVTdXBlcihUaW1lc3RhbXBNaWNyb3NlY29uZCk7XG5cbiAgZnVuY3Rpb24gVGltZXN0YW1wTWljcm9zZWNvbmQoKSB7XG4gICAgdmFyIHRpbWV6b25lID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFRpbWVzdGFtcE1pY3Jvc2Vjb25kKTtcbiAgICByZXR1cm4gX3N1cGVyMjcuY2FsbCh0aGlzLCBUaW1lVW5pdC5NSUNST1NFQ09ORCwgdGltZXpvbmUpO1xuICB9XG5cbiAgcmV0dXJuIFRpbWVzdGFtcE1pY3Jvc2Vjb25kO1xufShUaW1lc3RhbXApO1xuXG5leHBvcnRzLlRpbWVzdGFtcE1pY3Jvc2Vjb25kID0gVGltZXN0YW1wTWljcm9zZWNvbmQ7XG5cbnZhciBUaW1lc3RhbXBOYW5vc2Vjb25kID0gZnVuY3Rpb24gKF9UaW1lc3RhbXA0KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKFRpbWVzdGFtcE5hbm9zZWNvbmQsIF9UaW1lc3RhbXA0KTtcblxuICB2YXIgX3N1cGVyMjggPSBfY3JlYXRlU3VwZXIoVGltZXN0YW1wTmFub3NlY29uZCk7XG5cbiAgZnVuY3Rpb24gVGltZXN0YW1wTmFub3NlY29uZCgpIHtcbiAgICB2YXIgdGltZXpvbmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgVGltZXN0YW1wTmFub3NlY29uZCk7XG4gICAgcmV0dXJuIF9zdXBlcjI4LmNhbGwodGhpcywgVGltZVVuaXQuTkFOT1NFQ09ORCwgdGltZXpvbmUpO1xuICB9XG5cbiAgcmV0dXJuIFRpbWVzdGFtcE5hbm9zZWNvbmQ7XG59KFRpbWVzdGFtcCk7XG5cbmV4cG9ydHMuVGltZXN0YW1wTmFub3NlY29uZCA9IFRpbWVzdGFtcE5hbm9zZWNvbmQ7XG52YXIgSW50ZXJ2YWxVbml0ID0ge1xuICBEQVlfVElNRTogMCxcbiAgWUVBUl9NT05USDogMVxufTtcbl9TeW1ib2wkdG9TdHJpbmdUYWc2ID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xuXG52YXIgSW50ZXJ2YWwgPSBmdW5jdGlvbiAoX0RhdGFUeXBlMTApIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoSW50ZXJ2YWwsIF9EYXRhVHlwZTEwKTtcblxuICB2YXIgX3N1cGVyMjkgPSBfY3JlYXRlU3VwZXIoSW50ZXJ2YWwpO1xuXG4gIGZ1bmN0aW9uIEludGVydmFsKHVuaXQpIHtcbiAgICB2YXIgX3RoaXM2O1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgSW50ZXJ2YWwpO1xuICAgIF90aGlzNiA9IF9zdXBlcjI5LmNhbGwodGhpcyk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzNiksIFwidW5pdFwiLCB2b2lkIDApO1xuICAgIF90aGlzNi51bml0ID0gdW5pdDtcbiAgICByZXR1cm4gX3RoaXM2O1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoSW50ZXJ2YWwsIFt7XG4gICAga2V5OiBcInR5cGVJZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9lbnVtLlR5cGUuSW50ZXJ2YWw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBfU3ltYm9sJHRvU3RyaW5nVGFnNixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnSW50ZXJ2YWwnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcIkludGVydmFsPFwiLmNvbmNhdChJbnRlcnZhbFVuaXRbdGhpcy51bml0XSwgXCI+XCIpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gSW50ZXJ2YWw7XG59KERhdGFUeXBlKTtcblxuZXhwb3J0cy5JbnRlcnZhbCA9IEludGVydmFsO1xuXG52YXIgSW50ZXJ2YWxEYXlUaW1lID0gZnVuY3Rpb24gKF9JbnRlcnZhbCkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShJbnRlcnZhbERheVRpbWUsIF9JbnRlcnZhbCk7XG5cbiAgdmFyIF9zdXBlcjMwID0gX2NyZWF0ZVN1cGVyKEludGVydmFsRGF5VGltZSk7XG5cbiAgZnVuY3Rpb24gSW50ZXJ2YWxEYXlUaW1lKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEludGVydmFsRGF5VGltZSk7XG4gICAgcmV0dXJuIF9zdXBlcjMwLmNhbGwodGhpcywgSW50ZXJ2YWxVbml0LkRBWV9USU1FKTtcbiAgfVxuXG4gIHJldHVybiBJbnRlcnZhbERheVRpbWU7XG59KEludGVydmFsKTtcblxuZXhwb3J0cy5JbnRlcnZhbERheVRpbWUgPSBJbnRlcnZhbERheVRpbWU7XG5cbnZhciBJbnRlcnZhbFllYXJNb250aCA9IGZ1bmN0aW9uIChfSW50ZXJ2YWwyKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEludGVydmFsWWVhck1vbnRoLCBfSW50ZXJ2YWwyKTtcblxuICB2YXIgX3N1cGVyMzEgPSBfY3JlYXRlU3VwZXIoSW50ZXJ2YWxZZWFyTW9udGgpO1xuXG4gIGZ1bmN0aW9uIEludGVydmFsWWVhck1vbnRoKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEludGVydmFsWWVhck1vbnRoKTtcbiAgICByZXR1cm4gX3N1cGVyMzEuY2FsbCh0aGlzLCBJbnRlcnZhbFVuaXQuWUVBUl9NT05USCk7XG4gIH1cblxuICByZXR1cm4gSW50ZXJ2YWxZZWFyTW9udGg7XG59KEludGVydmFsKTtcblxuZXhwb3J0cy5JbnRlcnZhbFllYXJNb250aCA9IEludGVydmFsWWVhck1vbnRoO1xuX1N5bWJvbCR0b1N0cmluZ1RhZzcgPSBTeW1ib2wudG9TdHJpbmdUYWc7XG5cbnZhciBGaXhlZFNpemVMaXN0ID0gZnVuY3Rpb24gKF9EYXRhVHlwZTExKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEZpeGVkU2l6ZUxpc3QsIF9EYXRhVHlwZTExKTtcblxuICB2YXIgX3N1cGVyMzIgPSBfY3JlYXRlU3VwZXIoRml4ZWRTaXplTGlzdCk7XG5cbiAgZnVuY3Rpb24gRml4ZWRTaXplTGlzdChsaXN0U2l6ZSwgY2hpbGQpIHtcbiAgICB2YXIgX3RoaXM3O1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgRml4ZWRTaXplTGlzdCk7XG4gICAgX3RoaXM3ID0gX3N1cGVyMzIuY2FsbCh0aGlzKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXM3KSwgXCJsaXN0U2l6ZVwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczcpLCBcImNoaWxkcmVuXCIsIHZvaWQgMCk7XG4gICAgX3RoaXM3Lmxpc3RTaXplID0gbGlzdFNpemU7XG4gICAgX3RoaXM3LmNoaWxkcmVuID0gW2NoaWxkXTtcbiAgICByZXR1cm4gX3RoaXM3O1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoRml4ZWRTaXplTGlzdCwgW3tcbiAgICBrZXk6IFwidHlwZUlkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2VudW0uVHlwZS5GaXhlZFNpemVMaXN0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZVR5cGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuWzBdLnR5cGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlRmllbGRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuWzBdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogX1N5bWJvbCR0b1N0cmluZ1RhZzcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ0ZpeGVkU2l6ZUxpc3QnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcIkZpeGVkU2l6ZUxpc3RbXCIuY29uY2F0KHRoaXMubGlzdFNpemUsIFwiXTxcIikuY29uY2F0KHRoaXMudmFsdWVUeXBlLCBcIj5cIik7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBGaXhlZFNpemVMaXN0O1xufShEYXRhVHlwZSk7XG5cbmV4cG9ydHMuRml4ZWRTaXplTGlzdCA9IEZpeGVkU2l6ZUxpc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNjaGVtYVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmllbGRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ZpZWxkLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHlwZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5UeXBlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRhdGFUeXBlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLkRhdGFUeXBlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk51bGxcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuTnVsbDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCb29sXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLkJvb2w7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW50XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLkludDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnQ4XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLkludDg7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW50MTZcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuSW50MTY7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW50MzJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuSW50MzI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW50NjRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuSW50NjQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVWludDhcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuVWludDg7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVWludDE2XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLlVpbnQxNjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVaW50MzJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuVWludDMyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVpbnQ2NFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5VaW50NjQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmxvYXRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuRmxvYXQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmxvYXQxNlwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5GbG9hdDE2O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZsb2F0MzJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuRmxvYXQzMjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGbG9hdDY0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLkZsb2F0NjQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmluYXJ5XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLkJpbmFyeTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVdGY4XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLlV0Zjg7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGF0ZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5EYXRlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRhdGVEYXlcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuRGF0ZURheTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEYXRlTWlsbGlzZWNvbmRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuRGF0ZU1pbGxpc2Vjb25kO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRpbWVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuVGltZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUaW1lU2Vjb25kXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLlRpbWVTZWNvbmQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGltZU1pbGxpc2Vjb25kXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLlRpbWVNaWxsaXNlY29uZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUaW1lc3RhbXBcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuVGltZXN0YW1wO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRpbWVzdGFtcFNlY29uZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5UaW1lc3RhbXBTZWNvbmQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGltZXN0YW1wTWlsbGlzZWNvbmRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuVGltZXN0YW1wTWlsbGlzZWNvbmQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGltZXN0YW1wTWljcm9zZWNvbmRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuVGltZXN0YW1wTWljcm9zZWNvbmQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGltZXN0YW1wTmFub3NlY29uZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5UaW1lc3RhbXBOYW5vc2Vjb25kO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludGVydmFsXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLkludGVydmFsO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludGVydmFsRGF5VGltZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5JbnRlcnZhbERheVRpbWU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW50ZXJ2YWxZZWFyTW9udGhcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuSW50ZXJ2YWxZZWFyTW9udGg7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRml4ZWRTaXplTGlzdFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5GaXhlZFNpemVMaXN0O1xuICB9XG59KTtcblxudmFyIF9zY2hlbWEgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2ltcGwvc2NoZW1hXCIpKTtcblxudmFyIF9maWVsZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaW1wbC9maWVsZFwiKSk7XG5cbnZhciBfdHlwZSA9IHJlcXVpcmUoXCIuL2ltcGwvdHlwZVwiKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIERFRkFVTFRfUk9XX0NPVU5UID0gMTAwO1xuXG52YXIgUm93VGFibGVCYXRjaEFnZ3JlZ2F0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJvd1RhYmxlQmF0Y2hBZ2dyZWdhdG9yKHNjaGVtYSwgb3B0aW9ucykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFJvd1RhYmxlQmF0Y2hBZ2dyZWdhdG9yKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcInNjaGVtYVwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwibGVuZ3RoXCIsIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwicm93c1wiLCBudWxsKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcImN1cnNvclwiLCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcIl9oZWFkZXJzXCIsIFtdKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICAgIHRoaXMuX2hlYWRlcnMgPSBbXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNjaGVtYSkge1xuICAgICAgICB0aGlzLl9oZWFkZXJzW3NjaGVtYVtrZXldLmluZGV4XSA9IHNjaGVtYVtrZXldLm5hbWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoUm93VGFibGVCYXRjaEFnZ3JlZ2F0b3IsIFt7XG4gICAga2V5OiBcInJvd0NvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvd0NvdW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRBcnJheVJvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRBcnJheVJvdyhyb3csIGN1cnNvcikge1xuICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShjdXJzb3IpKSB7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gY3Vyc29yO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJvd3MgPSB0aGlzLnJvd3MgfHwgbmV3IEFycmF5KERFRkFVTFRfUk9XX0NPVU5UKTtcbiAgICAgIHRoaXMucm93c1t0aGlzLmxlbmd0aF0gPSByb3c7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRPYmplY3RSb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkT2JqZWN0Um93KHJvdywgY3Vyc29yKSB7XG4gICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGN1cnNvcikpIHtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBjdXJzb3I7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucm93cyA9IHRoaXMucm93cyB8fCBuZXcgQXJyYXkoREVGQVVMVF9ST1dfQ09VTlQpO1xuICAgICAgdGhpcy5yb3dzW3RoaXMubGVuZ3RoXSA9IHJvdztcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEJhdGNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJhdGNoKCkge1xuICAgICAgdmFyIHJvd3MgPSB0aGlzLnJvd3M7XG5cbiAgICAgIGlmICghcm93cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcm93cyA9IHJvd3Muc2xpY2UoMCwgdGhpcy5sZW5ndGgpO1xuICAgICAgdGhpcy5yb3dzID0gbnVsbDtcbiAgICAgIHZhciBiYXRjaCA9IHtcbiAgICAgICAgc2hhcGU6IHRoaXMub3B0aW9ucy5zaGFwZSxcbiAgICAgICAgYmF0Y2hUeXBlOiAnZGF0YScsXG4gICAgICAgIGRhdGE6IHJvd3MsXG4gICAgICAgIGxlbmd0aDogdGhpcy5sZW5ndGgsXG4gICAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWEsXG4gICAgICAgIGN1cnNvcjogdGhpcy5jdXJzb3JcbiAgICAgIH07XG4gICAgICByZXR1cm4gYmF0Y2g7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBSb3dUYWJsZUJhdGNoQWdncmVnYXRvcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUm93VGFibGVCYXRjaEFnZ3JlZ2F0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLXRhYmxlLWJhdGNoLWFnZ3JlZ2F0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5XCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIERFRkFVTFRfUk9XX0NPVU5UID0gMTAwO1xuXG52YXIgQ29sdW1uYXJUYWJsZUJhdGNoQWdncmVnYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29sdW1uYXJUYWJsZUJhdGNoQWdncmVnYXRvcihzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBDb2x1bW5hclRhYmxlQmF0Y2hBZ2dyZWdhdG9yKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcInNjaGVtYVwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwibGVuZ3RoXCIsIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiYWxsb2NhdGVkXCIsIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiY29sdW1uc1wiLCB7fSk7XG4gICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG5cbiAgICB0aGlzLl9yZWFsbG9jYXRlQ29sdW1ucygpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoQ29sdW1uYXJUYWJsZUJhdGNoQWdncmVnYXRvciwgW3tcbiAgICBrZXk6IFwicm93Q291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcm93Q291bnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZEFycmF5Um93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEFycmF5Um93KHJvdykge1xuICAgICAgdGhpcy5fcmVhbGxvY2F0ZUNvbHVtbnMoKTtcblxuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICBmb3IgKHZhciBmaWVsZE5hbWUgaW4gdGhpcy5jb2x1bW5zKSB7XG4gICAgICAgIHRoaXMuY29sdW1uc1tmaWVsZE5hbWVdW3RoaXMubGVuZ3RoXSA9IHJvd1tpKytdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRPYmplY3RSb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkT2JqZWN0Um93KHJvdykge1xuICAgICAgdGhpcy5fcmVhbGxvY2F0ZUNvbHVtbnMoKTtcblxuICAgICAgZm9yICh2YXIgZmllbGROYW1lIGluIHJvdykge1xuICAgICAgICB0aGlzLmNvbHVtbnNbZmllbGROYW1lXVt0aGlzLmxlbmd0aF0gPSByb3dbZmllbGROYW1lXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QmF0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QmF0Y2goKSB7XG4gICAgICB0aGlzLl9wcnVuZUNvbHVtbnMoKTtcblxuICAgICAgdmFyIGNvbHVtbnMgPSBBcnJheS5pc0FycmF5KHRoaXMuc2NoZW1hKSA/IHRoaXMuY29sdW1ucyA6IHt9O1xuXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy5zY2hlbWEpKSB7XG4gICAgICAgIGZvciAodmFyIGZpZWxkTmFtZSBpbiB0aGlzLnNjaGVtYSkge1xuICAgICAgICAgIHZhciBmaWVsZCA9IHRoaXMuc2NoZW1hW2ZpZWxkTmFtZV07XG4gICAgICAgICAgY29sdW1uc1tmaWVsZC5uYW1lXSA9IHRoaXMuY29sdW1uc1tmaWVsZC5pbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5jb2x1bW5zID0ge307XG4gICAgICB2YXIgYmF0Y2ggPSB7XG4gICAgICAgIHNoYXBlOiAnY29sdW1uYXItdGFibGUnLFxuICAgICAgICBiYXRjaFR5cGU6ICdkYXRhJyxcbiAgICAgICAgZGF0YTogY29sdW1ucyxcbiAgICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgICAgbGVuZ3RoOiB0aGlzLmxlbmd0aFxuICAgICAgfTtcbiAgICAgIHJldHVybiBiYXRjaDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlYWxsb2NhdGVDb2x1bW5zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWFsbG9jYXRlQ29sdW1ucygpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA8IHRoaXMuYWxsb2NhdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hbGxvY2F0ZWQgPSB0aGlzLmFsbG9jYXRlZCA+IDAgPyB0aGlzLmFsbG9jYXRlZCAqPSAyIDogREVGQVVMVF9ST1dfQ09VTlQ7XG4gICAgICB0aGlzLmNvbHVtbnMgPSB7fTtcblxuICAgICAgZm9yICh2YXIgZmllbGROYW1lIGluIHRoaXMuc2NoZW1hKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IHRoaXMuc2NoZW1hW2ZpZWxkTmFtZV07XG4gICAgICAgIHZhciBBcnJheVR5cGUgPSBmaWVsZC50eXBlIHx8IEZsb2F0MzJBcnJheTtcbiAgICAgICAgdmFyIG9sZENvbHVtbiA9IHRoaXMuY29sdW1uc1tmaWVsZC5pbmRleF07XG5cbiAgICAgICAgaWYgKG9sZENvbHVtbiAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcob2xkQ29sdW1uKSkge1xuICAgICAgICAgIHZhciB0eXBlZEFycmF5ID0gbmV3IEFycmF5VHlwZSh0aGlzLmFsbG9jYXRlZCk7XG4gICAgICAgICAgdHlwZWRBcnJheS5zZXQob2xkQ29sdW1uKTtcbiAgICAgICAgICB0aGlzLmNvbHVtbnNbZmllbGQuaW5kZXhdID0gdHlwZWRBcnJheTtcbiAgICAgICAgfSBlbHNlIGlmIChvbGRDb2x1bW4pIHtcbiAgICAgICAgICBvbGRDb2x1bW4ubGVuZ3RoID0gdGhpcy5hbGxvY2F0ZWQ7XG4gICAgICAgICAgdGhpcy5jb2x1bW5zW2ZpZWxkLmluZGV4XSA9IG9sZENvbHVtbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNvbHVtbnNbZmllbGQuaW5kZXhdID0gbmV3IEFycmF5VHlwZSh0aGlzLmFsbG9jYXRlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3BydW5lQ29sdW1uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJ1bmVDb2x1bW5zKCkge1xuICAgICAgZm9yICh2YXIgX2kgPSAwLCBfT2JqZWN0JGVudHJpZXMgPSBPYmplY3QuZW50cmllcyh0aGlzLmNvbHVtbnMpOyBfaSA8IF9PYmplY3QkZW50cmllcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIF9PYmplY3QkZW50cmllcyRfaSA9ICgwLCBfc2xpY2VkVG9BcnJheTIuZGVmYXVsdCkoX09iamVjdCRlbnRyaWVzW19pXSwgMiksXG4gICAgICAgICAgICBfY29sdW1uTmFtZSA9IF9PYmplY3QkZW50cmllcyRfaVswXSxcbiAgICAgICAgICAgIGNvbHVtbiA9IF9PYmplY3QkZW50cmllcyRfaVsxXTtcblxuICAgICAgICB0aGlzLmNvbHVtbnNbX2NvbHVtbk5hbWVdID0gY29sdW1uLnNsaWNlKDAsIHRoaXMubGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENvbHVtbmFyVGFibGVCYXRjaEFnZ3JlZ2F0b3I7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENvbHVtbmFyVGFibGVCYXRjaEFnZ3JlZ2F0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2x1bW5hci10YWJsZS1iYXRjaC1hZ2dyZWdhdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9yb3dVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy9yb3ctdXRpbHNcIik7XG5cbnZhciBERUZBVUxUX1JPV19DT1VOVCA9IDEwMDtcblxudmFyIFJvd1RhYmxlQmF0Y2hBZ2dyZWdhdG9yID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSb3dUYWJsZUJhdGNoQWdncmVnYXRvcihzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBSb3dUYWJsZUJhdGNoQWdncmVnYXRvcik7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJzY2hlbWFcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcImxlbmd0aFwiLCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcIm9iamVjdFJvd3NcIiwgbnVsbCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJhcnJheVJvd3NcIiwgbnVsbCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJjdXJzb3JcIiwgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJfaGVhZGVyc1wiLCBbXSk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgICB0aGlzLl9oZWFkZXJzID0gW107XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgdGhpcy5faGVhZGVyc1tzY2hlbWFba2V5XS5pbmRleF0gPSBzY2hlbWFba2V5XS5uYW1lO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKFJvd1RhYmxlQmF0Y2hBZ2dyZWdhdG9yLCBbe1xuICAgIGtleTogXCJyb3dDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByb3dDb3VudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkQXJyYXlSb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQXJyYXlSb3cocm93LCBjdXJzb3IpIHtcbiAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoY3Vyc29yKSkge1xuICAgICAgICB0aGlzLmN1cnNvciA9IGN1cnNvcjtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh0aGlzLm9wdGlvbnMuc2hhcGUpIHtcbiAgICAgICAgY2FzZSAnb2JqZWN0LXJvdy10YWJsZSc6XG4gICAgICAgICAgdmFyIHJvd09iamVjdCA9ICgwLCBfcm93VXRpbHMuY29udmVydFRvT2JqZWN0Um93KShyb3csIHRoaXMuX2hlYWRlcnMpO1xuICAgICAgICAgIHRoaXMuYWRkT2JqZWN0Um93KHJvd09iamVjdCwgY3Vyc29yKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdhcnJheS1yb3ctdGFibGUnOlxuICAgICAgICAgIHRoaXMuYXJyYXlSb3dzID0gdGhpcy5hcnJheVJvd3MgfHwgbmV3IEFycmF5KERFRkFVTFRfUk9XX0NPVU5UKTtcbiAgICAgICAgICB0aGlzLmFycmF5Um93c1t0aGlzLmxlbmd0aF0gPSByb3c7XG4gICAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkT2JqZWN0Um93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE9iamVjdFJvdyhyb3csIGN1cnNvcikge1xuICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShjdXJzb3IpKSB7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gY3Vyc29yO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHRoaXMub3B0aW9ucy5zaGFwZSkge1xuICAgICAgICBjYXNlICdhcnJheS1yb3ctdGFibGUnOlxuICAgICAgICAgIHZhciByb3dBcnJheSA9ICgwLCBfcm93VXRpbHMuY29udmVydFRvQXJyYXlSb3cpKHJvdywgdGhpcy5faGVhZGVycyk7XG4gICAgICAgICAgdGhpcy5hZGRBcnJheVJvdyhyb3dBcnJheSwgY3Vyc29yKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdvYmplY3Qtcm93LXRhYmxlJzpcbiAgICAgICAgICB0aGlzLm9iamVjdFJvd3MgPSB0aGlzLm9iamVjdFJvd3MgfHwgbmV3IEFycmF5KERFRkFVTFRfUk9XX0NPVU5UKTtcbiAgICAgICAgICB0aGlzLm9iamVjdFJvd3NbdGhpcy5sZW5ndGhdID0gcm93O1xuICAgICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEJhdGNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJhdGNoKCkge1xuICAgICAgdmFyIHJvd3MgPSB0aGlzLmFycmF5Um93cyB8fCB0aGlzLm9iamVjdFJvd3M7XG5cbiAgICAgIGlmICghcm93cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcm93cyA9IHJvd3Muc2xpY2UoMCwgdGhpcy5sZW5ndGgpO1xuICAgICAgdGhpcy5hcnJheVJvd3MgPSBudWxsO1xuICAgICAgdGhpcy5vYmplY3RSb3dzID0gbnVsbDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNoYXBlOiB0aGlzLm9wdGlvbnMuc2hhcGUsXG4gICAgICAgIGJhdGNoVHlwZTogJ2RhdGEnLFxuICAgICAgICBkYXRhOiByb3dzLFxuICAgICAgICBsZW5ndGg6IHRoaXMubGVuZ3RoLFxuICAgICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgICBjdXJzb3I6IHRoaXMuY3Vyc29yXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUm93VGFibGVCYXRjaEFnZ3JlZ2F0b3I7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJvd1RhYmxlQmF0Y2hBZ2dyZWdhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm93LXRhYmxlLWJhdGNoLWFnZ3JlZ2F0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX2Jhc2VUYWJsZUJhdGNoQWdncmVnYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYmFzZS10YWJsZS1iYXRjaC1hZ2dyZWdhdG9yXCIpKTtcblxudmFyIF9yb3dUYWJsZUJhdGNoQWdncmVnYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcm93LXRhYmxlLWJhdGNoLWFnZ3JlZ2F0b3JcIikpO1xuXG52YXIgX2NvbHVtbmFyVGFibGVCYXRjaEFnZ3JlZ2F0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbHVtbmFyLXRhYmxlLWJhdGNoLWFnZ3JlZ2F0b3JcIikpO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgc2hhcGU6ICdhcnJheS1yb3ctdGFibGUnLFxuICBiYXRjaFNpemU6ICdhdXRvJyxcbiAgYmF0Y2hEZWJvdW5jZU1zOiAwLFxuICBsaW1pdDogMCxcbiAgX2xpbWl0TUI6IDBcbn07XG52YXIgRVJSX01FU1NBR0UgPSAnVGFibGVCYXRjaEJ1aWxkZXInO1xuXG52YXIgVGFibGVCYXRjaEJ1aWxkZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRhYmxlQmF0Y2hCdWlsZGVyKHNjaGVtYSwgb3B0aW9ucykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFRhYmxlQmF0Y2hCdWlsZGVyKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcInNjaGVtYVwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiYWdncmVnYXRvclwiLCBudWxsKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcImJhdGNoQ291bnRcIiwgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJieXRlc1VzZWRcIiwgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJpc0NodW5rQ29tcGxldGVcIiwgZmFsc2UpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwibGFzdEJhdGNoRW1pdHRlZE1zXCIsIERhdGUubm93KCkpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwidG90YWxMZW5ndGhcIiwgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJ0b3RhbEJ5dGVzXCIsIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwicm93Qnl0ZXNcIiwgMCk7XG4gICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgdGhpcy5vcHRpb25zID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBERUZBVUxUX09QVElPTlMpLCBvcHRpb25zKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKFRhYmxlQmF0Y2hCdWlsZGVyLCBbe1xuICAgIGtleTogXCJsaW1pdFJlYWNoZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGltaXRSZWFjaGVkKCkge1xuICAgICAgdmFyIF90aGlzJG9wdGlvbnMsIF90aGlzJG9wdGlvbnMyO1xuXG4gICAgICBpZiAoQm9vbGVhbigoX3RoaXMkb3B0aW9ucyA9IHRoaXMub3B0aW9ucykgPT09IG51bGwgfHwgX3RoaXMkb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkb3B0aW9ucy5saW1pdCkgJiYgdGhpcy50b3RhbExlbmd0aCA+PSB0aGlzLm9wdGlvbnMubGltaXQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChCb29sZWFuKChfdGhpcyRvcHRpb25zMiA9IHRoaXMub3B0aW9ucykgPT09IG51bGwgfHwgX3RoaXMkb3B0aW9uczIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJG9wdGlvbnMyLl9saW1pdE1CKSAmJiB0aGlzLnRvdGFsQnl0ZXMgLyAxZTYgPj0gdGhpcy5vcHRpb25zLl9saW1pdE1CKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFJvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRSb3cocm93KSB7XG4gICAgICBpZiAodGhpcy5saW1pdFJlYWNoZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMudG90YWxMZW5ndGgrKztcbiAgICAgIHRoaXMucm93Qnl0ZXMgPSB0aGlzLnJvd0J5dGVzIHx8IHRoaXMuX2VzdGltYXRlUm93TUIocm93KTtcbiAgICAgIHRoaXMudG90YWxCeXRlcyArPSB0aGlzLnJvd0J5dGVzO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyb3cpKSB7XG4gICAgICAgIHRoaXMuYWRkQXJyYXlSb3cocm93KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRkT2JqZWN0Um93KHJvdyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZEFycmF5Um93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEFycmF5Um93KHJvdykge1xuICAgICAgaWYgKCF0aGlzLmFnZ3JlZ2F0b3IpIHtcbiAgICAgICAgdmFyIFRhYmxlQmF0Y2hUeXBlID0gdGhpcy5fZ2V0VGFibGVCYXRjaFR5cGUoKTtcblxuICAgICAgICB0aGlzLmFnZ3JlZ2F0b3IgPSBuZXcgVGFibGVCYXRjaFR5cGUodGhpcy5zY2hlbWEsIHRoaXMub3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWdncmVnYXRvci5hZGRBcnJheVJvdyhyb3cpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRPYmplY3RSb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkT2JqZWN0Um93KHJvdykge1xuICAgICAgaWYgKCF0aGlzLmFnZ3JlZ2F0b3IpIHtcbiAgICAgICAgdmFyIFRhYmxlQmF0Y2hUeXBlID0gdGhpcy5fZ2V0VGFibGVCYXRjaFR5cGUoKTtcblxuICAgICAgICB0aGlzLmFnZ3JlZ2F0b3IgPSBuZXcgVGFibGVCYXRjaFR5cGUodGhpcy5zY2hlbWEsIHRoaXMub3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWdncmVnYXRvci5hZGRPYmplY3RSb3cocm93KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2h1bmtDb21wbGV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaHVua0NvbXBsZXRlKGNodW5rKSB7XG4gICAgICBpZiAoY2h1bmsgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICB0aGlzLmJ5dGVzVXNlZCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLmJ5dGVzVXNlZCArPSBjaHVuay5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaXNDaHVua0NvbXBsZXRlID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RnVsbEJhdGNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZ1bGxCYXRjaChvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXNGdWxsKCkgPyB0aGlzLl9nZXRCYXRjaChvcHRpb25zKSA6IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZpbmFsQmF0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RmluYWxCYXRjaChvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0QmF0Y2gob3B0aW9ucyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9lc3RpbWF0ZVJvd01CXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lc3RpbWF0ZVJvd01CKHJvdykge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocm93KSA/IHJvdy5sZW5ndGggKiA4IDogT2JqZWN0LmtleXMocm93KS5sZW5ndGggKiA4O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaXNGdWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pc0Z1bGwoKSB7XG4gICAgICBpZiAoIXRoaXMuYWdncmVnYXRvciB8fCB0aGlzLmFnZ3JlZ2F0b3Iucm93Q291bnQoKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmF0Y2hTaXplID09PSAnYXV0bycpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ2h1bmtDb21wbGV0ZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuYmF0Y2hTaXplID4gdGhpcy5hZ2dyZWdhdG9yLnJvd0NvdW50KCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmJhdGNoRGVib3VuY2VNcyA+IERhdGUubm93KCkgLSB0aGlzLmxhc3RCYXRjaEVtaXR0ZWRNcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaXNDaHVua0NvbXBsZXRlID0gZmFsc2U7XG4gICAgICB0aGlzLmxhc3RCYXRjaEVtaXR0ZWRNcyA9IERhdGUubm93KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEJhdGNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRCYXRjaChvcHRpb25zKSB7XG4gICAgICBpZiAoIXRoaXMuYWdncmVnYXRvcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwICYmIG9wdGlvbnMuYnl0ZXNVc2VkKSB7XG4gICAgICAgIHRoaXMuYnl0ZXNVc2VkID0gb3B0aW9ucy5ieXRlc1VzZWQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBub3JtYWxpemVkQmF0Y2ggPSB0aGlzLmFnZ3JlZ2F0b3IuZ2V0QmF0Y2goKTtcbiAgICAgIG5vcm1hbGl6ZWRCYXRjaC5jb3VudCA9IHRoaXMuYmF0Y2hDb3VudDtcbiAgICAgIG5vcm1hbGl6ZWRCYXRjaC5ieXRlc1VzZWQgPSB0aGlzLmJ5dGVzVXNlZDtcbiAgICAgIE9iamVjdC5hc3NpZ24obm9ybWFsaXplZEJhdGNoLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuYmF0Y2hDb3VudCsrO1xuICAgICAgdGhpcy5hZ2dyZWdhdG9yID0gbnVsbDtcbiAgICAgIHJldHVybiBub3JtYWxpemVkQmF0Y2g7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRUYWJsZUJhdGNoVHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VGFibGVCYXRjaFR5cGUoKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMub3B0aW9ucy5zaGFwZSkge1xuICAgICAgICBjYXNlICdyb3ctdGFibGUnOlxuICAgICAgICAgIHJldHVybiBfYmFzZVRhYmxlQmF0Y2hBZ2dyZWdhdG9yLmRlZmF1bHQ7XG5cbiAgICAgICAgY2FzZSAnYXJyYXktcm93LXRhYmxlJzpcbiAgICAgICAgY2FzZSAnb2JqZWN0LXJvdy10YWJsZSc6XG4gICAgICAgICAgcmV0dXJuIF9yb3dUYWJsZUJhdGNoQWdncmVnYXRvci5kZWZhdWx0O1xuXG4gICAgICAgIGNhc2UgJ2NvbHVtbmFyLXRhYmxlJzpcbiAgICAgICAgICByZXR1cm4gX2NvbHVtbmFyVGFibGVCYXRjaEFnZ3JlZ2F0b3IuZGVmYXVsdDtcblxuICAgICAgICBjYXNlICdhcnJvdy10YWJsZSc6XG4gICAgICAgICAgaWYgKCFUYWJsZUJhdGNoQnVpbGRlci5BcnJvd0JhdGNoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJSX01FU1NBR0UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBUYWJsZUJhdGNoQnVpbGRlci5BcnJvd0JhdGNoO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUl9NRVNTQUdFKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFRhYmxlQmF0Y2hCdWlsZGVyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBUYWJsZUJhdGNoQnVpbGRlcjtcbigwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKFRhYmxlQmF0Y2hCdWlsZGVyLCBcIkFycm93QmF0Y2hcIiwgdm9pZCAwKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhYmxlLWJhdGNoLWJ1aWxkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy50YWtlQXN5bmMgPSB0YWtlQXN5bmM7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF93cmFwTmF0aXZlU3VwZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy93cmFwTmF0aXZlU3VwZXJcIikpO1xuXG52YXIgX1N5bWJvbCRhc3luY0l0ZXJhdG9yO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIuZGVmYXVsdCkodGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIEFycmF5UXVldWUgPSBmdW5jdGlvbiAoX0FycmF5KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEFycmF5UXVldWUsIF9BcnJheSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihBcnJheVF1ZXVlKTtcblxuICBmdW5jdGlvbiBBcnJheVF1ZXVlKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEFycmF5UXVldWUpO1xuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEFycmF5UXVldWUsIFt7XG4gICAga2V5OiBcImVucXVldWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5xdWV1ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlcXVldWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVxdWV1ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNoaWZ0KCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBBcnJheVF1ZXVlO1xufSgoMCwgX3dyYXBOYXRpdmVTdXBlcjIuZGVmYXVsdCkoQXJyYXkpKTtcblxuX1N5bWJvbCRhc3luY0l0ZXJhdG9yID0gU3ltYm9sLmFzeW5jSXRlcmF0b3I7XG5cbnZhciBBc3luY1F1ZXVlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBc3luY1F1ZXVlKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEFzeW5jUXVldWUpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiX3ZhbHVlc1wiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiX3NldHRsZXJzXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJfY2xvc2VkXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5fdmFsdWVzID0gbmV3IEFycmF5UXVldWUoKTtcbiAgICB0aGlzLl9zZXR0bGVycyA9IG5ldyBBcnJheVF1ZXVlKCk7XG4gICAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShBc3luY1F1ZXVlLCBbe1xuICAgIGtleTogXCJjbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIHdoaWxlICh0aGlzLl9zZXR0bGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuX3NldHRsZXJzLmRlcXVldWUoKS5yZXNvbHZlKHtcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogX1N5bWJvbCRhc3luY0l0ZXJhdG9yLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbnF1ZXVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVucXVldWUodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbG9zZWQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3NldHRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHRoaXMuX3ZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGludGVybmFsIHN0YXRlJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2V0dGxlciA9IHRoaXMuX3NldHRsZXJzLmRlcXVldWUoKTtcblxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHNldHRsZXIucmVqZWN0KHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXR0bGVyLnJlc29sdmUoe1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlcy5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibmV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX3ZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX3ZhbHVlcy5kZXF1ZXVlKCk7XG5cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgIGlmICh0aGlzLl9zZXR0bGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGludGVybmFsIHN0YXRlJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBfdGhpcy5fc2V0dGxlcnMuZW5xdWV1ZSh7XG4gICAgICAgICAgcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICAgICAgICByZWplY3Q6IHJlamVjdFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQXN5bmNRdWV1ZTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQXN5bmNRdWV1ZTtcblxuZnVuY3Rpb24gdGFrZUFzeW5jKF94KSB7XG4gIHJldHVybiBfdGFrZUFzeW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF90YWtlQXN5bmMoKSB7XG4gIF90YWtlQXN5bmMgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZShhc3luY0l0ZXJhYmxlKSB7XG4gICAgdmFyIGNvdW50LFxuICAgICAgICByZXN1bHQsXG4gICAgICAgIGl0ZXJhdG9yLFxuICAgICAgICBfeWllbGQkaXRlcmF0b3IkbmV4dCxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRvbmUsXG4gICAgICAgIF9hcmdzID0gYXJndW1lbnRzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjb3VudCA9IF9hcmdzLmxlbmd0aCA+IDEgJiYgX2FyZ3NbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzWzFdIDogSW5maW5pdHk7XG4gICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGl0ZXJhdG9yID0gYXN5bmNJdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGlmICghKHJlc3VsdC5sZW5ndGggPCBjb3VudCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3IubmV4dCgpO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgX3lpZWxkJGl0ZXJhdG9yJG5leHQgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgdmFsdWUgPSBfeWllbGQkaXRlcmF0b3IkbmV4dC52YWx1ZTtcbiAgICAgICAgICAgIGRvbmUgPSBfeWllbGQkaXRlcmF0b3IkbmV4dC5kb25lO1xuXG4gICAgICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDExO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcImJyZWFrXCIsIDE0KTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzdWx0KTtcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUpO1xuICB9KSk7XG4gIHJldHVybiBfdGFrZUFzeW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3luYy1xdWV1ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY29udmVydFRvT2JqZWN0Um93ID0gY29udmVydFRvT2JqZWN0Um93O1xuZXhwb3J0cy5jb252ZXJ0VG9BcnJheVJvdyA9IGNvbnZlcnRUb0FycmF5Um93O1xuXG5mdW5jdGlvbiBjb252ZXJ0VG9PYmplY3RSb3coYXJyYXlSb3csIGhlYWRlcnMpIHtcbiAgaWYgKCFhcnJheVJvdykge1xuICAgIHRocm93IG5ldyBFcnJvcignbnVsbCByb3cnKTtcbiAgfVxuXG4gIGlmICghaGVhZGVycykge1xuICAgIHRocm93IG5ldyBFcnJvcignbm8gaGVhZGVycycpO1xuICB9XG5cbiAgdmFyIG9iamVjdFJvdyA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkrKykge1xuICAgIG9iamVjdFJvd1toZWFkZXJzW2ldXSA9IGFycmF5Um93W2ldO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdFJvdztcbn1cblxuZnVuY3Rpb24gY29udmVydFRvQXJyYXlSb3cob2JqZWN0Um93LCBoZWFkZXJzKSB7XG4gIGlmICghb2JqZWN0Um93KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdudWxsIHJvdycpO1xuICB9XG5cbiAgaWYgKCFoZWFkZXJzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdubyBoZWFkZXJzJyk7XG4gIH1cblxuICB2YXIgYXJyYXlSb3cgPSBuZXcgQXJyYXkoaGVhZGVycy5sZW5ndGgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkrKykge1xuICAgIGFycmF5Um93W2ldID0gb2JqZWN0Um93W2hlYWRlcnNbaV1dO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5Um93O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm93LXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzc2VydFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYXNzZXJ0LmFzc2VydDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0Jyb3dzZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dsb2JhbHMuaXNCcm93c2VyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzV29ya2VyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxzLmlzV29ya2VyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldvcmtlckpvYlwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfd29ya2VySm9iLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29ya2VyVGhyZWFkXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF93b3JrZXJUaHJlYWQuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXb3JrZXJGYXJtXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF93b3JrZXJGYXJtLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29ya2VyUG9vbFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfd29ya2VyUG9vbC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldvcmtlckJvZHlcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3dvcmtlckJvZHkuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwcm9jZXNzT25Xb3JrZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3Byb2Nlc3NPbldvcmtlci5wcm9jZXNzT25Xb3JrZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2FuUHJvY2Vzc09uV29ya2VyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9wcm9jZXNzT25Xb3JrZXIuY2FuUHJvY2Vzc09uV29ya2VyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZVdvcmtlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfY3JlYXRlV29ya2VyLmNyZWF0ZVdvcmtlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRXb3JrZXJVUkxcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dldFdvcmtlclVybC5nZXRXb3JrZXJVUkw7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmFsaWRhdGVXb3JrZXJWZXJzaW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF92YWxpZGF0ZVdvcmtlclZlcnNpb24udmFsaWRhdGVXb3JrZXJWZXJzaW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFRyYW5zZmVyTGlzdFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2V0VHJhbnNmZXJMaXN0LmdldFRyYW5zZmVyTGlzdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRMaWJyYXJ5VXJsXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9saWJyYXJ5VXRpbHMuZ2V0TGlicmFyeVVybDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJsb2FkTGlicmFyeVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbGlicmFyeVV0aWxzLmxvYWRMaWJyYXJ5O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFzeW5jUXVldWVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2FzeW5jUXVldWUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDaGlsZFByb2Nlc3NQcm94eVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfY2hpbGRQcm9jZXNzUHJveHkuZGVmYXVsdDtcbiAgfVxufSk7XG5leHBvcnRzLk51bGxXb3JrZXIgPSB2b2lkIDA7XG5cbnZhciBfdmVyc2lvbiA9IHJlcXVpcmUoXCIuL2xpYi9lbnYtdXRpbHMvdmVyc2lvblwiKTtcblxudmFyIF9hc3NlcnQgPSByZXF1aXJlKFwiLi9saWIvZW52LXV0aWxzL2Fzc2VydFwiKTtcblxudmFyIF9nbG9iYWxzID0gcmVxdWlyZShcIi4vbGliL2Vudi11dGlscy9nbG9iYWxzXCIpO1xuXG52YXIgX3dvcmtlckpvYiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL3dvcmtlci1mYXJtL3dvcmtlci1qb2JcIikpO1xuXG52YXIgX3dvcmtlclRocmVhZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL3dvcmtlci1mYXJtL3dvcmtlci10aHJlYWRcIikpO1xuXG52YXIgX3dvcmtlckZhcm0gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi93b3JrZXItZmFybS93b3JrZXItZmFybVwiKSk7XG5cbnZhciBfd29ya2VyUG9vbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL3dvcmtlci1mYXJtL3dvcmtlci1wb29sXCIpKTtcblxudmFyIF93b3JrZXJCb2R5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvd29ya2VyLWZhcm0vd29ya2VyLWJvZHlcIikpO1xuXG52YXIgX3Byb2Nlc3NPbldvcmtlciA9IHJlcXVpcmUoXCIuL2xpYi93b3JrZXItYXBpL3Byb2Nlc3Mtb24td29ya2VyXCIpO1xuXG52YXIgX2NyZWF0ZVdvcmtlciA9IHJlcXVpcmUoXCIuL2xpYi93b3JrZXItYXBpL2NyZWF0ZS13b3JrZXJcIik7XG5cbnZhciBfZ2V0V29ya2VyVXJsID0gcmVxdWlyZShcIi4vbGliL3dvcmtlci1hcGkvZ2V0LXdvcmtlci11cmxcIik7XG5cbnZhciBfdmFsaWRhdGVXb3JrZXJWZXJzaW9uID0gcmVxdWlyZShcIi4vbGliL3dvcmtlci1hcGkvdmFsaWRhdGUtd29ya2VyLXZlcnNpb25cIik7XG5cbnZhciBfZ2V0VHJhbnNmZXJMaXN0ID0gcmVxdWlyZShcIi4vbGliL3dvcmtlci11dGlscy9nZXQtdHJhbnNmZXItbGlzdFwiKTtcblxudmFyIF9saWJyYXJ5VXRpbHMgPSByZXF1aXJlKFwiLi9saWIvbGlicmFyeS11dGlscy9saWJyYXJ5LXV0aWxzXCIpO1xuXG52YXIgX2FzeW5jUXVldWUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9hc3luYy1xdWV1ZS9hc3luYy1xdWV1ZVwiKSk7XG5cbnZhciBfY2hpbGRQcm9jZXNzUHJveHkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9wcm9jZXNzLXV0aWxzL2NoaWxkLXByb2Nlc3MtcHJveHlcIikpO1xuXG52YXIgTnVsbFdvcmtlciA9IHtcbiAgaWQ6ICdudWxsJyxcbiAgbmFtZTogJ251bGwnLFxuICBtb2R1bGU6ICd3b3JrZXItdXRpbHMnLFxuICB2ZXJzaW9uOiBfdmVyc2lvbi5WRVJTSU9OLFxuICBvcHRpb25zOiB7XG4gICAgbnVsbDoge31cbiAgfVxufTtcbmV4cG9ydHMuTnVsbFdvcmtlciA9IE51bGxXb3JrZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfU3ltYm9sJGFzeW5jSXRlcmF0b3I7XG5cbl9TeW1ib2wkYXN5bmNJdGVyYXRvciA9IFN5bWJvbC5hc3luY0l0ZXJhdG9yO1xuXG52YXIgQXN5bmNRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQXN5bmNRdWV1ZSgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBBc3luY1F1ZXVlKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcIl92YWx1ZXNcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcIl9zZXR0bGVyc1wiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiX2Nsb3NlZFwiLCB2b2lkIDApO1xuICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xuICAgIHRoaXMuX3NldHRsZXJzID0gW107XG4gICAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShBc3luY1F1ZXVlLCBbe1xuICAgIGtleTogX1N5bWJvbCRhc3luY0l0ZXJhdG9yLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwdXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2godmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmVucXVldWUodmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbnF1ZXVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVucXVldWUodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbG9zZWQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3NldHRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHRoaXMuX3ZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGludGVybmFsIHN0YXRlJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2V0dGxlciA9IHRoaXMuX3NldHRsZXJzLnNoaWZ0KCk7XG5cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBzZXR0bGVyLnJlamVjdCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0dGxlci5yZXNvbHZlKHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl92YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgd2hpbGUgKHRoaXMuX3NldHRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHNldHRsZXIgPSB0aGlzLl9zZXR0bGVycy5zaGlmdCgpO1xuXG4gICAgICAgIHNldHRsZXIucmVzb2x2ZSh7XG4gICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibmV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX3ZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX3ZhbHVlcy5zaGlmdCgpO1xuXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICBpZiAodGhpcy5fc2V0dGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBpbnRlcm5hbCBzdGF0ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBfdGhpcy5fc2V0dGxlcnMucHVzaCh7XG4gICAgICAgICAgcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICAgICAgICByZWplY3Q6IHJlamVjdFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQXN5bmNRdWV1ZTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQXN5bmNRdWV1ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzeW5jLXF1ZXVlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG5cbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCAnbG9hZGVycy5nbCBhc3NlcnRpb24gZmFpbGVkLicpO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NlcnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5ub2RlVmVyc2lvbiA9IGV4cG9ydHMuaXNNb2JpbGUgPSBleHBvcnRzLmlzV29ya2VyID0gZXhwb3J0cy5pc0Jyb3dzZXIgPSBleHBvcnRzLmRvY3VtZW50ID0gZXhwb3J0cy5nbG9iYWwgPSBleHBvcnRzLndpbmRvdyA9IGV4cG9ydHMuc2VsZiA9IHZvaWQgMDtcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG52YXIgZ2xvYmFscyA9IHtcbiAgc2VsZjogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYsXG4gIHdpbmRvdzogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LFxuICBnbG9iYWw6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbCxcbiAgZG9jdW1lbnQ6IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnRcbn07XG52YXIgc2VsZl8gPSBnbG9iYWxzLnNlbGYgfHwgZ2xvYmFscy53aW5kb3cgfHwgZ2xvYmFscy5nbG9iYWwgfHwge307XG5leHBvcnRzLnNlbGYgPSBzZWxmXztcbnZhciB3aW5kb3dfID0gZ2xvYmFscy53aW5kb3cgfHwgZ2xvYmFscy5zZWxmIHx8IGdsb2JhbHMuZ2xvYmFsIHx8IHt9O1xuZXhwb3J0cy53aW5kb3cgPSB3aW5kb3dfO1xudmFyIGdsb2JhbF8gPSBnbG9iYWxzLmdsb2JhbCB8fCBnbG9iYWxzLnNlbGYgfHwgZ2xvYmFscy53aW5kb3cgfHwge307XG5leHBvcnRzLmdsb2JhbCA9IGdsb2JhbF87XG52YXIgZG9jdW1lbnRfID0gZ2xvYmFscy5kb2N1bWVudCB8fCB7fTtcbmV4cG9ydHMuZG9jdW1lbnQgPSBkb2N1bWVudF87XG52YXIgaXNCcm93c2VyID0gKHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMi5kZWZhdWx0KShwcm9jZXNzKSkgIT09ICdvYmplY3QnIHx8IFN0cmluZyhwcm9jZXNzKSAhPT0gJ1tvYmplY3QgcHJvY2Vzc10nIHx8IHByb2Nlc3MuYnJvd3NlcjtcbmV4cG9ydHMuaXNCcm93c2VyID0gaXNCcm93c2VyO1xudmFyIGlzV29ya2VyID0gdHlwZW9mIGltcG9ydFNjcmlwdHMgPT09ICdmdW5jdGlvbic7XG5leHBvcnRzLmlzV29ya2VyID0gaXNXb3JrZXI7XG52YXIgaXNNb2JpbGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93Lm9yaWVudGF0aW9uICE9PSAndW5kZWZpbmVkJztcbmV4cG9ydHMuaXNNb2JpbGUgPSBpc01vYmlsZTtcbnZhciBtYXRjaGVzID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MudmVyc2lvbiAmJiAvdihbMC05XSopLy5leGVjKHByb2Nlc3MudmVyc2lvbik7XG52YXIgbm9kZVZlcnNpb24gPSBtYXRjaGVzICYmIHBhcnNlRmxvYXQobWF0Y2hlc1sxXSkgfHwgMDtcbmV4cG9ydHMubm9kZVZlcnNpb24gPSBub2RlVmVyc2lvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsb2JhbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlZFUlNJT04gPSB2b2lkIDA7XG52YXIgREVGQVVMVF9WRVJTSU9OID0gJ2JldGEnO1xudmFyIFZFUlNJT04gPSB0eXBlb2YgXCIzLjAuOVwiICE9PSAndW5kZWZpbmVkJyA/IFwiMy4wLjlcIiA6IERFRkFVTFRfVkVSU0lPTjtcbmV4cG9ydHMuVkVSU0lPTiA9IFZFUlNJT047XG5cbmlmICh0eXBlb2YgXCIzLjAuOVwiID09PSAndW5kZWZpbmVkJykge1xuICBjb25zb2xlLmVycm9yKCdsb2FkZXJzLmdsOiBUaGUgX19WRVJTSU9OX18gdmFyaWFibGUgaXMgbm90IGluamVjdGVkIHVzaW5nIGJhYmVsIHBsdWdpbi4gTGF0ZXN0IHVuc3RhYmxlIHdvcmtlcnMgd291bGQgYmUgZmV0Y2hlZCBmcm9tIHRoZSBDRE4uJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxudmFyIF90eXBlb2YgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmxvYWRMaWJyYXJ5ID0gbG9hZExpYnJhcnk7XG5leHBvcnRzLmdldExpYnJhcnlVcmwgPSBnZXRMaWJyYXJ5VXJsO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9nbG9iYWxzID0gcmVxdWlyZShcIi4uL2Vudi11dGlscy9nbG9iYWxzXCIpO1xuXG52YXIgbm9kZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuLi9ub2RlL3JlcXVpcmUtdXRpbHMubm9kZVwiKSk7XG5cbnZhciBfYXNzZXJ0ID0gcmVxdWlyZShcIi4uL2Vudi11dGlscy9hc3NlcnRcIik7XG5cbnZhciBfdmVyc2lvbiA9IHJlcXVpcmUoXCIuLi9lbnYtdXRpbHMvdmVyc2lvblwiKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7IH0pKG5vZGVJbnRlcm9wKTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7IGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG52YXIgTEFURVNUID0gJ2JldGEnO1xudmFyIFZFUlNJT04gPSB0eXBlb2YgXCIzLjAuOVwiICE9PSAndW5kZWZpbmVkJyA/IFwiMy4wLjlcIiA6IExBVEVTVDtcbnZhciBsb2FkTGlicmFyeVByb21pc2VzID0ge307XG5cbmZ1bmN0aW9uIGxvYWRMaWJyYXJ5KF94KSB7XG4gIHJldHVybiBfbG9hZExpYnJhcnkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2xvYWRMaWJyYXJ5KCkge1xuICBfbG9hZExpYnJhcnkgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZShsaWJyYXJ5VXJsKSB7XG4gICAgdmFyIG1vZHVsZU5hbWUsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIF9hcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgbW9kdWxlTmFtZSA9IF9hcmdzLmxlbmd0aCA+IDEgJiYgX2FyZ3NbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzWzFdIDogbnVsbDtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBfYXJncy5sZW5ndGggPiAyICYmIF9hcmdzWzJdICE9PSB1bmRlZmluZWQgPyBfYXJnc1syXSA6IHt9O1xuXG4gICAgICAgICAgICBpZiAobW9kdWxlTmFtZSkge1xuICAgICAgICAgICAgICBsaWJyYXJ5VXJsID0gZ2V0TGlicmFyeVVybChsaWJyYXJ5VXJsLCBtb2R1bGVOYW1lLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbG9hZExpYnJhcnlQcm9taXNlc1tsaWJyYXJ5VXJsXSA9IGxvYWRMaWJyYXJ5UHJvbWlzZXNbbGlicmFyeVVybF0gfHwgbG9hZExpYnJhcnlGcm9tRmlsZShsaWJyYXJ5VXJsKTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2O1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRMaWJyYXJ5UHJvbWlzZXNbbGlicmFyeVVybF07XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0LnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlKTtcbiAgfSkpO1xuICByZXR1cm4gX2xvYWRMaWJyYXJ5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldExpYnJhcnlVcmwobGlicmFyeSwgbW9kdWxlTmFtZSwgb3B0aW9ucykge1xuICBpZiAobGlicmFyeS5zdGFydHNXaXRoKCdodHRwJykpIHtcbiAgICByZXR1cm4gbGlicmFyeTtcbiAgfVxuXG4gIHZhciBtb2R1bGVzID0gb3B0aW9ucy5tb2R1bGVzIHx8IHt9O1xuXG4gIGlmIChtb2R1bGVzW2xpYnJhcnldKSB7XG4gICAgcmV0dXJuIG1vZHVsZXNbbGlicmFyeV07XG4gIH1cblxuICBpZiAoIV9nbG9iYWxzLmlzQnJvd3Nlcikge1xuICAgIHJldHVybiBcIm1vZHVsZXMvXCIuY29uY2F0KG1vZHVsZU5hbWUsIFwiL2Rpc3QvbGlicy9cIikuY29uY2F0KGxpYnJhcnkpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuQ0ROKSB7XG4gICAgKDAsIF9hc3NlcnQuYXNzZXJ0KShvcHRpb25zLkNETi5zdGFydHNXaXRoKCdodHRwJykpO1xuICAgIHJldHVybiBcIlwiLmNvbmNhdChvcHRpb25zLkNETiwgXCIvXCIpLmNvbmNhdChtb2R1bGVOYW1lLCBcIkBcIikuY29uY2F0KFZFUlNJT04sIFwiL2Rpc3QvbGlicy9cIikuY29uY2F0KGxpYnJhcnkpO1xuICB9XG5cbiAgaWYgKF9nbG9iYWxzLmlzV29ya2VyKSB7XG4gICAgcmV0dXJuIFwiLi4vc3JjL2xpYnMvXCIuY29uY2F0KGxpYnJhcnkpO1xuICB9XG5cbiAgcmV0dXJuIFwibW9kdWxlcy9cIi5jb25jYXQobW9kdWxlTmFtZSwgXCIvc3JjL2xpYnMvXCIpLmNvbmNhdChsaWJyYXJ5KTtcbn1cblxuZnVuY3Rpb24gbG9hZExpYnJhcnlGcm9tRmlsZShfeDIpIHtcbiAgcmV0dXJuIF9sb2FkTGlicmFyeUZyb21GaWxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9sb2FkTGlicmFyeUZyb21GaWxlKCkge1xuICBfbG9hZExpYnJhcnlGcm9tRmlsZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMihsaWJyYXJ5VXJsKSB7XG4gICAgdmFyIF9yZXNwb25zZSwgcmVzcG9uc2UsIHNjcmlwdFNvdXJjZTtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghbGlicmFyeVVybC5lbmRzV2l0aCgnd2FzbScpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiBmZXRjaChsaWJyYXJ5VXJsKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIF9yZXNwb25zZSA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA2O1xuICAgICAgICAgICAgcmV0dXJuIF9yZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQyLnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgaWYgKF9nbG9iYWxzLmlzQnJvd3Nlcikge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gbm9kZS5yZXF1aXJlRnJvbUZpbGU7XG5cbiAgICAgICAgICAgIGlmICghX2NvbnRleHQyLnQwKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEyO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUucmVxdWlyZUZyb21GaWxlKGxpYnJhcnlVcmwpO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IF9jb250ZXh0Mi5zZW50O1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0Mi50MCk7XG5cbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgaWYgKCFfZ2xvYmFscy5pc1dvcmtlcikge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE2O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgaW1wb3J0U2NyaXB0cyhsaWJyYXJ5VXJsKSk7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxODtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaChsaWJyYXJ5VXJsKTtcblxuICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICByZXNwb25zZSA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyMTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG5cbiAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgc2NyaXB0U291cmNlID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBsb2FkTGlicmFyeUZyb21TdHJpbmcoc2NyaXB0U291cmNlLCBsaWJyYXJ5VXJsKSk7XG5cbiAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIpO1xuICB9KSk7XG4gIHJldHVybiBfbG9hZExpYnJhcnlGcm9tRmlsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBsb2FkTGlicmFyeUZyb21TdHJpbmcoc2NyaXB0U291cmNlLCBpZCkge1xuICBpZiAoIV9nbG9iYWxzLmlzQnJvd3Nlcikge1xuICAgIHJldHVybiBub2RlLnJlcXVpcmVGcm9tU3RyaW5nICYmIG5vZGUucmVxdWlyZUZyb21TdHJpbmcoc2NyaXB0U291cmNlLCBpZCk7XG4gIH1cblxuICBpZiAoX2dsb2JhbHMuaXNXb3JrZXIpIHtcbiAgICBldmFsLmNhbGwoX2dsb2JhbHMuZ2xvYmFsLCBzY3JpcHRTb3VyY2UpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICBzY3JpcHQuaWQgPSBpZDtcblxuICB0cnkge1xuICAgIHNjcmlwdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzY3JpcHRTb3VyY2UpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHNjcmlwdC50ZXh0ID0gc2NyaXB0U291cmNlO1xuICB9XG5cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICByZXR1cm4gbnVsbDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpYnJhcnktdXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jcmVhdGVXb3JrZXIgPSBjcmVhdGVXb3JrZXI7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jSXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY0l0ZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1F1ZXVlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vYXN5bmMtcXVldWUvYXN5bmMtcXVldWVcIikpO1xuXG52YXIgX3dvcmtlckJvZHkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi93b3JrZXItZmFybS93b3JrZXItYm9keVwiKSk7XG5cbnZhciByZXF1ZXN0SWQgPSAwO1xudmFyIGlucHV0QmF0Y2hlcztcbnZhciBvcHRpb25zO1xuXG5mdW5jdGlvbiBjcmVhdGVXb3JrZXIocHJvY2VzcywgcHJvY2Vzc0luQmF0Y2hlcykge1xuICBpZiAodHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgcHJvY2VzczogcHJvY2Vzc09uTWFpblRocmVhZFxuICB9O1xuXG4gIF93b3JrZXJCb2R5LmRlZmF1bHQub25tZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUodHlwZSwgcGF5bG9hZCkge1xuICAgICAgdmFyIHJlc3VsdCwgcmVzdWx0SXRlcmF0b3IsIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24sIF9kaWRJdGVyYXRvckVycm9yLCBfaXRlcmF0b3JFcnJvciwgX2l0ZXJhdG9yLCBfc3RlcCwgX3ZhbHVlLCBiYXRjaCwgbWVzc2FnZTtcblxuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAwO1xuICAgICAgICAgICAgICBfY29udGV4dC50MCA9IHR5cGU7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSBfY29udGV4dC50MCA9PT0gJ3Byb2Nlc3MnID8gNCA6IF9jb250ZXh0LnQwID09PSAncHJvY2Vzcy1pbi1iYXRjaGVzJyA/IDExIDogX2NvbnRleHQudDAgPT09ICdpbnB1dC1iYXRjaCcgPyA1MSA6IF9jb250ZXh0LnQwID09PSAnaW5wdXQtZG9uZScgPyA1MyA6IDU1O1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBpZiAocHJvY2Vzcykge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3JrZXIgZG9lcyBub3Qgc3VwcG9ydCBhdG9taWMgcHJvY2Vzc2luZycpO1xuXG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA4O1xuICAgICAgICAgICAgICByZXR1cm4gcHJvY2VzcyhwYXlsb2FkLmlucHV0LCBwYXlsb2FkLm9wdGlvbnMgfHwge30sIGNvbnRleHQpO1xuXG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgICAgX3dvcmtlckJvZHkuZGVmYXVsdC5wb3N0TWVzc2FnZSgnZG9uZScsIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwiYnJlYWtcIiwgNTUpO1xuXG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICBpZiAocHJvY2Vzc0luQmF0Y2hlcykge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya2VyIGRvZXMgbm90IHN1cHBvcnQgYmF0Y2hlZCBwcm9jZXNzaW5nJyk7XG5cbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgIGlucHV0QmF0Y2hlcyA9IG5ldyBfYXN5bmNRdWV1ZS5kZWZhdWx0KCk7XG4gICAgICAgICAgICAgIG9wdGlvbnMgPSBwYXlsb2FkLm9wdGlvbnMgfHwge307XG4gICAgICAgICAgICAgIHJlc3VsdEl0ZXJhdG9yID0gcHJvY2Vzc0luQmF0Y2hlcyhpbnB1dEJhdGNoZXMsIG9wdGlvbnMsIGNvbnRleHQgPT09IG51bGwgfHwgY29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGV4dC5wcm9jZXNzSW5CYXRjaGVzKTtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxODtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yID0gKDAsIF9hc3luY0l0ZXJhdG9yMi5kZWZhdWx0KShyZXN1bHRJdGVyYXRvcik7XG5cbiAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyMjtcbiAgICAgICAgICAgICAgcmV0dXJuIF9pdGVyYXRvci5uZXh0KCk7XG5cbiAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgIF9zdGVwID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IF9zdGVwLmRvbmU7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyNjtcbiAgICAgICAgICAgICAgcmV0dXJuIF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgICAgICBfdmFsdWUgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgICAgIGlmIChfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDMzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYmF0Y2ggPSBfdmFsdWU7XG5cbiAgICAgICAgICAgICAgX3dvcmtlckJvZHkuZGVmYXVsdC5wb3N0TWVzc2FnZSgnb3V0cHV0LWJhdGNoJywge1xuICAgICAgICAgICAgICAgIHJlc3VsdDogYmF0Y2hcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNhc2UgMzA6XG4gICAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDMzOlxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMzk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDM1OlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMzU7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnQxID0gX2NvbnRleHRbXCJjYXRjaFwiXSgxOCk7XG4gICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBfY29udGV4dC50MTtcblxuICAgICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDM5O1xuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gNDA7XG5cbiAgICAgICAgICAgICAgaWYgKCEoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0NDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0NDtcbiAgICAgICAgICAgICAgcmV0dXJuIF9pdGVyYXRvci5yZXR1cm4oKTtcblxuICAgICAgICAgICAgY2FzZSA0NDpcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDQ0O1xuXG4gICAgICAgICAgICAgIGlmICghX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcblxuICAgICAgICAgICAgY2FzZSA0NzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmZpbmlzaCg0NCk7XG5cbiAgICAgICAgICAgIGNhc2UgNDg6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5maW5pc2goMzkpO1xuXG4gICAgICAgICAgICBjYXNlIDQ5OlxuICAgICAgICAgICAgICBfd29ya2VyQm9keS5kZWZhdWx0LnBvc3RNZXNzYWdlKCdkb25lJywge30pO1xuXG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJicmVha1wiLCA1NSk7XG5cbiAgICAgICAgICAgIGNhc2UgNTE6XG4gICAgICAgICAgICAgIGlucHV0QmF0Y2hlcy5wdXNoKHBheWxvYWQuaW5wdXQpO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwiYnJlYWtcIiwgNTUpO1xuXG4gICAgICAgICAgICBjYXNlIDUzOlxuICAgICAgICAgICAgICBpbnB1dEJhdGNoZXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcImJyZWFrXCIsIDU1KTtcblxuICAgICAgICAgICAgY2FzZSA1NTpcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDYxO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA1NzpcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDU3O1xuICAgICAgICAgICAgICBfY29udGV4dC50MiA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICAgIG1lc3NhZ2UgPSBfY29udGV4dC50MiBpbnN0YW5jZW9mIEVycm9yID8gX2NvbnRleHQudDIubWVzc2FnZSA6ICcnO1xuXG4gICAgICAgICAgICAgIF93b3JrZXJCb2R5LmRlZmF1bHQucG9zdE1lc3NhZ2UoJ2Vycm9yJywge1xuICAgICAgICAgICAgICAgIGVycm9yOiBtZXNzYWdlXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjYXNlIDYxOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZSwgbnVsbCwgW1swLCA1N10sIFsxOCwgMzUsIDM5LCA0OV0sIFs0MCwsIDQ0LCA0OF1dKTtcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKF94LCBfeDIpIHtcbiAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSgpO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzT25NYWluVGhyZWFkKGFycmF5QnVmZmVyKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgaWQgPSByZXF1ZXN0SWQrKztcblxuICAgIHZhciBvbk1lc3NhZ2UgPSBmdW5jdGlvbiBvbk1lc3NhZ2UodHlwZSwgcGF5bG9hZCkge1xuICAgICAgaWYgKHBheWxvYWQuaWQgIT09IGlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2RvbmUnOlxuICAgICAgICAgIF93b3JrZXJCb2R5LmRlZmF1bHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihvbk1lc3NhZ2UpO1xuXG4gICAgICAgICAgcmVzb2x2ZShwYXlsb2FkLnJlc3VsdCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgIF93b3JrZXJCb2R5LmRlZmF1bHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihvbk1lc3NhZ2UpO1xuXG4gICAgICAgICAgcmVqZWN0KHBheWxvYWQuZXJyb3IpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICB9XG4gICAgfTtcblxuICAgIF93b3JrZXJCb2R5LmRlZmF1bHQuYWRkRXZlbnRMaXN0ZW5lcihvbk1lc3NhZ2UpO1xuXG4gICAgdmFyIHBheWxvYWQgPSB7XG4gICAgICBpZDogaWQsXG4gICAgICBpbnB1dDogYXJyYXlCdWZmZXIsXG4gICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgfTtcblxuICAgIF93b3JrZXJCb2R5LmRlZmF1bHQucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MnLCBwYXlsb2FkKTtcbiAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGUtd29ya2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXRXb3JrZXJOYW1lID0gZ2V0V29ya2VyTmFtZTtcbmV4cG9ydHMuZ2V0V29ya2VyVVJMID0gZ2V0V29ya2VyVVJMO1xuXG52YXIgX2Fzc2VydCA9IHJlcXVpcmUoXCIuLi9lbnYtdXRpbHMvYXNzZXJ0XCIpO1xuXG52YXIgX3ZlcnNpb24gPSByZXF1aXJlKFwiLi4vZW52LXV0aWxzL3ZlcnNpb25cIik7XG5cbnZhciBOUE1fVEFHID0gJ2xhdGVzdCc7XG52YXIgVkVSU0lPTiA9IHR5cGVvZiBcIjMuMC45XCIgIT09ICd1bmRlZmluZWQnID8gXCIzLjAuOVwiIDogTlBNX1RBRztcblxuZnVuY3Rpb24gZ2V0V29ya2VyTmFtZSh3b3JrZXIpIHtcbiAgdmFyIHdhcm5pbmcgPSB3b3JrZXIudmVyc2lvbiAhPT0gVkVSU0lPTiA/IFwiICh3b3JrZXItdXRpbHNAXCIuY29uY2F0KFZFUlNJT04sIFwiKVwiKSA6ICcnO1xuICByZXR1cm4gXCJcIi5jb25jYXQod29ya2VyLm5hbWUsIFwiQFwiKS5jb25jYXQod29ya2VyLnZlcnNpb24pLmNvbmNhdCh3YXJuaW5nKTtcbn1cblxuZnVuY3Rpb24gZ2V0V29ya2VyVVJMKHdvcmtlcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciB3b3JrZXJPcHRpb25zID0gb3B0aW9uc1t3b3JrZXIuaWRdIHx8IHt9O1xuICB2YXIgd29ya2VyRmlsZSA9IFwiXCIuY29uY2F0KHdvcmtlci5pZCwgXCItd29ya2VyLmpzXCIpO1xuICB2YXIgdXJsID0gd29ya2VyT3B0aW9ucy53b3JrZXJVcmw7XG5cbiAgaWYgKG9wdGlvbnMuX3dvcmtlclR5cGUgPT09ICd0ZXN0Jykge1xuICAgIHVybCA9IFwibW9kdWxlcy9cIi5jb25jYXQod29ya2VyLm1vZHVsZSwgXCIvZGlzdC9cIikuY29uY2F0KHdvcmtlckZpbGUpO1xuICB9XG5cbiAgaWYgKCF1cmwpIHtcbiAgICB2YXIgdmVyc2lvbiA9IHdvcmtlci52ZXJzaW9uO1xuXG4gICAgaWYgKHZlcnNpb24gPT09ICdsYXRlc3QnKSB7XG4gICAgICB2ZXJzaW9uID0gTlBNX1RBRztcbiAgICB9XG5cbiAgICB2YXIgdmVyc2lvblRhZyA9IHZlcnNpb24gPyBcIkBcIi5jb25jYXQodmVyc2lvbikgOiAnJztcbiAgICB1cmwgPSBcImh0dHBzOi8vdW5wa2cuY29tL0Bsb2FkZXJzLmdsL1wiLmNvbmNhdCh3b3JrZXIubW9kdWxlKS5jb25jYXQodmVyc2lvblRhZywgXCIvZGlzdC9cIikuY29uY2F0KHdvcmtlckZpbGUpO1xuICB9XG5cbiAgKDAsIF9hc3NlcnQuYXNzZXJ0KSh1cmwpO1xuICByZXR1cm4gdXJsO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LXdvcmtlci11cmwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jYW5Qcm9jZXNzT25Xb3JrZXIgPSBjYW5Qcm9jZXNzT25Xb3JrZXI7XG5leHBvcnRzLnByb2Nlc3NPbldvcmtlciA9IHByb2Nlc3NPbldvcmtlcjtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfd29ya2VyRmFybSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3dvcmtlci1mYXJtL3dvcmtlci1mYXJtXCIpKTtcblxudmFyIF9yZW1vdmVOb250cmFuc2ZlcmFibGVPcHRpb25zID0gcmVxdWlyZShcIi4uL3dvcmtlci11dGlscy9yZW1vdmUtbm9udHJhbnNmZXJhYmxlLW9wdGlvbnNcIik7XG5cbnZhciBfZ2V0V29ya2VyVXJsID0gcmVxdWlyZShcIi4vZ2V0LXdvcmtlci11cmxcIik7XG5cbmZ1bmN0aW9uIGNhblByb2Nlc3NPbldvcmtlcih3b3JrZXIsIG9wdGlvbnMpIHtcbiAgaWYgKCFfd29ya2VyRmFybS5kZWZhdWx0LmlzU3VwcG9ydGVkKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gd29ya2VyLndvcmtlciAmJiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLndvcmtlcik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NPbldvcmtlcihfeCwgX3gyKSB7XG4gIHJldHVybiBfcHJvY2Vzc09uV29ya2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9wcm9jZXNzT25Xb3JrZXIoKSB7XG4gIF9wcm9jZXNzT25Xb3JrZXIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZSh3b3JrZXIsIGRhdGEpIHtcbiAgICB2YXIgb3B0aW9ucyxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdXJsLFxuICAgICAgICB3b3JrZXJGYXJtLFxuICAgICAgICB3b3JrZXJQb29sLFxuICAgICAgICBqb2JOYW1lLFxuICAgICAgICBqb2IsXG4gICAgICAgIHRyYW5zZmVyYWJsZU9wdGlvbnMsXG4gICAgICAgIHJlc3VsdCxcbiAgICAgICAgX2FyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBvcHRpb25zID0gX2FyZ3MubGVuZ3RoID4gMiAmJiBfYXJnc1syXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3NbMl0gOiB7fTtcbiAgICAgICAgICAgIGNvbnRleHQgPSBfYXJncy5sZW5ndGggPiAzICYmIF9hcmdzWzNdICE9PSB1bmRlZmluZWQgPyBfYXJnc1szXSA6IHt9O1xuICAgICAgICAgICAgbmFtZSA9ICgwLCBfZ2V0V29ya2VyVXJsLmdldFdvcmtlck5hbWUpKHdvcmtlcik7XG4gICAgICAgICAgICB1cmwgPSAoMCwgX2dldFdvcmtlclVybC5nZXRXb3JrZXJVUkwpKHdvcmtlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICB3b3JrZXJGYXJtID0gX3dvcmtlckZhcm0uZGVmYXVsdC5nZXRXb3JrZXJGYXJtKG9wdGlvbnMpO1xuICAgICAgICAgICAgd29ya2VyUG9vbCA9IHdvcmtlckZhcm0uZ2V0V29ya2VyUG9vbCh7XG4gICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGpvYk5hbWUgPSBvcHRpb25zLmpvYk5hbWUgfHwgd29ya2VyLm5hbWU7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gOTtcbiAgICAgICAgICAgIHJldHVybiB3b3JrZXJQb29sLnN0YXJ0Sm9iKGpvYk5hbWUsIG9uTWVzc2FnZS5iaW5kKG51bGwsIGNvbnRleHQpKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGpvYiA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICB0cmFuc2ZlcmFibGVPcHRpb25zID0gKDAsIF9yZW1vdmVOb250cmFuc2ZlcmFibGVPcHRpb25zLnJlbW92ZU5vbnRyYW5zZmVyYWJsZU9wdGlvbnMpKG9wdGlvbnMpO1xuICAgICAgICAgICAgam9iLnBvc3RNZXNzYWdlKCdwcm9jZXNzJywge1xuICAgICAgICAgICAgICBpbnB1dDogZGF0YSxcbiAgICAgICAgICAgICAgb3B0aW9uczogdHJhbnNmZXJhYmxlT3B0aW9uc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICByZXR1cm4gam9iLnJlc3VsdDtcblxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCByZXN1bHQucmVzdWx0KTtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUpO1xuICB9KSk7XG4gIHJldHVybiBfcHJvY2Vzc09uV29ya2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIG9uTWVzc2FnZShfeDMsIF94NCwgX3g1LCBfeDYpIHtcbiAgcmV0dXJuIF9vbk1lc3NhZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX29uTWVzc2FnZSgpIHtcbiAgX29uTWVzc2FnZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMihjb250ZXh0LCBqb2IsIHR5cGUsIHBheWxvYWQpIHtcbiAgICB2YXIgaWQsIGlucHV0LCBvcHRpb25zLCByZXN1bHQsIG1lc3NhZ2U7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gdHlwZTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gX2NvbnRleHQyLnQwID09PSAnZG9uZScgPyAzIDogX2NvbnRleHQyLnQwID09PSAnZXJyb3InID8gNSA6IF9jb250ZXh0Mi50MCA9PT0gJ3Byb2Nlc3MnID8gNyA6IDIzO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBqb2IuZG9uZShwYXlsb2FkKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwiYnJlYWtcIiwgMjQpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgam9iLmVycm9yKHBheWxvYWQuZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJicmVha1wiLCAyNCk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBpZCA9IHBheWxvYWQuaWQsIGlucHV0ID0gcGF5bG9hZC5pbnB1dCwgb3B0aW9ucyA9IHBheWxvYWQub3B0aW9ucztcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gODtcblxuICAgICAgICAgICAgaWYgKGNvbnRleHQucHJvY2Vzcykge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgam9iLnBvc3RNZXNzYWdlKCdlcnJvcicsIHtcbiAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICBlcnJvcjogJ1dvcmtlciBub3Qgc2V0IHVwIHRvIHByb2Nlc3Mgb24gbWFpbiB0aHJlYWQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTQ7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5wcm9jZXNzKGlucHV0LCBvcHRpb25zKTtcblxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgIGpvYi5wb3N0TWVzc2FnZSgnZG9uZScsIHtcbiAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDIyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAxODtcbiAgICAgICAgICAgIF9jb250ZXh0Mi50MSA9IF9jb250ZXh0MltcImNhdGNoXCJdKDgpO1xuICAgICAgICAgICAgbWVzc2FnZSA9IF9jb250ZXh0Mi50MSBpbnN0YW5jZW9mIEVycm9yID8gX2NvbnRleHQyLnQxLm1lc3NhZ2UgOiAndW5rbm93biBlcnJvcic7XG4gICAgICAgICAgICBqb2IucG9zdE1lc3NhZ2UoJ2Vycm9yJywge1xuICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgIGVycm9yOiBtZXNzYWdlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcImJyZWFrXCIsIDI0KTtcblxuICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJwcm9jZXNzLW9uLXdvcmtlcjogdW5rbm93biBtZXNzYWdlIFwiLmNvbmNhdCh0eXBlKSk7XG5cbiAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIsIG51bGwsIFtbOCwgMThdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9vbk1lc3NhZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb2Nlc3Mtb24td29ya2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy52YWxpZGF0ZVdvcmtlclZlcnNpb24gPSB2YWxpZGF0ZVdvcmtlclZlcnNpb247XG5cbnZhciBfYXNzZXJ0ID0gcmVxdWlyZShcIi4uL2Vudi11dGlscy9hc3NlcnRcIik7XG5cbnZhciBfdmVyc2lvbiA9IHJlcXVpcmUoXCIuLi9lbnYtdXRpbHMvdmVyc2lvblwiKTtcblxuZnVuY3Rpb24gdmFsaWRhdGVXb3JrZXJWZXJzaW9uKHdvcmtlcikge1xuICB2YXIgY29yZVZlcnNpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IF92ZXJzaW9uLlZFUlNJT047XG4gICgwLCBfYXNzZXJ0LmFzc2VydCkod29ya2VyLCAnbm8gd29ya2VyIHByb3ZpZGVkJyk7XG4gIHZhciB3b3JrZXJWZXJzaW9uID0gd29ya2VyLnZlcnNpb247XG5cbiAgaWYgKCFjb3JlVmVyc2lvbiB8fCAhd29ya2VyVmVyc2lvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBwYXJzZVZlcnNpb24odmVyc2lvbikge1xuICB2YXIgcGFydHMgPSB2ZXJzaW9uLnNwbGl0KCcuJykubWFwKE51bWJlcik7XG4gIHJldHVybiB7XG4gICAgbWFqb3I6IHBhcnRzWzBdLFxuICAgIG1pbm9yOiBwYXJ0c1sxXVxuICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWRhdGUtd29ya2VyLXZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2dldFRyYW5zZmVyTGlzdCA9IHJlcXVpcmUoXCIuLi93b3JrZXItdXRpbHMvZ2V0LXRyYW5zZmVyLWxpc3RcIik7XG5cbnZhciBvbk1lc3NhZ2VXcmFwcGVyTWFwID0gbmV3IE1hcCgpO1xuXG52YXIgV29ya2VyQm9keSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gV29ya2VyQm9keSgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBXb3JrZXJCb2R5KTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKFdvcmtlckJvZHksIG51bGwsIFt7XG4gICAga2V5OiBcIm9ubWVzc2FnZVwiLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG9uTWVzc2FnZSkge1xuICAgICAgc2VsZi5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICBpZiAoIWlzS25vd25NZXNzYWdlKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9tZXNzYWdlJGRhdGEgPSBtZXNzYWdlLmRhdGEsXG4gICAgICAgICAgICB0eXBlID0gX21lc3NhZ2UkZGF0YS50eXBlLFxuICAgICAgICAgICAgcGF5bG9hZCA9IF9tZXNzYWdlJGRhdGEucGF5bG9hZDtcbiAgICAgICAgb25NZXNzYWdlKHR5cGUsIHBheWxvYWQpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRXZlbnRMaXN0ZW5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKG9uTWVzc2FnZSkge1xuICAgICAgdmFyIG9uTWVzc2FnZVdyYXBwZXIgPSBvbk1lc3NhZ2VXcmFwcGVyTWFwLmdldChvbk1lc3NhZ2UpO1xuXG4gICAgICBpZiAoIW9uTWVzc2FnZVdyYXBwZXIpIHtcbiAgICAgICAgb25NZXNzYWdlV3JhcHBlciA9IGZ1bmN0aW9uIG9uTWVzc2FnZVdyYXBwZXIobWVzc2FnZSkge1xuICAgICAgICAgIGlmICghaXNLbm93bk1lc3NhZ2UobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX21lc3NhZ2UkZGF0YTIgPSBtZXNzYWdlLmRhdGEsXG4gICAgICAgICAgICAgIHR5cGUgPSBfbWVzc2FnZSRkYXRhMi50eXBlLFxuICAgICAgICAgICAgICBwYXlsb2FkID0gX21lc3NhZ2UkZGF0YTIucGF5bG9hZDtcbiAgICAgICAgICBvbk1lc3NhZ2UodHlwZSwgcGF5bG9hZCk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG9uTWVzc2FnZVdyYXBwZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVFdmVudExpc3RlbmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIob25NZXNzYWdlKSB7XG4gICAgICB2YXIgb25NZXNzYWdlV3JhcHBlciA9IG9uTWVzc2FnZVdyYXBwZXJNYXAuZ2V0KG9uTWVzc2FnZSk7XG4gICAgICBvbk1lc3NhZ2VXcmFwcGVyTWFwLmRlbGV0ZShvbk1lc3NhZ2UpO1xuICAgICAgc2VsZi5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25NZXNzYWdlV3JhcHBlcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvc3RNZXNzYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc3RNZXNzYWdlKHR5cGUsIHBheWxvYWQpIHtcbiAgICAgIGlmIChzZWxmKSB7XG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgIHNvdXJjZTogJ2xvYWRlcnMuZ2wnLFxuICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgcGF5bG9hZDogcGF5bG9hZFxuICAgICAgICB9O1xuICAgICAgICB2YXIgdHJhbnNmZXJMaXN0ID0gKDAsIF9nZXRUcmFuc2Zlckxpc3QuZ2V0VHJhbnNmZXJMaXN0KShwYXlsb2FkKTtcbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZShkYXRhLCB0cmFuc2Zlckxpc3QpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gV29ya2VyQm9keTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gV29ya2VyQm9keTtcblxuZnVuY3Rpb24gaXNLbm93bk1lc3NhZ2UobWVzc2FnZSkge1xuICB2YXIgdHlwZSA9IG1lc3NhZ2UudHlwZSxcbiAgICAgIGRhdGEgPSBtZXNzYWdlLmRhdGE7XG4gIHJldHVybiB0eXBlID09PSAnbWVzc2FnZScgJiYgZGF0YSAmJiB0eXBlb2YgZGF0YS5zb3VyY2UgPT09ICdzdHJpbmcnICYmIGRhdGEuc291cmNlLnN0YXJ0c1dpdGgoJ2xvYWRlcnMuZ2wnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmtlci1ib2R5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF93b3JrZXJQb29sID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi93b3JrZXItcG9vbFwiKSk7XG5cbnZhciBfd29ya2VyVGhyZWFkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi93b3JrZXItdGhyZWFkXCIpKTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIERFRkFVTFRfUFJPUFMgPSB7XG4gIG1heENvbmN1cnJlbmN5OiAzLFxuICBtYXhNb2JpbGVDb25jdXJyZW5jeTogMSxcbiAgb25EZWJ1ZzogZnVuY3Rpb24gb25EZWJ1ZygpIHt9LFxuICByZXVzZVdvcmtlcnM6IHRydWVcbn07XG5cbnZhciBXb3JrZXJGYXJtID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBXb3JrZXJGYXJtKHByb3BzKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgV29ya2VyRmFybSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJwcm9wc1wiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwid29ya2VyUG9vbHNcIiwgbmV3IE1hcCgpKTtcbiAgICB0aGlzLnByb3BzID0gX29iamVjdFNwcmVhZCh7fSwgREVGQVVMVF9QUk9QUyk7XG4gICAgdGhpcy5zZXRQcm9wcyhwcm9wcyk7XG4gICAgdGhpcy53b3JrZXJQb29scyA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKFdvcmtlckZhcm0sIFt7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLndvcmtlclBvb2xzLnZhbHVlcygpKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgd29ya2VyUG9vbCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIHdvcmtlclBvb2wuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFByb3BzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFByb3BzKHByb3BzKSB7XG4gICAgICB0aGlzLnByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLnByb3BzKSwgcHJvcHMpO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMud29ya2VyUG9vbHMudmFsdWVzKCkpLFxuICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgd29ya2VyUG9vbCA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICB3b3JrZXJQb29sLnNldFByb3BzKHRoaXMuX2dldFdvcmtlclBvb2xQcm9wcygpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFdvcmtlclBvb2xcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0V29ya2VyUG9vbChvcHRpb25zKSB7XG4gICAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSxcbiAgICAgICAgICBzb3VyY2UgPSBvcHRpb25zLnNvdXJjZSxcbiAgICAgICAgICB1cmwgPSBvcHRpb25zLnVybDtcbiAgICAgIHZhciB3b3JrZXJQb29sID0gdGhpcy53b3JrZXJQb29scy5nZXQobmFtZSk7XG5cbiAgICAgIGlmICghd29ya2VyUG9vbCkge1xuICAgICAgICB3b3JrZXJQb29sID0gbmV3IF93b3JrZXJQb29sLmRlZmF1bHQoe1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgfSk7XG4gICAgICAgIHdvcmtlclBvb2wuc2V0UHJvcHModGhpcy5fZ2V0V29ya2VyUG9vbFByb3BzKCkpO1xuICAgICAgICB0aGlzLndvcmtlclBvb2xzLnNldChuYW1lLCB3b3JrZXJQb29sKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHdvcmtlclBvb2w7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRXb3JrZXJQb29sUHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFdvcmtlclBvb2xQcm9wcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1heENvbmN1cnJlbmN5OiB0aGlzLnByb3BzLm1heENvbmN1cnJlbmN5LFxuICAgICAgICBtYXhNb2JpbGVDb25jdXJyZW5jeTogdGhpcy5wcm9wcy5tYXhNb2JpbGVDb25jdXJyZW5jeSxcbiAgICAgICAgcmV1c2VXb3JrZXJzOiB0aGlzLnByb3BzLnJldXNlV29ya2VycyxcbiAgICAgICAgb25EZWJ1ZzogdGhpcy5wcm9wcy5vbkRlYnVnXG4gICAgICB9O1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImlzU3VwcG9ydGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzU3VwcG9ydGVkKCkge1xuICAgICAgcmV0dXJuIF93b3JrZXJUaHJlYWQuZGVmYXVsdC5pc1N1cHBvcnRlZCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRXb3JrZXJGYXJtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFdvcmtlckZhcm0oKSB7XG4gICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgV29ya2VyRmFybS5fd29ya2VyRmFybSA9IFdvcmtlckZhcm0uX3dvcmtlckZhcm0gfHwgbmV3IFdvcmtlckZhcm0oe30pO1xuXG4gICAgICBXb3JrZXJGYXJtLl93b3JrZXJGYXJtLnNldFByb3BzKHByb3BzKTtcblxuICAgICAgcmV0dXJuIFdvcmtlckZhcm0uX3dvcmtlckZhcm07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBXb3JrZXJGYXJtO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBXb3JrZXJGYXJtO1xuKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoV29ya2VyRmFybSwgXCJfd29ya2VyRmFybVwiLCB2b2lkIDApO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d29ya2VyLWZhcm0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX2Fzc2VydCA9IHJlcXVpcmUoXCIuLi9lbnYtdXRpbHMvYXNzZXJ0XCIpO1xuXG52YXIgV29ya2VySm9iID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBXb3JrZXJKb2Ioam9iTmFtZSwgd29ya2VyVGhyZWFkKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFdvcmtlckpvYik7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJuYW1lXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJ3b3JrZXJUaHJlYWRcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcImlzUnVubmluZ1wiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwicmVzdWx0XCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJfcmVzb2x2ZVwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiX3JlamVjdFwiLCB2b2lkIDApO1xuICAgIHRoaXMubmFtZSA9IGpvYk5hbWU7XG4gICAgdGhpcy53b3JrZXJUaHJlYWQgPSB3b3JrZXJUaHJlYWQ7XG4gICAgdGhpcy5pc1J1bm5pbmcgPSB0cnVlO1xuXG4gICAgdGhpcy5fcmVzb2x2ZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgdGhpcy5fcmVqZWN0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICB0aGlzLnJlc3VsdCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIF90aGlzLl9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIF90aGlzLl9yZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShXb3JrZXJKb2IsIFt7XG4gICAga2V5OiBcInBvc3RNZXNzYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc3RNZXNzYWdlKHR5cGUsIHBheWxvYWQpIHtcbiAgICAgIHRoaXMud29ya2VyVGhyZWFkLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgc291cmNlOiAnbG9hZGVycy5nbCcsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvbmUodmFsdWUpIHtcbiAgICAgICgwLCBfYXNzZXJ0LmFzc2VydCkodGhpcy5pc1J1bm5pbmcpO1xuICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcblxuICAgICAgdGhpcy5fcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVycm9yKF9lcnJvcikge1xuICAgICAgKDAsIF9hc3NlcnQuYXNzZXJ0KSh0aGlzLmlzUnVubmluZyk7XG4gICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuXG4gICAgICB0aGlzLl9yZWplY3QoX2Vycm9yKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFdvcmtlckpvYjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gV29ya2VySm9iO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d29ya2VyLWpvYi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX2dsb2JhbHMgPSByZXF1aXJlKFwiLi4vZW52LXV0aWxzL2dsb2JhbHNcIik7XG5cbnZhciBfd29ya2VyVGhyZWFkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi93b3JrZXItdGhyZWFkXCIpKTtcblxudmFyIF93b3JrZXJKb2IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3dvcmtlci1qb2JcIikpO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIFdvcmtlclBvb2wgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFdvcmtlclBvb2wocHJvcHMpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBXb3JrZXJQb29sKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcIm5hbWVcIiwgJ3VubmFtZWQnKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcInNvdXJjZVwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwidXJsXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJtYXhDb25jdXJyZW5jeVwiLCAxKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcIm1heE1vYmlsZUNvbmN1cnJlbmN5XCIsIDEpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwib25EZWJ1Z1wiLCBmdW5jdGlvbiAoKSB7fSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJyZXVzZVdvcmtlcnNcIiwgdHJ1ZSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJwcm9wc1wiLCB7fSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJqb2JRdWV1ZVwiLCBbXSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJpZGxlUXVldWVcIiwgW10pO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiY291bnRcIiwgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJpc0Rlc3Ryb3llZFwiLCBmYWxzZSk7XG4gICAgdGhpcy5zb3VyY2UgPSBwcm9wcy5zb3VyY2U7XG4gICAgdGhpcy51cmwgPSBwcm9wcy51cmw7XG4gICAgdGhpcy5zZXRQcm9wcyhwcm9wcyk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShXb3JrZXJQb29sLCBbe1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmlkbGVRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uICh3b3JrZXIpIHtcbiAgICAgICAgcmV0dXJuIHdvcmtlci5kZXN0cm95KCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRQcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQcm9wcyhwcm9wcykge1xuICAgICAgdGhpcy5wcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdGhpcy5wcm9wcyksIHByb3BzKTtcblxuICAgICAgaWYgKHByb3BzLm5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBwcm9wcy5uYW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcHMubWF4Q29uY3VycmVuY3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLm1heENvbmN1cnJlbmN5ID0gcHJvcHMubWF4Q29uY3VycmVuY3k7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wcy5tYXhNb2JpbGVDb25jdXJyZW5jeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubWF4TW9iaWxlQ29uY3VycmVuY3kgPSBwcm9wcy5tYXhNb2JpbGVDb25jdXJyZW5jeTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3BzLnJldXNlV29ya2VycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMucmV1c2VXb3JrZXJzID0gcHJvcHMucmV1c2VXb3JrZXJzO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcHMub25EZWJ1ZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMub25EZWJ1ZyA9IHByb3BzLm9uRGVidWc7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0Sm9iXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfc3RhcnRKb2IgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZShuYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIG9uTWVzc2FnZSxcbiAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgICBzdGFydFByb21pc2UsXG4gICAgICAgICAgICBfYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgb25NZXNzYWdlID0gX2FyZ3MubGVuZ3RoID4gMSAmJiBfYXJnc1sxXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3NbMV0gOiBmdW5jdGlvbiAoam9iLCB0eXBlLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gam9iLmRvbmUoZGF0YSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBvbkVycm9yID0gX2FyZ3MubGVuZ3RoID4gMiAmJiBfYXJnc1syXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3NbMl0gOiBmdW5jdGlvbiAoam9iLCBlcnJvcikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGpvYi5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzdGFydFByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAob25TdGFydCkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMuam9iUXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG9uTWVzc2FnZTogb25NZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBvbkVycm9yLFxuICAgICAgICAgICAgICAgICAgICBvblN0YXJ0OiBvblN0YXJ0XG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRRdWV1ZWRKb2IoKTtcblxuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydFByb21pc2U7XG5cbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQuc2VudCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBzdGFydEpvYihfeCkge1xuICAgICAgICByZXR1cm4gX3N0YXJ0Sm9iLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGFydEpvYjtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJfc3RhcnRRdWV1ZWRKb2JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9zdGFydFF1ZXVlZEpvYjIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICAgIHZhciB3b3JrZXJUaHJlYWQsIHF1ZXVlZEpvYiwgX2pvYjtcblxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuam9iUXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgd29ya2VyVGhyZWFkID0gdGhpcy5fZ2V0QXZhaWxhYmxlV29ya2VyKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAod29ya2VyVGhyZWFkKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgcXVldWVkSm9iID0gdGhpcy5qb2JRdWV1ZS5zaGlmdCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFxdWV1ZWRKb2IpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTg7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLm9uRGVidWcoe1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ1N0YXJ0aW5nIGpvYicsXG4gICAgICAgICAgICAgICAgICBuYW1lOiBxdWV1ZWRKb2IubmFtZSxcbiAgICAgICAgICAgICAgICAgIHdvcmtlclRocmVhZDogd29ya2VyVGhyZWFkLFxuICAgICAgICAgICAgICAgICAgYmFja2xvZzogdGhpcy5qb2JRdWV1ZS5sZW5ndGhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBfam9iID0gbmV3IF93b3JrZXJKb2IuZGVmYXVsdChxdWV1ZWRKb2IubmFtZSwgd29ya2VyVGhyZWFkKTtcblxuICAgICAgICAgICAgICAgIHdvcmtlclRocmVhZC5vbk1lc3NhZ2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXVlZEpvYi5vbk1lc3NhZ2UoX2pvYiwgZGF0YS50eXBlLCBkYXRhLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB3b3JrZXJUaHJlYWQub25FcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXVlZEpvYi5vbkVycm9yKF9qb2IsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcXVldWVkSm9iLm9uU3RhcnQoX2pvYik7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAxMjtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE1O1xuICAgICAgICAgICAgICAgIHJldHVybiBfam9iLnJlc3VsdDtcblxuICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTU7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXR1cm5Xb3JrZXJUb1F1ZXVlKHdvcmtlclRocmVhZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5maW5pc2goMTUpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzLCBbWzEyLCwgMTUsIDE4XV0pO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBfc3RhcnRRdWV1ZWRKb2IoKSB7XG4gICAgICAgIHJldHVybiBfc3RhcnRRdWV1ZWRKb2IyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfc3RhcnRRdWV1ZWRKb2I7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwicmV0dXJuV29ya2VyVG9RdWV1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXR1cm5Xb3JrZXJUb1F1ZXVlKHdvcmtlcikge1xuICAgICAgdmFyIHNob3VsZERlc3Ryb3lXb3JrZXIgPSB0aGlzLmlzRGVzdHJveWVkIHx8ICF0aGlzLnJldXNlV29ya2VycyB8fCB0aGlzLmNvdW50ID4gdGhpcy5fZ2V0TWF4Q29uY3VycmVuY3koKTtcblxuICAgICAgaWYgKHNob3VsZERlc3Ryb3lXb3JrZXIpIHtcbiAgICAgICAgd29ya2VyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5jb3VudC0tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pZGxlUXVldWUucHVzaCh3b3JrZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgdGhpcy5fc3RhcnRRdWV1ZWRKb2IoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEF2YWlsYWJsZVdvcmtlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QXZhaWxhYmxlV29ya2VyKCkge1xuICAgICAgaWYgKHRoaXMuaWRsZVF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWRsZVF1ZXVlLnNoaWZ0KCkgfHwgbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY291bnQgPCB0aGlzLl9nZXRNYXhDb25jdXJyZW5jeSgpKSB7XG4gICAgICAgIHRoaXMuY291bnQrKztcbiAgICAgICAgdmFyIG5hbWUgPSBcIlwiLmNvbmNhdCh0aGlzLm5hbWUudG9Mb3dlckNhc2UoKSwgXCIgKCNcIikuY29uY2F0KHRoaXMuY291bnQsIFwiIG9mIFwiKS5jb25jYXQodGhpcy5tYXhDb25jdXJyZW5jeSwgXCIpXCIpO1xuICAgICAgICByZXR1cm4gbmV3IF93b3JrZXJUaHJlYWQuZGVmYXVsdCh7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICAgIHVybDogdGhpcy51cmxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0TWF4Q29uY3VycmVuY3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldE1heENvbmN1cnJlbmN5KCkge1xuICAgICAgcmV0dXJuIF9nbG9iYWxzLmlzTW9iaWxlID8gdGhpcy5tYXhNb2JpbGVDb25jdXJyZW5jeSA6IHRoaXMubWF4Q29uY3VycmVuY3k7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBXb3JrZXJQb29sO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBXb3JrZXJQb29sO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d29ya2VyLXBvb2wuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX2Fzc2VydCA9IHJlcXVpcmUoXCIuLi9lbnYtdXRpbHMvYXNzZXJ0XCIpO1xuXG52YXIgX2dldExvYWRhYmxlV29ya2VyVXJsID0gcmVxdWlyZShcIi4uL3dvcmtlci11dGlscy9nZXQtbG9hZGFibGUtd29ya2VyLXVybFwiKTtcblxudmFyIF9nZXRUcmFuc2Zlckxpc3QgPSByZXF1aXJlKFwiLi4vd29ya2VyLXV0aWxzL2dldC10cmFuc2Zlci1saXN0XCIpO1xuXG52YXIgTk9PUCA9IGZ1bmN0aW9uIE5PT1AoKSB7fTtcblxudmFyIFdvcmtlclRocmVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gV29ya2VyVGhyZWFkKHByb3BzKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgV29ya2VyVGhyZWFkKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcIm5hbWVcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcInNvdXJjZVwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwidXJsXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJ0ZXJtaW5hdGVkXCIsIGZhbHNlKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcIndvcmtlclwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwib25NZXNzYWdlXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJvbkVycm9yXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJfbG9hZGFibGVVUkxcIiwgJycpO1xuICAgIHZhciBuYW1lID0gcHJvcHMubmFtZSxcbiAgICAgICAgc291cmNlID0gcHJvcHMuc291cmNlLFxuICAgICAgICB1cmwgPSBwcm9wcy51cmw7XG4gICAgKDAsIF9hc3NlcnQuYXNzZXJ0KShzb3VyY2UgfHwgdXJsKTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMub25NZXNzYWdlID0gTk9PUDtcblxuICAgIHRoaXMub25FcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICB9O1xuXG4gICAgdGhpcy53b3JrZXIgPSB0aGlzLl9jcmVhdGVCcm93c2VyV29ya2VyKCk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShXb3JrZXJUaHJlYWQsIFt7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMub25NZXNzYWdlID0gTk9PUDtcbiAgICAgIHRoaXMub25FcnJvciA9IE5PT1A7XG4gICAgICB0aGlzLndvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgIHRoaXMudGVybWluYXRlZCA9IHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzUnVubmluZ1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5vbk1lc3NhZ2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3N0TWVzc2FnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3N0TWVzc2FnZShkYXRhLCB0cmFuc2Zlckxpc3QpIHtcbiAgICAgIHRyYW5zZmVyTGlzdCA9IHRyYW5zZmVyTGlzdCB8fCAoMCwgX2dldFRyYW5zZmVyTGlzdC5nZXRUcmFuc2Zlckxpc3QpKGRhdGEpO1xuICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UoZGF0YSwgdHJhbnNmZXJMaXN0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEVycm9yRnJvbUVycm9yRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEVycm9yRnJvbUVycm9yRXZlbnQoZXZlbnQpIHtcbiAgICAgIHZhciBtZXNzYWdlID0gJ0ZhaWxlZCB0byBsb2FkICc7XG4gICAgICBtZXNzYWdlICs9IFwid29ya2VyIFwiLmNvbmNhdCh0aGlzLm5hbWUsIFwiLiBcIik7XG5cbiAgICAgIGlmIChldmVudC5tZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gXCJcIi5jb25jYXQoZXZlbnQubWVzc2FnZSwgXCIgaW4gXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQubGluZW5vKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gXCI6XCIuY29uY2F0KGV2ZW50LmxpbmVubywgXCI6XCIpLmNvbmNhdChldmVudC5jb2xubyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVCcm93c2VyV29ya2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVCcm93c2VyV29ya2VyKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5fbG9hZGFibGVVUkwgPSAoMCwgX2dldExvYWRhYmxlV29ya2VyVXJsLmdldExvYWRhYmxlV29ya2VyVVJMKSh7XG4gICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgIHVybDogdGhpcy51cmxcbiAgICAgIH0pO1xuICAgICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIodGhpcy5fbG9hZGFibGVVUkwsIHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lXG4gICAgICB9KTtcblxuICAgICAgd29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoIWV2ZW50LmRhdGEpIHtcbiAgICAgICAgICBfdGhpcy5vbkVycm9yKG5ldyBFcnJvcignTm8gZGF0YSByZWNlaXZlZCcpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5vbk1lc3NhZ2UoZXZlbnQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHdvcmtlci5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIF90aGlzLm9uRXJyb3IoX3RoaXMuX2dldEVycm9yRnJvbUVycm9yRXZlbnQoZXJyb3IpKTtcblxuICAgICAgICBfdGhpcy50ZXJtaW5hdGVkID0gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIHdvcmtlci5vbm1lc3NhZ2VlcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gY29uc29sZS5lcnJvcihldmVudCk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gd29ya2VyO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImlzU3VwcG9ydGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzU3VwcG9ydGVkKCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gV29ya2VyVGhyZWFkO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBXb3JrZXJUaHJlYWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JrZXItdGhyZWFkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXRMb2FkYWJsZVdvcmtlclVSTCA9IGdldExvYWRhYmxlV29ya2VyVVJMO1xuXG52YXIgX2Fzc2VydCA9IHJlcXVpcmUoXCIuLi9lbnYtdXRpbHMvYXNzZXJ0XCIpO1xuXG52YXIgd29ya2VyVVJMQ2FjaGUgPSBuZXcgTWFwKCk7XG5cbmZ1bmN0aW9uIGdldExvYWRhYmxlV29ya2VyVVJMKHByb3BzKSB7XG4gICgwLCBfYXNzZXJ0LmFzc2VydCkocHJvcHMuc291cmNlICYmICFwcm9wcy51cmwgfHwgIXByb3BzLnNvdXJjZSAmJiBwcm9wcy51cmwpO1xuICB2YXIgd29ya2VyVVJMID0gd29ya2VyVVJMQ2FjaGUuZ2V0KHByb3BzLnNvdXJjZSB8fCBwcm9wcy51cmwpO1xuXG4gIGlmICghd29ya2VyVVJMKSB7XG4gICAgaWYgKHByb3BzLnVybCkge1xuICAgICAgd29ya2VyVVJMID0gZ2V0TG9hZGFibGVXb3JrZXJVUkxGcm9tVVJMKHByb3BzLnVybCk7XG4gICAgICB3b3JrZXJVUkxDYWNoZS5zZXQocHJvcHMudXJsLCB3b3JrZXJVUkwpO1xuICAgIH1cblxuICAgIGlmIChwcm9wcy5zb3VyY2UpIHtcbiAgICAgIHdvcmtlclVSTCA9IGdldExvYWRhYmxlV29ya2VyVVJMRnJvbVNvdXJjZShwcm9wcy5zb3VyY2UpO1xuICAgICAgd29ya2VyVVJMQ2FjaGUuc2V0KHByb3BzLnNvdXJjZSwgd29ya2VyVVJMKTtcbiAgICB9XG4gIH1cblxuICAoMCwgX2Fzc2VydC5hc3NlcnQpKHdvcmtlclVSTCk7XG4gIHJldHVybiB3b3JrZXJVUkw7XG59XG5cbmZ1bmN0aW9uIGdldExvYWRhYmxlV29ya2VyVVJMRnJvbVVSTCh1cmwpIHtcbiAgaWYgKCF1cmwuc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIHZhciB3b3JrZXJTb3VyY2UgPSBidWlsZFNjcmlwdFNvdXJjZSh1cmwpO1xuICByZXR1cm4gZ2V0TG9hZGFibGVXb3JrZXJVUkxGcm9tU291cmNlKHdvcmtlclNvdXJjZSk7XG59XG5cbmZ1bmN0aW9uIGdldExvYWRhYmxlV29ya2VyVVJMRnJvbVNvdXJjZSh3b3JrZXJTb3VyY2UpIHtcbiAgdmFyIGJsb2IgPSBuZXcgQmxvYihbd29ya2VyU291cmNlXSwge1xuICAgIHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0J1xuICB9KTtcbiAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkU2NyaXB0U291cmNlKHdvcmtlclVybCkge1xuICByZXR1cm4gXCJ0cnkge1xcbiAgaW1wb3J0U2NyaXB0cygnXCIuY29uY2F0KHdvcmtlclVybCwgXCInKTtcXG59IGNhdGNoIChlcnJvcikge1xcbiAgY29uc29sZS5lcnJvcihlcnJvcik7XFxuICB0aHJvdyBlcnJvcjtcXG59XCIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LWxvYWRhYmxlLXdvcmtlci11cmwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXRUcmFuc2Zlckxpc3QgPSBnZXRUcmFuc2Zlckxpc3Q7XG5cbnZhciBfdHlwZW9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpKTtcblxuZnVuY3Rpb24gZ2V0VHJhbnNmZXJMaXN0KG9iamVjdCkge1xuICB2YXIgcmVjdXJzaXZlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICB2YXIgdHJhbnNmZXJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciB0cmFuc2ZlcnNTZXQgPSB0cmFuc2ZlcnMgfHwgbmV3IFNldCgpO1xuXG4gIGlmICghb2JqZWN0KSB7fSBlbHNlIGlmIChpc1RyYW5zZmVyYWJsZShvYmplY3QpKSB7XG4gICAgdHJhbnNmZXJzU2V0LmFkZChvYmplY3QpO1xuICB9IGVsc2UgaWYgKGlzVHJhbnNmZXJhYmxlKG9iamVjdC5idWZmZXIpKSB7XG4gICAgdHJhbnNmZXJzU2V0LmFkZChvYmplY3QuYnVmZmVyKTtcbiAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcob2JqZWN0KSkge30gZWxzZSBpZiAocmVjdXJzaXZlICYmICgwLCBfdHlwZW9mMi5kZWZhdWx0KShvYmplY3QpID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGdldFRyYW5zZmVyTGlzdChvYmplY3Rba2V5XSwgcmVjdXJzaXZlLCB0cmFuc2ZlcnNTZXQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cmFuc2ZlcnMgPT09IHVuZGVmaW5lZCA/IEFycmF5LmZyb20odHJhbnNmZXJzU2V0KSA6IFtdO1xufVxuXG5mdW5jdGlvbiBpc1RyYW5zZmVyYWJsZShvYmplY3QpIHtcbiAgaWYgKCFvYmplY3QpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgTWVzc2FnZVBvcnQgIT09ICd1bmRlZmluZWQnICYmIG9iamVjdCBpbnN0YW5jZW9mIE1lc3NhZ2VQb3J0KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIEltYWdlQml0bWFwICE9PSAndW5kZWZpbmVkJyAmJiBvYmplY3QgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnICYmIG9iamVjdCBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LXRyYW5zZmVyLWxpc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5yZW1vdmVOb250cmFuc2ZlcmFibGVPcHRpb25zID0gcmVtb3ZlTm9udHJhbnNmZXJhYmxlT3B0aW9ucztcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG5mdW5jdGlvbiByZW1vdmVOb250cmFuc2ZlcmFibGVPcHRpb25zKG9iamVjdCkge1xuICByZXR1cm4gSlNPTi5wYXJzZShzdHJpbmdpZnlKU09OKG9iamVjdCkpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlKU09OKHYpIHtcbiAgdmFyIGNhY2hlID0gbmV3IFNldCgpO1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodiwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoKDAsIF90eXBlb2YyLmRlZmF1bHQpKHZhbHVlKSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGlmIChjYWNoZS5oYXModmFsdWUpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjYWNoZS5hZGQodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdmUtbm9udHJhbnNmZXJhYmxlLW9wdGlvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3RhdHNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3N0YXRzLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3RhdFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc3RhdC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9nZXRIaVJlc1RpbWVzdGFtcFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaGlSZXNUaW1lc3RhbXAuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfc3RhdHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9zdGF0c1wiKSk7XG5cbnZhciBfc3RhdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL3N0YXRcIikpO1xuXG52YXIgX2hpUmVzVGltZXN0YW1wID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlscy9oaS1yZXMtdGltZXN0YW1wXCIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9oaVJlc1RpbWVzdGFtcCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3V0aWxzL2hpLXJlcy10aW1lc3RhbXBcIikpO1xuXG52YXIgU3RhdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3RhdChuYW1lLCB0eXBlKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgU3RhdCk7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuc2FtcGxlU2l6ZSA9IDE7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoU3RhdCwgW3tcbiAgICBrZXk6IFwic2V0U2FtcGxlU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTYW1wbGVTaXplKHNhbXBsZXMpIHtcbiAgICAgIHRoaXMuc2FtcGxlU2l6ZSA9IHNhbXBsZXM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5jcmVtZW50Q291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5jcmVtZW50Q291bnQoKSB7XG4gICAgICB0aGlzLmFkZENvdW50KDEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlY3JlbWVudENvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY3JlbWVudENvdW50KCkge1xuICAgICAgdGhpcy5zdWJ0cmFjdENvdW50KDEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZENvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZENvdW50KHZhbHVlKSB7XG4gICAgICB0aGlzLl9jb3VudCArPSB2YWx1ZTtcbiAgICAgIHRoaXMuX3NhbXBsZXMrKztcblxuICAgICAgdGhpcy5fY2hlY2tTYW1wbGluZygpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3VidHJhY3RDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJ0cmFjdENvdW50KHZhbHVlKSB7XG4gICAgICB0aGlzLl9jb3VudCAtPSB2YWx1ZTtcbiAgICAgIHRoaXMuX3NhbXBsZXMrKztcblxuICAgICAgdGhpcy5fY2hlY2tTYW1wbGluZygpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkVGltZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRUaW1lKHRpbWUpIHtcbiAgICAgIHRoaXMuX3RpbWUgKz0gdGltZTtcbiAgICAgIHRoaXMubGFzdFRpbWluZyA9IHRpbWU7XG4gICAgICB0aGlzLl9zYW1wbGVzKys7XG5cbiAgICAgIHRoaXMuX2NoZWNrU2FtcGxpbmcoKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRpbWVTdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aW1lU3RhcnQoKSB7XG4gICAgICB0aGlzLl9zdGFydFRpbWUgPSAoMCwgX2hpUmVzVGltZXN0YW1wLmRlZmF1bHQpKCk7XG4gICAgICB0aGlzLl90aW1lclBlbmRpbmcgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRpbWVFbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGltZUVuZCgpIHtcbiAgICAgIGlmICghdGhpcy5fdGltZXJQZW5kaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFkZFRpbWUoKDAsIF9oaVJlc1RpbWVzdGFtcC5kZWZhdWx0KSgpIC0gdGhpcy5fc3RhcnRUaW1lKTtcbiAgICAgIHRoaXMuX3RpbWVyUGVuZGluZyA9IGZhbHNlO1xuXG4gICAgICB0aGlzLl9jaGVja1NhbXBsaW5nKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTYW1wbGVBdmVyYWdlQ291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2FtcGxlQXZlcmFnZUNvdW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2FtcGxlU2l6ZSA+IDAgPyB0aGlzLmxhc3RTYW1wbGVDb3VudCAvIHRoaXMuc2FtcGxlU2l6ZSA6IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFNhbXBsZUF2ZXJhZ2VUaW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNhbXBsZUF2ZXJhZ2VUaW1lKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2FtcGxlU2l6ZSA+IDAgPyB0aGlzLmxhc3RTYW1wbGVUaW1lIC8gdGhpcy5zYW1wbGVTaXplIDogMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2FtcGxlSHpcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2FtcGxlSHooKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXN0U2FtcGxlVGltZSA+IDAgPyB0aGlzLnNhbXBsZVNpemUgLyAodGhpcy5sYXN0U2FtcGxlVGltZSAvIDEwMDApIDogMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QXZlcmFnZUNvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF2ZXJhZ2VDb3VudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNhbXBsZXMgPiAwID8gdGhpcy5jb3VudCAvIHRoaXMuc2FtcGxlcyA6IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEF2ZXJhZ2VUaW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF2ZXJhZ2VUaW1lKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2FtcGxlcyA+IDAgPyB0aGlzLnRpbWUgLyB0aGlzLnNhbXBsZXMgOiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRIelwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIeigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRpbWUgPiAwID8gdGhpcy5zYW1wbGVzIC8gKHRoaXMudGltZSAvIDEwMDApIDogMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLnRpbWUgPSAwO1xuICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICB0aGlzLnNhbXBsZXMgPSAwO1xuICAgICAgdGhpcy5sYXN0VGltaW5nID0gMDtcbiAgICAgIHRoaXMubGFzdFNhbXBsZVRpbWUgPSAwO1xuICAgICAgdGhpcy5sYXN0U2FtcGxlQ291bnQgPSAwO1xuICAgICAgdGhpcy5fY291bnQgPSAwO1xuICAgICAgdGhpcy5fdGltZSA9IDA7XG4gICAgICB0aGlzLl9zYW1wbGVzID0gMDtcbiAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IDA7XG4gICAgICB0aGlzLl90aW1lclBlbmRpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY2hlY2tTYW1wbGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2tTYW1wbGluZygpIHtcbiAgICAgIGlmICh0aGlzLl9zYW1wbGVzID09PSB0aGlzLnNhbXBsZVNpemUpIHtcbiAgICAgICAgdGhpcy5sYXN0U2FtcGxlVGltZSA9IHRoaXMuX3RpbWU7XG4gICAgICAgIHRoaXMubGFzdFNhbXBsZUNvdW50ID0gdGhpcy5fY291bnQ7XG4gICAgICAgIHRoaXMuY291bnQgKz0gdGhpcy5fY291bnQ7XG4gICAgICAgIHRoaXMudGltZSArPSB0aGlzLl90aW1lO1xuICAgICAgICB0aGlzLnNhbXBsZXMgKz0gdGhpcy5fc2FtcGxlcztcbiAgICAgICAgdGhpcy5fdGltZSA9IDA7XG4gICAgICAgIHRoaXMuX2NvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fc2FtcGxlcyA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTdGF0O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTdGF0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfc3RhdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vc3RhdFwiKSk7XG5cbnZhciBTdGF0cyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3RhdHMoX3JlZikge1xuICAgIHZhciBpZCA9IF9yZWYuaWQsXG4gICAgICAgIHN0YXRzID0gX3JlZi5zdGF0cztcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBTdGF0cyk7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuc3RhdHMgPSB7fTtcblxuICAgIHRoaXMuX2luaXRpYWxpemVTdGF0cyhzdGF0cyk7XG5cbiAgICBPYmplY3Quc2VhbCh0aGlzKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKFN0YXRzLCBbe1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICAgIHZhciB0eXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnY291bnQnO1xuICAgICAgcmV0dXJuIHRoaXMuX2dldE9yQ3JlYXRlKHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdHlwZTogdHlwZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNpemVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnN0YXRzKS5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuc3RhdHMpIHtcbiAgICAgICAgdGhpcy5zdGF0c1trZXldLnJlc2V0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmb3JFYWNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnN0YXRzKSB7XG4gICAgICAgIGZuKHRoaXMuc3RhdHNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRhYmxlKCkge1xuICAgICAgdmFyIHRhYmxlID0ge307XG4gICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHN0YXQpIHtcbiAgICAgICAgdGFibGVbc3RhdC5uYW1lXSA9IHtcbiAgICAgICAgICB0aW1lOiBzdGF0LnRpbWUgfHwgMCxcbiAgICAgICAgICBjb3VudDogc3RhdC5jb3VudCB8fCAwLFxuICAgICAgICAgIGF2ZXJhZ2U6IHN0YXQuZ2V0QXZlcmFnZVRpbWUoKSB8fCAwLFxuICAgICAgICAgIGh6OiBzdGF0LmdldEh6KCkgfHwgMFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGFibGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0aWFsaXplU3RhdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRpYWxpemVTdGF0cygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBzdGF0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gICAgICBzdGF0cy5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5fZ2V0T3JDcmVhdGUoc3RhdCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldE9yQ3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRPckNyZWF0ZShzdGF0KSB7XG4gICAgICBpZiAoIXN0YXQgfHwgIXN0YXQubmFtZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIG5hbWUgPSBzdGF0Lm5hbWUsXG4gICAgICAgICAgdHlwZSA9IHN0YXQudHlwZTtcblxuICAgICAgaWYgKCF0aGlzLnN0YXRzW25hbWVdKSB7XG4gICAgICAgIGlmIChzdGF0IGluc3RhbmNlb2YgX3N0YXQuZGVmYXVsdCkge1xuICAgICAgICAgIHRoaXMuc3RhdHNbbmFtZV0gPSBzdGF0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RhdHNbbmFtZV0gPSBuZXcgX3N0YXQuZGVmYXVsdChuYW1lLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zdGF0c1tuYW1lXTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFN0YXRzO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTdGF0cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0SGlSZXNUaW1lc3RhbXA7XG5cbmZ1bmN0aW9uIGdldEhpUmVzVGltZXN0YW1wKCkge1xuICB2YXIgdGltZXN0YW1wO1xuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucGVyZm9ybWFuY2UpIHtcbiAgICB0aW1lc3RhbXAgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuaHJ0aW1lKSB7XG4gICAgdmFyIHRpbWVQYXJ0cyA9IHByb2Nlc3MuaHJ0aW1lKCk7XG4gICAgdGltZXN0YW1wID0gdGltZVBhcnRzWzBdICogMTAwMCArIHRpbWVQYXJ0c1sxXSAvIDFlNjtcbiAgfSBlbHNlIHtcbiAgICB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICB9XG5cbiAgcmV0dXJuIHRpbWVzdGFtcDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhpLXJlcy10aW1lc3RhbXAuanMubWFwIiwiIiwibW9kdWxlLmV4cG9ydHMgPSBhdHRyaWJ1dGVUb1Byb3BlcnR5XG5cbnZhciB0cmFuc2Zvcm0gPSB7XG4gICdjbGFzcyc6ICdjbGFzc05hbWUnLFxuICAnZm9yJzogJ2h0bWxGb3InLFxuICAnaHR0cC1lcXVpdic6ICdodHRwRXF1aXYnXG59XG5cbmZ1bmN0aW9uIGF0dHJpYnV0ZVRvUHJvcGVydHkgKGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0YWdOYW1lLCBhdHRycywgY2hpbGRyZW4pIHtcbiAgICBmb3IgKHZhciBhdHRyIGluIGF0dHJzKSB7XG4gICAgICBpZiAoYXR0ciBpbiB0cmFuc2Zvcm0pIHtcbiAgICAgICAgYXR0cnNbdHJhbnNmb3JtW2F0dHJdXSA9IGF0dHJzW2F0dHJdXG4gICAgICAgIGRlbGV0ZSBhdHRyc1thdHRyXVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaCh0YWdOYW1lLCBhdHRycywgY2hpbGRyZW4pXG4gIH1cbn1cbiIsInZhciBhdHRyVG9Qcm9wID0gcmVxdWlyZSgnaHlwZXJzY3JpcHQtYXR0cmlidXRlLXRvLXByb3BlcnR5JylcblxudmFyIFZBUiA9IDAsIFRFWFQgPSAxLCBPUEVOID0gMiwgQ0xPU0UgPSAzLCBBVFRSID0gNFxudmFyIEFUVFJfS0VZID0gNSwgQVRUUl9LRVlfVyA9IDZcbnZhciBBVFRSX1ZBTFVFX1cgPSA3LCBBVFRSX1ZBTFVFID0gOFxudmFyIEFUVFJfVkFMVUVfU1EgPSA5LCBBVFRSX1ZBTFVFX0RRID0gMTBcbnZhciBBVFRSX0VRID0gMTEsIEFUVFJfQlJFQUsgPSAxMlxudmFyIENPTU1FTlQgPSAxM1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChoLCBvcHRzKSB7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG4gIHZhciBjb25jYXQgPSBvcHRzLmNvbmNhdCB8fCBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBTdHJpbmcoYSkgKyBTdHJpbmcoYilcbiAgfVxuICBpZiAob3B0cy5hdHRyVG9Qcm9wICE9PSBmYWxzZSkge1xuICAgIGggPSBhdHRyVG9Qcm9wKGgpXG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKHN0cmluZ3MpIHtcbiAgICB2YXIgc3RhdGUgPSBURVhULCByZWcgPSAnJ1xuICAgIHZhciBhcmdsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgdmFyIHBhcnRzID0gW11cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGkgPCBhcmdsZW4gLSAxKSB7XG4gICAgICAgIHZhciBhcmcgPSBhcmd1bWVudHNbaSsxXVxuICAgICAgICB2YXIgcCA9IHBhcnNlKHN0cmluZ3NbaV0pXG4gICAgICAgIHZhciB4c3RhdGUgPSBzdGF0ZVxuICAgICAgICBpZiAoeHN0YXRlID09PSBBVFRSX1ZBTFVFX0RRKSB4c3RhdGUgPSBBVFRSX1ZBTFVFXG4gICAgICAgIGlmICh4c3RhdGUgPT09IEFUVFJfVkFMVUVfU1EpIHhzdGF0ZSA9IEFUVFJfVkFMVUVcbiAgICAgICAgaWYgKHhzdGF0ZSA9PT0gQVRUUl9WQUxVRV9XKSB4c3RhdGUgPSBBVFRSX1ZBTFVFXG4gICAgICAgIGlmICh4c3RhdGUgPT09IEFUVFIpIHhzdGF0ZSA9IEFUVFJfS0VZXG4gICAgICAgIGlmICh4c3RhdGUgPT09IE9QRU4pIHtcbiAgICAgICAgICBpZiAocmVnID09PSAnLycpIHtcbiAgICAgICAgICAgIHAucHVzaChbIE9QRU4sICcvJywgYXJnIF0pXG4gICAgICAgICAgICByZWcgPSAnJ1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwLnB1c2goWyBPUEVOLCBhcmcgXSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoeHN0YXRlID09PSBDT01NRU5UICYmIG9wdHMuY29tbWVudHMpIHtcbiAgICAgICAgICByZWcgKz0gU3RyaW5nKGFyZylcbiAgICAgICAgfSBlbHNlIGlmICh4c3RhdGUgIT09IENPTU1FTlQpIHtcbiAgICAgICAgICBwLnB1c2goWyBWQVIsIHhzdGF0ZSwgYXJnIF0pXG4gICAgICAgIH1cbiAgICAgICAgcGFydHMucHVzaC5hcHBseShwYXJ0cywgcClcbiAgICAgIH0gZWxzZSBwYXJ0cy5wdXNoLmFwcGx5KHBhcnRzLCBwYXJzZShzdHJpbmdzW2ldKSlcbiAgICB9XG5cbiAgICB2YXIgdHJlZSA9IFtudWxsLHt9LFtdXVxuICAgIHZhciBzdGFjayA9IFtbdHJlZSwtMV1dXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGN1ciA9IHN0YWNrW3N0YWNrLmxlbmd0aC0xXVswXVxuICAgICAgdmFyIHAgPSBwYXJ0c1tpXSwgcyA9IHBbMF1cbiAgICAgIGlmIChzID09PSBPUEVOICYmIC9eXFwvLy50ZXN0KHBbMV0pKSB7XG4gICAgICAgIHZhciBpeCA9IHN0YWNrW3N0YWNrLmxlbmd0aC0xXVsxXVxuICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMSkge1xuICAgICAgICAgIHN0YWNrLnBvcCgpXG4gICAgICAgICAgc3RhY2tbc3RhY2subGVuZ3RoLTFdWzBdWzJdW2l4XSA9IGgoXG4gICAgICAgICAgICBjdXJbMF0sIGN1clsxXSwgY3VyWzJdLmxlbmd0aCA/IGN1clsyXSA6IHVuZGVmaW5lZFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzID09PSBPUEVOKSB7XG4gICAgICAgIHZhciBjID0gW3BbMV0se30sW11dXG4gICAgICAgIGN1clsyXS5wdXNoKGMpXG4gICAgICAgIHN0YWNrLnB1c2goW2MsY3VyWzJdLmxlbmd0aC0xXSlcbiAgICAgIH0gZWxzZSBpZiAocyA9PT0gQVRUUl9LRVkgfHwgKHMgPT09IFZBUiAmJiBwWzFdID09PSBBVFRSX0tFWSkpIHtcbiAgICAgICAgdmFyIGtleSA9ICcnXG4gICAgICAgIHZhciBjb3B5S2V5XG4gICAgICAgIGZvciAoOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAocGFydHNbaV1bMF0gPT09IEFUVFJfS0VZKSB7XG4gICAgICAgICAgICBrZXkgPSBjb25jYXQoa2V5LCBwYXJ0c1tpXVsxXSlcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcnRzW2ldWzBdID09PSBWQVIgJiYgcGFydHNbaV1bMV0gPT09IEFUVFJfS0VZKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcnRzW2ldWzJdID09PSAnb2JqZWN0JyAmJiAha2V5KSB7XG4gICAgICAgICAgICAgIGZvciAoY29weUtleSBpbiBwYXJ0c1tpXVsyXSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0c1tpXVsyXS5oYXNPd25Qcm9wZXJ0eShjb3B5S2V5KSAmJiAhY3VyWzFdW2NvcHlLZXldKSB7XG4gICAgICAgICAgICAgICAgICBjdXJbMV1bY29weUtleV0gPSBwYXJ0c1tpXVsyXVtjb3B5S2V5XVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAga2V5ID0gY29uY2F0KGtleSwgcGFydHNbaV1bMl0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRzW2ldWzBdID09PSBBVFRSX0VRKSBpKytcbiAgICAgICAgdmFyIGogPSBpXG4gICAgICAgIGZvciAoOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAocGFydHNbaV1bMF0gPT09IEFUVFJfVkFMVUUgfHwgcGFydHNbaV1bMF0gPT09IEFUVFJfS0VZKSB7XG4gICAgICAgICAgICBpZiAoIWN1clsxXVtrZXldKSBjdXJbMV1ba2V5XSA9IHN0cmZuKHBhcnRzW2ldWzFdKVxuICAgICAgICAgICAgZWxzZSBwYXJ0c1tpXVsxXT09PVwiXCIgfHwgKGN1clsxXVtrZXldID0gY29uY2F0KGN1clsxXVtrZXldLCBwYXJ0c1tpXVsxXSkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocGFydHNbaV1bMF0gPT09IFZBUlxuICAgICAgICAgICYmIChwYXJ0c1tpXVsxXSA9PT0gQVRUUl9WQUxVRSB8fCBwYXJ0c1tpXVsxXSA9PT0gQVRUUl9LRVkpKSB7XG4gICAgICAgICAgICBpZiAoIWN1clsxXVtrZXldKSBjdXJbMV1ba2V5XSA9IHN0cmZuKHBhcnRzW2ldWzJdKVxuICAgICAgICAgICAgZWxzZSBwYXJ0c1tpXVsyXT09PVwiXCIgfHwgKGN1clsxXVtrZXldID0gY29uY2F0KGN1clsxXVtrZXldLCBwYXJ0c1tpXVsyXSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoa2V5Lmxlbmd0aCAmJiAhY3VyWzFdW2tleV0gJiYgaSA9PT0galxuICAgICAgICAgICAgJiYgKHBhcnRzW2ldWzBdID09PSBDTE9TRSB8fCBwYXJ0c1tpXVswXSA9PT0gQVRUUl9CUkVBSykpIHtcbiAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNib29sZWFuLWF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgLy8gZW1wdHkgc3RyaW5nIGlzIGZhbHN5LCBub3Qgd2VsbCBiZWhhdmVkIHZhbHVlIGluIGJyb3dzZXJcbiAgICAgICAgICAgICAgY3VyWzFdW2tleV0gPSBrZXkudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnRzW2ldWzBdID09PSBDTE9TRSkge1xuICAgICAgICAgICAgICBpLS1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHMgPT09IEFUVFJfS0VZKSB7XG4gICAgICAgIGN1clsxXVtwWzFdXSA9IHRydWVcbiAgICAgIH0gZWxzZSBpZiAocyA9PT0gVkFSICYmIHBbMV0gPT09IEFUVFJfS0VZKSB7XG4gICAgICAgIGN1clsxXVtwWzJdXSA9IHRydWVcbiAgICAgIH0gZWxzZSBpZiAocyA9PT0gQ0xPU0UpIHtcbiAgICAgICAgaWYgKHNlbGZDbG9zaW5nKGN1clswXSkgJiYgc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGl4ID0gc3RhY2tbc3RhY2subGVuZ3RoLTFdWzFdXG4gICAgICAgICAgc3RhY2sucG9wKClcbiAgICAgICAgICBzdGFja1tzdGFjay5sZW5ndGgtMV1bMF1bMl1baXhdID0gaChcbiAgICAgICAgICAgIGN1clswXSwgY3VyWzFdLCBjdXJbMl0ubGVuZ3RoID8gY3VyWzJdIDogdW5kZWZpbmVkXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHMgPT09IFZBUiAmJiBwWzFdID09PSBURVhUKSB7XG4gICAgICAgIGlmIChwWzJdID09PSB1bmRlZmluZWQgfHwgcFsyXSA9PT0gbnVsbCkgcFsyXSA9ICcnXG4gICAgICAgIGVsc2UgaWYgKCFwWzJdKSBwWzJdID0gY29uY2F0KCcnLCBwWzJdKVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwWzJdWzBdKSkge1xuICAgICAgICAgIGN1clsyXS5wdXNoLmFwcGx5KGN1clsyXSwgcFsyXSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJbMl0ucHVzaChwWzJdKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHMgPT09IFRFWFQpIHtcbiAgICAgICAgY3VyWzJdLnB1c2gocFsxXSlcbiAgICAgIH0gZWxzZSBpZiAocyA9PT0gQVRUUl9FUSB8fCBzID09PSBBVFRSX0JSRUFLKSB7XG4gICAgICAgIC8vIG5vLW9wXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuaGFuZGxlZDogJyArIHMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRyZWVbMl0ubGVuZ3RoID4gMSAmJiAvXlxccyokLy50ZXN0KHRyZWVbMl1bMF0pKSB7XG4gICAgICB0cmVlWzJdLnNoaWZ0KClcbiAgICB9XG5cbiAgICBpZiAodHJlZVsyXS5sZW5ndGggPiAyXG4gICAgfHwgKHRyZWVbMl0ubGVuZ3RoID09PSAyICYmIC9cXFMvLnRlc3QodHJlZVsyXVsxXSkpKSB7XG4gICAgICBpZiAob3B0cy5jcmVhdGVGcmFnbWVudCkgcmV0dXJuIG9wdHMuY3JlYXRlRnJhZ21lbnQodHJlZVsyXSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ211bHRpcGxlIHJvb3QgZWxlbWVudHMgbXVzdCBiZSB3cmFwcGVkIGluIGFuIGVuY2xvc2luZyB0YWcnXG4gICAgICApXG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHRyZWVbMl1bMF0pICYmIHR5cGVvZiB0cmVlWzJdWzBdWzBdID09PSAnc3RyaW5nJ1xuICAgICYmIEFycmF5LmlzQXJyYXkodHJlZVsyXVswXVsyXSkpIHtcbiAgICAgIHRyZWVbMl1bMF0gPSBoKHRyZWVbMl1bMF1bMF0sIHRyZWVbMl1bMF1bMV0sIHRyZWVbMl1bMF1bMl0pXG4gICAgfVxuICAgIHJldHVybiB0cmVlWzJdWzBdXG5cbiAgICBmdW5jdGlvbiBwYXJzZSAoc3RyKSB7XG4gICAgICB2YXIgcmVzID0gW11cbiAgICAgIGlmIChzdGF0ZSA9PT0gQVRUUl9WQUxVRV9XKSBzdGF0ZSA9IEFUVFJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKVxuICAgICAgICBpZiAoc3RhdGUgPT09IFRFWFQgJiYgYyA9PT0gJzwnKSB7XG4gICAgICAgICAgaWYgKHJlZy5sZW5ndGgpIHJlcy5wdXNoKFtURVhULCByZWddKVxuICAgICAgICAgIHJlZyA9ICcnXG4gICAgICAgICAgc3RhdGUgPSBPUEVOXG4gICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz4nICYmICFxdW90KHN0YXRlKSAmJiBzdGF0ZSAhPT0gQ09NTUVOVCkge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gT1BFTiAmJiByZWcubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXMucHVzaChbT1BFTixyZWddKVxuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IEFUVFJfS0VZKSB7XG4gICAgICAgICAgICByZXMucHVzaChbQVRUUl9LRVkscmVnXSlcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBBVFRSX1ZBTFVFICYmIHJlZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKFtBVFRSX1ZBTFVFLHJlZ10pXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcy5wdXNoKFtDTE9TRV0pXG4gICAgICAgICAgcmVnID0gJydcbiAgICAgICAgICBzdGF0ZSA9IFRFWFRcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQ09NTUVOVCAmJiAvLSQvLnRlc3QocmVnKSAmJiBjID09PSAnLScpIHtcbiAgICAgICAgICBpZiAob3B0cy5jb21tZW50cykge1xuICAgICAgICAgICAgcmVzLnB1c2goW0FUVFJfVkFMVUUscmVnLnN1YnN0cigwLCByZWcubGVuZ3RoIC0gMSldKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZWcgPSAnJ1xuICAgICAgICAgIHN0YXRlID0gVEVYVFxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBPUEVOICYmIC9eIS0tJC8udGVzdChyZWcpKSB7XG4gICAgICAgICAgaWYgKG9wdHMuY29tbWVudHMpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKFtPUEVOLCByZWddLFtBVFRSX0tFWSwnY29tbWVudCddLFtBVFRSX0VRXSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVnID0gY1xuICAgICAgICAgIHN0YXRlID0gQ09NTUVOVFxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBURVhUIHx8IHN0YXRlID09PSBDT01NRU5UKSB7XG4gICAgICAgICAgcmVnICs9IGNcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gT1BFTiAmJiBjID09PSAnLycgJiYgcmVnLmxlbmd0aCkge1xuICAgICAgICAgIC8vIG5vLW9wLCBzZWxmIGNsb3NpbmcgdGFnIHdpdGhvdXQgYSBzcGFjZSA8YnIvPlxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBPUEVOICYmIC9cXHMvLnRlc3QoYykpIHtcbiAgICAgICAgICBpZiAocmVnLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzLnB1c2goW09QRU4sIHJlZ10pXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlZyA9ICcnXG4gICAgICAgICAgc3RhdGUgPSBBVFRSXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IE9QRU4pIHtcbiAgICAgICAgICByZWcgKz0gY1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBBVFRSICYmIC9bXlxcc1wiJz0vXS8udGVzdChjKSkge1xuICAgICAgICAgIHN0YXRlID0gQVRUUl9LRVlcbiAgICAgICAgICByZWcgPSBjXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IEFUVFIgJiYgL1xccy8udGVzdChjKSkge1xuICAgICAgICAgIGlmIChyZWcubGVuZ3RoKSByZXMucHVzaChbQVRUUl9LRVkscmVnXSlcbiAgICAgICAgICByZXMucHVzaChbQVRUUl9CUkVBS10pXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IEFUVFJfS0VZICYmIC9cXHMvLnRlc3QoYykpIHtcbiAgICAgICAgICByZXMucHVzaChbQVRUUl9LRVkscmVnXSlcbiAgICAgICAgICByZWcgPSAnJ1xuICAgICAgICAgIHN0YXRlID0gQVRUUl9LRVlfV1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBBVFRSX0tFWSAmJiBjID09PSAnPScpIHtcbiAgICAgICAgICByZXMucHVzaChbQVRUUl9LRVkscmVnXSxbQVRUUl9FUV0pXG4gICAgICAgICAgcmVnID0gJydcbiAgICAgICAgICBzdGF0ZSA9IEFUVFJfVkFMVUVfV1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBBVFRSX0tFWSkge1xuICAgICAgICAgIHJlZyArPSBjXG4gICAgICAgIH0gZWxzZSBpZiAoKHN0YXRlID09PSBBVFRSX0tFWV9XIHx8IHN0YXRlID09PSBBVFRSKSAmJiBjID09PSAnPScpIHtcbiAgICAgICAgICByZXMucHVzaChbQVRUUl9FUV0pXG4gICAgICAgICAgc3RhdGUgPSBBVFRSX1ZBTFVFX1dcbiAgICAgICAgfSBlbHNlIGlmICgoc3RhdGUgPT09IEFUVFJfS0VZX1cgfHwgc3RhdGUgPT09IEFUVFIpICYmICEvXFxzLy50ZXN0KGMpKSB7XG4gICAgICAgICAgcmVzLnB1c2goW0FUVFJfQlJFQUtdKVxuICAgICAgICAgIGlmICgvW1xcdy1dLy50ZXN0KGMpKSB7XG4gICAgICAgICAgICByZWcgKz0gY1xuICAgICAgICAgICAgc3RhdGUgPSBBVFRSX0tFWVxuICAgICAgICAgIH0gZWxzZSBzdGF0ZSA9IEFUVFJcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQVRUUl9WQUxVRV9XICYmIGMgPT09ICdcIicpIHtcbiAgICAgICAgICBzdGF0ZSA9IEFUVFJfVkFMVUVfRFFcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQVRUUl9WQUxVRV9XICYmIGMgPT09IFwiJ1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBBVFRSX1ZBTFVFX1NRXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IEFUVFJfVkFMVUVfRFEgJiYgYyA9PT0gJ1wiJykge1xuICAgICAgICAgIHJlcy5wdXNoKFtBVFRSX1ZBTFVFLHJlZ10sW0FUVFJfQlJFQUtdKVxuICAgICAgICAgIHJlZyA9ICcnXG4gICAgICAgICAgc3RhdGUgPSBBVFRSXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IEFUVFJfVkFMVUVfU1EgJiYgYyA9PT0gXCInXCIpIHtcbiAgICAgICAgICByZXMucHVzaChbQVRUUl9WQUxVRSxyZWddLFtBVFRSX0JSRUFLXSlcbiAgICAgICAgICByZWcgPSAnJ1xuICAgICAgICAgIHN0YXRlID0gQVRUUlxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBBVFRSX1ZBTFVFX1cgJiYgIS9cXHMvLnRlc3QoYykpIHtcbiAgICAgICAgICBzdGF0ZSA9IEFUVFJfVkFMVUVcbiAgICAgICAgICBpLS1cbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQVRUUl9WQUxVRSAmJiAvXFxzLy50ZXN0KGMpKSB7XG4gICAgICAgICAgcmVzLnB1c2goW0FUVFJfVkFMVUUscmVnXSxbQVRUUl9CUkVBS10pXG4gICAgICAgICAgcmVnID0gJydcbiAgICAgICAgICBzdGF0ZSA9IEFUVFJcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQVRUUl9WQUxVRSB8fCBzdGF0ZSA9PT0gQVRUUl9WQUxVRV9TUVxuICAgICAgICB8fCBzdGF0ZSA9PT0gQVRUUl9WQUxVRV9EUSkge1xuICAgICAgICAgIHJlZyArPSBjXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZSA9PT0gVEVYVCAmJiByZWcubGVuZ3RoKSB7XG4gICAgICAgIHJlcy5wdXNoKFtURVhULHJlZ10pXG4gICAgICAgIHJlZyA9ICcnXG4gICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBBVFRSX1ZBTFVFICYmIHJlZy5sZW5ndGgpIHtcbiAgICAgICAgcmVzLnB1c2goW0FUVFJfVkFMVUUscmVnXSlcbiAgICAgICAgcmVnID0gJydcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IEFUVFJfVkFMVUVfRFEgJiYgcmVnLmxlbmd0aCkge1xuICAgICAgICByZXMucHVzaChbQVRUUl9WQUxVRSxyZWddKVxuICAgICAgICByZWcgPSAnJ1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQVRUUl9WQUxVRV9TUSAmJiByZWcubGVuZ3RoKSB7XG4gICAgICAgIHJlcy5wdXNoKFtBVFRSX1ZBTFVFLHJlZ10pXG4gICAgICAgIHJlZyA9ICcnXG4gICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBBVFRSX0tFWSkge1xuICAgICAgICByZXMucHVzaChbQVRUUl9LRVkscmVnXSlcbiAgICAgICAgcmVnID0gJydcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdHJmbiAoeCkge1xuICAgIGlmICh0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHhcbiAgICBlbHNlIGlmICh0eXBlb2YgeCA9PT0gJ3N0cmluZycpIHJldHVybiB4XG4gICAgZWxzZSBpZiAoeCAmJiB0eXBlb2YgeCA9PT0gJ29iamVjdCcpIHJldHVybiB4XG4gICAgZWxzZSBpZiAoeCA9PT0gbnVsbCB8fCB4ID09PSB1bmRlZmluZWQpIHJldHVybiB4XG4gICAgZWxzZSByZXR1cm4gY29uY2F0KCcnLCB4KVxuICB9XG59XG5cbmZ1bmN0aW9uIHF1b3QgKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZSA9PT0gQVRUUl9WQUxVRV9TUSB8fCBzdGF0ZSA9PT0gQVRUUl9WQUxVRV9EUVxufVxuXG52YXIgY2xvc2VSRSA9IFJlZ0V4cCgnXignICsgW1xuICAnYXJlYScsICdiYXNlJywgJ2Jhc2Vmb250JywgJ2Jnc291bmQnLCAnYnInLCAnY29sJywgJ2NvbW1hbmQnLCAnZW1iZWQnLFxuICAnZnJhbWUnLCAnaHInLCAnaW1nJywgJ2lucHV0JywgJ2lzaW5kZXgnLCAna2V5Z2VuJywgJ2xpbmsnLCAnbWV0YScsICdwYXJhbScsXG4gICdzb3VyY2UnLCAndHJhY2snLCAnd2JyJywgJyEtLScsXG4gIC8vIFNWRyBUQUdTXG4gICdhbmltYXRlJywgJ2FuaW1hdGVUcmFuc2Zvcm0nLCAnY2lyY2xlJywgJ2N1cnNvcicsICdkZXNjJywgJ2VsbGlwc2UnLFxuICAnZmVCbGVuZCcsICdmZUNvbG9yTWF0cml4JywgJ2ZlQ29tcG9zaXRlJyxcbiAgJ2ZlQ29udm9sdmVNYXRyaXgnLCAnZmVEaWZmdXNlTGlnaHRpbmcnLCAnZmVEaXNwbGFjZW1lbnRNYXAnLFxuICAnZmVEaXN0YW50TGlnaHQnLCAnZmVGbG9vZCcsICdmZUZ1bmNBJywgJ2ZlRnVuY0InLCAnZmVGdW5jRycsICdmZUZ1bmNSJyxcbiAgJ2ZlR2F1c3NpYW5CbHVyJywgJ2ZlSW1hZ2UnLCAnZmVNZXJnZU5vZGUnLCAnZmVNb3JwaG9sb2d5JyxcbiAgJ2ZlT2Zmc2V0JywgJ2ZlUG9pbnRMaWdodCcsICdmZVNwZWN1bGFyTGlnaHRpbmcnLCAnZmVTcG90TGlnaHQnLCAnZmVUaWxlJyxcbiAgJ2ZlVHVyYnVsZW5jZScsICdmb250LWZhY2UtZm9ybWF0JywgJ2ZvbnQtZmFjZS1uYW1lJywgJ2ZvbnQtZmFjZS11cmknLFxuICAnZ2x5cGgnLCAnZ2x5cGhSZWYnLCAnaGtlcm4nLCAnaW1hZ2UnLCAnbGluZScsICdtaXNzaW5nLWdseXBoJywgJ21wYXRoJyxcbiAgJ3BhdGgnLCAncG9seWdvbicsICdwb2x5bGluZScsICdyZWN0JywgJ3NldCcsICdzdG9wJywgJ3RyZWYnLCAndXNlJywgJ3ZpZXcnLFxuICAndmtlcm4nXG5dLmpvaW4oJ3wnKSArICcpKD86W1xcLiNdW2EtekEtWjAtOVxcdTAwN0YtXFx1RkZGRl86LV0rKSokJylcbmZ1bmN0aW9uIHNlbGZDbG9zaW5nICh0YWcpIHsgcmV0dXJuIGNsb3NlUkUudGVzdCh0YWcpIH1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgdHJhaWxpbmdOZXdsaW5lUmVnZXggPSAvXFxuW1xcc10rJC9cbnZhciBsZWFkaW5nTmV3bGluZVJlZ2V4ID0gL15cXG5bXFxzXSsvXG52YXIgdHJhaWxpbmdTcGFjZVJlZ2V4ID0gL1tcXHNdKyQvXG52YXIgbGVhZGluZ1NwYWNlUmVnZXggPSAvXltcXHNdKy9cbnZhciBtdWx0aVNwYWNlUmVnZXggPSAvW1xcblxcc10rL2dcblxudmFyIFRFWFRfVEFHUyA9IFtcbiAgJ2EnLCAnYWJicicsICdiJywgJ2JkaScsICdiZG8nLCAnYnInLCAnY2l0ZScsICdkYXRhJywgJ2RmbicsICdlbScsICdpJyxcbiAgJ2tiZCcsICdtYXJrJywgJ3EnLCAncnAnLCAncnQnLCAncnRjJywgJ3J1YnknLCAncycsICdhbXAnLCAnc21hbGwnLCAnc3BhbicsXG4gICdzdHJvbmcnLCAnc3ViJywgJ3N1cCcsICd0aW1lJywgJ3UnLCAndmFyJywgJ3dicidcbl1cblxudmFyIFZFUkJBVElNX1RBR1MgPSBbXG4gICdjb2RlJywgJ3ByZScsICd0ZXh0YXJlYSdcbl1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhcHBlbmRDaGlsZCAoZWwsIGNoaWxkcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoY2hpbGRzKSkgcmV0dXJuXG5cbiAgdmFyIG5vZGVOYW1lID0gZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKVxuXG4gIHZhciBoYWRUZXh0ID0gZmFsc2VcbiAgdmFyIHZhbHVlLCBsZWFkZXJcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2hpbGRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBjaGlsZHNbaV1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgICAgYXBwZW5kQ2hpbGQoZWwsIG5vZGUpXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ251bWJlcicgfHxcbiAgICAgIHR5cGVvZiBub2RlID09PSAnYm9vbGVhbicgfHxcbiAgICAgIHR5cGVvZiBub2RlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICBub2RlIGluc3RhbmNlb2YgRGF0ZSB8fFxuICAgICAgbm9kZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgbm9kZSA9IG5vZGUudG9TdHJpbmcoKVxuICAgIH1cblxuICAgIHZhciBsYXN0Q2hpbGQgPSBlbC5jaGlsZE5vZGVzW2VsLmNoaWxkTm9kZXMubGVuZ3RoIC0gMV1cblxuICAgIC8vIEl0ZXJhdGUgb3ZlciB0ZXh0IG5vZGVzXG4gICAgaWYgKHR5cGVvZiBub2RlID09PSAnc3RyaW5nJykge1xuICAgICAgaGFkVGV4dCA9IHRydWVcblxuICAgICAgLy8gSWYgd2UgYWxyZWFkeSBoYWQgdGV4dCwgYXBwZW5kIHRvIHRoZSBleGlzdGluZyB0ZXh0XG4gICAgICBpZiAobGFzdENoaWxkICYmIGxhc3RDaGlsZC5ub2RlTmFtZSA9PT0gJyN0ZXh0Jykge1xuICAgICAgICBsYXN0Q2hpbGQubm9kZVZhbHVlICs9IG5vZGVcblxuICAgICAgLy8gV2UgZGlkbid0IGhhdmUgYSB0ZXh0IG5vZGUgeWV0LCBjcmVhdGUgb25lXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gZWwub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShub2RlKVxuICAgICAgICBlbC5hcHBlbmRDaGlsZChub2RlKVxuICAgICAgICBsYXN0Q2hpbGQgPSBub2RlXG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGxhc3Qgb2YgdGhlIGNoaWxkIG5vZGVzLCBtYWtlIHN1cmUgd2UgY2xvc2UgaXQgb3V0XG4gICAgICAvLyByaWdodFxuICAgICAgaWYgKGkgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgaGFkVGV4dCA9IGZhbHNlXG4gICAgICAgIC8vIFRyaW0gdGhlIGNoaWxkIHRleHQgbm9kZXMgaWYgdGhlIGN1cnJlbnQgbm9kZSBpc24ndCBhXG4gICAgICAgIC8vIG5vZGUgd2hlcmUgd2hpdGVzcGFjZSBtYXR0ZXJzLlxuICAgICAgICBpZiAoVEVYVF9UQUdTLmluZGV4T2Yobm9kZU5hbWUpID09PSAtMSAmJlxuICAgICAgICAgIFZFUkJBVElNX1RBR1MuaW5kZXhPZihub2RlTmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgdmFsdWUgPSBsYXN0Q2hpbGQubm9kZVZhbHVlXG4gICAgICAgICAgICAucmVwbGFjZShsZWFkaW5nTmV3bGluZVJlZ2V4LCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKHRyYWlsaW5nU3BhY2VSZWdleCwgJycpXG4gICAgICAgICAgICAucmVwbGFjZSh0cmFpbGluZ05ld2xpbmVSZWdleCwgJycpXG4gICAgICAgICAgICAucmVwbGFjZShtdWx0aVNwYWNlUmVnZXgsICcgJylcbiAgICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVDaGlsZChsYXN0Q2hpbGQpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3RDaGlsZC5ub2RlVmFsdWUgPSB2YWx1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChWRVJCQVRJTV9UQUdTLmluZGV4T2Yobm9kZU5hbWUpID09PSAtMSkge1xuICAgICAgICAgIC8vIFRoZSB2ZXJ5IGZpcnN0IG5vZGUgaW4gdGhlIGxpc3Qgc2hvdWxkIG5vdCBoYXZlIGxlYWRpbmdcbiAgICAgICAgICAvLyB3aGl0ZXNwYWNlLiBTaWJsaW5nIHRleHQgbm9kZXMgc2hvdWxkIGhhdmUgd2hpdGVzcGFjZSBpZiB0aGVyZVxuICAgICAgICAgIC8vIHdhcyBhbnkuXG4gICAgICAgICAgbGVhZGVyID0gaSA9PT0gMCA/ICcnIDogJyAnXG4gICAgICAgICAgdmFsdWUgPSBsYXN0Q2hpbGQubm9kZVZhbHVlXG4gICAgICAgICAgICAucmVwbGFjZShsZWFkaW5nTmV3bGluZVJlZ2V4LCBsZWFkZXIpXG4gICAgICAgICAgICAucmVwbGFjZShsZWFkaW5nU3BhY2VSZWdleCwgJyAnKVxuICAgICAgICAgICAgLnJlcGxhY2UodHJhaWxpbmdTcGFjZVJlZ2V4LCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKHRyYWlsaW5nTmV3bGluZVJlZ2V4LCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKG11bHRpU3BhY2VSZWdleCwgJyAnKVxuICAgICAgICAgIGxhc3RDaGlsZC5ub2RlVmFsdWUgPSB2YWx1ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgRE9NIG5vZGVzXG4gICAgfSBlbHNlIGlmIChub2RlICYmIG5vZGUubm9kZVR5cGUpIHtcbiAgICAgIC8vIElmIHRoZSBsYXN0IG5vZGUgd2FzIGEgdGV4dCBub2RlLCBtYWtlIHN1cmUgaXQgaXMgcHJvcGVybHkgY2xvc2VkIG91dFxuICAgICAgaWYgKGhhZFRleHQpIHtcbiAgICAgICAgaGFkVGV4dCA9IGZhbHNlXG5cbiAgICAgICAgLy8gVHJpbSB0aGUgY2hpbGQgdGV4dCBub2RlcyBpZiB0aGUgY3VycmVudCBub2RlIGlzbid0IGFcbiAgICAgICAgLy8gdGV4dCBub2RlIG9yIGEgY29kZSBub2RlXG4gICAgICAgIGlmIChURVhUX1RBR1MuaW5kZXhPZihub2RlTmFtZSkgPT09IC0xICYmXG4gICAgICAgICAgVkVSQkFUSU1fVEFHUy5pbmRleE9mKG5vZGVOYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICB2YWx1ZSA9IGxhc3RDaGlsZC5ub2RlVmFsdWVcbiAgICAgICAgICAgIC5yZXBsYWNlKGxlYWRpbmdOZXdsaW5lUmVnZXgsICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UodHJhaWxpbmdOZXdsaW5lUmVnZXgsICcgJylcbiAgICAgICAgICAgIC5yZXBsYWNlKG11bHRpU3BhY2VSZWdleCwgJyAnKVxuXG4gICAgICAgICAgLy8gUmVtb3ZlIGVtcHR5IHRleHQgbm9kZXMsIGFwcGVuZCBvdGhlcndpc2VcbiAgICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVDaGlsZChsYXN0Q2hpbGQpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3RDaGlsZC5ub2RlVmFsdWUgPSB2YWx1ZVxuICAgICAgICAgIH1cbiAgICAgICAgLy8gVHJpbSB0aGUgY2hpbGQgbm9kZXMgYnV0IHByZXNlcnZlIHRoZSBhcHByb3ByaWF0ZSB3aGl0ZXNwYWNlXG4gICAgICAgIH0gZWxzZSBpZiAoVkVSQkFUSU1fVEFHUy5pbmRleE9mKG5vZGVOYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICB2YWx1ZSA9IGxhc3RDaGlsZC5ub2RlVmFsdWVcbiAgICAgICAgICAgIC5yZXBsYWNlKGxlYWRpbmdTcGFjZVJlZ2V4LCAnICcpXG4gICAgICAgICAgICAucmVwbGFjZShsZWFkaW5nTmV3bGluZVJlZ2V4LCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKHRyYWlsaW5nTmV3bGluZVJlZ2V4LCAnICcpXG4gICAgICAgICAgICAucmVwbGFjZShtdWx0aVNwYWNlUmVnZXgsICcgJylcbiAgICAgICAgICBsYXN0Q2hpbGQubm9kZVZhbHVlID0gdmFsdWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBTdG9yZSB0aGUgbGFzdCBub2RlbmFtZVxuICAgICAgdmFyIF9ub2RlTmFtZSA9IG5vZGUubm9kZU5hbWVcbiAgICAgIGlmIChfbm9kZU5hbWUpIG5vZGVOYW1lID0gX25vZGVOYW1lLnRvTG93ZXJDYXNlKClcblxuICAgICAgLy8gQXBwZW5kIHRoZSBub2RlIHRvIHRoZSBET01cbiAgICAgIGVsLmFwcGVuZENoaWxkKG5vZGUpXG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBbXG4gICdhc3luYycsICdhdXRvZm9jdXMnLCAnYXV0b3BsYXknLCAnY2hlY2tlZCcsICdjb250cm9scycsICdkZWZhdWx0JyxcbiAgJ2RlZmF1bHRjaGVja2VkJywgJ2RlZmVyJywgJ2Rpc2FibGVkJywgJ2Zvcm1ub3ZhbGlkYXRlJywgJ2hpZGRlbicsXG4gICdpc21hcCcsICdsb29wJywgJ211bHRpcGxlJywgJ211dGVkJywgJ25vdmFsaWRhdGUnLCAnb3BlbicsICdwbGF5c2lubGluZScsXG4gICdyZWFkb25seScsICdyZXF1aXJlZCcsICdyZXZlcnNlZCcsICdzZWxlY3RlZCdcbl1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kb20nKShkb2N1bWVudClcbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgJ2luZGV0ZXJtaW5hdGUnXG5dXG4iLCIndXNlIHN0cmljdCdcblxudmFyIGh5cGVyeCA9IHJlcXVpcmUoJ2h5cGVyeCcpXG52YXIgYXBwZW5kQ2hpbGQgPSByZXF1aXJlKCcuL2FwcGVuZC1jaGlsZCcpXG52YXIgU1ZHX1RBR1MgPSByZXF1aXJlKCcuL3N2Zy10YWdzJylcbnZhciBCT09MX1BST1BTID0gcmVxdWlyZSgnLi9ib29sLXByb3BzJylcbi8vIFByb3BzIHRoYXQgbmVlZCB0byBiZSBzZXQgZGlyZWN0bHkgcmF0aGVyIHRoYW4gd2l0aCBlbC5zZXRBdHRyaWJ1dGUoKVxudmFyIERJUkVDVF9QUk9QUyA9IHJlcXVpcmUoJy4vZGlyZWN0LXByb3BzJylcblxudmFyIFNWR05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJ1xudmFyIFhMSU5LTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaydcblxudmFyIENPTU1FTlRfVEFHID0gJyEtLSdcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9jdW1lbnQpIHtcbiAgZnVuY3Rpb24gbmFub0h0bWxDcmVhdGVFbGVtZW50ICh0YWcsIHByb3BzLCBjaGlsZHJlbikge1xuICAgIHZhciBlbFxuXG4gICAgLy8gSWYgYW4gc3ZnIHRhZywgaXQgbmVlZHMgYSBuYW1lc3BhY2VcbiAgICBpZiAoU1ZHX1RBR1MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgcHJvcHMubmFtZXNwYWNlID0gU1ZHTlNcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBhcmUgdXNpbmcgYSBuYW1lc3BhY2VcbiAgICB2YXIgbnMgPSBmYWxzZVxuICAgIGlmIChwcm9wcy5uYW1lc3BhY2UpIHtcbiAgICAgIG5zID0gcHJvcHMubmFtZXNwYWNlXG4gICAgICBkZWxldGUgcHJvcHMubmFtZXNwYWNlXG4gICAgfVxuXG4gICAgLy8gSWYgd2UgYXJlIGV4dGVuZGluZyBhIGJ1aWx0aW4gZWxlbWVudFxuICAgIHZhciBpc0N1c3RvbUVsZW1lbnQgPSBmYWxzZVxuICAgIGlmIChwcm9wcy5pcykge1xuICAgICAgaXNDdXN0b21FbGVtZW50ID0gcHJvcHMuaXNcbiAgICAgIGRlbGV0ZSBwcm9wcy5pc1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSB0aGUgZWxlbWVudFxuICAgIGlmIChucykge1xuICAgICAgaWYgKGlzQ3VzdG9tRWxlbWVudCkge1xuICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucywgdGFnLCB7IGlzOiBpc0N1c3RvbUVsZW1lbnQgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCB0YWcpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0YWcgPT09IENPTU1FTlRfVEFHKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudChwcm9wcy5jb21tZW50KVxuICAgIH0gZWxzZSBpZiAoaXNDdXN0b21FbGVtZW50KSB7XG4gICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnLCB7IGlzOiBpc0N1c3RvbUVsZW1lbnQgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZylcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgdGhlIHByb3BlcnRpZXNcbiAgICBmb3IgKHZhciBwIGluIHByb3BzKSB7XG4gICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgdmFyIGtleSA9IHAudG9Mb3dlckNhc2UoKVxuICAgICAgICB2YXIgdmFsID0gcHJvcHNbcF1cbiAgICAgICAgLy8gTm9ybWFsaXplIGNsYXNzTmFtZVxuICAgICAgICBpZiAoa2V5ID09PSAnY2xhc3NuYW1lJykge1xuICAgICAgICAgIGtleSA9ICdjbGFzcydcbiAgICAgICAgICBwID0gJ2NsYXNzJ1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBmb3IgYXR0cmlidXRlIGdldHMgdHJhbnNmb3JtZWQgdG8gaHRtbEZvciwgYnV0IHdlIGp1c3Qgc2V0IGFzIGZvclxuICAgICAgICBpZiAocCA9PT0gJ2h0bWxGb3InKSB7XG4gICAgICAgICAgcCA9ICdmb3InXG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYSBwcm9wZXJ0eSBpcyBib29sZWFuLCBzZXQgaXRzZWxmIHRvIHRoZSBrZXlcbiAgICAgICAgaWYgKEJPT0xfUFJPUFMuaW5kZXhPZihrZXkpICE9PSAtMSkge1xuICAgICAgICAgIGlmIChTdHJpbmcodmFsKSA9PT0gJ3RydWUnKSB2YWwgPSBrZXlcbiAgICAgICAgICBlbHNlIGlmIChTdHJpbmcodmFsKSA9PT0gJ2ZhbHNlJykgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhIHByb3BlcnR5IHByZWZlcnMgYmVpbmcgc2V0IGRpcmVjdGx5IHZzIHNldEF0dHJpYnV0ZVxuICAgICAgICBpZiAoa2V5LnNsaWNlKDAsIDIpID09PSAnb24nIHx8IERJUkVDVF9QUk9QUy5pbmRleE9mKGtleSkgIT09IC0xKSB7XG4gICAgICAgICAgZWxbcF0gPSB2YWxcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobnMpIHtcbiAgICAgICAgICAgIGlmIChwID09PSAneGxpbms6aHJlZicpIHtcbiAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlTlMoWExJTktOUywgcCwgdmFsKVxuICAgICAgICAgICAgfSBlbHNlIGlmICgvXnhtbG5zKCR8OikvaS50ZXN0KHApKSB7XG4gICAgICAgICAgICAgIC8vIHNraXAgeG1sbnMgZGVmaW5pdGlvbnNcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKG51bGwsIHAsIHZhbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKHAsIHZhbClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBhcHBlbmRDaGlsZChlbCwgY2hpbGRyZW4pXG4gICAgcmV0dXJuIGVsXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVGcmFnbWVudCAobm9kZXMpIHtcbiAgICB2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobm9kZXNbaV0gPT0gbnVsbCkgY29udGludWVcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGVzW2ldKSkge1xuICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChjcmVhdGVGcmFnbWVudChub2Rlc1tpXSkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIG5vZGVzW2ldID09PSAnc3RyaW5nJykgbm9kZXNbaV0gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShub2Rlc1tpXSlcbiAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQobm9kZXNbaV0pXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudFxuICB9XG5cbiAgdmFyIGV4cG9ydHMgPSBoeXBlcngobmFub0h0bWxDcmVhdGVFbGVtZW50LCB7XG4gICAgY29tbWVudHM6IHRydWUsXG4gICAgY3JlYXRlRnJhZ21lbnQ6IGNyZWF0ZUZyYWdtZW50XG4gIH0pXG4gIGV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHNcbiAgZXhwb3J0cy5jcmVhdGVDb21tZW50ID0gbmFub0h0bWxDcmVhdGVFbGVtZW50XG4gIHJldHVybiBleHBvcnRzXG59XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBbXG4gICdzdmcnLCAnYWx0R2x5cGgnLCAnYWx0R2x5cGhEZWYnLCAnYWx0R2x5cGhJdGVtJywgJ2FuaW1hdGUnLCAnYW5pbWF0ZUNvbG9yJyxcbiAgJ2FuaW1hdGVNb3Rpb24nLCAnYW5pbWF0ZVRyYW5zZm9ybScsICdjaXJjbGUnLCAnY2xpcFBhdGgnLCAnY29sb3ItcHJvZmlsZScsXG4gICdjdXJzb3InLCAnZGVmcycsICdkZXNjJywgJ2VsbGlwc2UnLCAnZmVCbGVuZCcsICdmZUNvbG9yTWF0cml4JyxcbiAgJ2ZlQ29tcG9uZW50VHJhbnNmZXInLCAnZmVDb21wb3NpdGUnLCAnZmVDb252b2x2ZU1hdHJpeCcsXG4gICdmZURpZmZ1c2VMaWdodGluZycsICdmZURpc3BsYWNlbWVudE1hcCcsICdmZURpc3RhbnRMaWdodCcsICdmZUZsb29kJyxcbiAgJ2ZlRnVuY0EnLCAnZmVGdW5jQicsICdmZUZ1bmNHJywgJ2ZlRnVuY1InLCAnZmVHYXVzc2lhbkJsdXInLCAnZmVJbWFnZScsXG4gICdmZU1lcmdlJywgJ2ZlTWVyZ2VOb2RlJywgJ2ZlTW9ycGhvbG9neScsICdmZU9mZnNldCcsICdmZVBvaW50TGlnaHQnLFxuICAnZmVTcGVjdWxhckxpZ2h0aW5nJywgJ2ZlU3BvdExpZ2h0JywgJ2ZlVGlsZScsICdmZVR1cmJ1bGVuY2UnLCAnZmlsdGVyJyxcbiAgJ2ZvbnQnLCAnZm9udC1mYWNlJywgJ2ZvbnQtZmFjZS1mb3JtYXQnLCAnZm9udC1mYWNlLW5hbWUnLCAnZm9udC1mYWNlLXNyYycsXG4gICdmb250LWZhY2UtdXJpJywgJ2ZvcmVpZ25PYmplY3QnLCAnZycsICdnbHlwaCcsICdnbHlwaFJlZicsICdoa2VybicsICdpbWFnZScsXG4gICdsaW5lJywgJ2xpbmVhckdyYWRpZW50JywgJ21hcmtlcicsICdtYXNrJywgJ21ldGFkYXRhJywgJ21pc3NpbmctZ2x5cGgnLFxuICAnbXBhdGgnLCAncGF0aCcsICdwYXR0ZXJuJywgJ3BvbHlnb24nLCAncG9seWxpbmUnLCAncmFkaWFsR3JhZGllbnQnLCAncmVjdCcsXG4gICdzZXQnLCAnc3RvcCcsICdzd2l0Y2gnLCAnc3ltYm9sJywgJ3RleHQnLCAndGV4dFBhdGgnLCAndGl0bGUnLCAndHJlZicsXG4gICd0c3BhbicsICd1c2UnLCAndmlldycsICd2a2Vybidcbl1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuaXNNb2JpbGUgPSBpc01vYmlsZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGdldEJyb3dzZXI7XG5cbnZhciBfZ2xvYmFscyA9IHJlcXVpcmUoXCIuL2dsb2JhbHNcIik7XG5cbnZhciBfaXNCcm93c2VyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pcy1icm93c2VyXCIpKTtcblxudmFyIF9pc0VsZWN0cm9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pcy1lbGVjdHJvblwiKSk7XG5cbmZ1bmN0aW9uIGlzTW9iaWxlKCkge1xuICByZXR1cm4gdHlwZW9mIF9nbG9iYWxzLndpbmRvdy5vcmllbnRhdGlvbiAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbmZ1bmN0aW9uIGdldEJyb3dzZXIobW9ja1VzZXJBZ2VudCkge1xuICBpZiAoIW1vY2tVc2VyQWdlbnQgJiYgISgwLCBfaXNCcm93c2VyLmRlZmF1bHQpKCkpIHtcbiAgICByZXR1cm4gJ05vZGUnO1xuICB9XG5cbiAgaWYgKCgwLCBfaXNFbGVjdHJvbi5kZWZhdWx0KShtb2NrVXNlckFnZW50KSkge1xuICAgIHJldHVybiAnRWxlY3Ryb24nO1xuICB9XG5cbiAgdmFyIG5hdmlnYXRvcl8gPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyA/IG5hdmlnYXRvciA6IHt9O1xuICB2YXIgdXNlckFnZW50ID0gbW9ja1VzZXJBZ2VudCB8fCBuYXZpZ2F0b3JfLnVzZXJBZ2VudCB8fCAnJztcblxuICBpZiAodXNlckFnZW50LmluZGV4T2YoJ0VkZ2UnKSA+IC0xKSB7XG4gICAgcmV0dXJuICdFZGdlJztcbiAgfVxuXG4gIHZhciBpc01TSUUgPSB1c2VyQWdlbnQuaW5kZXhPZignTVNJRSAnKSAhPT0gLTE7XG4gIHZhciBpc1RyaWRlbnQgPSB1c2VyQWdlbnQuaW5kZXhPZignVHJpZGVudC8nKSAhPT0gLTE7XG5cbiAgaWYgKGlzTVNJRSB8fCBpc1RyaWRlbnQpIHtcbiAgICByZXR1cm4gJ0lFJztcbiAgfVxuXG4gIGlmIChfZ2xvYmFscy53aW5kb3cuY2hyb21lKSB7XG4gICAgcmV0dXJuICdDaHJvbWUnO1xuICB9XG5cbiAgaWYgKF9nbG9iYWxzLndpbmRvdy5zYWZhcmkpIHtcbiAgICByZXR1cm4gJ1NhZmFyaSc7XG4gIH1cblxuICBpZiAoX2dsb2JhbHMud2luZG93Lm1veklubmVyU2NyZWVuWCkge1xuICAgIHJldHVybiAnRmlyZWZveCc7XG4gIH1cblxuICByZXR1cm4gJ1Vua25vd24nO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LWJyb3dzZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jb25zb2xlID0gZXhwb3J0cy5wcm9jZXNzID0gZXhwb3J0cy5kb2N1bWVudCA9IGV4cG9ydHMuZ2xvYmFsID0gZXhwb3J0cy53aW5kb3cgPSBleHBvcnRzLnNlbGYgPSB2b2lkIDA7XG5cbnZhciBfdHlwZW9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpKTtcblxudmFyIGdsb2JhbHMgPSB7XG4gIHNlbGY6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLFxuICB3aW5kb3c6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdyxcbiAgZ2xvYmFsOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwsXG4gIGRvY3VtZW50OiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LFxuICBwcm9jZXNzOiAodHlwZW9mIHByb2Nlc3MgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogKDAsIF90eXBlb2YyLmRlZmF1bHQpKHByb2Nlc3MpKSA9PT0gJ29iamVjdCcgJiYgcHJvY2Vzc1xufTtcbnZhciBzZWxmXyA9IGdsb2JhbHMuc2VsZiB8fCBnbG9iYWxzLndpbmRvdyB8fCBnbG9iYWxzLmdsb2JhbDtcbmV4cG9ydHMuc2VsZiA9IHNlbGZfO1xudmFyIHdpbmRvd18gPSBnbG9iYWxzLndpbmRvdyB8fCBnbG9iYWxzLnNlbGYgfHwgZ2xvYmFscy5nbG9iYWw7XG5leHBvcnRzLndpbmRvdyA9IHdpbmRvd187XG52YXIgZ2xvYmFsXyA9IGdsb2JhbHMuZ2xvYmFsIHx8IGdsb2JhbHMuc2VsZiB8fCBnbG9iYWxzLndpbmRvdztcbmV4cG9ydHMuZ2xvYmFsID0gZ2xvYmFsXztcbnZhciBkb2N1bWVudF8gPSBnbG9iYWxzLmRvY3VtZW50IHx8IHt9O1xuZXhwb3J0cy5kb2N1bWVudCA9IGRvY3VtZW50XztcbnZhciBwcm9jZXNzXyA9IGdsb2JhbHMucHJvY2VzcyB8fCB7fTtcbmV4cG9ydHMucHJvY2VzcyA9IHByb2Nlc3NfO1xudmFyIGNvbnNvbGVfID0gY29uc29sZTtcbmV4cG9ydHMuY29uc29sZSA9IGNvbnNvbGVfO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2xvYmFscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0Jyb3dzZXI7XG5leHBvcnRzLmlzQnJvd3Nlck1haW5UaHJlYWQgPSBpc0Jyb3dzZXJNYWluVGhyZWFkO1xuXG52YXIgX3R5cGVvZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKSk7XG5cbnZhciBfaXNFbGVjdHJvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaXMtZWxlY3Ryb25cIikpO1xuXG5mdW5jdGlvbiBpc0Jyb3dzZXIoKSB7XG4gIHZhciBpc05vZGUgPSAodHlwZW9mIHByb2Nlc3MgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogKDAsIF90eXBlb2YyLmRlZmF1bHQpKHByb2Nlc3MpKSA9PT0gJ29iamVjdCcgJiYgU3RyaW5nKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScgJiYgIXByb2Nlc3MuYnJvd3NlcjtcbiAgcmV0dXJuICFpc05vZGUgfHwgKDAsIF9pc0VsZWN0cm9uLmRlZmF1bHQpKCk7XG59XG5cbmZ1bmN0aW9uIGlzQnJvd3Nlck1haW5UaHJlYWQoKSB7XG4gIHJldHVybiBpc0Jyb3dzZXIoKSAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtYnJvd3Nlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0VsZWN0cm9uO1xuXG52YXIgX3R5cGVvZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKSk7XG5cbmZ1bmN0aW9uIGlzRWxlY3Ryb24obW9ja1VzZXJBZ2VudCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKDAsIF90eXBlb2YyLmRlZmF1bHQpKHdpbmRvdy5wcm9jZXNzKSA9PT0gJ29iamVjdCcgJiYgd2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAoMCwgX3R5cGVvZjIuZGVmYXVsdCkocHJvY2Vzcy52ZXJzaW9ucykgPT09ICdvYmplY3QnICYmIEJvb2xlYW4ocHJvY2Vzcy52ZXJzaW9ucy5lbGVjdHJvbikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciByZWFsVXNlckFnZW50ID0gKHR5cGVvZiBuYXZpZ2F0b3IgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogKDAsIF90eXBlb2YyLmRlZmF1bHQpKG5hdmlnYXRvcikpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbmF2aWdhdG9yLnVzZXJBZ2VudCA9PT0gJ3N0cmluZycgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgdmFyIHVzZXJBZ2VudCA9IG1vY2tVc2VyQWdlbnQgfHwgcmVhbFVzZXJBZ2VudDtcblxuICBpZiAodXNlckFnZW50ICYmIHVzZXJBZ2VudC5pbmRleE9mKCdFbGVjdHJvbicpID49IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWVsZWN0cm9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxudmFyIF90eXBlb2YgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMb2dcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2xvZy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZFUlNJT05cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dsb2JhbHMuVkVSU0lPTjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzZWxmXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxzMi5zZWxmO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIndpbmRvd1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2xvYmFsczIud2luZG93O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdsb2JhbFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2xvYmFsczIuZ2xvYmFsO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRvY3VtZW50XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxzMi5kb2N1bWVudDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwcm9jZXNzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxzMi5wcm9jZXNzO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbnNvbGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dsb2JhbHMyLmNvbnNvbGU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNCcm93c2VyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pc0Jyb3dzZXIuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0Jyb3dzZXJNYWluVGhyZWFkXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pc0Jyb3dzZXIuaXNCcm93c2VyTWFpblRocmVhZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRCcm93c2VyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nZXRCcm93c2VyLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNNb2JpbGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dldEJyb3dzZXIuaXNNb2JpbGU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNFbGVjdHJvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaXNFbGVjdHJvbi5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzc2VydFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYXNzZXJ0LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ09MT1JcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2NvbG9yLkNPTE9SO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFkZENvbG9yXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9jb2xvci5hZGRDb2xvcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJsZWZ0UGFkXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9mb3JtYXR0ZXJzLmxlZnRQYWQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmlnaHRQYWRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2Zvcm1hdHRlcnMucmlnaHRQYWQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXV0b2JpbmRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2F1dG9iaW5kLmF1dG9iaW5kO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxvY2FsU3RvcmFnZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbG9jYWxTdG9yYWdlLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0SGlSZXNUaW1lc3RhbXBcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2hpUmVzVGltZXN0YW1wLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3RhdHNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3N0YXRzLlN0YXRzO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN0YXRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3N0YXRzLlN0YXQ7XG4gIH1cbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG5yZXF1aXJlKFwiLi9pbml0XCIpO1xuXG52YXIgX2xvZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2xvZ1wiKSk7XG5cbnZhciBfZ2xvYmFscyA9IHJlcXVpcmUoXCIuL3V0aWxzL2dsb2JhbHNcIik7XG5cbnZhciBfZ2xvYmFsczIgPSByZXF1aXJlKFwiLi9lbnYvZ2xvYmFsc1wiKTtcblxudmFyIF9pc0Jyb3dzZXIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9lbnYvaXMtYnJvd3NlclwiKSk7XG5cbnZhciBfZ2V0QnJvd3NlciA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2Vudi9nZXQtYnJvd3NlclwiKSk7XG5cbnZhciBfaXNFbGVjdHJvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZW52L2lzLWVsZWN0cm9uXCIpKTtcblxudmFyIF9hc3NlcnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWxzL2Fzc2VydFwiKSk7XG5cbnZhciBfY29sb3IgPSByZXF1aXJlKFwiLi91dGlscy9jb2xvclwiKTtcblxudmFyIF9mb3JtYXR0ZXJzID0gcmVxdWlyZShcIi4vdXRpbHMvZm9ybWF0dGVyc1wiKTtcblxudmFyIF9hdXRvYmluZCA9IHJlcXVpcmUoXCIuL3V0aWxzL2F1dG9iaW5kXCIpO1xuXG52YXIgX2xvY2FsU3RvcmFnZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbHMvbG9jYWwtc3RvcmFnZVwiKSk7XG5cbnZhciBfaGlSZXNUaW1lc3RhbXAgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWxzL2hpLXJlcy10aW1lc3RhbXBcIikpO1xuXG52YXIgX3N0YXRzID0gcmVxdWlyZShcIkBwcm9iZS5nbC9zdGF0c1wiKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7IH0pKG5vZGVJbnRlcm9wKTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7IGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG52YXIgX2RlZmF1bHQgPSBuZXcgX2xvZy5kZWZhdWx0KHtcbiAgaWQ6ICdwcm9iZS5nbCdcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2dsb2JhbHMgPSByZXF1aXJlKFwiLi91dGlscy9nbG9iYWxzXCIpO1xuXG5fZ2xvYmFscy5nbG9iYWwucHJvYmUgPSB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluaXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5ub3JtYWxpemVBcmd1bWVudHMgPSBub3JtYWxpemVBcmd1bWVudHM7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfdHlwZW9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpKTtcblxudmFyIF90b0NvbnN1bWFibGVBcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5XCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9nbG9iYWxzID0gcmVxdWlyZShcIi4uL3V0aWxzL2dsb2JhbHNcIik7XG5cbnZhciBfbG9jYWxTdG9yYWdlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdXRpbHMvbG9jYWwtc3RvcmFnZVwiKSk7XG5cbnZhciBfZm9ybWF0dGVycyA9IHJlcXVpcmUoXCIuLi91dGlscy9mb3JtYXR0ZXJzXCIpO1xuXG52YXIgX2NvbG9yID0gcmVxdWlyZShcIi4uL3V0aWxzL2NvbG9yXCIpO1xuXG52YXIgX2F1dG9iaW5kID0gcmVxdWlyZShcIi4uL3V0aWxzL2F1dG9iaW5kXCIpO1xuXG52YXIgX2Fzc2VydDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlscy9hc3NlcnRcIikpO1xuXG52YXIgX2hpUmVzVGltZXN0YW1wID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdXRpbHMvaGktcmVzLXRpbWVzdGFtcFwiKSk7XG5cbnZhciBvcmlnaW5hbENvbnNvbGUgPSB7XG4gIGRlYnVnOiBfZ2xvYmFscy5pc0Jyb3dzZXIgPyBjb25zb2xlLmRlYnVnIHx8IGNvbnNvbGUubG9nIDogY29uc29sZS5sb2csXG4gIGxvZzogY29uc29sZS5sb2csXG4gIGluZm86IGNvbnNvbGUuaW5mbyxcbiAgd2FybjogY29uc29sZS53YXJuLFxuICBlcnJvcjogY29uc29sZS5lcnJvclxufTtcbnZhciBERUZBVUxUX1NFVFRJTkdTID0ge1xuICBlbmFibGVkOiB0cnVlLFxuICBsZXZlbDogMFxufTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBjYWNoZSA9IHt9O1xudmFyIE9OQ0UgPSB7XG4gIG9uY2U6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGdldFRhYmxlSGVhZGVyKHRhYmxlKSB7XG4gIGZvciAodmFyIGtleSBpbiB0YWJsZSkge1xuICAgIGZvciAodmFyIHRpdGxlIGluIHRhYmxlW2tleV0pIHtcbiAgICAgIHJldHVybiB0aXRsZSB8fCAndW50aXRsZWQnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnZW1wdHknO1xufVxuXG52YXIgTG9nID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMb2coKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHtcbiAgICAgIGlkOiAnJ1xuICAgIH0sXG4gICAgICAgIGlkID0gX3JlZi5pZDtcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIExvZyk7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuVkVSU0lPTiA9IF9nbG9iYWxzLlZFUlNJT047XG4gICAgdGhpcy5fc3RhcnRUcyA9ICgwLCBfaGlSZXNUaW1lc3RhbXAuZGVmYXVsdCkoKTtcbiAgICB0aGlzLl9kZWx0YVRzID0gKDAsIF9oaVJlc1RpbWVzdGFtcC5kZWZhdWx0KSgpO1xuICAgIHRoaXMuTE9HX1RIUk9UVExFX1RJTUVPVVQgPSAwO1xuICAgIHRoaXMuX3N0b3JhZ2UgPSBuZXcgX2xvY2FsU3RvcmFnZS5kZWZhdWx0KFwiX19wcm9iZS1cIi5jb25jYXQodGhpcy5pZCwgXCJfX1wiKSwgREVGQVVMVF9TRVRUSU5HUyk7XG4gICAgdGhpcy51c2VyRGF0YSA9IHt9O1xuICAgIHRoaXMudGltZVN0YW1wKFwiXCIuY29uY2F0KHRoaXMuaWQsIFwiIHN0YXJ0ZWRcIikpO1xuICAgICgwLCBfYXV0b2JpbmQuYXV0b2JpbmQpKHRoaXMpO1xuICAgIE9iamVjdC5zZWFsKHRoaXMpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoTG9nLCBbe1xuICAgIGtleTogXCJsZXZlbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TGV2ZWwoKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0xldmVsKSB7XG4gICAgICB0aGlzLnNldExldmVsKG5ld0xldmVsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNFbmFibGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRW5hYmxlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdG9yYWdlLmNvbmZpZy5lbmFibGVkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRMZXZlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMZXZlbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdG9yYWdlLmNvbmZpZy5sZXZlbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VG90YWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VG90YWwoKSB7XG4gICAgICByZXR1cm4gTnVtYmVyKCgoMCwgX2hpUmVzVGltZXN0YW1wLmRlZmF1bHQpKCkgLSB0aGlzLl9zdGFydFRzKS50b1ByZWNpc2lvbigxMCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXREZWx0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZWx0YSgpIHtcbiAgICAgIHJldHVybiBOdW1iZXIoKCgwLCBfaGlSZXNUaW1lc3RhbXAuZGVmYXVsdCkoKSAtIHRoaXMuX2RlbHRhVHMpLnRvUHJlY2lzaW9uKDEwKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByaW9yaXR5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZXZlbDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld1ByaW9yaXR5KSB7XG4gICAgICB0aGlzLmxldmVsID0gbmV3UHJpb3JpdHk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFByaW9yaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFByaW9yaXR5KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGV2ZWw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgICB2YXIgZW5hYmxlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcblxuICAgICAgdGhpcy5fc3RvcmFnZS51cGRhdGVDb25maWd1cmF0aW9uKHtcbiAgICAgICAgZW5hYmxlZDogZW5hYmxlZFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRMZXZlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRMZXZlbChsZXZlbCkge1xuICAgICAgdGhpcy5fc3RvcmFnZS51cGRhdGVDb25maWd1cmF0aW9uKHtcbiAgICAgICAgbGV2ZWw6IGxldmVsXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFzc2VydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAoMCwgX2Fzc2VydDIuZGVmYXVsdCkoY29uZGl0aW9uLCBtZXNzYWdlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2FyblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3YXJuKG1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRMb2dGdW5jdGlvbigwLCBtZXNzYWdlLCBvcmlnaW5hbENvbnNvbGUud2FybiwgYXJndW1lbnRzLCBPTkNFKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXJyb3IobWVzc2FnZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldExvZ0Z1bmN0aW9uKDAsIG1lc3NhZ2UsIG9yaWdpbmFsQ29uc29sZS5lcnJvciwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVwcmVjYXRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXByZWNhdGVkKG9sZFVzYWdlLCBuZXdVc2FnZSkge1xuICAgICAgcmV0dXJuIHRoaXMud2FybihcImBcIi5jb25jYXQob2xkVXNhZ2UsIFwiYCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBsYXRlciB2ZXJzaW9uLiBVc2UgYFwiKS5jb25jYXQobmV3VXNhZ2UsIFwiYCBpbnN0ZWFkXCIpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVkKG9sZFVzYWdlLCBuZXdVc2FnZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoXCJgXCIuY29uY2F0KG9sZFVzYWdlLCBcImAgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIGBcIikuY29uY2F0KG5ld1VzYWdlLCBcImAgaW5zdGVhZFwiKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByb2JlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2JlKGxvZ0xldmVsLCBtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0TG9nRnVuY3Rpb24obG9nTGV2ZWwsIG1lc3NhZ2UsIG9yaWdpbmFsQ29uc29sZS5sb2csIGFyZ3VtZW50cywge1xuICAgICAgICB0aW1lOiB0cnVlLFxuICAgICAgICBvbmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibG9nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvZyhsb2dMZXZlbCwgbWVzc2FnZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldExvZ0Z1bmN0aW9uKGxvZ0xldmVsLCBtZXNzYWdlLCBvcmlnaW5hbENvbnNvbGUuZGVidWcsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluZm9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5mbyhsb2dMZXZlbCwgbWVzc2FnZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldExvZ0Z1bmN0aW9uKGxvZ0xldmVsLCBtZXNzYWdlLCBjb25zb2xlLmluZm8sIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25jZShsb2dMZXZlbCwgbWVzc2FnZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldExvZ0Z1bmN0aW9uKGxvZ0xldmVsLCBtZXNzYWdlLCBvcmlnaW5hbENvbnNvbGUuZGVidWcgfHwgb3JpZ2luYWxDb25zb2xlLmluZm8sIGFyZ3VtZW50cywgT05DRSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRhYmxlKGxvZ0xldmVsLCBfdGFibGUsIGNvbHVtbnMpIHtcbiAgICAgIGlmIChfdGFibGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldExvZ0Z1bmN0aW9uKGxvZ0xldmVsLCBfdGFibGUsIGNvbnNvbGUudGFibGUgfHwgbm9vcCwgY29sdW1ucyAmJiBbY29sdW1uc10sIHtcbiAgICAgICAgICB0YWc6IGdldFRhYmxlSGVhZGVyKF90YWJsZSlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub29wO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbWFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbWFnZShfcmVmMikge1xuICAgICAgdmFyIGxvZ0xldmVsID0gX3JlZjIubG9nTGV2ZWwsXG4gICAgICAgICAgcHJpb3JpdHkgPSBfcmVmMi5wcmlvcml0eSxcbiAgICAgICAgICBfaW1hZ2UgPSBfcmVmMi5pbWFnZSxcbiAgICAgICAgICBfcmVmMiRtZXNzYWdlID0gX3JlZjIubWVzc2FnZSxcbiAgICAgICAgICBtZXNzYWdlID0gX3JlZjIkbWVzc2FnZSA9PT0gdm9pZCAwID8gJycgOiBfcmVmMiRtZXNzYWdlLFxuICAgICAgICAgIF9yZWYyJHNjYWxlID0gX3JlZjIuc2NhbGUsXG4gICAgICAgICAgc2NhbGUgPSBfcmVmMiRzY2FsZSA9PT0gdm9pZCAwID8gMSA6IF9yZWYyJHNjYWxlO1xuXG4gICAgICBpZiAoIXRoaXMuX3Nob3VsZExvZyhsb2dMZXZlbCB8fCBwcmlvcml0eSkpIHtcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZ2xvYmFscy5pc0Jyb3dzZXIgPyBsb2dJbWFnZUluQnJvd3Nlcih7XG4gICAgICAgIGltYWdlOiBfaW1hZ2UsXG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgIHNjYWxlOiBzY2FsZVxuICAgICAgfSkgOiBsb2dJbWFnZUluTm9kZSh7XG4gICAgICAgIGltYWdlOiBfaW1hZ2UsXG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgIHNjYWxlOiBzY2FsZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldHRpbmdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldHRpbmdzKCkge1xuICAgICAgaWYgKGNvbnNvbGUudGFibGUpIHtcbiAgICAgICAgY29uc29sZS50YWJsZSh0aGlzLl9zdG9yYWdlLmNvbmZpZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLl9zdG9yYWdlLmNvbmZpZyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoc2V0dGluZykge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0b3JhZ2UuY29uZmlnW3NldHRpbmddO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KHNldHRpbmcsIHZhbHVlKSB7XG4gICAgICB0aGlzLl9zdG9yYWdlLnVwZGF0ZUNvbmZpZ3VyYXRpb24oKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoe30sIHNldHRpbmcsIHZhbHVlKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRpbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGltZShsb2dMZXZlbCwgbWVzc2FnZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldExvZ0Z1bmN0aW9uKGxvZ0xldmVsLCBtZXNzYWdlLCBjb25zb2xlLnRpbWUgPyBjb25zb2xlLnRpbWUgOiBjb25zb2xlLmluZm8pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0aW1lRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRpbWVFbmQobG9nTGV2ZWwsIG1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRMb2dGdW5jdGlvbihsb2dMZXZlbCwgbWVzc2FnZSwgY29uc29sZS50aW1lRW5kID8gY29uc29sZS50aW1lRW5kIDogY29uc29sZS5pbmZvKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGltZVN0YW1wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRpbWVTdGFtcChsb2dMZXZlbCwgbWVzc2FnZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldExvZ0Z1bmN0aW9uKGxvZ0xldmVsLCBtZXNzYWdlLCBjb25zb2xlLnRpbWVTdGFtcCB8fCBub29wKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ3JvdXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ3JvdXAobG9nTGV2ZWwsIG1lc3NhZ2UpIHtcbiAgICAgIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7XG4gICAgICAgIGNvbGxhcHNlZDogZmFsc2VcbiAgICAgIH07XG4gICAgICBvcHRzID0gbm9ybWFsaXplQXJndW1lbnRzKHtcbiAgICAgICAgbG9nTGV2ZWw6IGxvZ0xldmVsLFxuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICBvcHRzOiBvcHRzXG4gICAgICB9KTtcbiAgICAgIHZhciBfb3B0cyA9IG9wdHMsXG4gICAgICAgICAgY29sbGFwc2VkID0gX29wdHMuY29sbGFwc2VkO1xuICAgICAgb3B0cy5tZXRob2QgPSAoY29sbGFwc2VkID8gY29uc29sZS5ncm91cENvbGxhcHNlZCA6IGNvbnNvbGUuZ3JvdXApIHx8IGNvbnNvbGUuaW5mbztcbiAgICAgIHJldHVybiB0aGlzLl9nZXRMb2dGdW5jdGlvbihvcHRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ3JvdXBDb2xsYXBzZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ3JvdXBDb2xsYXBzZWQobG9nTGV2ZWwsIG1lc3NhZ2UpIHtcbiAgICAgIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgIHJldHVybiB0aGlzLmdyb3VwKGxvZ0xldmVsLCBtZXNzYWdlLCBPYmplY3QuYXNzaWduKHt9LCBvcHRzLCB7XG4gICAgICAgIGNvbGxhcHNlZDogdHJ1ZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJncm91cEVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBncm91cEVuZChsb2dMZXZlbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldExvZ0Z1bmN0aW9uKGxvZ0xldmVsLCAnJywgY29uc29sZS5ncm91cEVuZCB8fCBub29wKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2l0aEdyb3VwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhHcm91cChsb2dMZXZlbCwgbWVzc2FnZSwgZnVuYykge1xuICAgICAgdGhpcy5ncm91cChsb2dMZXZlbCwgbWVzc2FnZSkoKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZnVuYygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5ncm91cEVuZChsb2dMZXZlbCkoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidHJhY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhY2UoKSB7XG4gICAgICBpZiAoY29uc29sZS50cmFjZSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zaG91bGRMb2dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Nob3VsZExvZyhsb2dMZXZlbCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNFbmFibGVkKCkgJiYgdGhpcy5nZXRMZXZlbCgpID49IG5vcm1hbGl6ZUxvZ0xldmVsKGxvZ0xldmVsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldExvZ0Z1bmN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRMb2dGdW5jdGlvbihsb2dMZXZlbCwgbWVzc2FnZSwgbWV0aG9kKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogW107XG4gICAgICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ID8gYXJndW1lbnRzWzRdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAodGhpcy5fc2hvdWxkTG9nKGxvZ0xldmVsKSkge1xuICAgICAgICB2YXIgX21ldGhvZDtcblxuICAgICAgICBvcHRzID0gbm9ybWFsaXplQXJndW1lbnRzKHtcbiAgICAgICAgICBsb2dMZXZlbDogbG9nTGV2ZWwsXG4gICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICBhcmdzOiBhcmdzLFxuICAgICAgICAgIG9wdHM6IG9wdHNcbiAgICAgICAgfSk7XG4gICAgICAgIG1ldGhvZCA9IG1ldGhvZCB8fCBvcHRzLm1ldGhvZDtcbiAgICAgICAgKDAsIF9hc3NlcnQyLmRlZmF1bHQpKG1ldGhvZCk7XG4gICAgICAgIG9wdHMudG90YWwgPSB0aGlzLmdldFRvdGFsKCk7XG4gICAgICAgIG9wdHMuZGVsdGEgPSB0aGlzLmdldERlbHRhKCk7XG4gICAgICAgIHRoaXMuX2RlbHRhVHMgPSAoMCwgX2hpUmVzVGltZXN0YW1wLmRlZmF1bHQpKCk7XG4gICAgICAgIHZhciB0YWcgPSBvcHRzLnRhZyB8fCBvcHRzLm1lc3NhZ2U7XG5cbiAgICAgICAgaWYgKG9wdHMub25jZSkge1xuICAgICAgICAgIGlmICghY2FjaGVbdGFnXSkge1xuICAgICAgICAgICAgY2FjaGVbdGFnXSA9ICgwLCBfaGlSZXNUaW1lc3RhbXAuZGVmYXVsdCkoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWVzc2FnZSA9IGRlY29yYXRlTWVzc2FnZSh0aGlzLmlkLCBvcHRzLm1lc3NhZ2UsIG9wdHMpO1xuICAgICAgICByZXR1cm4gKF9tZXRob2QgPSBtZXRob2QpLmJpbmQuYXBwbHkoX21ldGhvZCwgW2NvbnNvbGUsIG1lc3NhZ2VdLmNvbmNhdCgoMCwgX3RvQ29uc3VtYWJsZUFycmF5Mi5kZWZhdWx0KShvcHRzLmFyZ3MpKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub29wO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTG9nO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBMb2c7XG5Mb2cuVkVSU0lPTiA9IF9nbG9iYWxzLlZFUlNJT047XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxvZ0xldmVsKGxvZ0xldmVsKSB7XG4gIGlmICghbG9nTGV2ZWwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciByZXNvbHZlZExldmVsO1xuXG4gIHN3aXRjaCAoKDAsIF90eXBlb2YyLmRlZmF1bHQpKGxvZ0xldmVsKSkge1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXNvbHZlZExldmVsID0gbG9nTGV2ZWw7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXNvbHZlZExldmVsID0gbG9nTGV2ZWwubG9nTGV2ZWwgfHwgbG9nTGV2ZWwucHJpb3JpdHkgfHwgMDtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAwO1xuICB9XG5cbiAgKDAsIF9hc3NlcnQyLmRlZmF1bHQpKE51bWJlci5pc0Zpbml0ZShyZXNvbHZlZExldmVsKSAmJiByZXNvbHZlZExldmVsID49IDApO1xuICByZXR1cm4gcmVzb2x2ZWRMZXZlbDtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQXJndW1lbnRzKG9wdHMpIHtcbiAgdmFyIGxvZ0xldmVsID0gb3B0cy5sb2dMZXZlbCxcbiAgICAgIG1lc3NhZ2UgPSBvcHRzLm1lc3NhZ2U7XG4gIG9wdHMubG9nTGV2ZWwgPSBub3JtYWxpemVMb2dMZXZlbChsb2dMZXZlbCk7XG4gIHZhciBhcmdzID0gb3B0cy5hcmdzID8gQXJyYXkuZnJvbShvcHRzLmFyZ3MpIDogW107XG5cbiAgd2hpbGUgKGFyZ3MubGVuZ3RoICYmIGFyZ3Muc2hpZnQoKSAhPT0gbWVzc2FnZSkge31cblxuICBvcHRzLmFyZ3MgPSBhcmdzO1xuXG4gIHN3aXRjaCAoKDAsIF90eXBlb2YyLmRlZmF1bHQpKGxvZ0xldmVsKSkge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgaWYgKG1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhcmdzLnVuc2hpZnQobWVzc2FnZSk7XG4gICAgICB9XG5cbiAgICAgIG9wdHMubWVzc2FnZSA9IGxvZ0xldmVsO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgT2JqZWN0LmFzc2lnbihvcHRzLCBsb2dMZXZlbCk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdHMubWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdHMubWVzc2FnZSA9IG9wdHMubWVzc2FnZSgpO1xuICB9XG5cbiAgdmFyIG1lc3NhZ2VUeXBlID0gKDAsIF90eXBlb2YyLmRlZmF1bHQpKG9wdHMubWVzc2FnZSk7XG4gICgwLCBfYXNzZXJ0Mi5kZWZhdWx0KShtZXNzYWdlVHlwZSA9PT0gJ3N0cmluZycgfHwgbWVzc2FnZVR5cGUgPT09ICdvYmplY3QnKTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob3B0cywgb3B0cy5vcHRzKTtcbn1cblxuZnVuY3Rpb24gZGVjb3JhdGVNZXNzYWdlKGlkLCBtZXNzYWdlLCBvcHRzKSB7XG4gIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgdGltZSA9IG9wdHMudGltZSA/ICgwLCBfZm9ybWF0dGVycy5sZWZ0UGFkKSgoMCwgX2Zvcm1hdHRlcnMuZm9ybWF0VGltZSkob3B0cy50b3RhbCkpIDogJyc7XG4gICAgbWVzc2FnZSA9IG9wdHMudGltZSA/IFwiXCIuY29uY2F0KGlkLCBcIjogXCIpLmNvbmNhdCh0aW1lLCBcIiAgXCIpLmNvbmNhdChtZXNzYWdlKSA6IFwiXCIuY29uY2F0KGlkLCBcIjogXCIpLmNvbmNhdChtZXNzYWdlKTtcbiAgICBtZXNzYWdlID0gKDAsIF9jb2xvci5hZGRDb2xvcikobWVzc2FnZSwgb3B0cy5jb2xvciwgb3B0cy5iYWNrZ3JvdW5kKTtcbiAgfVxuXG4gIHJldHVybiBtZXNzYWdlO1xufVxuXG5mdW5jdGlvbiBsb2dJbWFnZUluTm9kZShfcmVmMykge1xuICB2YXIgaW1hZ2UgPSBfcmVmMy5pbWFnZSxcbiAgICAgIF9yZWYzJG1lc3NhZ2UgPSBfcmVmMy5tZXNzYWdlLFxuICAgICAgbWVzc2FnZSA9IF9yZWYzJG1lc3NhZ2UgPT09IHZvaWQgMCA/ICcnIDogX3JlZjMkbWVzc2FnZSxcbiAgICAgIF9yZWYzJHNjYWxlID0gX3JlZjMuc2NhbGUsXG4gICAgICBzY2FsZSA9IF9yZWYzJHNjYWxlID09PSB2b2lkIDAgPyAxIDogX3JlZjMkc2NhbGU7XG4gIHZhciBhc2NpaWZ5ID0gbnVsbDtcblxuICB0cnkge1xuICAgIGFzY2lpZnkgPSBtb2R1bGUucmVxdWlyZSgnYXNjaWlmeS1pbWFnZScpO1xuICB9IGNhdGNoIChlcnJvcikge31cblxuICBpZiAoYXNjaWlmeSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXNjaWlmeShpbWFnZSwge1xuICAgICAgICBmaXQ6ICdib3gnLFxuICAgICAgICB3aWR0aDogXCJcIi5jb25jYXQoTWF0aC5yb3VuZCg4MCAqIHNjYWxlKSwgXCIlXCIpXG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gbm9vcDtcbn1cblxuZnVuY3Rpb24gbG9nSW1hZ2VJbkJyb3dzZXIoX3JlZjQpIHtcbiAgdmFyIGltYWdlID0gX3JlZjQuaW1hZ2UsXG4gICAgICBfcmVmNCRtZXNzYWdlID0gX3JlZjQubWVzc2FnZSxcbiAgICAgIG1lc3NhZ2UgPSBfcmVmNCRtZXNzYWdlID09PSB2b2lkIDAgPyAnJyA6IF9yZWY0JG1lc3NhZ2UsXG4gICAgICBfcmVmNCRzY2FsZSA9IF9yZWY0LnNjYWxlLFxuICAgICAgc2NhbGUgPSBfcmVmNCRzY2FsZSA9PT0gdm9pZCAwID8gMSA6IF9yZWY0JHNjYWxlO1xuXG4gIGlmICh0eXBlb2YgaW1hZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuXG4gICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfY29uc29sZTtcblxuICAgICAgdmFyIGFyZ3MgPSAoMCwgX2Zvcm1hdHRlcnMuZm9ybWF0SW1hZ2UpKGltZywgbWVzc2FnZSwgc2NhbGUpO1xuXG4gICAgICAoX2NvbnNvbGUgPSBjb25zb2xlKS5sb2cuYXBwbHkoX2NvbnNvbGUsICgwLCBfdG9Db25zdW1hYmxlQXJyYXkyLmRlZmF1bHQpKGFyZ3MpKTtcbiAgICB9O1xuXG4gICAgaW1nLnNyYyA9IGltYWdlO1xuICAgIHJldHVybiBub29wO1xuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBpbWFnZS5ub2RlTmFtZSB8fCAnJztcblxuICBpZiAoZWxlbWVudC50b0xvd2VyQ2FzZSgpID09PSAnaW1nJykge1xuICAgIHZhciBfY29uc29sZTI7XG5cbiAgICAoX2NvbnNvbGUyID0gY29uc29sZSkubG9nLmFwcGx5KF9jb25zb2xlMiwgKDAsIF90b0NvbnN1bWFibGVBcnJheTIuZGVmYXVsdCkoKDAsIF9mb3JtYXR0ZXJzLmZvcm1hdEltYWdlKShpbWFnZSwgbWVzc2FnZSwgc2NhbGUpKSk7XG5cbiAgICByZXR1cm4gbm9vcDtcbiAgfVxuXG4gIGlmIChlbGVtZW50LnRvTG93ZXJDYXNlKCkgPT09ICdjYW52YXMnKSB7XG4gICAgdmFyIF9pbWcgPSBuZXcgSW1hZ2UoKTtcblxuICAgIF9pbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9jb25zb2xlMztcblxuICAgICAgcmV0dXJuIChfY29uc29sZTMgPSBjb25zb2xlKS5sb2cuYXBwbHkoX2NvbnNvbGUzLCAoMCwgX3RvQ29uc3VtYWJsZUFycmF5Mi5kZWZhdWx0KSgoMCwgX2Zvcm1hdHRlcnMuZm9ybWF0SW1hZ2UpKF9pbWcsIG1lc3NhZ2UsIHNjYWxlKSkpO1xuICAgIH07XG5cbiAgICBfaW1nLnNyYyA9IGltYWdlLnRvRGF0YVVSTCgpO1xuICAgIHJldHVybiBub29wO1xuICB9XG5cbiAgcmV0dXJuIG5vb3A7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2cuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBhc3NlcnQ7XG5cbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NlcnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmF1dG9iaW5kID0gYXV0b2JpbmQ7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gYXV0b2JpbmQob2JqKSB7XG4gIHZhciBwcmVkZWZpbmVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbJ2NvbnN0cnVjdG9yJ107XG4gIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuICB2YXIgcHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pO1xuXG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihwcm9wTmFtZXMpLFxuICAgICAgX3N0ZXA7XG5cbiAgdHJ5IHtcbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIHZhciBrZXkgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoIXByZWRlZmluZWQuZmluZChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIHJldHVybiBrZXkgPT09IG5hbWU7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgb2JqW2tleV0gPSBvYmpba2V5XS5iaW5kKG9iaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIF9sb29wKCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvci5mKCk7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dG9iaW5kLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5hZGRDb2xvciA9IGFkZENvbG9yO1xuZXhwb3J0cy5DT0xPUiA9IHZvaWQgMDtcblxudmFyIF9nbG9iYWxzID0gcmVxdWlyZShcIi4vZ2xvYmFsc1wiKTtcblxudmFyIENPTE9SID0ge1xuICBCTEFDSzogMzAsXG4gIFJFRDogMzEsXG4gIEdSRUVOOiAzMixcbiAgWUVMTE9XOiAzMyxcbiAgQkxVRTogMzQsXG4gIE1BR0VOVEE6IDM1LFxuICBDWUFOOiAzNixcbiAgV0hJVEU6IDM3LFxuICBCUklHSFRfQkxBQ0s6IDkwLFxuICBCUklHSFRfUkVEOiA5MSxcbiAgQlJJR0hUX0dSRUVOOiA5MixcbiAgQlJJR0hUX1lFTExPVzogOTMsXG4gIEJSSUdIVF9CTFVFOiA5NCxcbiAgQlJJR0hUX01BR0VOVEE6IDk1LFxuICBCUklHSFRfQ1lBTjogOTYsXG4gIEJSSUdIVF9XSElURTogOTdcbn07XG5leHBvcnRzLkNPTE9SID0gQ09MT1I7XG5cbmZ1bmN0aW9uIGdldENvbG9yKGNvbG9yKSB7XG4gIHJldHVybiB0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnID8gQ09MT1JbY29sb3IudG9VcHBlckNhc2UoKV0gfHwgQ09MT1IuV0hJVEUgOiBjb2xvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29sb3Ioc3RyaW5nLCBjb2xvciwgYmFja2dyb3VuZCkge1xuICBpZiAoIV9nbG9iYWxzLmlzQnJvd3NlciAmJiB0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJykge1xuICAgIGlmIChjb2xvcikge1xuICAgICAgY29sb3IgPSBnZXRDb2xvcihjb2xvcik7XG4gICAgICBzdHJpbmcgPSBcIlxceDFCW1wiLmNvbmNhdChjb2xvciwgXCJtXCIpLmNvbmNhdChzdHJpbmcsIFwiXFx4MUJbMzltXCIpO1xuICAgIH1cblxuICAgIGlmIChiYWNrZ3JvdW5kKSB7XG4gICAgICBjb2xvciA9IGdldENvbG9yKGJhY2tncm91bmQpO1xuICAgICAgc3RyaW5nID0gXCJcXHgxQltcIi5jb25jYXQoYmFja2dyb3VuZCArIDEwLCBcIm1cIikuY29uY2F0KHN0cmluZywgXCJcXHgxQls0OW1cIik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cmluZztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5mb3JtYXRUaW1lID0gZm9ybWF0VGltZTtcbmV4cG9ydHMubGVmdFBhZCA9IGxlZnRQYWQ7XG5leHBvcnRzLnJpZ2h0UGFkID0gcmlnaHRQYWQ7XG5leHBvcnRzLmZvcm1hdFZhbHVlID0gZm9ybWF0VmFsdWU7XG5leHBvcnRzLmZvcm1hdEltYWdlID0gZm9ybWF0SW1hZ2U7XG5cbmZ1bmN0aW9uIGZvcm1hdFRpbWUobXMpIHtcbiAgdmFyIGZvcm1hdHRlZDtcblxuICBpZiAobXMgPCAxMCkge1xuICAgIGZvcm1hdHRlZCA9IFwiXCIuY29uY2F0KG1zLnRvRml4ZWQoMiksIFwibXNcIik7XG4gIH0gZWxzZSBpZiAobXMgPCAxMDApIHtcbiAgICBmb3JtYXR0ZWQgPSBcIlwiLmNvbmNhdChtcy50b0ZpeGVkKDEpLCBcIm1zXCIpO1xuICB9IGVsc2UgaWYgKG1zIDwgMTAwMCkge1xuICAgIGZvcm1hdHRlZCA9IFwiXCIuY29uY2F0KG1zLnRvRml4ZWQoMCksIFwibXNcIik7XG4gIH0gZWxzZSB7XG4gICAgZm9ybWF0dGVkID0gXCJcIi5jb25jYXQoKG1zIC8gMTAwMCkudG9GaXhlZCgyKSwgXCJzXCIpO1xuICB9XG5cbiAgcmV0dXJuIGZvcm1hdHRlZDtcbn1cblxuZnVuY3Rpb24gbGVmdFBhZChzdHJpbmcpIHtcbiAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogODtcbiAgdmFyIHBhZExlbmd0aCA9IE1hdGgubWF4KGxlbmd0aCAtIHN0cmluZy5sZW5ndGgsIDApO1xuICByZXR1cm4gXCJcIi5jb25jYXQoJyAnLnJlcGVhdChwYWRMZW5ndGgpKS5jb25jYXQoc3RyaW5nKTtcbn1cblxuZnVuY3Rpb24gcmlnaHRQYWQoc3RyaW5nKSB7XG4gIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDg7XG4gIHZhciBwYWRMZW5ndGggPSBNYXRoLm1heChsZW5ndGggLSBzdHJpbmcubGVuZ3RoLCAwKTtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KHN0cmluZykuY29uY2F0KCcgJy5yZXBlYXQocGFkTGVuZ3RoKSk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKHYpIHtcbiAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgRVBTSUxPTiA9IDFlLTE2O1xuICB2YXIgX29wdHMkaXNJbnRlZ2VyID0gb3B0cy5pc0ludGVnZXIsXG4gICAgICBpc0ludGVnZXIgPSBfb3B0cyRpc0ludGVnZXIgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdHMkaXNJbnRlZ2VyO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHYpIHx8IEFycmF5QnVmZmVyLmlzVmlldyh2KSkge1xuICAgIHJldHVybiBmb3JtYXRBcnJheVZhbHVlKHYsIG9wdHMpO1xuICB9XG5cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodikpIHtcbiAgICByZXR1cm4gU3RyaW5nKHYpO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKHYpIDwgRVBTSUxPTikge1xuICAgIHJldHVybiBpc0ludGVnZXIgPyAnMCcgOiAnMC4nO1xuICB9XG5cbiAgaWYgKGlzSW50ZWdlcikge1xuICAgIHJldHVybiB2LnRvRml4ZWQoMCk7XG4gIH1cblxuICBpZiAoTWF0aC5hYnModikgPiAxMDAgJiYgTWF0aC5hYnModikgPCAxMDAwMCkge1xuICAgIHJldHVybiB2LnRvRml4ZWQoMCk7XG4gIH1cblxuICB2YXIgc3RyaW5nID0gdi50b1ByZWNpc2lvbigyKTtcbiAgdmFyIGRlY2ltYWwgPSBzdHJpbmcuaW5kZXhPZignLjAnKTtcbiAgcmV0dXJuIGRlY2ltYWwgPT09IHN0cmluZy5sZW5ndGggLSAyID8gc3RyaW5nLnNsaWNlKDAsIC0xKSA6IHN0cmluZztcbn1cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXlWYWx1ZSh2LCBvcHRzKSB7XG4gIHZhciBfb3B0cyRtYXhFbHRzID0gb3B0cy5tYXhFbHRzLFxuICAgICAgbWF4RWx0cyA9IF9vcHRzJG1heEVsdHMgPT09IHZvaWQgMCA/IDE2IDogX29wdHMkbWF4RWx0cyxcbiAgICAgIF9vcHRzJHNpemUgPSBvcHRzLnNpemUsXG4gICAgICBzaXplID0gX29wdHMkc2l6ZSA9PT0gdm9pZCAwID8gMSA6IF9vcHRzJHNpemU7XG4gIHZhciBzdHJpbmcgPSAnWyc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aCAmJiBpIDwgbWF4RWx0czsgKytpKSB7XG4gICAgaWYgKGkgPiAwKSB7XG4gICAgICBzdHJpbmcgKz0gXCIsXCIuY29uY2F0KGkgJSBzaXplID09PSAwID8gJyAnIDogJycpO1xuICAgIH1cblxuICAgIHN0cmluZyArPSBmb3JtYXRWYWx1ZSh2W2ldLCBvcHRzKTtcbiAgfVxuXG4gIHZhciB0ZXJtaW5hdG9yID0gdi5sZW5ndGggPiBtYXhFbHRzID8gJy4uLicgOiAnXSc7XG4gIHJldHVybiBcIlwiLmNvbmNhdChzdHJpbmcpLmNvbmNhdCh0ZXJtaW5hdG9yKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0SW1hZ2UoaW1hZ2UsIG1lc3NhZ2UsIHNjYWxlKSB7XG4gIHZhciBtYXhXaWR0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogNjAwO1xuICB2YXIgaW1hZ2VVcmwgPSBpbWFnZS5zcmMucmVwbGFjZSgvXFwoL2csICclMjgnKS5yZXBsYWNlKC9cXCkvZywgJyUyOScpO1xuXG4gIGlmIChpbWFnZS53aWR0aCA+IG1heFdpZHRoKSB7XG4gICAgc2NhbGUgPSBNYXRoLm1pbihzY2FsZSwgbWF4V2lkdGggLyBpbWFnZS53aWR0aCk7XG4gIH1cblxuICB2YXIgd2lkdGggPSBpbWFnZS53aWR0aCAqIHNjYWxlO1xuICB2YXIgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0ICogc2NhbGU7XG4gIHZhciBzdHlsZSA9IFsnZm9udC1zaXplOjFweDsnLCBcInBhZGRpbmc6XCIuY29uY2F0KE1hdGguZmxvb3IoaGVpZ2h0IC8gMiksIFwicHggXCIpLmNvbmNhdChNYXRoLmZsb29yKHdpZHRoIC8gMiksIFwicHg7XCIpLCBcImxpbmUtaGVpZ2h0OlwiLmNvbmNhdChoZWlnaHQsIFwicHg7XCIpLCBcImJhY2tncm91bmQ6dXJsKFwiLmNvbmNhdChpbWFnZVVybCwgXCIpO1wiKSwgXCJiYWNrZ3JvdW5kLXNpemU6XCIuY29uY2F0KHdpZHRoLCBcInB4IFwiKS5jb25jYXQoaGVpZ2h0LCBcInB4O1wiKSwgJ2NvbG9yOnRyYW5zcGFyZW50OyddLmpvaW4oJycpO1xuICByZXR1cm4gW1wiXCIuY29uY2F0KG1lc3NhZ2UsIFwiICVjK1wiKSwgc3R5bGVdO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0dGVycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzZWxmXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxzLnNlbGY7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwid2luZG93XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxzLndpbmRvdztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnbG9iYWxcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dsb2JhbHMuZ2xvYmFsO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRvY3VtZW50XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxzLmRvY3VtZW50O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInByb2Nlc3NcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dsb2JhbHMucHJvY2VzcztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb25zb2xlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxzLmNvbnNvbGU7XG4gIH1cbn0pO1xuZXhwb3J0cy5pc0Jyb3dzZXIgPSBleHBvcnRzLlZFUlNJT04gPSB2b2lkIDA7XG5cbnZhciBfaXNCcm93c2VyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vZW52L2lzLWJyb3dzZXJcIikpO1xuXG52YXIgX2dsb2JhbHMgPSByZXF1aXJlKFwiLi4vZW52L2dsb2JhbHNcIik7XG5cbnZhciBWRVJTSU9OID0gdHlwZW9mIF9fVkVSU0lPTl9fICE9PSAndW5kZWZpbmVkJyA/IF9fVkVSU0lPTl9fIDogJ3VudHJhbnNwaWxlZCBzb3VyY2UnO1xuZXhwb3J0cy5WRVJTSU9OID0gVkVSU0lPTjtcbnZhciBpc0Jyb3dzZXIgPSAoMCwgX2lzQnJvd3Nlci5kZWZhdWx0KSgpO1xuZXhwb3J0cy5pc0Jyb3dzZXIgPSBpc0Jyb3dzZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nbG9iYWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0SGlSZXNUaW1lc3RhbXA7XG5cbnZhciBfZ2xvYmFscyA9IHJlcXVpcmUoXCIuL2dsb2JhbHNcIik7XG5cbmZ1bmN0aW9uIGdldEhpUmVzVGltZXN0YW1wKCkge1xuICB2YXIgdGltZXN0YW1wO1xuXG4gIGlmIChfZ2xvYmFscy5pc0Jyb3dzZXIgJiYgX2dsb2JhbHMud2luZG93LnBlcmZvcm1hbmNlKSB7XG4gICAgdGltZXN0YW1wID0gX2dsb2JhbHMud2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICB9IGVsc2UgaWYgKF9nbG9iYWxzLnByb2Nlc3MuaHJ0aW1lKSB7XG4gICAgdmFyIHRpbWVQYXJ0cyA9IF9nbG9iYWxzLnByb2Nlc3MuaHJ0aW1lKCk7XG5cbiAgICB0aW1lc3RhbXAgPSB0aW1lUGFydHNbMF0gKiAxMDAwICsgdGltZVBhcnRzWzFdIC8gMWU2O1xuICB9IGVsc2Uge1xuICAgIHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gIH1cblxuICByZXR1cm4gdGltZXN0YW1wO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGktcmVzLXRpbWVzdGFtcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbmZ1bmN0aW9uIGdldFN0b3JhZ2UodHlwZSkge1xuICB0cnkge1xuICAgIHZhciBzdG9yYWdlID0gd2luZG93W3R5cGVdO1xuICAgIHZhciB4ID0gJ19fc3RvcmFnZV90ZXN0X18nO1xuICAgIHN0b3JhZ2Uuc2V0SXRlbSh4LCB4KTtcbiAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oeCk7XG4gICAgcmV0dXJuIHN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG52YXIgTG9jYWxTdG9yYWdlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMb2NhbFN0b3JhZ2UoaWQsIGRlZmF1bHRTZXR0aW5ncykge1xuICAgIHZhciB0eXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnc2Vzc2lvblN0b3JhZ2UnO1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIExvY2FsU3RvcmFnZSk7XG4gICAgdGhpcy5zdG9yYWdlID0gZ2V0U3RvcmFnZSh0eXBlKTtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5jb25maWcgPSB7fTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuY29uZmlnLCBkZWZhdWx0U2V0dGluZ3MpO1xuXG4gICAgdGhpcy5fbG9hZENvbmZpZ3VyYXRpb24oKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKExvY2FsU3RvcmFnZSwgW3tcbiAgICBrZXk6IFwiZ2V0Q29uZmlndXJhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb25maWd1cmF0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uZmlnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRDb25maWd1cmF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldENvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbikge1xuICAgICAgdGhpcy5jb25maWcgPSB7fTtcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUNvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUNvbmZpZ3VyYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQ29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMuY29uZmlnLCBjb25maWd1cmF0aW9uKTtcblxuICAgICAgaWYgKHRoaXMuc3RvcmFnZSkge1xuICAgICAgICB2YXIgc2VyaWFsaXplZCA9IEpTT04uc3RyaW5naWZ5KHRoaXMuY29uZmlnKTtcbiAgICAgICAgdGhpcy5zdG9yYWdlLnNldEl0ZW0odGhpcy5pZCwgc2VyaWFsaXplZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfbG9hZENvbmZpZ3VyYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2xvYWRDb25maWd1cmF0aW9uKCkge1xuICAgICAgdmFyIGNvbmZpZ3VyYXRpb24gPSB7fTtcblxuICAgICAgaWYgKHRoaXMuc3RvcmFnZSkge1xuICAgICAgICB2YXIgc2VyaWFsaXplZENvbmZpZ3VyYXRpb24gPSB0aGlzLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLmlkKTtcbiAgICAgICAgY29uZmlndXJhdGlvbiA9IHNlcmlhbGl6ZWRDb25maWd1cmF0aW9uID8gSlNPTi5wYXJzZShzZXJpYWxpemVkQ29uZmlndXJhdGlvbikgOiB7fTtcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmNvbmZpZywgY29uZmlndXJhdGlvbik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIExvY2FsU3RvcmFnZTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gTG9jYWxTdG9yYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWwtc3RvcmFnZS5qcy5tYXAiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfVxuICB0cnkge1xuICAgIC8vIElFIDggaGFzIGEgYnJva2VuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGF0IG9ubHkgd29ya3Mgb24gRE9NIG9iamVjdHMuXG4gICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgZGVmaW5lKEl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBkZWZpbmUoR3AsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb24pO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShcbiAgICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSxcbiAgICB0b1N0cmluZ1RhZ1N5bWJvbCxcbiAgICBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgKTtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKTtcbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIGRlZmluZShBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSwgYXN5bmNJdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XG5cbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksXG4gICAgICBQcm9taXNlSW1wbFxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIik7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgZGVmaW5lKEdwLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9KTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcbiAgLy8gb3Igbm90LCByZXR1cm4gdGhlIHJ1bnRpbWUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGRlY2xhcmUgdGhlIHZhcmlhYmxlXG4gIC8vIHJlZ2VuZXJhdG9yUnVudGltZSBpbiB0aGUgb3V0ZXIgc2NvcGUsIHdoaWNoIGFsbG93cyB0aGlzIG1vZHVsZSB0byBiZVxuICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxuICByZXR1cm4gZXhwb3J0cztcblxufShcbiAgLy8gSWYgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlLCB1c2UgbW9kdWxlLmV4cG9ydHNcbiAgLy8gYXMgdGhlIHJlZ2VuZXJhdG9yUnVudGltZSBuYW1lc3BhY2UuIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgZW1wdHlcbiAgLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxuICAvLyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIHZhcmlhYmxlIGF0IHRoZSB0b3Agb2YgdGhpcyBmaWxlLlxuICB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiID8gbW9kdWxlLmV4cG9ydHMgOiB7fVxuKSk7XG5cbnRyeSB7XG4gIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG59IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xuICAvLyBUaGlzIG1vZHVsZSBzaG91bGQgbm90IGJlIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUsIHNvIHRoZSBhYm92ZVxuICAvLyBhc3NpZ25tZW50IHNob3VsZCBhbHdheXMgd29yayB1bmxlc3Mgc29tZXRoaW5nIGlzIG1pc2NvbmZpZ3VyZWQuIEp1c3RcbiAgLy8gaW4gY2FzZSBydW50aW1lLmpzIGFjY2lkZW50YWxseSBydW5zIGluIHN0cmljdCBtb2RlLCBpbiBtb2Rlcm4gZW5naW5lc1xuICAvLyB3ZSBjYW4gZXhwbGljaXRseSBhY2Nlc3MgZ2xvYmFsVGhpcy4gSW4gb2xkZXIgZW5naW5lcyB3ZSBjYW4gZXNjYXBlXG4gIC8vIHN0cmljdCBtb2RlIHVzaW5nIGEgZ2xvYmFsIEZ1bmN0aW9uIGNhbGwuIFRoaXMgY291bGQgY29uY2VpdmFibHkgZmFpbFxuICAvLyBpZiBhIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IGZvcmJpZHMgdXNpbmcgRnVuY3Rpb24sIGJ1dCBpbiB0aGF0IGNhc2VcbiAgLy8gdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlIGFjY2lkZW50YWwgc3RyaWN0IG1vZGUgcHJvYmxlbS4gSWZcbiAgLy8geW91J3ZlIG1pc2NvbmZpZ3VyZWQgeW91ciBidW5kbGVyIHRvIGZvcmNlIHN0cmljdCBtb2RlIGFuZCBhcHBsaWVkIGFcbiAgLy8gQ1NQIHRvIGZvcmJpZCBGdW5jdGlvbiwgYW5kIHlvdSdyZSBub3Qgd2lsbGluZyB0byBmaXggZWl0aGVyIG9mIHRob3NlXG4gIC8vIHByb2JsZW1zLCBwbGVhc2UgZGV0YWlsIHlvdXIgdW5pcXVlIHByZWRpY2FtZW50IGluIGEgR2l0SHViIGlzc3VlLlxuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBnbG9iYWxUaGlzLnJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG4gIH0gZWxzZSB7XG4gICAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbiAgfVxufVxuIl19

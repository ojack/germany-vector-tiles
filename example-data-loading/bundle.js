(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

var _core = require("@loaders.gl/core");

var _csv = require("@loaders.gl/csv");

var _nanohtml = _interopRequireDefault(require("nanohtml"));

var _templateObject, _templateObject2, _templateObject3;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

/*
* To do:
* - how to update tooltip when date is updated? 
* - definition file for datasets
* - make dataset files that only contain values, not geoid
* - implement start date and end date
* - add sample data for timeseries
* - loading spinner while data is loading
* - show selected elements as separate array
* 
* assumptions: geo id in tileset refers to data order (?)
* are there datasets that only exist at certain geolevels?
* https://deck.gl/docs/api-reference/geo-layers/mvt-layer
*/
var _deck = deck,
    DeckGL = _deck.DeckGL,
    MVTLayer = _deck.MVTLayer; //import { csv } from 'd3'

var viz;
var geoRegion;
var dataset = 'mobility';
var baseURL = window.location.href.replace('/example-data-loading/', '');
var datasetPath = "/sample-data/datasets/";
var tilesetPath = "/sample-data/tilesets/"; // sets of vector tilesets representing different geo-regions

var tilesets = [{
  label: 'gemeinden',
  // 
  id: 'gemeinden',
  // 
  url: 'gemeinden',
  numEntries: 11431,
  idLookup: 'myLookup.csv' // not yet implemented, a csv file with an array, where each value in the array is a geographicId. All datasets that use this geodata should have values in the same order as this array.

}, {
  label: 'kreise',
  id: 'kreise',
  url: 'kreise',
  numEntries: 432
}, {
  label: 'laender',
  id: 'laender',
  url: 'laender',
  numEntries: 34
}];
var datasets = [{
  label: 'Mobility by Date',
  id: 'mobility',
  url: '',
  startDate: '2021-05-23',
  endDate: '2021-08-30',
  tilesets: ['laendergeo', 'kreisegeo', 'gemeindengeo']
}];
tilesets.forEach(function (tileset, i) {
  var URL = "".concat(baseURL).concat(tilesetPath).concat(tileset.url, "/{z}/{x}/{y}.pbf");
  tileset.tiles = [URL];
  tileset.visibile = false;
  tileset.mobility = new Array(tileset.numEntries).fill(0).map(function (_, i) {
    return Math.random();
  });
});
var numDates = 100;
var currentDateIndex = 0;
selectGeoLevel('gemeinden'); //geoRegion = tilesets[0]

console.log('base url', tilesets, geoRegion);
var footer = (0, _nanohtml["default"])(_templateObject || (_templateObject = _taggedTemplateLiteral(["<div style=\"position:absolute;bottom:0px;right:0px;width:100%\"></div>"])));

var generateDate = function generateDate() {
  var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'hi';
  return "<div style=\"font-size:4rem;color:white;background:rgba(0, 0, 0, 0.4)\">".concat(date, "</div>");
};

var dateEl = document.createElement('div');
var geoSelect = (0, _nanohtml["default"])(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["<label for=\"geolevel\">Select map geo level</label>\n<select label=\"geolevel\" onchange=", " id=\"geolevel\">\n ", "\n</select>"])), function (e) {
  selectGeoLevel(e.target.value);
}, tilesets.map(function (tileset) {
  return (0, _nanohtml["default"])(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["<option value=\"", "\" ", ">", "</option>"])), tileset.id, tileset.id === geoRegion.id ? 'selected' : '', tileset.label);
}));
footer.appendChild(geoSelect);
footer.appendChild(dateEl); // optimizations for this: load directly as an array and do not parse into objects
// store already loaded data in some way and only load new data as necessary
// read more about deckgl / webgl performance
// show loading animation while loading

function getData() {
  return _getData.apply(this, arguments);
}

function _getData() {
  _getData = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
    var d, dateStr, newData;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            currentDateIndex++;
            if (currentDateIndex > numDates) currentDateIndex = 0;
            d = new Date();
            d.setDate(-numDates + currentDateIndex);
            dateStr = d.toLocaleDateString('en-CA'); //date.format(d, 'YYYY-MM-DD')

            dateEl.innerHTML = generateDate(dateStr);
            _context.next = 8;
            return (0, _core.load)("".concat(baseURL).concat(datasetPath).concat(dataset, "/").concat(geoRegion.id, "/values-by-date/").concat(dateStr, ".csv"), _csv.CSVLoader);

          case 8:
            newData = _context.sent;
            // console.log('loaded', newData, geoRegion)
            geoRegion.mobility = geoRegion.mobility.map(function (_, i) {
              return newData[i].mobility;
            }); //gemeinden: new Array(11431).fill(0).map((_, i) => Math.random()),
            //kreise: new Array(432).fill(0).map((_, i) => Math.random())

            render();

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _getData.apply(this, arguments);
}

getData();

function selectGeoLevel(id) {
  tilesets.forEach(function (tileset) {
    if (tileset.id === id) {
      tileset.visible = true;
      geoRegion = tileset;
    } else {
      tileset.visible = false;
    }
  });
}

function render() {
  // console.log(tilesets, 'tilesets')
  var layers = tilesets.map(function (tileset) {
    return new MVTLayer({
      // id: tileset.id,
      id: tileset.id,
      data: tileset.tiles,
      pickable: tileset.visible,
      getFillColor: function getFillColor(obj) {
        //console.log('getting mobility at', obj.id, tileset.mobility)
        var j = tileset.mobility[obj.id];
        return [j * 255, j * 255, j * 255]; //return [Math.random() * 255, Math.random() * 255, Math.random() * 255]
      },
      getLineWidth: 4,
      transitions: {
        getFillColor: 100
      },
      updateTriggers: {
        // if currentDateIndex changes, recompute getFillColor for each point
        getFillColor: [currentDateIndex]
      },
      visible: tileset.visible,
      lineWidthMinPixels: 0,
      maxZoom: 13,
      minZoom: 0
    });
  });
  viz.setProps({
    layers: layers
  });
}

viz = new DeckGL({
  initialViewState: {
    // longitude: -122.4,
    latitude: 51.66403781658121,
    longitude: 10.6460952758789,
    // latitude: 37.74,
    // longitude: 13.765869,
    //13.765869,54.117382
    zoom: 6,
    maxZoom: 20,
    pitch: 30,
    bearing: 0
  },
  controller: true,
  getTooltip: function getTooltip(_ref) {
    var object = _ref.object;

    if (object) {
      console.log(object);
      return "".concat(object.properties.GEN, " mobility ").concat(geoRegion.mobility[object.id]);
    }

    return null;
  } //layers: [layer]

});
setInterval(function () {
  //  console.log(shouldUpdate)
  // fakeData.laender = fakeData.laender.map((_, i) => Math.random())
  // fakeData.kreise = fakeData.kreise.map((_, i) => Math.random())
  //fakeData[geoRegion] = fakeData[geoRegion].map((_, i) => Math.random())
  //gemeinden: new Array(11431).fill(0).map((_, i) => Math.random()),
  //kreise: new Array(432).fill(0).map((_, i) => Math.random())
  //render()
  getData(); // shouldUpdate ++
}, 2000);
document.body.appendChild(footer); //   const tileURL = `${window.location.origin}/gemeinden-z7-uncompressed/{z}/{x}/{y}.pbf`
// const DATA = [
//     tileURL
//     //'https://tiles-a.basemaps.cartocdn.com/vectortiles/carto.streets/v1/{z}/{x}/{y}.mvt'
//   ]
// function render () {
// const gemeinden = new MVTLayer({
//   id: 'gemeindengeo',
//   data: DATA,
//   pickable: true,
//   getFillColor: () => {
//    // console.log(shouldUpdate)
//    return [Math.random() * 255, Math.random() * 255, Math.random() * 255]
//   },
//   getLineColor: () => [Math.random() * 255, Math.random() * 255, Math.random() * 255],
//   getLineWidth: 4,
//   transitions: {
//     getFillColor: 100,
//   },
//   updateTriggers: {
//     // if showLibraries changes, recompute getFillColor for each point
//     getFillColor: [shouldUpdate]
//   },
//   lineWidthMinPixels: 1,
//   /* props from MVTLayer class */
//   // binary: false,
//   // highlightedFeatureId: null,
//   // loaders: ,
//   // uniqueIdProperty: '',
//   /* props inherited from TileLayer class */
//   // extent: null,
//   // getTileData: null,
//   // maxCacheByteSize: null,
//   // maxCacheSize: null,
//   // maxRequests: 6,
//   maxZoom: 13,
//   minZoom: 7,
//   // onTileError: null,
//   // onTileLoad: null,
//   // onTileUnload: null,
//   // onViewportLoad: null,
//   // refinementStrategy: 'best-available',
//   // renderSubLayers: null,
//   // tileSize: 512,
//   // zRange: null,
//   /* props inherited from Layer class */
//   // autoHighlight: false,
//   // coordinateOrigin: [0, 0, 0],
//   // coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
//   // highlightColor: [0, 0, 128, 128],
//   // modelMatrix: null,
//   // opacity: 1,
//   // pickable: false,
//   // visible: true,
//   // wrapLongitude: false,
// });

},{"@loaders.gl/core":34,"@loaders.gl/csv":70,"nanohtml":135}],2:[function(require,module,exports){
var AwaitValue = require("./AwaitValue.js");

function AsyncGenerator(gen) {
  var front, back;

  function send(key, arg) {
    return new Promise(function (resolve, reject) {
      var request = {
        key: key,
        arg: arg,
        resolve: resolve,
        reject: reject,
        next: null
      };

      if (back) {
        back = back.next = request;
      } else {
        front = back = request;
        resume(key, arg);
      }
    });
  }

  function resume(key, arg) {
    try {
      var result = gen[key](arg);
      var value = result.value;
      var wrappedAwait = value instanceof AwaitValue;
      Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {
        if (wrappedAwait) {
          resume(key === "return" ? "return" : "next", arg);
          return;
        }

        settle(result.done ? "return" : "normal", arg);
      }, function (err) {
        resume("throw", err);
      });
    } catch (err) {
      settle("throw", err);
    }
  }

  function settle(type, value) {
    switch (type) {
      case "return":
        front.resolve({
          value: value,
          done: true
        });
        break;

      case "throw":
        front.reject(value);
        break;

      default:
        front.resolve({
          value: value,
          done: false
        });
        break;
    }

    front = front.next;

    if (front) {
      resume(front.key, front.arg);
    } else {
      back = null;
    }
  }

  this._invoke = send;

  if (typeof gen["return"] !== "function") {
    this["return"] = undefined;
  }
}

AsyncGenerator.prototype[typeof Symbol === "function" && Symbol.asyncIterator || "@@asyncIterator"] = function () {
  return this;
};

AsyncGenerator.prototype.next = function (arg) {
  return this._invoke("next", arg);
};

AsyncGenerator.prototype["throw"] = function (arg) {
  return this._invoke("throw", arg);
};

AsyncGenerator.prototype["return"] = function (arg) {
  return this._invoke("return", arg);
};

module.exports = AsyncGenerator;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./AwaitValue.js":3}],3:[function(require,module,exports){
function _AwaitValue(value) {
  this.wrapped = value;
}

module.exports = _AwaitValue;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],4:[function(require,module,exports){
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],5:[function(require,module,exports){
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],6:[function(require,module,exports){
var arrayLikeToArray = require("./arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./arrayLikeToArray.js":4}],7:[function(require,module,exports){
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],8:[function(require,module,exports){
function _asyncGeneratorDelegate(inner, awaitWrap) {
  var iter = {},
      waiting = false;

  function pump(key, value) {
    waiting = true;
    value = new Promise(function (resolve) {
      resolve(inner[key](value));
    });
    return {
      done: false,
      value: awaitWrap(value)
    };
  }

  ;

  iter[typeof Symbol !== "undefined" && Symbol.iterator || "@@iterator"] = function () {
    return this;
  };

  iter.next = function (value) {
    if (waiting) {
      waiting = false;
      return value;
    }

    return pump("next", value);
  };

  if (typeof inner["throw"] === "function") {
    iter["throw"] = function (value) {
      if (waiting) {
        waiting = false;
        throw value;
      }

      return pump("throw", value);
    };
  }

  if (typeof inner["return"] === "function") {
    iter["return"] = function (value) {
      if (waiting) {
        waiting = false;
        return value;
      }

      return pump("return", value);
    };
  }

  return iter;
}

module.exports = _asyncGeneratorDelegate;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],9:[function(require,module,exports){
function _asyncIterator(iterable) {
  var method;

  if (typeof Symbol !== "undefined") {
    if (Symbol.asyncIterator) method = iterable[Symbol.asyncIterator];
    if (method == null && Symbol.iterator) method = iterable[Symbol.iterator];
  }

  if (method == null) method = iterable["@@asyncIterator"];
  if (method == null) method = iterable["@@iterator"];
  if (method == null) throw new TypeError("Object is not async iterable");
  return method.call(iterable);
}

module.exports = _asyncIterator;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],10:[function(require,module,exports){
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],11:[function(require,module,exports){
var AwaitValue = require("./AwaitValue.js");

function _awaitAsyncGenerator(value) {
  return new AwaitValue(value);
}

module.exports = _awaitAsyncGenerator;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./AwaitValue.js":3}],12:[function(require,module,exports){
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],13:[function(require,module,exports){
var setPrototypeOf = require("./setPrototypeOf.js");

var isNativeReflectConstruct = require("./isNativeReflectConstruct.js");

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./isNativeReflectConstruct.js":20,"./setPrototypeOf.js":26}],14:[function(require,module,exports){
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],15:[function(require,module,exports){
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],16:[function(require,module,exports){
function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],17:[function(require,module,exports){
var setPrototypeOf = require("./setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./setPrototypeOf.js":26}],18:[function(require,module,exports){
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],19:[function(require,module,exports){
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

module.exports = _isNativeFunction;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],20:[function(require,module,exports){
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = _isNativeReflectConstruct;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],21:[function(require,module,exports){
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

module.exports = _iterableToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],22:[function(require,module,exports){
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],23:[function(require,module,exports){
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],24:[function(require,module,exports){
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],25:[function(require,module,exports){
var _typeof = require("@babel/runtime/helpers/typeof")["default"];

var assertThisInitialized = require("./assertThisInitialized.js");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./assertThisInitialized.js":7,"@babel/runtime/helpers/typeof":29}],26:[function(require,module,exports){
function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],27:[function(require,module,exports){
var arrayWithHoles = require("./arrayWithHoles.js");

var iterableToArrayLimit = require("./iterableToArrayLimit.js");

var unsupportedIterableToArray = require("./unsupportedIterableToArray.js");

var nonIterableRest = require("./nonIterableRest.js");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./arrayWithHoles.js":5,"./iterableToArrayLimit.js":22,"./nonIterableRest.js":23,"./unsupportedIterableToArray.js":30}],28:[function(require,module,exports){
var arrayWithoutHoles = require("./arrayWithoutHoles.js");

var iterableToArray = require("./iterableToArray.js");

var unsupportedIterableToArray = require("./unsupportedIterableToArray.js");

var nonIterableSpread = require("./nonIterableSpread.js");

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./arrayWithoutHoles.js":6,"./iterableToArray.js":21,"./nonIterableSpread.js":24,"./unsupportedIterableToArray.js":30}],29:[function(require,module,exports){
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _typeof(obj);
}

module.exports = _typeof;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],30:[function(require,module,exports){
var arrayLikeToArray = require("./arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./arrayLikeToArray.js":4}],31:[function(require,module,exports){
var AsyncGenerator = require("./AsyncGenerator.js");

function _wrapAsyncGenerator(fn) {
  return function () {
    return new AsyncGenerator(fn.apply(this, arguments));
  };
}

module.exports = _wrapAsyncGenerator;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./AsyncGenerator.js":2}],32:[function(require,module,exports){
var getPrototypeOf = require("./getPrototypeOf.js");

var setPrototypeOf = require("./setPrototypeOf.js");

var isNativeFunction = require("./isNativeFunction.js");

var construct = require("./construct.js");

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return construct(Class, arguments, getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return setPrototypeOf(Wrapper, Class);
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _wrapNativeSuper(Class);
}

module.exports = _wrapNativeSuper;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./construct.js":13,"./getPrototypeOf.js":16,"./isNativeFunction.js":19,"./setPrototypeOf.js":26}],33:[function(require,module,exports){
module.exports = require("regenerator-runtime");

},{"regenerator-runtime":154}],34:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "fetchFile", {
  enumerable: true,
  get: function get() {
    return _fetchFile.fetchFile;
  }
});
Object.defineProperty(exports, "readArrayBuffer", {
  enumerable: true,
  get: function get() {
    return _readArrayBuffer.readArrayBuffer;
  }
});
Object.defineProperty(exports, "readFileSync", {
  enumerable: true,
  get: function get() {
    return _readFile.readFileSync;
  }
});
Object.defineProperty(exports, "writeFile", {
  enumerable: true,
  get: function get() {
    return _writeFile.writeFile;
  }
});
Object.defineProperty(exports, "writeFileSync", {
  enumerable: true,
  get: function get() {
    return _writeFile.writeFileSync;
  }
});
Object.defineProperty(exports, "setLoaderOptions", {
  enumerable: true,
  get: function get() {
    return _setLoaderOptions.setLoaderOptions;
  }
});
Object.defineProperty(exports, "registerLoaders", {
  enumerable: true,
  get: function get() {
    return _registerLoaders.registerLoaders;
  }
});
Object.defineProperty(exports, "_unregisterLoaders", {
  enumerable: true,
  get: function get() {
    return _registerLoaders._unregisterLoaders;
  }
});
Object.defineProperty(exports, "selectLoader", {
  enumerable: true,
  get: function get() {
    return _selectLoader.selectLoader;
  }
});
Object.defineProperty(exports, "selectLoaderSync", {
  enumerable: true,
  get: function get() {
    return _selectLoader.selectLoaderSync;
  }
});
Object.defineProperty(exports, "parse", {
  enumerable: true,
  get: function get() {
    return _parse.parse;
  }
});
Object.defineProperty(exports, "parseSync", {
  enumerable: true,
  get: function get() {
    return _parseSync.parseSync;
  }
});
Object.defineProperty(exports, "parseInBatches", {
  enumerable: true,
  get: function get() {
    return _parseInBatches.parseInBatches;
  }
});
Object.defineProperty(exports, "load", {
  enumerable: true,
  get: function get() {
    return _load.load;
  }
});
Object.defineProperty(exports, "loadInBatches", {
  enumerable: true,
  get: function get() {
    return _loadInBatches.loadInBatches;
  }
});
Object.defineProperty(exports, "encode", {
  enumerable: true,
  get: function get() {
    return _encode.encode;
  }
});
Object.defineProperty(exports, "encodeSync", {
  enumerable: true,
  get: function get() {
    return _encode.encodeSync;
  }
});
Object.defineProperty(exports, "encodeInBatches", {
  enumerable: true,
  get: function get() {
    return _encode.encodeInBatches;
  }
});
Object.defineProperty(exports, "encodeText", {
  enumerable: true,
  get: function get() {
    return _encode.encodeText;
  }
});
Object.defineProperty(exports, "encodeURLtoURL", {
  enumerable: true,
  get: function get() {
    return _encode.encodeURLtoURL;
  }
});
Object.defineProperty(exports, "save", {
  enumerable: true,
  get: function get() {
    return _save.save;
  }
});
Object.defineProperty(exports, "saveSync", {
  enumerable: true,
  get: function get() {
    return _save.saveSync;
  }
});
Object.defineProperty(exports, "setPathPrefix", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.setPathPrefix;
  }
});
Object.defineProperty(exports, "getPathPrefix", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.getPathPrefix;
  }
});
Object.defineProperty(exports, "resolvePath", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.resolvePath;
  }
});
Object.defineProperty(exports, "RequestScheduler", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.RequestScheduler;
  }
});
Object.defineProperty(exports, "JSONLoader", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.JSONLoader;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.isBrowser;
  }
});
Object.defineProperty(exports, "isWorker", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.isWorker;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.window;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.global;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.document;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.assert;
  }
});
Object.defineProperty(exports, "forEach", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.forEach;
  }
});
Object.defineProperty(exports, "concatenateArrayBuffersAsync", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.concatenateArrayBuffersAsync;
  }
});
Object.defineProperty(exports, "makeTextDecoderIterator", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.makeTextDecoderIterator;
  }
});
Object.defineProperty(exports, "makeTextEncoderIterator", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.makeTextEncoderIterator;
  }
});
Object.defineProperty(exports, "makeLineIterator", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.makeLineIterator;
  }
});
Object.defineProperty(exports, "makeNumberedLineIterator", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.makeNumberedLineIterator;
  }
});
Object.defineProperty(exports, "makeIterator", {
  enumerable: true,
  get: function get() {
    return _makeIterator.makeIterator;
  }
});
Object.defineProperty(exports, "makeStream", {
  enumerable: true,
  get: function get() {
    return _makeStream.makeStream;
  }
});
Object.defineProperty(exports, "makeDOMStream", {
  enumerable: true,
  get: function get() {
    return _makeDomStream.makeDOMStream;
  }
});
Object.defineProperty(exports, "makeNodeStream", {
  enumerable: true,
  get: function get() {
    return _makeNodeStream.default;
  }
});
Object.defineProperty(exports, "NullWorkerLoader", {
  enumerable: true,
  get: function get() {
    return _nullLoader.NullWorkerLoader;
  }
});
Object.defineProperty(exports, "NullLoader", {
  enumerable: true,
  get: function get() {
    return _nullLoader.NullLoader;
  }
});
Object.defineProperty(exports, "_fetchProgress", {
  enumerable: true,
  get: function get() {
    return _fetchProgress.default;
  }
});
Object.defineProperty(exports, "_BrowserFileSystem", {
  enumerable: true,
  get: function get() {
    return _browserFilesystem.default;
  }
});
Object.defineProperty(exports, "isPureObject", {
  enumerable: true,
  get: function get() {
    return _isType.isPureObject;
  }
});
Object.defineProperty(exports, "isPromise", {
  enumerable: true,
  get: function get() {
    return _isType.isPromise;
  }
});
Object.defineProperty(exports, "isIterable", {
  enumerable: true,
  get: function get() {
    return _isType.isIterable;
  }
});
Object.defineProperty(exports, "isAsyncIterable", {
  enumerable: true,
  get: function get() {
    return _isType.isAsyncIterable;
  }
});
Object.defineProperty(exports, "isIterator", {
  enumerable: true,
  get: function get() {
    return _isType.isIterator;
  }
});
Object.defineProperty(exports, "isResponse", {
  enumerable: true,
  get: function get() {
    return _isType.isResponse;
  }
});
Object.defineProperty(exports, "isReadableStream", {
  enumerable: true,
  get: function get() {
    return _isType.isReadableStream;
  }
});
Object.defineProperty(exports, "isWritableStream", {
  enumerable: true,
  get: function get() {
    return _isType.isWritableStream;
  }
});

var _fetchFile = require("./lib/fetch/fetch-file");

var _readArrayBuffer = require("./lib/fetch/read-array-buffer");

var _readFile = require("./lib/fetch/read-file");

var _writeFile = require("./lib/fetch/write-file");

var _setLoaderOptions = require("./lib/api/set-loader-options");

var _registerLoaders = require("./lib/api/register-loaders");

var _selectLoader = require("./lib/api/select-loader");

var _parse = require("./lib/api/parse");

var _parseSync = require("./lib/api/parse-sync");

var _parseInBatches = require("./lib/api/parse-in-batches");

var _load = require("./lib/api/load");

var _loadInBatches = require("./lib/api/load-in-batches");

var _encode = require("./lib/api/encode");

var _save = require("./lib/api/save");

var _loaderUtils = require("@loaders.gl/loader-utils");

var _makeIterator = require("./iterators/make-iterator/make-iterator");

var _makeStream = require("./iterators/make-stream/make-stream");

var _makeDomStream = require("./iterators/make-stream/make-dom-stream");

var _makeNodeStream = _interopRequireDefault(require("./iterators/make-stream/make-node-stream"));

var _nullLoader = require("./null-loader");

var _fetchProgress = _interopRequireDefault(require("./lib/progress/fetch-progress"));

var _browserFilesystem = _interopRequireDefault(require("./lib/filesystems/browser-filesystem"));

var _isType = require("./javascript-utils/is-type");

},{"./iterators/make-iterator/make-iterator":37,"./iterators/make-stream/make-dom-stream":40,"./iterators/make-stream/make-node-stream":130,"./iterators/make-stream/make-stream":41,"./javascript-utils/is-type":42,"./lib/api/encode":43,"./lib/api/load":45,"./lib/api/load-in-batches":44,"./lib/api/parse":48,"./lib/api/parse-in-batches":46,"./lib/api/parse-sync":47,"./lib/api/register-loaders":49,"./lib/api/save":50,"./lib/api/select-loader":51,"./lib/api/set-loader-options":52,"./lib/fetch/fetch-file":53,"./lib/fetch/read-array-buffer":54,"./lib/fetch/read-file":55,"./lib/fetch/write-file":56,"./lib/filesystems/browser-filesystem":57,"./lib/progress/fetch-progress":64,"./null-loader":68,"@babel/runtime/helpers/interopRequireDefault":18,"@loaders.gl/loader-utils":73}],35:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeArrayBufferIterator = makeArrayBufferIterator;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _marked = _regenerator.default.mark(makeArrayBufferIterator);

var DEFAULT_CHUNK_SIZE = 256 * 1024;

function makeArrayBufferIterator(arrayBuffer) {
  var options,
      _options$chunkSize,
      chunkSize,
      byteOffset,
      chunkByteLength,
      chunk,
      sourceArray,
      chunkArray,
      _args = arguments;

  return _regenerator.default.wrap(function makeArrayBufferIterator$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
          _options$chunkSize = options.chunkSize, chunkSize = _options$chunkSize === void 0 ? DEFAULT_CHUNK_SIZE : _options$chunkSize;
          byteOffset = 0;

        case 3:
          if (!(byteOffset < arrayBuffer.byteLength)) {
            _context.next = 14;
            break;
          }

          chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);
          chunk = new ArrayBuffer(chunkByteLength);
          sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);
          chunkArray = new Uint8Array(chunk);
          chunkArray.set(sourceArray);
          byteOffset += chunkByteLength;
          _context.next = 12;
          return chunk;

        case 12:
          _context.next = 3;
          break;

        case 14:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}

},{"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],36:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeBlobIterator = makeBlobIterator;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _awaitAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/awaitAsyncGenerator"));

var _wrapAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapAsyncGenerator"));

var DEFAULT_CHUNK_SIZE = 1024 * 1024;

function makeBlobIterator(_x, _x2) {
  return _makeBlobIterator.apply(this, arguments);
}

function _makeBlobIterator() {
  _makeBlobIterator = (0, _wrapAsyncGenerator2.default)(_regenerator.default.mark(function _callee(blob, options) {
    var chunkSize, offset, end, chunk;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE;
            offset = 0;

          case 2:
            if (!(offset < blob.size)) {
              _context.next = 12;
              break;
            }

            end = offset + chunkSize;
            _context.next = 6;
            return (0, _awaitAsyncGenerator2.default)(blob.slice(offset, end).arrayBuffer());

          case 6:
            chunk = _context.sent;
            offset = end;
            _context.next = 10;
            return chunk;

          case 10:
            _context.next = 2;
            break;

          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _makeBlobIterator.apply(this, arguments);
}

},{"@babel/runtime/helpers/awaitAsyncGenerator":11,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/wrapAsyncGenerator":31,"@babel/runtime/regenerator":33}],37:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeIterator = makeIterator;

var _makeStringIterator = require("./make-string-iterator");

var _makeArrayBufferIterator = require("./make-array-buffer-iterator");

var _makeBlobIterator = require("./make-blob-iterator");

var _makeStreamIterator = require("./make-stream-iterator");

var _isType = require("../../javascript-utils/is-type");

function makeIterator(data, options) {
  if (typeof data === 'string') {
    return (0, _makeStringIterator.makeStringIterator)(data, options);
  }

  if (data instanceof ArrayBuffer) {
    return (0, _makeArrayBufferIterator.makeArrayBufferIterator)(data, options);
  }

  if ((0, _isType.isBlob)(data)) {
    return (0, _makeBlobIterator.makeBlobIterator)(data, options);
  }

  if ((0, _isType.isReadableStream)(data)) {
    return (0, _makeStreamIterator.makeStreamIterator)(data, options);
  }

  if ((0, _isType.isResponse)(data)) {
    var response = data;
    return (0, _makeStreamIterator.makeStreamIterator)(response.body, options);
  }

  throw new Error('makeIterator');
}

},{"../../javascript-utils/is-type":42,"./make-array-buffer-iterator":35,"./make-blob-iterator":36,"./make-stream-iterator":38,"./make-string-iterator":39}],38:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeStreamIterator = makeStreamIterator;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

var _awaitAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/awaitAsyncGenerator"));

var _wrapAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapAsyncGenerator"));

var _loaderUtils = require("@loaders.gl/loader-utils");

function makeStreamIterator(stream, options) {
  return _loaderUtils.isBrowser ? makeBrowserStreamIterator(stream, options) : makeNodeStreamIterator(stream, options);
}

function makeBrowserStreamIterator(_x, _x2) {
  return _makeBrowserStreamIterator.apply(this, arguments);
}

function _makeBrowserStreamIterator() {
  _makeBrowserStreamIterator = (0, _wrapAsyncGenerator2.default)(_regenerator.default.mark(function _callee(stream, options) {
    var reader, nextBatchPromise, currentBatchPromise, _yield$_awaitAsyncGen, done, value;

    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            reader = stream.getReader();
            _context.prev = 1;

          case 2:
            if (!true) {
              _context.next = 16;
              break;
            }

            currentBatchPromise = nextBatchPromise || reader.read();

            if (options !== null && options !== void 0 && options._streamReadAhead) {
              nextBatchPromise = reader.read();
            }

            _context.next = 7;
            return (0, _awaitAsyncGenerator2.default)(currentBatchPromise);

          case 7:
            _yield$_awaitAsyncGen = _context.sent;
            done = _yield$_awaitAsyncGen.done;
            value = _yield$_awaitAsyncGen.value;

            if (!done) {
              _context.next = 12;
              break;
            }

            return _context.abrupt("return");

          case 12:
            _context.next = 14;
            return (0, _loaderUtils.toArrayBuffer)(value);

          case 14:
            _context.next = 2;
            break;

          case 16:
            _context.next = 21;
            break;

          case 18:
            _context.prev = 18;
            _context.t0 = _context["catch"](1);
            reader.releaseLock();

          case 21:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[1, 18]]);
  }));
  return _makeBrowserStreamIterator.apply(this, arguments);
}

function makeNodeStreamIterator(_x3, _x4) {
  return _makeNodeStreamIterator.apply(this, arguments);
}

function _makeNodeStreamIterator() {
  _makeNodeStreamIterator = (0, _wrapAsyncGenerator2.default)(_regenerator.default.mark(function _callee2(stream, options) {
    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk;

    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _context2.prev = 2;
            _iterator = (0, _asyncIterator2.default)(stream);

          case 4:
            _context2.next = 6;
            return (0, _awaitAsyncGenerator2.default)(_iterator.next());

          case 6:
            _step = _context2.sent;
            _iteratorNormalCompletion = _step.done;
            _context2.next = 10;
            return (0, _awaitAsyncGenerator2.default)(_step.value);

          case 10:
            _value = _context2.sent;

            if (_iteratorNormalCompletion) {
              _context2.next = 18;
              break;
            }

            chunk = _value;
            _context2.next = 15;
            return (0, _loaderUtils.toArrayBuffer)(chunk);

          case 15:
            _iteratorNormalCompletion = true;
            _context2.next = 4;
            break;

          case 18:
            _context2.next = 24;
            break;

          case 20:
            _context2.prev = 20;
            _context2.t0 = _context2["catch"](2);
            _didIteratorError = true;
            _iteratorError = _context2.t0;

          case 24:
            _context2.prev = 24;
            _context2.prev = 25;

            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
              _context2.next = 29;
              break;
            }

            _context2.next = 29;
            return (0, _awaitAsyncGenerator2.default)(_iterator.return());

          case 29:
            _context2.prev = 29;

            if (!_didIteratorError) {
              _context2.next = 32;
              break;
            }

            throw _iteratorError;

          case 32:
            return _context2.finish(29);

          case 33:
            return _context2.finish(24);

          case 34:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[2, 20, 24, 34], [25,, 29, 33]]);
  }));
  return _makeNodeStreamIterator.apply(this, arguments);
}

},{"@babel/runtime/helpers/asyncIterator":9,"@babel/runtime/helpers/awaitAsyncGenerator":11,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/wrapAsyncGenerator":31,"@babel/runtime/regenerator":33,"@loaders.gl/loader-utils":73}],39:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeStringIterator = makeStringIterator;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _marked = _regenerator.default.mark(makeStringIterator);

var DEFAULT_CHUNK_SIZE = 256 * 1024;

function makeStringIterator(string, options) {
  var chunkSize, offset, textEncoder, chunkLength, chunk;
  return _regenerator.default.wrap(function makeStringIterator$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE;
          offset = 0;
          textEncoder = new TextEncoder();

        case 3:
          if (!(offset < string.length)) {
            _context.next = 11;
            break;
          }

          chunkLength = Math.min(string.length - offset, chunkSize);
          chunk = string.slice(offset, offset + chunkLength);
          offset += chunkLength;
          _context.next = 9;
          return textEncoder.encode(chunk);

        case 9:
          _context.next = 3;
          break;

        case 11:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}

},{"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],40:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeDOMStream = makeDOMStream;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function makeDOMStream(source, options) {
  var iterator = source[Symbol.asyncIterator] ? source[Symbol.asyncIterator]() : source[Symbol.iterator]();
  return new ReadableStream({
    type: 'bytes',
    pull: function pull(controller) {
      return (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {
        var _yield$iterator$next, done, value;

        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _context.next = 3;
                return iterator.next();

              case 3:
                _yield$iterator$next = _context.sent;
                done = _yield$iterator$next.done;
                value = _yield$iterator$next.value;

                if (done) {
                  controller.close();
                } else {
                  controller.enqueue(new Uint8Array(value));
                }

                _context.next = 12;
                break;

              case 9:
                _context.prev = 9;
                _context.t0 = _context["catch"](0);
                controller.error(_context.t0);

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[0, 9]]);
      }))();
    },
    cancel: function cancel() {
      return (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2() {
        var _iterator$return;

        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return iterator === null || iterator === void 0 ? void 0 : (_iterator$return = iterator.return) === null || _iterator$return === void 0 ? void 0 : _iterator$return.call(iterator);

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }))();
    }
  }, _objectSpread({
    highWaterMark: Math.pow(2, 24)
  }, options));
}

},{"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],41:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeStream = makeStream;

var _loaderUtils = require("@loaders.gl/loader-utils");

var _makeDomStream = require("./make-dom-stream");

var _makeNodeStream = _interopRequireDefault(require("./make-node-stream"));

function makeStream(data, options) {
  return _loaderUtils.isBrowser ? (0, _makeDomStream.makeDOMStream)(data, options) : (0, _makeNodeStream.default)(data, options);
}

},{"./make-dom-stream":40,"./make-node-stream":130,"@babel/runtime/helpers/interopRequireDefault":18,"@loaders.gl/loader-utils":73}],42:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isWritableStream = exports.isReadableStream = exports.isReadableNodeStream = exports.isWritableNodeStream = exports.isBuffer = exports.isReadableDOMStream = exports.isWritableDOMStream = exports.isBlob = exports.isFile = exports.isResponse = exports.isIterator = exports.isAsyncIterable = exports.isIterable = exports.isPromise = exports.isPureObject = exports.isObject = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var isBoolean = function isBoolean(x) {
  return typeof x === 'boolean';
};

var isFunction = function isFunction(x) {
  return typeof x === 'function';
};

var isObject = function isObject(x) {
  return x !== null && (0, _typeof2.default)(x) === 'object';
};

exports.isObject = isObject;

var isPureObject = function isPureObject(x) {
  return isObject(x) && x.constructor === {}.constructor;
};

exports.isPureObject = isPureObject;

var isPromise = function isPromise(x) {
  return isObject(x) && isFunction(x.then);
};

exports.isPromise = isPromise;

var isIterable = function isIterable(x) {
  return x && typeof x[Symbol.iterator] === 'function';
};

exports.isIterable = isIterable;

var isAsyncIterable = function isAsyncIterable(x) {
  return x && typeof x[Symbol.asyncIterator] === 'function';
};

exports.isAsyncIterable = isAsyncIterable;

var isIterator = function isIterator(x) {
  return x && isFunction(x.next);
};

exports.isIterator = isIterator;

var isResponse = function isResponse(x) {
  return typeof Response !== 'undefined' && x instanceof Response || x && x.arrayBuffer && x.text && x.json;
};

exports.isResponse = isResponse;

var isFile = function isFile(x) {
  return typeof File !== 'undefined' && x instanceof File;
};

exports.isFile = isFile;

var isBlob = function isBlob(x) {
  return typeof Blob !== 'undefined' && x instanceof Blob;
};

exports.isBlob = isBlob;

var isWritableDOMStream = function isWritableDOMStream(x) {
  return isObject(x) && isFunction(x.abort) && isFunction(x.getWriter);
};

exports.isWritableDOMStream = isWritableDOMStream;

var isReadableDOMStream = function isReadableDOMStream(x) {
  return typeof ReadableStream !== 'undefined' && x instanceof ReadableStream || isObject(x) && isFunction(x.tee) && isFunction(x.cancel) && isFunction(x.getReader);
};

exports.isReadableDOMStream = isReadableDOMStream;

var isBuffer = function isBuffer(x) {
  return x && (0, _typeof2.default)(x) === 'object' && x.isBuffer;
};

exports.isBuffer = isBuffer;

var isWritableNodeStream = function isWritableNodeStream(x) {
  return isObject(x) && isFunction(x.end) && isFunction(x.write) && isBoolean(x.writable);
};

exports.isWritableNodeStream = isWritableNodeStream;

var isReadableNodeStream = function isReadableNodeStream(x) {
  return isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);
};

exports.isReadableNodeStream = isReadableNodeStream;

var isReadableStream = function isReadableStream(x) {
  return isReadableDOMStream(x) || isReadableNodeStream(x);
};

exports.isReadableStream = isReadableStream;

var isWritableStream = function isWritableStream(x) {
  return isWritableDOMStream(x) || isWritableNodeStream(x);
};

exports.isWritableStream = isWritableStream;

},{"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29}],43:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encode = encode;
exports.encodeSync = encodeSync;
exports.encodeText = encodeText;
exports.encodeInBatches = encodeInBatches;
exports.encodeURLtoURL = encodeURLtoURL;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

var _loaderUtils = require("@loaders.gl/loader-utils");

var _writeFile = require("../fetch/write-file");

var _fetchFile = require("../fetch/fetch-file");

function encode(_x, _x2, _x3) {
  return _encode.apply(this, arguments);
}

function _encode() {
  _encode = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(data, writer, options) {
    var batches, chunks, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, batch, tmpInputFilename, tmpOutputFilename, outputFilename, response;

    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!writer.encode) {
              _context.next = 4;
              break;
            }

            _context.next = 3;
            return writer.encode(data, options);

          case 3:
            return _context.abrupt("return", _context.sent);

          case 4:
            if (!writer.encodeSync) {
              _context.next = 6;
              break;
            }

            return _context.abrupt("return", writer.encodeSync(data, options));

          case 6:
            if (!writer.encodeText) {
              _context.next = 12;
              break;
            }

            _context.t0 = new TextEncoder();
            _context.next = 10;
            return writer.encodeText(data, options);

          case 10:
            _context.t1 = _context.sent;
            return _context.abrupt("return", _context.t0.encode.call(_context.t0, _context.t1));

          case 12:
            if (!writer.encodeInBatches) {
              _context.next = 49;
              break;
            }

            batches = encodeInBatches(data, writer, options);
            chunks = [];
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _context.prev = 17;
            _iterator = (0, _asyncIterator2.default)(batches);

          case 19:
            _context.next = 21;
            return _iterator.next();

          case 21:
            _step = _context.sent;
            _iteratorNormalCompletion = _step.done;
            _context.next = 25;
            return _step.value;

          case 25:
            _value = _context.sent;

            if (_iteratorNormalCompletion) {
              _context.next = 32;
              break;
            }

            batch = _value;
            chunks.push(batch);

          case 29:
            _iteratorNormalCompletion = true;
            _context.next = 19;
            break;

          case 32:
            _context.next = 38;
            break;

          case 34:
            _context.prev = 34;
            _context.t2 = _context["catch"](17);
            _didIteratorError = true;
            _iteratorError = _context.t2;

          case 38:
            _context.prev = 38;
            _context.prev = 39;

            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
              _context.next = 43;
              break;
            }

            _context.next = 43;
            return _iterator.return();

          case 43:
            _context.prev = 43;

            if (!_didIteratorError) {
              _context.next = 46;
              break;
            }

            throw _iteratorError;

          case 46:
            return _context.finish(43);

          case 47:
            return _context.finish(38);

          case 48:
            return _context.abrupt("return", _loaderUtils.concatenateArrayBuffers.apply(void 0, chunks));

          case 49:
            if (!(!_loaderUtils.isBrowser && writer.encodeURLtoURL)) {
              _context.next = 61;
              break;
            }

            tmpInputFilename = getTemporaryFilename('input');
            _context.next = 53;
            return (0, _writeFile.writeFile)(tmpInputFilename, data);

          case 53:
            tmpOutputFilename = getTemporaryFilename('output');
            _context.next = 56;
            return encodeURLtoURL(tmpInputFilename, tmpOutputFilename, writer, options);

          case 56:
            outputFilename = _context.sent;
            _context.next = 59;
            return (0, _fetchFile.fetchFile)(outputFilename);

          case 59:
            response = _context.sent;
            return _context.abrupt("return", response.arrayBuffer());

          case 61:
            throw new Error('Writer could not encode data');

          case 62:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[17, 34, 38, 48], [39,, 43, 47]]);
  }));
  return _encode.apply(this, arguments);
}

function encodeSync(data, writer, options) {
  if (writer.encodeSync) {
    return writer.encodeSync(data, options);
  }

  throw new Error('Writer could not synchronously encode data');
}

function encodeText(_x4, _x5, _x6) {
  return _encodeText.apply(this, arguments);
}

function _encodeText() {
  _encodeText = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(data, writer, options) {
    var arrayBuffer;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(writer.text && writer.encodeText)) {
              _context2.next = 4;
              break;
            }

            _context2.next = 3;
            return writer.encodeText(data, options);

          case 3:
            return _context2.abrupt("return", _context2.sent);

          case 4:
            if (!(writer.text && (writer.encode || writer.encodeInBatches))) {
              _context2.next = 9;
              break;
            }

            _context2.next = 7;
            return encode(data, writer, options);

          case 7:
            arrayBuffer = _context2.sent;
            return _context2.abrupt("return", new TextDecoder().decode(arrayBuffer));

          case 9:
            throw new Error('Writer could not encode data as text');

          case 10:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _encodeText.apply(this, arguments);
}

function encodeInBatches(data, writer, options) {
  if (writer.encodeInBatches) {
    var dataIterator = getIterator(data);
    return writer.encodeInBatches(dataIterator, options);
  }

  throw new Error('Writer could not encode data in batches');
}

function encodeURLtoURL(_x7, _x8, _x9, _x10) {
  return _encodeURLtoURL.apply(this, arguments);
}

function _encodeURLtoURL() {
  _encodeURLtoURL = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(inputUrl, outputUrl, writer, options) {
    var outputFilename;
    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            inputUrl = (0, _loaderUtils.resolvePath)(inputUrl);
            outputUrl = (0, _loaderUtils.resolvePath)(outputUrl);

            if (!(_loaderUtils.isBrowser || !writer.encodeURLtoURL)) {
              _context3.next = 4;
              break;
            }

            throw new Error();

          case 4:
            _context3.next = 6;
            return writer.encodeURLtoURL(inputUrl, outputUrl, options);

          case 6:
            outputFilename = _context3.sent;
            return _context3.abrupt("return", outputFilename);

          case 8:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _encodeURLtoURL.apply(this, arguments);
}

function getIterator(data) {
  var dataIterator = [{
    table: data,
    start: 0,
    end: data.length
  }];
  return dataIterator;
}

function getTemporaryFilename(filename) {
  return "/tmp/".concat(filename);
}

},{"../fetch/fetch-file":53,"../fetch/write-file":56,"@babel/runtime/helpers/asyncIterator":9,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33,"@loaders.gl/loader-utils":73}],44:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadInBatches = loadInBatches;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _normalizeLoader = require("../loader-utils/normalize-loader");

var _optionUtils = require("../loader-utils/option-utils");

var _parseInBatches = require("./parse-in-batches");

function loadInBatches(files, loaders, options, context) {
  if (!Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
    context = undefined;
    options = loaders;
    loaders = null;
  }

  var fetch = (0, _optionUtils.getFetchFunction)(options || {});

  if (!Array.isArray(files)) {
    return loadOneFileInBatches(files, loaders, options, fetch);
  }

  var promises = files.map(function (file) {
    return loadOneFileInBatches(file, loaders, options, fetch);
  });
  return promises;
}

function loadOneFileInBatches(_x, _x2, _x3, _x4) {
  return _loadOneFileInBatches.apply(this, arguments);
}

function _loadOneFileInBatches() {
  _loadOneFileInBatches = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(file, loaders, options, fetch) {
    var url, response;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(typeof file === 'string')) {
              _context.next = 8;
              break;
            }

            url = file;
            _context.next = 4;
            return fetch(url);

          case 4:
            response = _context.sent;
            _context.next = 7;
            return (0, _parseInBatches.parseInBatches)(response, loaders, options);

          case 7:
            return _context.abrupt("return", _context.sent);

          case 8:
            _context.next = 10;
            return (0, _parseInBatches.parseInBatches)(file, loaders, options);

          case 10:
            return _context.abrupt("return", _context.sent);

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _loadOneFileInBatches.apply(this, arguments);
}

},{"../loader-utils/normalize-loader":61,"../loader-utils/option-utils":63,"./parse-in-batches":46,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],45:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.load = load;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _isType = require("../../javascript-utils/is-type");

var _normalizeLoader = require("../loader-utils/normalize-loader");

var _optionUtils = require("../loader-utils/option-utils");

var _parse = require("./parse");

function load(_x, _x2, _x3, _x4) {
  return _load.apply(this, arguments);
}

function _load() {
  _load = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(url, loaders, options, context) {
    var fetch, data;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
              context = undefined;
              options = loaders;
              loaders = undefined;
            }

            fetch = (0, _optionUtils.getFetchFunction)(options);
            data = url;

            if (!(typeof url === 'string')) {
              _context.next = 7;
              break;
            }

            _context.next = 6;
            return fetch(url);

          case 6:
            data = _context.sent;

          case 7:
            if (!(0, _isType.isBlob)(url)) {
              _context.next = 11;
              break;
            }

            _context.next = 10;
            return fetch(url);

          case 10:
            data = _context.sent;

          case 11:
            _context.next = 13;
            return (0, _parse.parse)(data, loaders, options);

          case 13:
            return _context.abrupt("return", _context.sent);

          case 14:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _load.apply(this, arguments);
}

},{"../../javascript-utils/is-type":42,"../loader-utils/normalize-loader":61,"../loader-utils/option-utils":63,"./parse":48,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],46:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseInBatches = parseInBatches;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _wrapAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapAsyncGenerator"));

var _awaitAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/awaitAsyncGenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

var _asyncGeneratorDelegate2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncGeneratorDelegate"));

var _loaderUtils = require("@loaders.gl/loader-utils");

var _normalizeLoader = require("../loader-utils/normalize-loader");

var _optionUtils = require("../loader-utils/option-utils");

var _loaderContext = require("../loader-utils/loader-context");

var _getData = require("../loader-utils/get-data");

var _resourceUtils = require("../utils/resource-utils");

var _selectLoader = require("./select-loader");

var _parse = require("./parse");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function parseInBatches(_x2, _x3, _x4, _x5) {
  return _parseInBatches.apply(this, arguments);
}

function _parseInBatches() {
  _parseInBatches = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(data, loaders, options, context) {
    var _getResourceUrlAndTyp, url, loader;

    return _regenerator.default.wrap(function _callee2$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            (0, _loaderUtils.assert)(!context || (0, _typeof2.default)(context) === 'object');

            if (!Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
              context = undefined;
              options = loaders;
              loaders = undefined;
            }

            _context3.next = 4;
            return data;

          case 4:
            data = _context3.sent;
            options = options || {};
            _getResourceUrlAndTyp = (0, _resourceUtils.getResourceUrlAndType)(data), url = _getResourceUrlAndTyp.url;
            _context3.next = 9;
            return (0, _selectLoader.selectLoader)(data, loaders, options);

          case 9:
            loader = _context3.sent;

            if (loader) {
              _context3.next = 12;
              break;
            }

            return _context3.abrupt("return", null);

          case 12:
            options = (0, _optionUtils.normalizeOptions)(options, loader, loaders, url);
            context = (0, _loaderContext.getLoaderContext)({
              url: url,
              parseInBatches: parseInBatches,
              parse: _parse.parse,
              loaders: loaders
            }, options, context);
            _context3.next = 16;
            return parseWithLoaderInBatches(loader, data, options, context);

          case 16:
            return _context3.abrupt("return", _context3.sent);

          case 17:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee2);
  }));
  return _parseInBatches.apply(this, arguments);
}

function parseWithLoaderInBatches(loader, data, options, context) {
  var outputIterator, metadataBatch, makeMetadataBatchIterator, _makeMetadataBatchIterator;

  return _regenerator.default.async(function parseWithLoaderInBatches$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _makeMetadataBatchIterator = function _makeMetadataBatchIte2() {
            _makeMetadataBatchIterator = (0, _wrapAsyncGenerator2.default)(_regenerator.default.mark(function _callee(iterator) {
              return _regenerator.default.wrap(function _callee$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      _context2.next = 2;
                      return metadataBatch;

                    case 2:
                      return _context2.delegateYield((0, _asyncGeneratorDelegate2.default)((0, _asyncIterator2.default)(iterator), _awaitAsyncGenerator2.default), "t0", 3);

                    case 3:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee);
            }));
            return _makeMetadataBatchIterator.apply(this, arguments);
          };

          makeMetadataBatchIterator = function _makeMetadataBatchIte(_x) {
            return _makeMetadataBatchIterator.apply(this, arguments);
          };

          _context.next = 4;
          return _regenerator.default.awrap(parseToOutputIterator(loader, data, options, context));

        case 4:
          outputIterator = _context.sent;

          if (options.metadata) {
            _context.next = 7;
            break;
          }

          return _context.abrupt("return", outputIterator);

        case 7:
          metadataBatch = {
            batchType: 'metadata',
            metadata: {
              _loader: loader,
              _context: context
            },
            data: [],
            bytesUsed: 0
          };
          return _context.abrupt("return", makeMetadataBatchIterator(outputIterator));

        case 9:
        case "end":
          return _context.stop();
      }
    }
  }, null, null, null, Promise);
}

function parseToOutputIterator(_x6, _x7, _x8, _x9) {
  return _parseToOutputIterator.apply(this, arguments);
}

function _parseToOutputIterator() {
  _parseToOutputIterator = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee4(loader, data, options, context) {
    var inputIterator, transformedIterator, parseChunkInBatches, _parseChunkInBatches;

    return _regenerator.default.wrap(function _callee4$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _parseChunkInBatches = function _parseChunkInBatches3() {
              _parseChunkInBatches = (0, _wrapAsyncGenerator2.default)(_regenerator.default.mark(function _callee3() {
                var arrayBuffer, parsedData, batch;
                return _regenerator.default.wrap(function _callee3$(_context4) {
                  while (1) {
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        _context4.next = 2;
                        return (0, _awaitAsyncGenerator2.default)((0, _loaderUtils.concatenateArrayBuffersAsync)(transformedIterator));

                      case 2:
                        arrayBuffer = _context4.sent;
                        _context4.next = 5;
                        return (0, _awaitAsyncGenerator2.default)((0, _parse.parse)(arrayBuffer, loader, _objectSpread(_objectSpread({}, options), {}, {
                          mimeType: loader.mimeTypes[0]
                        }), context));

                      case 5:
                        parsedData = _context4.sent;
                        batch = {
                          mimeType: loader.mimeTypes[0],
                          shape: Array.isArray(parsedData) ? 'row-table' : 'unknown',
                          batchType: 'data',
                          data: parsedData,
                          length: Array.isArray(parsedData) ? parsedData.length : 1
                        };
                        _context4.next = 9;
                        return batch;

                      case 9:
                      case "end":
                        return _context4.stop();
                    }
                  }
                }, _callee3);
              }));
              return _parseChunkInBatches.apply(this, arguments);
            };

            parseChunkInBatches = function _parseChunkInBatches2() {
              return _parseChunkInBatches.apply(this, arguments);
            };

            _context5.next = 4;
            return (0, _getData.getAsyncIterableFromData)(data, options);

          case 4:
            inputIterator = _context5.sent;
            _context5.next = 7;
            return applyInputTransforms(inputIterator, (options === null || options === void 0 ? void 0 : options.transforms) || []);

          case 7:
            transformedIterator = _context5.sent;

            if (!loader.parseInBatches) {
              _context5.next = 10;
              break;
            }

            return _context5.abrupt("return", loader.parseInBatches(transformedIterator, options, context));

          case 10:
            return _context5.abrupt("return", parseChunkInBatches());

          case 11:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee4);
  }));
  return _parseToOutputIterator.apply(this, arguments);
}

function applyInputTransforms(_x10) {
  return _applyInputTransforms.apply(this, arguments);
}

function _applyInputTransforms() {
  _applyInputTransforms = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee5(inputIterator) {
    var transforms,
        iteratorChain,
        _iteratorNormalCompletion,
        _didIteratorError,
        _iteratorError,
        _iterator,
        _step,
        _value,
        transformBatches,
        _args6 = arguments;

    return _regenerator.default.wrap(function _callee5$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            transforms = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : [];
            iteratorChain = inputIterator;
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _context6.prev = 4;
            _iterator = (0, _asyncIterator2.default)(transforms);

          case 6:
            _context6.next = 8;
            return _iterator.next();

          case 8:
            _step = _context6.sent;
            _iteratorNormalCompletion = _step.done;
            _context6.next = 12;
            return _step.value;

          case 12:
            _value = _context6.sent;

            if (_iteratorNormalCompletion) {
              _context6.next = 19;
              break;
            }

            transformBatches = _value;
            iteratorChain = transformBatches(iteratorChain);

          case 16:
            _iteratorNormalCompletion = true;
            _context6.next = 6;
            break;

          case 19:
            _context6.next = 25;
            break;

          case 21:
            _context6.prev = 21;
            _context6.t0 = _context6["catch"](4);
            _didIteratorError = true;
            _iteratorError = _context6.t0;

          case 25:
            _context6.prev = 25;
            _context6.prev = 26;

            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
              _context6.next = 30;
              break;
            }

            _context6.next = 30;
            return _iterator.return();

          case 30:
            _context6.prev = 30;

            if (!_didIteratorError) {
              _context6.next = 33;
              break;
            }

            throw _iteratorError;

          case 33:
            return _context6.finish(30);

          case 34:
            return _context6.finish(25);

          case 35:
            return _context6.abrupt("return", iteratorChain);

          case 36:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee5, null, [[4, 21, 25, 35], [26,, 30, 34]]);
  }));
  return _applyInputTransforms.apply(this, arguments);
}

},{"../loader-utils/get-data":58,"../loader-utils/loader-context":59,"../loader-utils/normalize-loader":61,"../loader-utils/option-utils":63,"../utils/resource-utils":66,"./parse":48,"./select-loader":51,"@babel/runtime/helpers/asyncGeneratorDelegate":8,"@babel/runtime/helpers/asyncIterator":9,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/awaitAsyncGenerator":11,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"@babel/runtime/helpers/wrapAsyncGenerator":31,"@babel/runtime/regenerator":33,"@loaders.gl/loader-utils":73}],47:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseSync = parseSync;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _loaderUtils = require("@loaders.gl/loader-utils");

var _selectLoader = require("./select-loader");

var _normalizeLoader = require("../loader-utils/normalize-loader");

var _optionUtils = require("../loader-utils/option-utils");

var _getData = require("../loader-utils/get-data");

var _loaderContext = require("../loader-utils/loader-context");

var _resourceUtils = require("../utils/resource-utils");

function parseSync(data, loaders, options, context) {
  (0, _loaderUtils.assert)(!context || (0, _typeof2.default)(context) === 'object');

  if (!Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
    context = undefined;
    options = loaders;
    loaders = undefined;
  }

  options = options || {};
  var typedLoaders = loaders;
  var candidateLoaders = (0, _loaderContext.getLoadersFromContext)(typedLoaders, context);
  var loader = (0, _selectLoader.selectLoaderSync)(data, candidateLoaders, options);

  if (!loader) {
    return null;
  }

  options = (0, _optionUtils.normalizeOptions)(options, loader, candidateLoaders);

  var _getResourceUrlAndTyp = (0, _resourceUtils.getResourceUrlAndType)(data),
      url = _getResourceUrlAndTyp.url;

  var parse = function parse() {
    throw new Error('parseSync called parse');
  };

  context = (0, _loaderContext.getLoaderContext)({
    url: url,
    parseSync: parseSync,
    parse: parse,
    loaders: loaders
  }, options);
  return parseWithLoaderSync(loader, data, options, context);
}

function parseWithLoaderSync(loader, data, options, context) {
  data = (0, _getData.getArrayBufferOrStringFromDataSync)(data, loader, options);

  if (loader.parseTextSync && typeof data === 'string') {
    return loader.parseTextSync(data, options);
  }

  if (loader.parseSync && data instanceof ArrayBuffer) {
    return loader.parseSync(data, options, context);
  }

  throw new Error("".concat(loader.name, " loader: 'parseSync' not supported by this loader, use 'parse' instead. ").concat(context.url || ''));
}

},{"../loader-utils/get-data":58,"../loader-utils/loader-context":59,"../loader-utils/normalize-loader":61,"../loader-utils/option-utils":63,"../utils/resource-utils":66,"./select-loader":51,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"@loaders.gl/loader-utils":73}],48:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = parse;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _workerUtils = require("@loaders.gl/worker-utils");

var _loaderUtils = require("@loaders.gl/loader-utils");

var _normalizeLoader = require("../loader-utils/normalize-loader");

var _optionUtils = require("../loader-utils/option-utils");

var _getData = require("../loader-utils/get-data");

var _loaderContext = require("../loader-utils/loader-context");

var _resourceUtils = require("../utils/resource-utils");

var _selectLoader = require("./select-loader");

function parse(_x, _x2, _x3, _x4) {
  return _parse.apply(this, arguments);
}

function _parse() {
  _parse = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(data, loaders, options, context) {
    var _getResourceUrlAndTyp, url, typedLoaders, candidateLoaders, loader;

    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            (0, _workerUtils.assert)(!context || (0, _typeof2.default)(context) === 'object');

            if (loaders && !Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
              context = undefined;
              options = loaders;
              loaders = undefined;
            }

            _context.next = 4;
            return data;

          case 4:
            data = _context.sent;
            options = options || {};
            _getResourceUrlAndTyp = (0, _resourceUtils.getResourceUrlAndType)(data), url = _getResourceUrlAndTyp.url;
            typedLoaders = loaders;
            candidateLoaders = (0, _loaderContext.getLoadersFromContext)(typedLoaders, context);
            _context.next = 11;
            return (0, _selectLoader.selectLoader)(data, candidateLoaders, options);

          case 11:
            loader = _context.sent;

            if (loader) {
              _context.next = 14;
              break;
            }

            return _context.abrupt("return", null);

          case 14:
            options = (0, _optionUtils.normalizeOptions)(options, loader, candidateLoaders, url);
            context = (0, _loaderContext.getLoaderContext)({
              url: url,
              parse: parse,
              loaders: candidateLoaders
            }, options, context);
            _context.next = 18;
            return parseWithLoader(loader, data, options, context);

          case 18:
            return _context.abrupt("return", _context.sent);

          case 19:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _parse.apply(this, arguments);
}

function parseWithLoader(_x5, _x6, _x7, _x8) {
  return _parseWithLoader.apply(this, arguments);
}

function _parseWithLoader() {
  _parseWithLoader = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(loader, data, options, context) {
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            (0, _workerUtils.validateWorkerVersion)(loader);
            _context2.next = 3;
            return (0, _getData.getArrayBufferOrStringFromData)(data, loader, options);

          case 3:
            data = _context2.sent;

            if (!(loader.parseTextSync && typeof data === 'string')) {
              _context2.next = 7;
              break;
            }

            options.dataType = 'text';
            return _context2.abrupt("return", loader.parseTextSync(data, options, context, loader));

          case 7:
            if (!(0, _loaderUtils.canParseWithWorker)(loader, options)) {
              _context2.next = 11;
              break;
            }

            _context2.next = 10;
            return (0, _loaderUtils.parseWithWorker)(loader, data, options, context, parse);

          case 10:
            return _context2.abrupt("return", _context2.sent);

          case 11:
            if (!(loader.parseText && typeof data === 'string')) {
              _context2.next = 15;
              break;
            }

            _context2.next = 14;
            return loader.parseText(data, options, context, loader);

          case 14:
            return _context2.abrupt("return", _context2.sent);

          case 15:
            if (!loader.parse) {
              _context2.next = 19;
              break;
            }

            _context2.next = 18;
            return loader.parse(data, options, context, loader);

          case 18:
            return _context2.abrupt("return", _context2.sent);

          case 19:
            (0, _workerUtils.assert)(!loader.parseSync);
            throw new Error("".concat(loader.id, " loader - no parser found and worker is disabled"));

          case 21:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _parseWithLoader.apply(this, arguments);
}

},{"../loader-utils/get-data":58,"../loader-utils/loader-context":59,"../loader-utils/normalize-loader":61,"../loader-utils/option-utils":63,"../utils/resource-utils":66,"./select-loader":51,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"@babel/runtime/regenerator":33,"@loaders.gl/loader-utils":73,"@loaders.gl/worker-utils":108}],49:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerLoaders = registerLoaders;
exports.getRegisteredLoaders = getRegisteredLoaders;
exports._unregisterLoaders = _unregisterLoaders;

var _normalizeLoader = require("../loader-utils/normalize-loader");

var _optionUtils = require("../loader-utils/option-utils");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var getGlobalLoaderRegistry = function getGlobalLoaderRegistry() {
  var state = (0, _optionUtils.getGlobalLoaderState)();
  state.loaderRegistry = state.loaderRegistry || [];
  return state.loaderRegistry;
};

function registerLoaders(loaders) {
  var loaderRegistry = getGlobalLoaderRegistry();
  loaders = Array.isArray(loaders) ? loaders : [loaders];

  var _iterator = _createForOfIteratorHelper(loaders),
      _step;

  try {
    var _loop = function _loop() {
      var loader = _step.value;
      var normalizedLoader = (0, _normalizeLoader.normalizeLoader)(loader);

      if (!loaderRegistry.find(function (registeredLoader) {
        return normalizedLoader === registeredLoader;
      })) {
        loaderRegistry.unshift(normalizedLoader);
      }
    };

    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      _loop();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}

function getRegisteredLoaders() {
  return getGlobalLoaderRegistry();
}

function _unregisterLoaders() {
  var state = (0, _optionUtils.getGlobalLoaderState)();
  state.loaderRegistry = [];
}

},{"../loader-utils/normalize-loader":61,"../loader-utils/option-utils":63}],50:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.save = save;
exports.saveSync = saveSync;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _encode = require("./encode");

var _writeFile = require("../fetch/write-file");

function save(_x, _x2, _x3, _x4) {
  return _save.apply(this, arguments);
}

function _save() {
  _save = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(data, url, writer, options) {
    var encodedData;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return (0, _encode.encode)(data, writer, options);

          case 2:
            encodedData = _context.sent;
            _context.next = 5;
            return (0, _writeFile.writeFile)(url, encodedData);

          case 5:
            return _context.abrupt("return", _context.sent);

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _save.apply(this, arguments);
}

function saveSync(data, url, writer, options) {
  var encodedData = (0, _encode.encodeSync)(data, writer, options);
  return (0, _writeFile.writeFileSync)(url, encodedData);
}

},{"../fetch/write-file":56,"./encode":43,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],51:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.selectLoader = selectLoader;
exports.selectLoaderSync = selectLoaderSync;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _loaderUtils = require("@loaders.gl/loader-utils");

var _normalizeLoader = require("../loader-utils/normalize-loader");

var _resourceUtils = require("../utils/resource-utils");

var _registerLoaders = require("./register-loaders");

var _isType = require("../../javascript-utils/is-type");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var EXT_PATTERN = /\.([^.]+)$/;

function selectLoader(_x) {
  return _selectLoader.apply(this, arguments);
}

function _selectLoader() {
  _selectLoader = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(data) {
    var loaders,
        options,
        context,
        loader,
        _args = arguments;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            loaders = _args.length > 1 && _args[1] !== undefined ? _args[1] : [];
            options = _args.length > 2 ? _args[2] : undefined;
            context = _args.length > 3 ? _args[3] : undefined;

            if (validHTTPResponse(data)) {
              _context.next = 5;
              break;
            }

            return _context.abrupt("return", null);

          case 5:
            loader = selectLoaderSync(data, loaders, _objectSpread(_objectSpread({}, options), {}, {
              nothrow: true
            }), context);

            if (!loader) {
              _context.next = 8;
              break;
            }

            return _context.abrupt("return", loader);

          case 8:
            if (!(0, _isType.isBlob)(data)) {
              _context.next = 13;
              break;
            }

            _context.next = 11;
            return data.slice(0, 10).arrayBuffer();

          case 11:
            data = _context.sent;
            loader = selectLoaderSync(data, loaders, options, context);

          case 13:
            if (!(!loader && !(options !== null && options !== void 0 && options.nothrow))) {
              _context.next = 15;
              break;
            }

            throw new Error(getNoValidLoaderMessage(data));

          case 15:
            return _context.abrupt("return", loader);

          case 16:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _selectLoader.apply(this, arguments);
}

function selectLoaderSync(data) {
  var loaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var options = arguments.length > 2 ? arguments[2] : undefined;
  var context = arguments.length > 3 ? arguments[3] : undefined;

  if (!validHTTPResponse(data)) {
    return null;
  }

  if (loaders && !Array.isArray(loaders)) {
    return (0, _normalizeLoader.normalizeLoader)(loaders);
  }

  var candidateLoaders = [];

  if (loaders) {
    candidateLoaders = candidateLoaders.concat(loaders);
  }

  if (!(options !== null && options !== void 0 && options.ignoreRegisteredLoaders)) {
    var _candidateLoaders;

    (_candidateLoaders = candidateLoaders).push.apply(_candidateLoaders, (0, _toConsumableArray2.default)((0, _registerLoaders.getRegisteredLoaders)()));
  }

  normalizeLoaders(candidateLoaders);
  var loader = selectLoaderInternal(data, candidateLoaders, options, context);

  if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {
    throw new Error(getNoValidLoaderMessage(data));
  }

  return loader;
}

function selectLoaderInternal(data, loaders, options, context) {
  var _getResourceUrlAndTyp = (0, _resourceUtils.getResourceUrlAndType)(data),
      url = _getResourceUrlAndTyp.url,
      type = _getResourceUrlAndTyp.type;

  var testUrl = url || (context === null || context === void 0 ? void 0 : context.url);
  var loader = null;

  if (options !== null && options !== void 0 && options.mimeType) {
    loader = findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.mimeType);
  }

  loader = loader || findLoaderByUrl(loaders, testUrl);
  loader = loader || findLoaderByMIMEType(loaders, type);
  loader = loader || findLoaderByInitialBytes(loaders, data);
  loader = loader || findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.fallbackMimeType);
  return loader;
}

function validHTTPResponse(data) {
  if (data instanceof Response) {
    if (data.status === 204) {
      return false;
    }
  }

  return true;
}

function getNoValidLoaderMessage(data) {
  var _getResourceUrlAndTyp2 = (0, _resourceUtils.getResourceUrlAndType)(data),
      url = _getResourceUrlAndTyp2.url,
      type = _getResourceUrlAndTyp2.type;

  var message = 'No valid loader found';

  if (data) {
    message += " data: \"".concat(getFirstCharacters(data), "\", contentType: \"").concat(type, "\"");
  }

  if (url) {
    message += " url: ".concat(url);
  }

  return message;
}

function normalizeLoaders(loaders) {
  var _iterator = _createForOfIteratorHelper(loaders),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var loader = _step.value;
      (0, _normalizeLoader.normalizeLoader)(loader);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}

function findLoaderByUrl(loaders, url) {
  var match = url && EXT_PATTERN.exec(url);
  var extension = match && match[1];
  return extension ? findLoaderByExtension(loaders, extension) : null;
}

function findLoaderByExtension(loaders, extension) {
  extension = extension.toLowerCase();

  var _iterator2 = _createForOfIteratorHelper(loaders),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var loader = _step2.value;

      var _iterator3 = _createForOfIteratorHelper(loader.extensions),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var loaderExtension = _step3.value;

          if (loaderExtension.toLowerCase() === extension) {
            return loader;
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return null;
}

function findLoaderByMIMEType(loaders, mimeType) {
  var _iterator4 = _createForOfIteratorHelper(loaders),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var loader = _step4.value;

      if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {
        return loader;
      }

      if (mimeType === "application/x.".concat(loader.id)) {
        return loader;
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  return null;
}

function findLoaderByInitialBytes(loaders, data) {
  if (!data) {
    return null;
  }

  var _iterator5 = _createForOfIteratorHelper(loaders),
      _step5;

  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var loader = _step5.value;

      if (typeof data === 'string') {
        if (testDataAgainstText(data, loader)) {
          return loader;
        }
      } else if (ArrayBuffer.isView(data)) {
        if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {
          return loader;
        }
      } else if (data instanceof ArrayBuffer) {
        var byteOffset = 0;

        if (testDataAgainstBinary(data, byteOffset, loader)) {
          return loader;
        }
      }
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }

  return null;
}

function testDataAgainstText(data, loader) {
  if (loader.testText) {
    return loader.testText(data);
  }

  var tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some(function (test) {
    return data.startsWith(test);
  });
}

function testDataAgainstBinary(data, byteOffset, loader) {
  var tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some(function (test) {
    return testBinary(data, byteOffset, loader, test);
  });
}

function testBinary(data, byteOffset, loader, test) {
  if (test instanceof ArrayBuffer) {
    return (0, _loaderUtils.compareArrayBuffers)(test, data, test.byteLength);
  }

  switch ((0, _typeof2.default)(test)) {
    case 'function':
      return test(data, loader);

    case 'string':
      var magic = getMagicString(data, byteOffset, test.length);
      return test === magic;

    default:
      return false;
  }
}

function getFirstCharacters(data) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;

  if (typeof data === 'string') {
    return data.slice(0, length);
  } else if (ArrayBuffer.isView(data)) {
    return getMagicString(data.buffer, data.byteOffset, length);
  } else if (data instanceof ArrayBuffer) {
    var byteOffset = 0;
    return getMagicString(data, byteOffset, length);
  }

  return '';
}

function getMagicString(arrayBuffer, byteOffset, length) {
  if (arrayBuffer.byteLength < byteOffset + length) {
    return '';
  }

  var dataView = new DataView(arrayBuffer);
  var magic = '';

  for (var i = 0; i < length; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }

  return magic;
}

},{"../../javascript-utils/is-type":42,"../loader-utils/normalize-loader":61,"../utils/resource-utils":66,"./register-loaders":49,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/toConsumableArray":28,"@babel/runtime/helpers/typeof":29,"@babel/runtime/regenerator":33,"@loaders.gl/loader-utils":73}],52:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setLoaderOptions = setLoaderOptions;

var _optionUtils = require("../loader-utils/option-utils");

function setLoaderOptions(options) {
  (0, _optionUtils.setGlobalOptions)(options);
}

},{"../loader-utils/option-utils":63}],53:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchFile = fetchFile;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _loaderUtils = require("@loaders.gl/loader-utils");

var _responseUtils = require("../utils/response-utils");

function fetchFile(_x, _x2) {
  return _fetchFile.apply(this, arguments);
}

function _fetchFile() {
  _fetchFile = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(url, options) {
    var fetchOptions;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(typeof url === 'string')) {
              _context.next = 7;
              break;
            }

            url = (0, _loaderUtils.resolvePath)(url);
            fetchOptions = options;

            if (options !== null && options !== void 0 && options.fetch && typeof (options === null || options === void 0 ? void 0 : options.fetch) !== 'function') {
              fetchOptions = options.fetch;
            }

            _context.next = 6;
            return fetch(url, fetchOptions);

          case 6:
            return _context.abrupt("return", _context.sent);

          case 7:
            _context.next = 9;
            return (0, _responseUtils.makeResponse)(url);

          case 9:
            return _context.abrupt("return", _context.sent);

          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _fetchFile.apply(this, arguments);
}

},{"../utils/response-utils":67,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33,"@loaders.gl/loader-utils":73}],54:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readArrayBuffer = readArrayBuffer;
exports.readBlob = readBlob;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _loaderUtils = require("@loaders.gl/loader-utils");

function readArrayBuffer(_x, _x2, _x3) {
  return _readArrayBuffer.apply(this, arguments);
}

function _readArrayBuffer() {
  _readArrayBuffer = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(file, start, length) {
    var slice;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(typeof file === 'number')) {
              _context.next = 4;
              break;
            }

            _context.next = 3;
            return _loaderUtils.fs._readToArrayBuffer(file, start, length);

          case 3:
            return _context.abrupt("return", _context.sent);

          case 4:
            if (!(file instanceof Blob)) {
              file = new Blob([file]);
            }

            slice = file.slice(start, start + length);
            _context.next = 8;
            return readBlob(slice);

          case 8:
            return _context.abrupt("return", _context.sent);

          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _readArrayBuffer.apply(this, arguments);
}

function readBlob(_x4) {
  return _readBlob.apply(this, arguments);
}

function _readBlob() {
  _readBlob = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(blob) {
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return new Promise(function (resolve, reject) {
              var fileReader = new FileReader();

              fileReader.onload = function (event) {
                var _event$target;

                return resolve(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);
              };

              fileReader.onerror = function (error) {
                return reject(error);
              };

              fileReader.readAsArrayBuffer(blob);
            });

          case 2:
            return _context2.abrupt("return", _context2.sent);

          case 3:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _readBlob.apply(this, arguments);
}

},{"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33,"@loaders.gl/loader-utils":73}],55:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readFileSync = readFileSync;

var _loaderUtils = require("@loaders.gl/loader-utils");

function readFileSync(url) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  url = (0, _loaderUtils.resolvePath)(url);

  if (!_loaderUtils.isBrowser) {
    var buffer = _loaderUtils.fs.readFileSync(url, options);

    return typeof buffer !== 'string' ? (0, _loaderUtils.toArrayBuffer)(buffer) : buffer;
  }

  if (!options.nothrow) {
    (0, _loaderUtils.assert)(false);
  }

  return null;
}

},{"@loaders.gl/loader-utils":73}],56:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.writeFile = writeFile;
exports.writeFileSync = writeFileSync;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _loaderUtils = require("@loaders.gl/loader-utils");

function writeFile(_x, _x2, _x3) {
  return _writeFile.apply(this, arguments);
}

function _writeFile() {
  _writeFile = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(filePath, arrayBufferOrString, options) {
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            filePath = (0, _loaderUtils.resolvePath)(filePath);

            if (_loaderUtils.isBrowser) {
              _context.next = 4;
              break;
            }

            _context.next = 4;
            return _loaderUtils.fs.writeFile(filePath, (0, _loaderUtils.toBuffer)(arrayBufferOrString), {
              flag: 'w'
            });

          case 4:
            (0, _loaderUtils.assert)(false);

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _writeFile.apply(this, arguments);
}

function writeFileSync(filePath, arrayBufferOrString, options) {
  filePath = (0, _loaderUtils.resolvePath)(filePath);

  if (!_loaderUtils.isBrowser) {
    _loaderUtils.fs.writeFileSync(filePath, (0, _loaderUtils.toBuffer)(arrayBufferOrString), {
      flag: 'w'
    });
  }

  (0, _loaderUtils.assert)(false);
}

},{"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33,"@loaders.gl/loader-utils":73}],57:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var BrowserFileSystem = function () {
  function BrowserFileSystem(files, options) {
    (0, _classCallCheck2.default)(this, BrowserFileSystem);
    (0, _defineProperty2.default)(this, "_fetch", void 0);
    (0, _defineProperty2.default)(this, "files", {});
    (0, _defineProperty2.default)(this, "lowerCaseFiles", {});
    (0, _defineProperty2.default)(this, "usedFiles", {});
    this._fetch = (options === null || options === void 0 ? void 0 : options.fetch) || fetch;

    for (var i = 0; i < files.length; ++i) {
      var file = files[i];
      this.files[file.name] = file;
      this.lowerCaseFiles[file.name.toLowerCase()] = file;
      this.usedFiles[file.name] = false;
    }

    this.fetch = this.fetch.bind(this);
  }

  (0, _createClass2.default)(BrowserFileSystem, [{
    key: "fetch",
    value: function () {
      var _fetch = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(path, options) {
        var file, headers, range, bytes, start, end, data, _response, response;

        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!path.includes('://')) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return", this._fetch(path, options));

              case 2:
                file = this.files[path];

                if (file) {
                  _context.next = 5;
                  break;
                }

                return _context.abrupt("return", new Response(path, {
                  status: 400,
                  statusText: 'NOT FOUND'
                }));

              case 5:
                headers = new Headers(options === null || options === void 0 ? void 0 : options.headers);
                range = headers.get('Range');
                bytes = range && /bytes=($1)-($2)/.exec(range);

                if (!bytes) {
                  _context.next = 17;
                  break;
                }

                start = parseInt(bytes[1]);
                end = parseInt(bytes[2]);
                _context.next = 13;
                return file.slice(start, end).arrayBuffer();

              case 13:
                data = _context.sent;
                _response = new Response(data);
                Object.defineProperty(_response, 'url', {
                  value: path
                });
                return _context.abrupt("return", _response);

              case 17:
                response = new Response(file);
                Object.defineProperty(response, 'url', {
                  value: path
                });
                return _context.abrupt("return", response);

              case 20:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function fetch(_x, _x2) {
        return _fetch.apply(this, arguments);
      }

      return fetch;
    }()
  }, {
    key: "readdir",
    value: function () {
      var _readdir = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(dirname) {
        var files, path;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                files = [];

                for (path in this.files) {
                  files.push(path);
                }

                return _context2.abrupt("return", files);

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function readdir(_x3) {
        return _readdir.apply(this, arguments);
      }

      return readdir;
    }()
  }, {
    key: "stat",
    value: function () {
      var _stat = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(path, options) {
        var file;
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                file = this.files[path];

                if (file) {
                  _context3.next = 3;
                  break;
                }

                throw new Error(path);

              case 3:
                return _context3.abrupt("return", {
                  size: file.size
                });

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function stat(_x4, _x5) {
        return _stat.apply(this, arguments);
      }

      return stat;
    }()
  }, {
    key: "unlink",
    value: function () {
      var _unlink = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee4(path) {
        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                delete this.files[path];
                delete this.lowerCaseFiles[path];
                this.usedFiles[path] = true;

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function unlink(_x6) {
        return _unlink.apply(this, arguments);
      }

      return unlink;
    }()
  }, {
    key: "open",
    value: function () {
      var _open = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee5(pathname, flags, mode) {
        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                return _context5.abrupt("return", this.files[pathname]);

              case 1:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function open(_x7, _x8, _x9) {
        return _open.apply(this, arguments);
      }

      return open;
    }()
  }, {
    key: "read",
    value: function () {
      var _read = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee6(fd, buffer) {
        var offset,
            length,
            position,
            file,
            startPosition,
            arrayBuffer,
            _args6 = arguments;
        return _regenerator.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                offset = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : 0;
                length = _args6.length > 3 && _args6[3] !== undefined ? _args6[3] : buffer.byteLength;
                position = _args6.length > 4 && _args6[4] !== undefined ? _args6[4] : null;
                file = fd;
                startPosition = 0;
                _context6.next = 7;
                return file.slice(startPosition, startPosition + length).arrayBuffer();

              case 7:
                arrayBuffer = _context6.sent;
                return _context6.abrupt("return", {
                  bytesRead: length,
                  buffer: arrayBuffer
                });

              case 9:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));

      function read(_x10, _x11) {
        return _read.apply(this, arguments);
      }

      return read;
    }()
  }, {
    key: "close",
    value: function () {
      var _close = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee7(fd) {
        return _regenerator.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));

      function close(_x12) {
        return _close.apply(this, arguments);
      }

      return close;
    }()
  }, {
    key: "_getFile",
    value: function _getFile(path, used) {
      var file = this.files[path] || this.lowerCaseFiles[path];

      if (file && used) {
        this.usedFiles[path] = true;
      }

      return file;
    }
  }]);
  return BrowserFileSystem;
}();

exports.default = BrowserFileSystem;

},{"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],58:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getArrayBufferOrStringFromDataSync = getArrayBufferOrStringFromDataSync;
exports.getArrayBufferOrStringFromData = getArrayBufferOrStringFromData;
exports.getAsyncIterableFromData = getAsyncIterableFromData;
exports.getReadableStream = getReadableStream;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _loaderUtils = require("@loaders.gl/loader-utils");

var _isType = require("../../javascript-utils/is-type");

var _makeIterator = require("../../iterators/make-iterator/make-iterator");

var _responseUtils = require("../utils/response-utils");

var ERR_DATA = 'Cannot convert supplied data type';

function getArrayBufferOrStringFromDataSync(data, loader, options) {
  if (loader.text && typeof data === 'string') {
    return data;
  }

  if ((0, _isType.isBuffer)(data)) {
    data = data.buffer;
  }

  if (data instanceof ArrayBuffer) {
    var arrayBuffer = data;

    if (loader.text && !loader.binary) {
      var textDecoder = new TextDecoder('utf8');
      return textDecoder.decode(arrayBuffer);
    }

    return arrayBuffer;
  }

  if (ArrayBuffer.isView(data)) {
    if (loader.text && !loader.binary) {
      var _textDecoder = new TextDecoder('utf8');

      return _textDecoder.decode(data);
    }

    var _arrayBuffer = data.buffer;
    var byteLength = data.byteLength || data.length;

    if (data.byteOffset !== 0 || byteLength !== _arrayBuffer.byteLength) {
      _arrayBuffer = _arrayBuffer.slice(data.byteOffset, data.byteOffset + byteLength);
    }

    return _arrayBuffer;
  }

  throw new Error(ERR_DATA);
}

function getArrayBufferOrStringFromData(_x, _x2, _x3) {
  return _getArrayBufferOrStringFromData.apply(this, arguments);
}

function _getArrayBufferOrStringFromData() {
  _getArrayBufferOrStringFromData = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(data, loader, options) {
    var isArrayBuffer, response;
    return _regenerator.default.wrap(function _callee$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);

            if (!(typeof data === 'string' || isArrayBuffer)) {
              _context3.next = 3;
              break;
            }

            return _context3.abrupt("return", getArrayBufferOrStringFromDataSync(data, loader, options));

          case 3:
            if (!(0, _isType.isBlob)(data)) {
              _context3.next = 7;
              break;
            }

            _context3.next = 6;
            return (0, _responseUtils.makeResponse)(data);

          case 6:
            data = _context3.sent;

          case 7:
            if (!(0, _isType.isResponse)(data)) {
              _context3.next = 21;
              break;
            }

            response = data;
            _context3.next = 11;
            return (0, _responseUtils.checkResponse)(response);

          case 11:
            if (!loader.binary) {
              _context3.next = 17;
              break;
            }

            _context3.next = 14;
            return response.arrayBuffer();

          case 14:
            _context3.t0 = _context3.sent;
            _context3.next = 20;
            break;

          case 17:
            _context3.next = 19;
            return response.text();

          case 19:
            _context3.t0 = _context3.sent;

          case 20:
            return _context3.abrupt("return", _context3.t0);

          case 21:
            if ((0, _isType.isReadableStream)(data)) {
              data = (0, _makeIterator.makeIterator)(data, options);
            }

            if (!((0, _isType.isIterable)(data) || (0, _isType.isAsyncIterable)(data))) {
              _context3.next = 24;
              break;
            }

            return _context3.abrupt("return", (0, _loaderUtils.concatenateArrayBuffersAsync)(data));

          case 24:
            throw new Error(ERR_DATA);

          case 25:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee);
  }));
  return _getArrayBufferOrStringFromData.apply(this, arguments);
}

function getAsyncIterableFromData(_x4, _x5) {
  return _getAsyncIterableFromData.apply(this, arguments);
}

function _getAsyncIterableFromData() {
  _getAsyncIterableFromData = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(data, options) {
    var response, body;
    return _regenerator.default.wrap(function _callee2$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (!(0, _isType.isIterator)(data)) {
              _context4.next = 2;
              break;
            }

            return _context4.abrupt("return", data);

          case 2:
            if (!(0, _isType.isResponse)(data)) {
              _context4.next = 10;
              break;
            }

            response = data;
            _context4.next = 6;
            return (0, _responseUtils.checkResponse)(response);

          case 6:
            _context4.next = 8;
            return response.body;

          case 8:
            body = _context4.sent;
            return _context4.abrupt("return", (0, _makeIterator.makeIterator)(body, options));

          case 10:
            if (!((0, _isType.isBlob)(data) || (0, _isType.isReadableStream)(data))) {
              _context4.next = 12;
              break;
            }

            return _context4.abrupt("return", (0, _makeIterator.makeIterator)(data, options));

          case 12:
            if (!(0, _isType.isAsyncIterable)(data)) {
              _context4.next = 14;
              break;
            }

            return _context4.abrupt("return", data[Symbol.asyncIterator]());

          case 14:
            return _context4.abrupt("return", getIterableFromData(data));

          case 15:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee2);
  }));
  return _getAsyncIterableFromData.apply(this, arguments);
}

function getReadableStream(_x6) {
  return _getReadableStream.apply(this, arguments);
}

function _getReadableStream() {
  _getReadableStream = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(data) {
    var response;
    return _regenerator.default.wrap(function _callee3$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            if (!(0, _isType.isReadableStream)(data)) {
              _context5.next = 2;
              break;
            }

            return _context5.abrupt("return", data);

          case 2:
            if (!(0, _isType.isResponse)(data)) {
              _context5.next = 4;
              break;
            }

            return _context5.abrupt("return", data.body);

          case 4:
            _context5.next = 6;
            return (0, _responseUtils.makeResponse)(data);

          case 6:
            response = _context5.sent;
            return _context5.abrupt("return", response.body);

          case 8:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee3);
  }));
  return _getReadableStream.apply(this, arguments);
}

function getIterableFromData(data) {
  if (ArrayBuffer.isView(data)) {
    return _regenerator.default.mark(function oneChunk() {
      return _regenerator.default.wrap(function oneChunk$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return data.buffer;

            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, oneChunk);
    })();
  }

  if (data instanceof ArrayBuffer) {
    return _regenerator.default.mark(function oneChunk() {
      return _regenerator.default.wrap(function oneChunk$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return data;

            case 2:
            case "end":
              return _context2.stop();
          }
        }
      }, oneChunk);
    })();
  }

  if ((0, _isType.isIterator)(data)) {
    return data;
  }

  if ((0, _isType.isIterable)(data)) {
    return data[Symbol.iterator]();
  }

  throw new Error(ERR_DATA);
}

},{"../../iterators/make-iterator/make-iterator":37,"../../javascript-utils/is-type":42,"../utils/response-utils":67,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33,"@loaders.gl/loader-utils":73}],59:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLoaderContext = getLoaderContext;
exports.getLoadersFromContext = getLoadersFromContext;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _optionUtils = require("./option-utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function getLoaderContext(context, options) {
  var previousContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  if (previousContext) {
    return previousContext;
  }

  var resolvedContext = _objectSpread({
    fetch: (0, _optionUtils.getFetchFunction)(options, context)
  }, context);

  if (!Array.isArray(resolvedContext.loaders)) {
    resolvedContext.loaders = null;
  }

  return resolvedContext;
}

function getLoadersFromContext(loaders, context) {
  if (!context && loaders && !Array.isArray(loaders)) {
    return loaders;
  }

  var candidateLoaders;

  if (loaders) {
    candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];
  }

  if (context && context.loaders) {
    var contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];
    candidateLoaders = candidateLoaders ? [].concat((0, _toConsumableArray2.default)(candidateLoaders), (0, _toConsumableArray2.default)(contextLoaders)) : contextLoaders;
  }

  return candidateLoaders && candidateLoaders.length ? candidateLoaders : null;
}

},{"./option-utils":63,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/toConsumableArray":28}],60:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConsoleLog = exports.NullLog = exports.probeLog = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _probe = require("probe.gl");

var probeLog = new _probe.Log({
  id: 'loaders.gl'
});
exports.probeLog = probeLog;

var NullLog = function () {
  function NullLog() {
    (0, _classCallCheck2.default)(this, NullLog);
  }

  (0, _createClass2.default)(NullLog, [{
    key: "log",
    value: function log() {
      return function () {};
    }
  }, {
    key: "info",
    value: function info() {
      return function () {};
    }
  }, {
    key: "warn",
    value: function warn() {
      return function () {};
    }
  }, {
    key: "error",
    value: function error() {
      return function () {};
    }
  }]);
  return NullLog;
}();

exports.NullLog = NullLog;

var ConsoleLog = function () {
  function ConsoleLog() {
    (0, _classCallCheck2.default)(this, ConsoleLog);
    (0, _defineProperty2.default)(this, "console", void 0);
    this.console = console;
  }

  (0, _createClass2.default)(ConsoleLog, [{
    key: "log",
    value: function log() {
      var _this$console$log;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return (_this$console$log = this.console.log).bind.apply(_this$console$log, [this.console].concat(args));
    }
  }, {
    key: "info",
    value: function info() {
      var _this$console$info;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return (_this$console$info = this.console.info).bind.apply(_this$console$info, [this.console].concat(args));
    }
  }, {
    key: "warn",
    value: function warn() {
      var _this$console$warn;

      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return (_this$console$warn = this.console.warn).bind.apply(_this$console$warn, [this.console].concat(args));
    }
  }, {
    key: "error",
    value: function error() {
      var _this$console$error;

      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return (_this$console$error = this.console.error).bind.apply(_this$console$error, [this.console].concat(args));
    }
  }]);
  return ConsoleLog;
}();

exports.ConsoleLog = ConsoleLog;

},{"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"probe.gl":143}],61:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isLoaderObject = isLoaderObject;
exports.normalizeLoader = normalizeLoader;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _loaderUtils = require("@loaders.gl/loader-utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function isLoaderObject(loader) {
  var _loader;

  if (!loader) {
    return false;
  }

  if (Array.isArray(loader)) {
    loader = loader[0];
  }

  var hasExtensions = Array.isArray((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.extensions);
  return hasExtensions;
}

function normalizeLoader(loader) {
  var _loader2, _loader3;

  (0, _loaderUtils.assert)(loader, 'null loader');
  (0, _loaderUtils.assert)(isLoaderObject(loader), 'invalid loader');
  var options;

  if (Array.isArray(loader)) {
    options = loader[1];
    loader = loader[0];
    loader = _objectSpread(_objectSpread({}, loader), {}, {
      options: _objectSpread(_objectSpread({}, loader.options), options)
    });
  }

  if ((_loader2 = loader) !== null && _loader2 !== void 0 && _loader2.parseTextSync || (_loader3 = loader) !== null && _loader3 !== void 0 && _loader3.parseText) {
    loader.text = true;
  }

  if (!loader.text) {
    loader.binary = true;
  }

  return loader;
}

},{"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@loaders.gl/loader-utils":73}],62:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.REMOVED_LOADER_OPTIONS = exports.DEFAULT_LOADER_OPTIONS = void 0;

var _loggers = require("./loggers");

var DEFAULT_LOADER_OPTIONS = {
  fetch: null,
  mimeType: undefined,
  nothrow: false,
  log: new _loggers.ConsoleLog(),
  CDN: 'https://unpkg.com/@loaders.gl',
  worker: true,
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: true,
  _workerType: '',
  limit: 0,
  _limitMB: 0,
  batchSize: 'auto',
  batchDebounceMs: 0,
  metadata: false,
  transforms: []
};
exports.DEFAULT_LOADER_OPTIONS = DEFAULT_LOADER_OPTIONS;
var REMOVED_LOADER_OPTIONS = {
  throws: 'nothrow',
  dataType: '(no longer used)',
  uri: 'baseUri',
  method: 'fetch.method',
  headers: 'fetch.headers',
  body: 'fetch.body',
  mode: 'fetch.mode',
  credentials: 'fetch.credentials',
  cache: 'fetch.cache',
  redirect: 'fetch.redirect',
  referrer: 'fetch.referrer',
  referrerPolicy: 'fetch.referrerPolicy',
  integrity: 'fetch.integrity',
  keepalive: 'fetch.keepalive',
  signal: 'fetch.signal'
};
exports.REMOVED_LOADER_OPTIONS = REMOVED_LOADER_OPTIONS;

},{"./loggers":60}],63:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getGlobalLoaderState = getGlobalLoaderState;
exports.setGlobalOptions = setGlobalOptions;
exports.normalizeOptions = normalizeOptions;
exports.getFetchFunction = getFetchFunction;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _loaderUtils = require("@loaders.gl/loader-utils");

var _isType = require("../../javascript-utils/is-type");

var _fetchFile = require("../fetch/fetch-file");

var _loggers = require("./loggers");

var _optionDefaults = require("./option-defaults");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function getGlobalLoaderState() {
  _loaderUtils.global.loaders = _loaderUtils.global.loaders || {};
  var loaders = _loaderUtils.global.loaders;
  loaders._state = loaders._state || {};
  return loaders._state;
}

var getGlobalLoaderOptions = function getGlobalLoaderOptions() {
  var state = getGlobalLoaderState();
  state.globalOptions = state.globalOptions || _objectSpread({}, _optionDefaults.DEFAULT_LOADER_OPTIONS);
  return state.globalOptions;
};

function setGlobalOptions(options) {
  var state = getGlobalLoaderState();
  var globalOptions = getGlobalLoaderOptions();
  state.globalOptions = normalizeOptionsInternal(globalOptions, options);
}

function normalizeOptions(options, loader, loaders, url) {
  loaders = loaders || [];
  loaders = Array.isArray(loaders) ? loaders : [loaders];
  validateOptions(options, loaders);
  return normalizeOptionsInternal(loader, options, url);
}

function getFetchFunction(options, context) {
  var globalOptions = getGlobalLoaderOptions();
  var fetchOptions = options || globalOptions;

  if (typeof fetchOptions.fetch === 'function') {
    return fetchOptions.fetch;
  }

  if ((0, _isType.isObject)(fetchOptions.fetch)) {
    return function (url) {
      return (0, _fetchFile.fetchFile)(url, fetchOptions);
    };
  }

  if (context !== null && context !== void 0 && context.fetch) {
    return context === null || context === void 0 ? void 0 : context.fetch;
  }

  return _fetchFile.fetchFile;
}

function validateOptions(options, loaders) {
  validateOptionsObject(options, null, _optionDefaults.DEFAULT_LOADER_OPTIONS, _optionDefaults.REMOVED_LOADER_OPTIONS, loaders);

  var _iterator = _createForOfIteratorHelper(loaders),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var loader = _step.value;
      var idOptions = options && options[loader.id] || {};
      var loaderOptions = loader.options && loader.options[loader.id] || {};
      var deprecatedOptions = loader.deprecatedOptions && loader.deprecatedOptions[loader.id] || {};
      validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}

function validateOptionsObject(options, id, defaultOptions, deprecatedOptions, loaders) {
  var loaderName = id || 'Top level';
  var prefix = id ? "".concat(id, ".") : '';

  for (var _key in options) {
    var isSubOptions = !id && (0, _isType.isObject)(options[_key]);
    var isBaseUriOption = _key === 'baseUri' && !id;
    var isWorkerUrlOption = _key === 'workerUrl' && id;

    if (!(_key in defaultOptions) && !isBaseUriOption && !isWorkerUrlOption) {
      if (_key in deprecatedOptions) {
        _loggers.probeLog.warn("".concat(loaderName, " loader option '").concat(prefix).concat(_key, "' no longer supported, use '").concat(deprecatedOptions[_key], "'"))();
      } else if (!isSubOptions) {
        var suggestion = findSimilarOption(_key, loaders);

        _loggers.probeLog.warn("".concat(loaderName, " loader option '").concat(prefix).concat(_key, "' not recognized. ").concat(suggestion))();
      }
    }
  }
}

function findSimilarOption(optionKey, loaders) {
  var lowerCaseOptionKey = optionKey.toLowerCase();
  var bestSuggestion = '';

  var _iterator2 = _createForOfIteratorHelper(loaders),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var loader = _step2.value;

      for (var _key2 in loader.options) {
        if (optionKey === _key2) {
          return "Did you mean '".concat(loader.id, ".").concat(_key2, "'?");
        }

        var lowerCaseKey = _key2.toLowerCase();

        var isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);

        if (isPartialMatch) {
          bestSuggestion = bestSuggestion || "Did you mean '".concat(loader.id, ".").concat(_key2, "'?");
        }
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return bestSuggestion;
}

function normalizeOptionsInternal(loader, options, url) {
  var loaderDefaultOptions = loader.options || {};

  var mergedOptions = _objectSpread({}, loaderDefaultOptions);

  addUrlOptions(mergedOptions, url);

  if (mergedOptions.log === null) {
    mergedOptions.log = new _loggers.NullLog();
  }

  mergeNestedFields(mergedOptions, getGlobalLoaderOptions());
  mergeNestedFields(mergedOptions, options);
  return mergedOptions;
}

function mergeNestedFields(mergedOptions, options) {
  for (var _key3 in options) {
    if (_key3 in options) {
      var value = options[_key3];

      if ((0, _isType.isPureObject)(value) && (0, _isType.isPureObject)(mergedOptions[_key3])) {
        mergedOptions[_key3] = _objectSpread(_objectSpread({}, mergedOptions[_key3]), options[_key3]);
      } else {
        mergedOptions[_key3] = options[_key3];
      }
    }
  }
}

function addUrlOptions(options, url) {
  if (url && !('baseUri' in options)) {
    options.baseUri = url;
  }
}

},{"../../javascript-utils/is-type":42,"../fetch/fetch-file":53,"./loggers":60,"./option-defaults":62,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@loaders.gl/loader-utils":73}],64:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fetchProgress;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

function fetchProgress(_x, _x2) {
  return _fetchProgress.apply(this, arguments);
}

function _fetchProgress() {
  _fetchProgress = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(response, onProgress) {
    var onDone,
        onError,
        body,
        contentLength,
        totalBytes,
        progressStream,
        _args2 = arguments;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            onDone = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : function () {};
            onError = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : function () {};
            _context2.next = 4;
            return response;

          case 4:
            response = _context2.sent;

            if (response.ok) {
              _context2.next = 7;
              break;
            }

            return _context2.abrupt("return", response);

          case 7:
            body = response.body;

            if (body) {
              _context2.next = 10;
              break;
            }

            return _context2.abrupt("return", response);

          case 10:
            contentLength = response.headers.get('content-length') || 0;
            totalBytes = contentLength && parseInt(contentLength);

            if (contentLength > 0) {
              _context2.next = 14;
              break;
            }

            return _context2.abrupt("return", response);

          case 14:
            if (!(typeof ReadableStream === 'undefined' || !body.getReader)) {
              _context2.next = 16;
              break;
            }

            return _context2.abrupt("return", response);

          case 16:
            progressStream = new ReadableStream({
              start: function start(controller) {
                return (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {
                  var reader;
                  return _regenerator.default.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          reader = body.getReader();
                          _context.next = 3;
                          return read(controller, reader, 0, totalBytes, onProgress, onDone, onError);

                        case 3:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee);
                }))();
              }
            });
            return _context2.abrupt("return", new Response(progressStream));

          case 18:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _fetchProgress.apply(this, arguments);
}

function read(_x3, _x4, _x5, _x6, _x7, _x8, _x9) {
  return _read.apply(this, arguments);
}

function _read() {
  _read = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError) {
    var _yield$reader$read, done, value, percent;

    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.prev = 0;
            _context3.next = 3;
            return reader.read();

          case 3:
            _yield$reader$read = _context3.sent;
            done = _yield$reader$read.done;
            value = _yield$reader$read.value;

            if (!done) {
              _context3.next = 10;
              break;
            }

            onDone();
            controller.close();
            return _context3.abrupt("return");

          case 10:
            loadedBytes += value.byteLength;
            percent = Math.round(loadedBytes / totalBytes * 100);
            onProgress(percent, {
              loadedBytes: loadedBytes,
              totalBytes: totalBytes
            });
            controller.enqueue(value);
            _context3.next = 16;
            return read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError);

          case 16:
            _context3.next = 22;
            break;

          case 18:
            _context3.prev = 18;
            _context3.t0 = _context3["catch"](0);
            controller.error(_context3.t0);
            onError(_context3.t0);

          case 22:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[0, 18]]);
  }));
  return _read.apply(this, arguments);
}

},{"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],65:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseMIMEType = parseMIMEType;
exports.parseMIMETypeFromURL = parseMIMETypeFromURL;
var DATA_URL_PATTERN = /^data:([-\w.]+\/[-\w.+]+)(;|,)/;
var MIME_TYPE_PATTERN = /^([-\w.]+\/[-\w.+]+)/;

function parseMIMEType(mimeString) {
  var matches = MIME_TYPE_PATTERN.exec(mimeString);

  if (matches) {
    return matches[1];
  }

  return mimeString;
}

function parseMIMETypeFromURL(url) {
  var matches = DATA_URL_PATTERN.exec(url);

  if (matches) {
    return matches[1];
  }

  return '';
}

},{}],66:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getResourceUrlAndType = getResourceUrlAndType;
exports.getResourceContentLength = getResourceContentLength;

var _isType = require("../../javascript-utils/is-type");

var _mimeTypeUtils = require("./mime-type-utils");

var QUERY_STRING_PATTERN = /\?.*/;

function getResourceUrlAndType(resource) {
  if ((0, _isType.isResponse)(resource)) {
    var url = stripQueryString(resource.url || '');
    var contentTypeHeader = resource.headers.get('content-type') || '';
    return {
      url: url,
      type: (0, _mimeTypeUtils.parseMIMEType)(contentTypeHeader) || (0, _mimeTypeUtils.parseMIMETypeFromURL)(url)
    };
  }

  if ((0, _isType.isBlob)(resource)) {
    return {
      url: stripQueryString(resource.name || ''),
      type: resource.type || ''
    };
  }

  if (typeof resource === 'string') {
    return {
      url: stripQueryString(resource),
      type: (0, _mimeTypeUtils.parseMIMETypeFromURL)(resource)
    };
  }

  return {
    url: '',
    type: ''
  };
}

function getResourceContentLength(resource) {
  if ((0, _isType.isResponse)(resource)) {
    return resource.headers['content-length'] || -1;
  }

  if ((0, _isType.isBlob)(resource)) {
    return resource.size;
  }

  if (typeof resource === 'string') {
    return resource.length;
  }

  if (resource instanceof ArrayBuffer) {
    return resource.byteLength;
  }

  if (ArrayBuffer.isView(resource)) {
    return resource.byteLength;
  }

  return -1;
}

function stripQueryString(url) {
  return url.replace(QUERY_STRING_PATTERN, '');
}

},{"../../javascript-utils/is-type":42,"./mime-type-utils":65}],67:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeResponse = makeResponse;
exports.checkResponse = checkResponse;
exports.checkResponseSync = checkResponseSync;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _isType = require("../../javascript-utils/is-type");

var _resourceUtils = require("./resource-utils");

function makeResponse(_x) {
  return _makeResponse.apply(this, arguments);
}

function _makeResponse() {
  _makeResponse = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(resource) {
    var headers, contentLength, _getResourceUrlAndTyp, url, type, initialDataUrl, response;

    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(0, _isType.isResponse)(resource)) {
              _context.next = 2;
              break;
            }

            return _context.abrupt("return", resource);

          case 2:
            headers = {};
            contentLength = (0, _resourceUtils.getResourceContentLength)(resource);

            if (contentLength >= 0) {
              headers['content-length'] = String(contentLength);
            }

            _getResourceUrlAndTyp = (0, _resourceUtils.getResourceUrlAndType)(resource), url = _getResourceUrlAndTyp.url, type = _getResourceUrlAndTyp.type;

            if (type) {
              headers['content-type'] = type;
            }

            _context.next = 9;
            return getInitialDataUrl(resource);

          case 9:
            initialDataUrl = _context.sent;

            if (initialDataUrl) {
              headers['x-first-bytes'] = initialDataUrl;
            }

            if (typeof resource === 'string') {
              resource = new TextEncoder().encode(resource);
            }

            response = new Response(resource, {
              headers: headers
            });
            Object.defineProperty(response, 'url', {
              value: url
            });
            return _context.abrupt("return", response);

          case 15:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _makeResponse.apply(this, arguments);
}

function checkResponse(_x2) {
  return _checkResponse.apply(this, arguments);
}

function _checkResponse() {
  _checkResponse = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(response) {
    var message;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (response.ok) {
              _context2.next = 5;
              break;
            }

            _context2.next = 3;
            return getResponseError(response);

          case 3:
            message = _context2.sent;
            throw new Error(message);

          case 5:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _checkResponse.apply(this, arguments);
}

function checkResponseSync(response) {
  if (!response.ok) {
    var message = "".concat(response.status, " ").concat(response.statusText);
    message = message.length > 60 ? "".concat(message.slice(60), "...") : message;
    throw new Error(message);
  }
}

function getResponseError(_x3) {
  return _getResponseError.apply(this, arguments);
}

function _getResponseError() {
  _getResponseError = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(response) {
    var message, contentType, text;
    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            message = "Failed to fetch resource ".concat(response.url, " (").concat(response.status, "): ");
            _context3.prev = 1;
            contentType = response.headers.get('Content-Type');
            text = response.statusText;

            if (!contentType.includes('application/json')) {
              _context3.next = 11;
              break;
            }

            _context3.t0 = text;
            _context3.t1 = " ";
            _context3.next = 9;
            return response.text();

          case 9:
            _context3.t2 = _context3.sent;
            text = _context3.t0 += _context3.t1.concat.call(_context3.t1, _context3.t2);

          case 11:
            message += text;
            message = message.length > 60 ? "".concat(message.slice(60), "...") : message;
            _context3.next = 17;
            break;

          case 15:
            _context3.prev = 15;
            _context3.t3 = _context3["catch"](1);

          case 17:
            return _context3.abrupt("return", message);

          case 18:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[1, 15]]);
  }));
  return _getResponseError.apply(this, arguments);
}

function getInitialDataUrl(_x4) {
  return _getInitialDataUrl.apply(this, arguments);
}

function _getInitialDataUrl() {
  _getInitialDataUrl = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee4(resource) {
    var INITIAL_DATA_LENGTH, blobSlice, slice, base64;
    return _regenerator.default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            INITIAL_DATA_LENGTH = 5;

            if (!(typeof resource === 'string')) {
              _context4.next = 3;
              break;
            }

            return _context4.abrupt("return", "data:,".concat(resource.slice(0, INITIAL_DATA_LENGTH)));

          case 3:
            if (!(resource instanceof Blob)) {
              _context4.next = 8;
              break;
            }

            blobSlice = resource.slice(0, 5);
            _context4.next = 7;
            return new Promise(function (resolve) {
              var reader = new FileReader();

              reader.onload = function (event) {
                var _event$target;

                return resolve(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);
              };

              reader.readAsDataURL(blobSlice);
            });

          case 7:
            return _context4.abrupt("return", _context4.sent);

          case 8:
            if (!(resource instanceof ArrayBuffer)) {
              _context4.next = 12;
              break;
            }

            slice = resource.slice(0, INITIAL_DATA_LENGTH);
            base64 = arrayBufferToBase64(slice);
            return _context4.abrupt("return", "data:base64,".concat(base64));

          case 12:
            return _context4.abrupt("return", null);

          case 13:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _getInitialDataUrl.apply(this, arguments);
}

function arrayBufferToBase64(buffer) {
  var binary = '';
  var bytes = new Uint8Array(buffer);

  for (var i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }

  return btoa(binary);
}

},{"../../javascript-utils/is-type":42,"./resource-utils":66,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],68:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NullLoader = exports.NullWorkerLoader = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _awaitAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/awaitAsyncGenerator"));

var _wrapAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapAsyncGenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

var VERSION = typeof "3.0.9" !== 'undefined' ? "3.0.9" : 'latest';
var NullWorkerLoader = {
  name: 'Null loader',
  id: 'null',
  module: 'core',
  version: VERSION,
  worker: true,
  mimeTypes: ['application/x.empty'],
  extensions: ['null'],
  tests: [function () {
    return false;
  }],
  options: {
    null: {}
  }
};
exports.NullWorkerLoader = NullWorkerLoader;
var NullLoader = {
  name: 'Null loader',
  id: 'null',
  module: 'core',
  version: VERSION,
  mimeTypes: ['application/x.empty'],
  extensions: ['null'],
  parse: function () {
    var _parse = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(arrayBuffer) {
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", arrayBuffer);

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function parse(_x2) {
      return _parse.apply(this, arguments);
    }

    return parse;
  }(),
  parseSync: function parseSync(arrayBuffer) {
    return arrayBuffer;
  },
  parseInBatches: function () {
    var _generator = (0, _wrapAsyncGenerator2.default)(_regenerator.default.mark(function _callee2(asyncIterator) {
      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, batch;

      return _regenerator.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _context2.prev = 2;
              _iterator = (0, _asyncIterator2.default)(asyncIterator);

            case 4:
              _context2.next = 6;
              return (0, _awaitAsyncGenerator2.default)(_iterator.next());

            case 6:
              _step = _context2.sent;
              _iteratorNormalCompletion = _step.done;
              _context2.next = 10;
              return (0, _awaitAsyncGenerator2.default)(_step.value);

            case 10:
              _value = _context2.sent;

              if (_iteratorNormalCompletion) {
                _context2.next = 18;
                break;
              }

              batch = _value;
              _context2.next = 15;
              return batch;

            case 15:
              _iteratorNormalCompletion = true;
              _context2.next = 4;
              break;

            case 18:
              _context2.next = 24;
              break;

            case 20:
              _context2.prev = 20;
              _context2.t0 = _context2["catch"](2);
              _didIteratorError = true;
              _iteratorError = _context2.t0;

            case 24:
              _context2.prev = 24;
              _context2.prev = 25;

              if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
                _context2.next = 29;
                break;
              }

              _context2.next = 29;
              return (0, _awaitAsyncGenerator2.default)(_iterator.return());

            case 29:
              _context2.prev = 29;

              if (!_didIteratorError) {
                _context2.next = 32;
                break;
              }

              throw _iteratorError;

            case 32:
              return _context2.finish(29);

            case 33:
              return _context2.finish(24);

            case 34:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[2, 20, 24, 34], [25,, 29, 33]]);
    }));

    function generator(_x) {
      return _generator.apply(this, arguments);
    }

    return generator;
  }(),
  tests: [function () {
    return false;
  }],
  options: {
    null: {}
  }
};
exports.NullLoader = NullLoader;

},{"@babel/runtime/helpers/asyncIterator":9,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/awaitAsyncGenerator":11,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/wrapAsyncGenerator":31,"@babel/runtime/regenerator":33}],69:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._typecheckCSVLoader = exports.CSVLoader = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _schema = require("@loaders.gl/schema");

var _papaparse = _interopRequireDefault(require("./libs/papaparse"));

var _asyncIteratorStreamer = _interopRequireDefault(require("./lib/async-iterator-streamer"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var VERSION = typeof "3.0.9" !== 'undefined' ? "3.0.9" : 'latest';
var DEFAULT_CSV_LOADER_OPTIONS = {
  csv: {
    shape: 'object-row-table',
    optimizeMemoryUsage: false,
    header: 'auto',
    columnPrefix: 'column',
    quoteChar: '"',
    escapeChar: '"',
    dynamicTyping: true,
    comments: false,
    skipEmptyLines: true,
    delimitersToGuess: [',', '\t', '|', ';']
  }
};
var CSVLoader = {
  id: 'csv',
  module: 'csv',
  name: 'CSV',
  version: VERSION,
  extensions: ['csv'],
  mimeTypes: ['text/csv'],
  category: 'table',
  parse: function () {
    var _parse = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(arrayBuffer, options) {
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", parseCSV(new TextDecoder().decode(arrayBuffer), options));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function parse(_x, _x2) {
      return _parse.apply(this, arguments);
    }

    return parse;
  }(),
  parseText: function parseText(text, options) {
    return parseCSV(text, options);
  },
  parseInBatches: parseCSVInBatches,
  options: DEFAULT_CSV_LOADER_OPTIONS
};
exports.CSVLoader = CSVLoader;

function parseCSV(_x3, _x4) {
  return _parseCSV.apply(this, arguments);
}

function _parseCSV() {
  _parseCSV = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(csvText, options) {
    var csvOptions, firstRow, header, parseWithHeader, papaparseConfig, result, rows, headerRow;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            csvOptions = _objectSpread(_objectSpread({}, DEFAULT_CSV_LOADER_OPTIONS.csv), options === null || options === void 0 ? void 0 : options.csv);
            firstRow = readFirstRow(csvText);
            header = csvOptions.header === 'auto' ? isHeaderRow(firstRow) : Boolean(csvOptions.header);
            parseWithHeader = header;
            papaparseConfig = _objectSpread(_objectSpread({}, csvOptions), {}, {
              header: parseWithHeader,
              download: false,
              transformHeader: parseWithHeader ? duplicateColumnTransformer() : undefined,
              error: function error(e) {
                throw new Error(e);
              }
            });
            result = _papaparse.default.parse(csvText, papaparseConfig);
            rows = result.data;
            headerRow = result.meta.fields || generateHeader(csvOptions.columnPrefix, firstRow.length);
            _context2.t0 = csvOptions.shape;
            _context2.next = _context2.t0 === 'object-row-table' ? 11 : _context2.t0 === 'array-row-table' ? 13 : 15;
            break;

          case 11:
            rows = rows.map(function (row) {
              return Array.isArray(row) ? (0, _schema.convertToObjectRow)(row, headerRow) : row;
            });
            return _context2.abrupt("break", 15);

          case 13:
            rows = rows.map(function (row) {
              return Array.isArray(row) ? row : (0, _schema.convertToArrayRow)(row, headerRow);
            });
            return _context2.abrupt("break", 15);

          case 15:
            return _context2.abrupt("return", rows);

          case 16:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _parseCSV.apply(this, arguments);
}

function parseCSVInBatches(asyncIterator, options) {
  var _options;

  options = _objectSpread({}, options);

  if (options.batchSize === 'auto') {
    options.batchSize = 4000;
  }

  var csvOptions = _objectSpread(_objectSpread({}, DEFAULT_CSV_LOADER_OPTIONS.csv), (_options = options) === null || _options === void 0 ? void 0 : _options.csv);

  var asyncQueue = new _schema.AsyncQueue();
  var isFirstRow = true;
  var headerRow = null;
  var tableBatchBuilder = null;
  var schema = null;

  var config = _objectSpread(_objectSpread({}, csvOptions), {}, {
    header: false,
    download: false,
    chunkSize: 1024 * 1024 * 5,
    skipEmptyLines: false,
    step: function step(results) {
      var row = results.data;

      if (csvOptions.skipEmptyLines) {
        var collapsedRow = row.flat().join('').trim();

        if (collapsedRow === '') {
          return;
        }
      }

      var bytesUsed = results.meta.cursor;

      if (isFirstRow && !headerRow) {
        var header = csvOptions.header === 'auto' ? isHeaderRow(row) : Boolean(csvOptions.header);

        if (header) {
          headerRow = row.map(duplicateColumnTransformer());
          return;
        }
      }

      if (isFirstRow) {
        isFirstRow = false;

        if (!headerRow) {
          headerRow = generateHeader(csvOptions.columnPrefix, row.length);
        }

        schema = deduceSchema(row, headerRow);
      }

      if (csvOptions.optimizeMemoryUsage) {
        row = JSON.parse(JSON.stringify(row));
      }

      tableBatchBuilder = tableBatchBuilder || new _schema.TableBatchBuilder(schema, _objectSpread({
        shape: csvOptions.shape || 'array-row-table'
      }, options));

      try {
        tableBatchBuilder.addRow(row);
        var batch = tableBatchBuilder && tableBatchBuilder.getFullBatch({
          bytesUsed: bytesUsed
        });

        if (batch) {
          asyncQueue.enqueue(batch);
        }
      } catch (error) {
        asyncQueue.enqueue(error);
      }
    },
    complete: function complete(results) {
      try {
        var bytesUsed = results.meta.cursor;
        var batch = tableBatchBuilder && tableBatchBuilder.getFinalBatch({
          bytesUsed: bytesUsed
        });

        if (batch) {
          asyncQueue.enqueue(batch);
        }
      } catch (error) {
        asyncQueue.enqueue(error);
      }

      asyncQueue.close();
    }
  });

  _papaparse.default.parse(asyncIterator, config, _asyncIteratorStreamer.default);

  return asyncQueue;
}

function isHeaderRow(row) {
  return row && row.every(function (value) {
    return typeof value === 'string';
  });
}

function readFirstRow(csvText) {
  var result = _papaparse.default.parse(csvText, {
    download: false,
    dynamicTyping: true,
    preview: 1
  });

  return result.data[0];
}

function duplicateColumnTransformer() {
  var observedColumns = new Set();
  return function (col) {
    var colName = col;
    var counter = 1;

    while (observedColumns.has(colName)) {
      colName = "".concat(col, ".").concat(counter);
      counter++;
    }

    observedColumns.add(colName);
    return colName;
  };
}

function generateHeader(columnPrefix) {
  var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var headers = [];

  for (var i = 0; i < count; i++) {
    headers.push("".concat(columnPrefix).concat(i + 1));
  }

  return headers;
}

function deduceSchema(row, headerRow) {
  var schema = headerRow ? {} : [];

  for (var i = 0; i < row.length; i++) {
    var columnName = headerRow && headerRow[i] || i;
    var value = row[i];

    switch ((0, _typeof2.default)(value)) {
      case 'number':
      case 'boolean':
        schema[columnName] = {
          name: String(columnName),
          index: i,
          type: Float32Array
        };
        break;

      case 'string':
      default:
        schema[columnName] = {
          name: String(columnName),
          index: i,
          type: Array
        };
    }
  }

  return schema;
}

var _typecheckCSVLoader = CSVLoader;
exports._typecheckCSVLoader = _typecheckCSVLoader;

},{"./lib/async-iterator-streamer":71,"./libs/papaparse":72,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"@babel/runtime/regenerator":33,"@loaders.gl/schema":92}],70:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "CSVLoader", {
  enumerable: true,
  get: function get() {
    return _csvLoader.CSVLoader;
  }
});

var _csvLoader = require("./csv-loader");

},{"./csv-loader":69}],71:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = AsyncIteratorStreamer;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

var _papaparse = _interopRequireDefault(require("../libs/papaparse"));

var ChunkStreamer = _papaparse.default.ChunkStreamer;

function AsyncIteratorStreamer(config) {
  config = config || {};
  ChunkStreamer.call(this, config);
  this.textDecoder = new TextDecoder(this._config.encoding);

  this.stream = function () {
    var _ref = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(asyncIterator) {
      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk;

      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              this._input = asyncIterator;
              _context.prev = 1;
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _context.prev = 4;
              _iterator = (0, _asyncIterator2.default)(asyncIterator);

            case 6:
              _context.next = 8;
              return _iterator.next();

            case 8:
              _step = _context.sent;
              _iteratorNormalCompletion = _step.done;
              _context.next = 12;
              return _step.value;

            case 12:
              _value = _context.sent;

              if (_iteratorNormalCompletion) {
                _context.next = 19;
                break;
              }

              chunk = _value;
              this.parseChunk(this.getStringChunk(chunk));

            case 16:
              _iteratorNormalCompletion = true;
              _context.next = 6;
              break;

            case 19:
              _context.next = 25;
              break;

            case 21:
              _context.prev = 21;
              _context.t0 = _context["catch"](4);
              _didIteratorError = true;
              _iteratorError = _context.t0;

            case 25:
              _context.prev = 25;
              _context.prev = 26;

              if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
                _context.next = 30;
                break;
              }

              _context.next = 30;
              return _iterator.return();

            case 30:
              _context.prev = 30;

              if (!_didIteratorError) {
                _context.next = 33;
                break;
              }

              throw _iteratorError;

            case 33:
              return _context.finish(30);

            case 34:
              return _context.finish(25);

            case 35:
              this._finished = true;
              this.parseChunk('');
              _context.next = 42;
              break;

            case 39:
              _context.prev = 39;
              _context.t1 = _context["catch"](1);

              this._sendError(_context.t1);

            case 42:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[1, 39], [4, 21, 25, 35], [26,, 30, 34]]);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }();

  this._nextChunk = function nextChunk() {};

  this.getStringChunk = function (chunk) {
    return typeof chunk === 'string' ? chunk : this.textDecoder.decode(chunk, {
      stream: true
    });
  };
}

AsyncIteratorStreamer.prototype = Object.create(ChunkStreamer.prototype);
AsyncIteratorStreamer.prototype.constructor = AsyncIteratorStreamer;

},{"../libs/papaparse":72,"@babel/runtime/helpers/asyncIterator":9,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],72:[function(require,module,exports){
// This is a fork of papaparse
// https://github.com/mholt/PapaParse
/* @license
Papa Parse
v5.0.0-beta.0
https://github.com/mholt/PapaParse
License: MIT
*/
// FORK SUMMARY:
// - Adopt ES6 exports
// - Implement new AsyncIteratorStreamer
// - Remove non Async Iterator streamers (can all be handled by new streamer)
// - Remove unused Worker support (loaders.gl worker system used instead)
// - Remove unused jQuery plugin support

/* eslint-disable */
// @ts-nocheck
var global = (function() {
  // alternative method, similar to `Function('return this')()`
  // but without using `eval` (which is disabled when
  // using Content Security Policy).

  if (typeof self !== 'undefined') {
    return self;
  }
  if (typeof window !== 'undefined') {
    return window;
  }
  if (typeof global !== 'undefined') {
    return global;
  }

  // When running tests none of the above have been defined
  return {};
})();

var IS_PAPA_WORKER = false;

var Papa = {};
module.exports = Papa;
Papa.parse = CsvToJson;
Papa.unparse = JsonToCsv;

Papa.RECORD_SEP = String.fromCharCode(30);
Papa.UNIT_SEP = String.fromCharCode(31);
Papa.BYTE_ORDER_MARK = '\ufeff';
Papa.BAD_DELIMITERS = ['\r', '\n', '"', Papa.BYTE_ORDER_MARK];
Papa.WORKERS_SUPPORTED = false; // !IS_WORKER && !!global.Worker;
Papa.NODE_STREAM_INPUT = 1;

// Configurable chunk sizes for local and remote files, respectively
Papa.LocalChunkSize = 1024 * 1024 * 10; // 10 MB
Papa.RemoteChunkSize = 1024 * 1024 * 5; // 5 MB
Papa.DefaultDelimiter = ','; // Used if not specified and detection fails

// Exposed for testing and development only
Papa.Parser = Parser;
Papa.ParserHandle = ParserHandle;

// BEGIN FORK
Papa.ChunkStreamer = ChunkStreamer;
Papa.StringStreamer = StringStreamer;
/*
Papa.NetworkStreamer = NetworkStreamer;
Papa.FileStreamer = FileStreamer;
Papa.ReadableStreamStreamer = ReadableStreamStreamer;
if (typeof PAPA_BROWSER_CONTEXT === 'undefined') {
  Papa.DuplexStreamStreamer = DuplexStreamStreamer;
}
*/
// END FORK

// BEGIN FORK
// Adds an argument to papa.parse
// function CsvToJson(_input, _config)
function CsvToJson(
  _input,
  _config,
  UserDefinedStreamer // BEGIN FORK
) {
  _config = _config || {};
  var dynamicTyping = _config.dynamicTyping || false;
  if (isFunction(dynamicTyping)) {
    _config.dynamicTypingFunction = dynamicTyping;
    // Will be filled on first row call
    dynamicTyping = {};
  }
  _config.dynamicTyping = dynamicTyping;

  _config.transform = isFunction(_config.transform) ? _config.transform : false;

  if (_config.worker && Papa.WORKERS_SUPPORTED) {
    var w = newWorker();

    w.userStep = _config.step;
    w.userChunk = _config.chunk;
    w.userComplete = _config.complete;
    w.userError = _config.error;

    _config.step = isFunction(_config.step);
    _config.chunk = isFunction(_config.chunk);
    _config.complete = isFunction(_config.complete);
    _config.error = isFunction(_config.error);
    delete _config.worker; // prevent infinite loop

    w.postMessage({
      input: _input,
      config: _config,
      workerId: w.id
    });

    return;
  }

  var streamer = null;
  /*
  if (_input === Papa.NODE_STREAM_INPUT && typeof PAPA_BROWSER_CONTEXT === 'undefined') {
    // create a node Duplex stream for use
    // with .pipe
    streamer = new DuplexStreamStreamer(_config);
    return streamer.getStream();
  } else
  */
  if (typeof _input === 'string') {
    // if (_config.download) streamer = new NetworkStreamer(_config);
    // else
    streamer = new StringStreamer(_config);
  }
  /*
  else if (_input.readable === true && isFunction(_input.read) && isFunction(_input.on)) {
    streamer = new ReadableStreamStreamer(_config);
  } else if ((global.File && _input instanceof File) || _input instanceof Object)
    // ...Safari. (see issue #106)
    streamer = new FileStreamer(_config);
  */

  // BEGIN FORK
  if (!streamer) {
    streamer = new UserDefinedStreamer(_config);
  }
  // END FORK

  return streamer.stream(_input);
}

function JsonToCsv(_input, _config) {
  // Default configuration

  /** whether to surround every datum with quotes */
  var _quotes = false;

  /** whether to write headers */
  var _writeHeader = true;

  /** delimiting character(s) */
  var _delimiter = ',';

  /** newline character(s) */
  var _newline = '\r\n';

  /** quote character */
  var _quoteChar = '"';

  /** escaped quote character, either "" or <config.escapeChar>" */
  var _escapedQuote = _quoteChar + _quoteChar;

  /** whether to skip empty lines */
  var _skipEmptyLines = false;

  /** the columns (keys) we expect when we unparse objects */
  var _columns = null;

  unpackConfig();

  var quoteCharRegex = new RegExp(escapeRegExp(_quoteChar), 'g');

  if (typeof _input === 'string') _input = JSON.parse(_input);

  if (Array.isArray(_input)) {
    if (!_input.length || Array.isArray(_input[0])) return serialize(null, _input, _skipEmptyLines);
    else if (typeof _input[0] === 'object')
      return serialize(_columns || objectKeys(_input[0]), _input, _skipEmptyLines);
  } else if (typeof _input === 'object') {
    if (typeof _input.data === 'string') _input.data = JSON.parse(_input.data);

    if (Array.isArray(_input.data)) {
      if (!_input.fields) _input.fields = _input.meta && _input.meta.fields;

      if (!_input.fields)
        _input.fields = Array.isArray(_input.data[0]) ? _input.fields : objectKeys(_input.data[0]);

      if (!Array.isArray(_input.data[0]) && typeof _input.data[0] !== 'object')
        _input.data = [_input.data]; // handles input like [1,2,3] or ['asdf']
    }

    return serialize(_input.fields || [], _input.data || [], _skipEmptyLines);
  }

  // Default (any valid paths should return before this)
  throw new Error('Unable to serialize unrecognized input');

  function unpackConfig() {
    if (typeof _config !== 'object') return;

    if (
      typeof _config.delimiter === 'string' &&
      !Papa.BAD_DELIMITERS.filter(function(value) {
        return _config.delimiter.indexOf(value) !== -1;
      }).length
    ) {
      _delimiter = _config.delimiter;
    }

    if (typeof _config.quotes === 'boolean' || Array.isArray(_config.quotes))
      _quotes = _config.quotes;

    if (typeof _config.skipEmptyLines === 'boolean' || typeof _config.skipEmptyLines === 'string')
      _skipEmptyLines = _config.skipEmptyLines;

    if (typeof _config.newline === 'string') _newline = _config.newline;

    if (typeof _config.quoteChar === 'string') _quoteChar = _config.quoteChar;

    if (typeof _config.header === 'boolean') _writeHeader = _config.header;

    if (Array.isArray(_config.columns)) {
      if (_config.columns.length === 0) throw new Error('Option columns is empty');

      _columns = _config.columns;
    }

    if (_config.escapeChar !== undefined) {
      _escapedQuote = _config.escapeChar + _quoteChar;
    }
  }

  /** Turns an object's keys into an array */
  function objectKeys(obj) {
    if (typeof obj !== 'object') return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    return keys;
  }

  /** The double for loop that iterates the data and writes out a CSV string including header row */
  function serialize(fields, data, skipEmptyLines) {
    var csv = '';

    if (typeof fields === 'string') fields = JSON.parse(fields);
    if (typeof data === 'string') data = JSON.parse(data);

    var hasHeader = Array.isArray(fields) && fields.length > 0;
    var dataKeyedByField = !Array.isArray(data[0]);

    // If there a header row, write it first
    if (hasHeader && _writeHeader) {
      for (var i = 0; i < fields.length; i++) {
        if (i > 0) csv += _delimiter;
        csv += safe(fields[i], i);
      }
      if (data.length > 0) csv += _newline;
    }

    // Then write out the data
    for (var row = 0; row < data.length; row++) {
      var maxCol = hasHeader ? fields.length : data[row].length;

      var emptyLine = false;
      var nullLine = hasHeader ? Object.keys(data[row]).length === 0 : data[row].length === 0;
      if (skipEmptyLines && !hasHeader) {
        emptyLine =
          skipEmptyLines === 'greedy'
            ? data[row].join('').trim() === ''
            : data[row].length === 1 && data[row][0].length === 0;
      }
      if (skipEmptyLines === 'greedy' && hasHeader) {
        var line = [];
        for (var c = 0; c < maxCol; c++) {
          var cx = dataKeyedByField ? fields[c] : c;
          line.push(data[row][cx]);
        }
        emptyLine = line.join('').trim() === '';
      }
      if (!emptyLine) {
        for (var col = 0; col < maxCol; col++) {
          if (col > 0 && !nullLine) csv += _delimiter;
          var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;
          csv += safe(data[row][colIdx], col);
        }
        if (row < data.length - 1 && (!skipEmptyLines || (maxCol > 0 && !nullLine))) {
          csv += _newline;
        }
      }
    }
    return csv;
  }

  /** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */
  function safe(str, col) {
    if (typeof str === 'undefined' || str === null) return '';

    if (str.constructor === Date) return JSON.stringify(str).slice(1, 25);

    str = str.toString().replace(quoteCharRegex, _escapedQuote);

    var needsQuotes =
      (typeof _quotes === 'boolean' && _quotes) ||
      (Array.isArray(_quotes) && _quotes[col]) ||
      hasAny(str, Papa.BAD_DELIMITERS) ||
      str.indexOf(_delimiter) > -1 ||
      str.charAt(0) === ' ' ||
      str.charAt(str.length - 1) === ' ';

    return needsQuotes ? _quoteChar + str + _quoteChar : str;
  }

  function hasAny(str, substrings) {
    for (var i = 0; i < substrings.length; i++) if (str.indexOf(substrings[i]) > -1) return true;
    return false;
  }
}

/** ChunkStreamer is the base prototype for various streamer implementations. */
function ChunkStreamer(config) {
  this._handle = null;
  this._finished = false;
  this._completed = false;
  this._input = null;
  this._baseIndex = 0;
  this._partialLine = '';
  this._rowCount = 0;
  this._start = 0;
  this._nextChunk = null;
  this.isFirstChunk = true;
  this._completeResults = {
    data: [],
    errors: [],
    meta: {}
  };
  replaceConfig.call(this, config);

  this.parseChunk = function(chunk, isFakeChunk) {
    // First chunk pre-processing
    if (this.isFirstChunk && isFunction(this._config.beforeFirstChunk)) {
      var modifiedChunk = this._config.beforeFirstChunk(chunk);
      if (modifiedChunk !== undefined) chunk = modifiedChunk;
    }
    this.isFirstChunk = false;

    // Rejoin the line we likely just split in two by chunking the file
    var aggregate = this._partialLine + chunk;
    this._partialLine = '';

    var results = this._handle.parse(aggregate, this._baseIndex, !this._finished);

    if (this._handle.paused() || this._handle.aborted()) return;

    var lastIndex = results.meta.cursor;

    if (!this._finished) {
      this._partialLine = aggregate.substring(lastIndex - this._baseIndex);
      this._baseIndex = lastIndex;
    }

    if (results && results.data) this._rowCount += results.data.length;

    var finishedIncludingPreview =
      this._finished || (this._config.preview && this._rowCount >= this._config.preview);

    if (IS_PAPA_WORKER) {
      global.postMessage({
        results: results,
        workerId: Papa.WORKER_ID,
        finished: finishedIncludingPreview
      });
    } else if (isFunction(this._config.chunk) && !isFakeChunk) {
      this._config.chunk(results, this._handle);
      if (this._handle.paused() || this._handle.aborted()) return;
      results = undefined;
      this._completeResults = undefined;
    }

    if (!this._config.step && !this._config.chunk) {
      this._completeResults.data = this._completeResults.data.concat(results.data);
      this._completeResults.errors = this._completeResults.errors.concat(results.errors);
      this._completeResults.meta = results.meta;
    }

    if (
      !this._completed &&
      finishedIncludingPreview &&
      isFunction(this._config.complete) &&
      (!results || !results.meta.aborted)
    ) {
      this._config.complete(this._completeResults, this._input);
      this._completed = true;
    }

    if (!finishedIncludingPreview && (!results || !results.meta.paused)) this._nextChunk();

    return results;
  };

  this._sendError = function(error) {
    if (isFunction(this._config.error)) this._config.error(error);
    else if (IS_PAPA_WORKER && this._config.error) {
      global.postMessage({
        workerId: Papa.WORKER_ID,
        error: error,
        finished: false
      });
    }
  };

  function replaceConfig(config) {
    // Deep-copy the config so we can edit it
    var configCopy = copy(config);
    configCopy.chunkSize = parseInt(configCopy.chunkSize); // parseInt VERY important so we don't concatenate strings!
    if (!config.step && !config.chunk) configCopy.chunkSize = null; // disable Range header if not streaming; bad values break IIS - see issue #196
    this._handle = new ParserHandle(configCopy);
    this._handle.streamer = this;
    this._config = configCopy; // persist the copy to the caller
  }
}
function StringStreamer(config) {
  config = config || {};
  ChunkStreamer.call(this, config);

  var remaining;
  this.stream = function(s) {
    remaining = s;
    return this._nextChunk();
  };
  this._nextChunk = function() {
    if (this._finished) return;
    var size = this._config.chunkSize;
    var chunk = size ? remaining.substr(0, size) : remaining;
    remaining = size ? remaining.substr(size) : '';
    this._finished = !remaining;
    return this.parseChunk(chunk);
  };
}
StringStreamer.prototype = Object.create(StringStreamer.prototype);
StringStreamer.prototype.constructor = StringStreamer;

// Use one ParserHandle per entire CSV file or string
function ParserHandle(_config) {
  // One goal is to minimize the use of regular expressions...
  var FLOAT = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i;
  var ISO_DATE = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/;

  var self = this;
  var _stepCounter = 0; // Number of times step was called (number of rows parsed)
  var _rowCounter = 0; // Number of rows that have been parsed so far
  var _input; // The input being parsed
  var _parser; // The core parser being used
  var _paused = false; // Whether we are paused or not
  var _aborted = false; // Whether the parser has aborted or not
  var _delimiterError; // Temporary state between delimiter detection and processing results
  var _fields = []; // Fields are from the header row of the input, if there is one
  var _results = {
    // The last results returned from the parser
    data: [],
    errors: [],
    meta: {}
  };

  if (isFunction(_config.step)) {
    var userStep = _config.step;
    _config.step = function(results) {
      _results = results;

      if (needsHeaderRow()) processResults();
      // only call user's step function after header row
      else {
        processResults();

        // It's possbile that this line was empty and there's no row here after all
        if (!_results.data || _results.data.length === 0) return;

        _stepCounter += results.data.length;
        if (_config.preview && _stepCounter > _config.preview) _parser.abort();
        else userStep(_results, self);
      }
    };
  }

  /**
   * Parses input. Most users won't need, and shouldn't mess with, the baseIndex
   * and ignoreLastRow parameters. They are used by streamers (wrapper functions)
   * when an input comes in multiple chunks, like from a file.
   */
  this.parse = function(input, baseIndex, ignoreLastRow) {
    var quoteChar = _config.quoteChar || '"';
    if (!_config.newline) _config.newline = guessLineEndings(input, quoteChar);

    _delimiterError = false;
    if (!_config.delimiter) {
      var delimGuess = guessDelimiter(
        input,
        _config.newline,
        _config.skipEmptyLines,
        _config.comments,
        _config.delimitersToGuess
      );
      if (delimGuess.successful) _config.delimiter = delimGuess.bestDelimiter;
      else {
        _delimiterError = true; // add error after parsing (otherwise it would be overwritten)
        _config.delimiter = Papa.DefaultDelimiter;
      }
      _results.meta.delimiter = _config.delimiter;
    } else if (isFunction(_config.delimiter)) {
      _config.delimiter = _config.delimiter(input);
      _results.meta.delimiter = _config.delimiter;
    }

    var parserConfig = copy(_config);
    if (_config.preview && _config.header) parserConfig.preview++; // to compensate for header row

    _input = input;
    _parser = new Parser(parserConfig);
    _results = _parser.parse(_input, baseIndex, ignoreLastRow);
    processResults();
    return _paused ? {meta: {paused: true}} : _results || {meta: {paused: false}};
  };

  this.paused = function() {
    return _paused;
  };

  this.pause = function() {
    _paused = true;
    _parser.abort();
    _input = _input.substr(_parser.getCharIndex());
  };

  this.resume = function() {
    _paused = false;
    self.streamer.parseChunk(_input, true);
  };

  this.aborted = function() {
    return _aborted;
  };

  this.abort = function() {
    _aborted = true;
    _parser.abort();
    _results.meta.aborted = true;
    if (isFunction(_config.complete)) _config.complete(_results);
    _input = '';
  };

  function testEmptyLine(s) {
    return _config.skipEmptyLines === 'greedy'
      ? s.join('').trim() === ''
      : s.length === 1 && s[0].length === 0;
  }

  function processResults() {
    if (_results && _delimiterError) {
      addError(
        'Delimiter',
        'UndetectableDelimiter',
        "Unable to auto-detect delimiting character; defaulted to '" + Papa.DefaultDelimiter + "'"
      );
      _delimiterError = false;
    }

    if (_config.skipEmptyLines) {
      for (var i = 0; i < _results.data.length; i++)
        if (testEmptyLine(_results.data[i])) _results.data.splice(i--, 1);
    }

    if (needsHeaderRow()) fillHeaderFields();

    return applyHeaderAndDynamicTypingAndTransformation();
  }

  function needsHeaderRow() {
    return _config.header && _fields.length === 0;
  }

  function fillHeaderFields() {
    if (!_results) return;

    function addHeder(header) {
      if (isFunction(_config.transformHeader)) header = _config.transformHeader(header);

      _fields.push(header);
    }

    if (Array.isArray(_results.data[0])) {
      for (var i = 0; needsHeaderRow() && i < _results.data.length; i++)
        _results.data[i].forEach(addHeder);

      _results.data.splice(0, 1);
    }
    // if _results.data[0] is not an array, we are in a step where _results.data is the row.
    else _results.data.forEach(addHeder);
  }

  function shouldApplyDynamicTyping(field) {
    // Cache function values to avoid calling it for each row
    if (_config.dynamicTypingFunction && _config.dynamicTyping[field] === undefined) {
      _config.dynamicTyping[field] = _config.dynamicTypingFunction(field);
    }
    return (_config.dynamicTyping[field] || _config.dynamicTyping) === true;
  }

  function parseDynamic(field, value) {
    if (shouldApplyDynamicTyping(field)) {
      if (value === 'true' || value === 'TRUE') return true;
      else if (value === 'false' || value === 'FALSE') return false;
      else if (FLOAT.test(value)) return parseFloat(value);
      else if (ISO_DATE.test(value)) return new Date(value);
      else return value === '' ? null : value;
    }
    return value;
  }

  function applyHeaderAndDynamicTypingAndTransformation() {
    if (!_results || !_results.data || (!_config.header && !_config.dynamicTyping && !_config.transform))
      return _results;

    function processRow(rowSource, i) {
      var row = _config.header ? {} : [];

      var j;
      for (j = 0; j < rowSource.length; j++) {
        var field = j;
        var value = rowSource[j];

        if (_config.header) field = j >= _fields.length ? '__parsed_extra' : _fields[j];

        if (_config.transform) value = _config.transform(value, field);

        value = parseDynamic(field, value);

        if (field === '__parsed_extra') {
          row[field] = row[field] || [];
          row[field].push(value);
        } else row[field] = value;
      }

      if (_config.header) {
        if (j > _fields.length)
          addError(
            'FieldMismatch',
            'TooManyFields',
            'Too many fields: expected ' + _fields.length + ' fields but parsed ' + j,
            _rowCounter + i
          );
        else if (j < _fields.length)
          addError(
            'FieldMismatch',
            'TooFewFields',
            'Too few fields: expected ' + _fields.length + ' fields but parsed ' + j,
            _rowCounter + i
          );
      }

      return row;
    }

    var incrementBy = 1;
    if (!_results.data[0] || Array.isArray(_results.data[0])) {
      _results.data = _results.data.map(processRow);
      incrementBy = _results.data.length;
    } else _results.data = processRow(_results.data, 0);

    if (_config.header && _results.meta) _results.meta.fields = _fields;

    _rowCounter += incrementBy;
    return _results;
  }

  function guessDelimiter(input, newline, skipEmptyLines, comments, delimitersToGuess) {
    var bestDelim, bestDelta, fieldCountPrevRow;

    delimitersToGuess = delimitersToGuess || [',', '\t', '|', ';', Papa.RECORD_SEP, Papa.UNIT_SEP];

    for (var i = 0; i < delimitersToGuess.length; i++) {
      var delim = delimitersToGuess[i];
      var delta = 0,
        avgFieldCount = 0,
        emptyLinesCount = 0;
      fieldCountPrevRow = undefined;

      var preview = new Parser({
        comments: comments,
        delimiter: delim,
        newline: newline,
        preview: 10
      }).parse(input);

      for (var j = 0; j < preview.data.length; j++) {
        if (skipEmptyLines && testEmptyLine(preview.data[j])) {
          emptyLinesCount++;
          continue;
        }
        var fieldCount = preview.data[j].length;
        avgFieldCount += fieldCount;

        if (typeof fieldCountPrevRow === 'undefined') {
          fieldCountPrevRow = 0;
          continue;
        } else if (fieldCount > 1) {
          delta += Math.abs(fieldCount - fieldCountPrevRow);
          fieldCountPrevRow = fieldCount;
        }
      }

      if (preview.data.length > 0) avgFieldCount /= preview.data.length - emptyLinesCount;

      if ((typeof bestDelta === 'undefined' || delta > bestDelta) && avgFieldCount > 1.99) {
        bestDelta = delta;
        bestDelim = delim;
      }
    }

    _config.delimiter = bestDelim;

    return {
      successful: !!bestDelim,
      bestDelimiter: bestDelim
    };
  }

  function guessLineEndings(input, quoteChar) {
    input = input.substr(0, 1024 * 1024); // max length 1 MB
    // Replace all the text inside quotes
    var re = new RegExp(escapeRegExp(quoteChar) + '([^]*?)' + escapeRegExp(quoteChar), 'gm');
    input = input.replace(re, '');

    var r = input.split('\r');

    var n = input.split('\n');

    var nAppearsFirst = n.length > 1 && n[0].length < r[0].length;

    if (r.length === 1 || nAppearsFirst) return '\n';

    var numWithN = 0;
    for (var i = 0; i < r.length; i++) {
      if (r[i][0] === '\n') numWithN++;
    }

    return numWithN >= r.length / 2 ? '\r\n' : '\r';
  }

  function addError(type, code, msg, row) {
    _results.errors.push({
      type: type,
      code: code,
      message: msg,
      row: row
    });
  }
}

/** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions */
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
}

/** The core parser implements speedy and correct CSV parsing */
function Parser(config) {
  // Unpack the config object
  config = config || {};
  var delim = config.delimiter;
  var newline = config.newline;
  var comments = config.comments;
  var step = config.step;
  var preview = config.preview;
  var fastMode = config.fastMode;
  var quoteChar;
  /** Allows for no quoteChar by setting quoteChar to undefined in config */
  if (config.quoteChar === undefined) {
    quoteChar = '"';
  } else {
    quoteChar = config.quoteChar;
  }
  var escapeChar = quoteChar;
  if (config.escapeChar !== undefined) {
    escapeChar = config.escapeChar;
  }

  // Delimiter must be valid
  if (typeof delim !== 'string' || Papa.BAD_DELIMITERS.indexOf(delim) > -1) delim = ',';

  // Comment character must be valid
  if (comments === delim) throw new Error('Comment character same as delimiter');
  else if (comments === true) comments = '#';
  else if (typeof comments !== 'string' || Papa.BAD_DELIMITERS.indexOf(comments) > -1)
    comments = false;

  // Newline must be valid: \r, \n, or \r\n
  if (newline !== '\n' && newline !== '\r' && newline !== '\r\n') newline = '\n';

  // We're gonna need these at the Parser scope
  var cursor = 0;
  var aborted = false;

  this.parse = function(input, baseIndex, ignoreLastRow) {
    // For some reason, in Chrome, this speeds things up (!?)
    if (typeof input !== 'string') throw new Error('Input must be a string');

    // We don't need to compute some of these every time parse() is called,
    // but having them in a more local scope seems to perform better
    var inputLen = input.length,
      delimLen = delim.length,
      newlineLen = newline.length,
      commentsLen = comments.length;
    var stepIsFunction = isFunction(step);

    // Establish starting state
    cursor = 0;
    var data = [],
      errors = [],
      row = [],
      lastCursor = 0;

    if (!input) return returnable();

    if (fastMode || (fastMode !== false && input.indexOf(quoteChar) === -1)) {
      var rows = input.split(newline);
      for (var i = 0; i < rows.length; i++) {
        row = rows[i];
        cursor += row.length;
        if (i !== rows.length - 1) cursor += newline.length;
        else if (ignoreLastRow) return returnable();
        if (comments && row.substr(0, commentsLen) === comments) continue;
        if (stepIsFunction) {
          data = [];
          pushRow(row.split(delim));
          doStep();
          if (aborted) return returnable();
        } else pushRow(row.split(delim));
        if (preview && i >= preview) {
          data = data.slice(0, preview);
          return returnable(true);
        }
      }
      return returnable();
    }

    var nextDelim = input.indexOf(delim, cursor);
    var nextNewline = input.indexOf(newline, cursor);
    var quoteCharRegex = new RegExp(escapeRegExp(escapeChar) + escapeRegExp(quoteChar), 'g');
    var quoteSearch;

    // Parser loop
    for (;;) {
      // Field has opening quote
      if (input[cursor] === quoteChar) {
        // Start our search for the closing quote where the cursor is
        quoteSearch = cursor;

        // Skip the opening quote
        cursor++;

        for (;;) {
          // Find closing quote
          quoteSearch = input.indexOf(quoteChar, quoteSearch + 1);

          //No other quotes are found - no other delimiters
          if (quoteSearch === -1) {
            if (!ignoreLastRow) {
              // No closing quote... what a pity
              errors.push({
                type: 'Quotes',
                code: 'MissingQuotes',
                message: 'Quoted field unterminated',
                row: data.length, // row has yet to be inserted
                index: cursor
              });
            }
            return finish();
          }

          // Closing quote at EOF
          if (quoteSearch === inputLen - 1) {
            var value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);
            return finish(value);
          }

          // If this quote is escaped, it's part of the data; skip it
          // If the quote character is the escape character, then check if the next character is the escape character
          if (quoteChar === escapeChar && input[quoteSearch + 1] === escapeChar) {
            quoteSearch++;
            continue;
          }

          // If the quote character is not the escape character, then check if the previous character was the escape character
          if (
            quoteChar !== escapeChar &&
            quoteSearch !== 0 &&
            input[quoteSearch - 1] === escapeChar
          ) {
            continue;
          }

          // Check up to nextDelim or nextNewline, whichever is closest
          var checkUpTo = nextNewline === -1 ? nextDelim : Math.min(nextDelim, nextNewline);
          var spacesBetweenQuoteAndDelimiter = extraSpaces(checkUpTo);

          // Closing quote followed by delimiter or 'unnecessary spaces + delimiter'
          if (input[quoteSearch + 1 + spacesBetweenQuoteAndDelimiter] === delim) {
            row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));
            cursor = quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen;
            nextDelim = input.indexOf(delim, cursor);
            nextNewline = input.indexOf(newline, cursor);

            if (stepIsFunction) {
              doStep();
              if (aborted) return returnable();
            }

            if (preview && data.length >= preview) return returnable(true);

            break;
          }

          var spacesBetweenQuoteAndNewLine = extraSpaces(nextNewline);

          // Closing quote followed by newline or 'unnecessary spaces + newLine'
          if (
            input.substr(quoteSearch + 1 + spacesBetweenQuoteAndNewLine, newlineLen) === newline
          ) {
            row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));
            saveRow(quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen);
            nextDelim = input.indexOf(delim, cursor); // because we may have skipped the nextDelim in the quoted field

            if (stepIsFunction) {
              doStep();
              if (aborted) return returnable();
            }

            if (preview && data.length >= preview) return returnable(true);

            break;
          }

          // Checks for valid closing quotes are complete (escaped quotes or quote followed by EOF/delimiter/newline) -- assume these quotes are part of an invalid text string
          errors.push({
            type: 'Quotes',
            code: 'InvalidQuotes',
            message: 'Trailing quote on quoted field is malformed',
            row: data.length, // row has yet to be inserted
            index: cursor
          });

          quoteSearch++;
          continue;
        }

        if (stepIsFunction) {
          doStep();
          if (aborted) return returnable();
        }

        if (preview && data.length >= preview) return returnable(true);
        continue;
      }

      // Comment found at start of new line
      if (comments && row.length === 0 && input.substr(cursor, commentsLen) === comments) {
        if (nextNewline === -1)
          // Comment ends at EOF
          return returnable();
        cursor = nextNewline + newlineLen;
        nextNewline = input.indexOf(newline, cursor);
        nextDelim = input.indexOf(delim, cursor);
        continue;
      }

      // Next delimiter comes before next newline, so we've reached end of field
      if (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1)) {
        row.push(input.substring(cursor, nextDelim));
        cursor = nextDelim + delimLen;
        nextDelim = input.indexOf(delim, cursor);
        continue;
      }

      // End of row
      if (nextNewline !== -1) {
        row.push(input.substring(cursor, nextNewline));
        saveRow(nextNewline + newlineLen);

        if (stepIsFunction) {
          doStep();
          if (aborted) return returnable();
        }

        if (preview && data.length >= preview) return returnable(true);

        continue;
      }

      break;
    }

    return finish();

    function pushRow(row) {
      data.push(row);
      lastCursor = cursor;
    }

    /**
     * checks if there are extra spaces after closing quote and given index without any text
     * if Yes, returns the number of spaces
     */
    function extraSpaces(index) {
      var spaceLength = 0;
      if (index !== -1) {
        var textBetweenClosingQuoteAndIndex = input.substring(quoteSearch + 1, index);
        if (textBetweenClosingQuoteAndIndex && textBetweenClosingQuoteAndIndex.trim() === '') {
          spaceLength = textBetweenClosingQuoteAndIndex.length;
        }
      }
      return spaceLength;
    }

    /**
     * Appends the remaining input from cursor to the end into
     * row, saves the row, calls step, and returns the results.
     */
    function finish(value) {
      if (ignoreLastRow) return returnable();
      if (typeof value === 'undefined') value = input.substr(cursor);
      row.push(value);
      cursor = inputLen; // important in case parsing is paused
      pushRow(row);
      if (stepIsFunction) doStep();
      return returnable();
    }

    /**
     * Appends the current row to the results. It sets the cursor
     * to newCursor and finds the nextNewline. The caller should
     * take care to execute user's step function and check for
     * preview and end parsing if necessary.
     */
    function saveRow(newCursor) {
      cursor = newCursor;
      pushRow(row);
      row = [];
      nextNewline = input.indexOf(newline, cursor);
    }

    /** Returns an object with the results, errors, and meta. */
    function returnable(stopped, step) {
      var isStep = step || false;
      return {
        data: isStep ? data[0] : data,
        errors: errors,
        meta: {
          delimiter: delim,
          linebreak: newline,
          aborted: aborted,
          truncated: !!stopped,
          cursor: lastCursor + (baseIndex || 0)
        }
      };
    }

    /** Executes the user's step function and resets data & errors. */
    function doStep() {
      step(returnable(undefined, true));
      data = [];
      errors = [];
    }
  };

  /** Sets the abort flag */
  this.abort = function() {
    aborted = true;
  };

  /** Gets the cursor position */
  this.getCharIndex = function() {
    return cursor;
  };
}

function notImplemented() {
  throw new Error('Not implemented.');
}

/** Makes a deep copy of an array or object (mostly) */
function copy(obj) {
  if (typeof obj !== 'object' || obj === null) return obj;
  var cpy = Array.isArray(obj) ? [] : {};
  for (var key in obj) cpy[key] = copy(obj[key]);
  return cpy;
}

function isFunction(func) {
  return typeof func === 'function';
}

},{}],73:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function get() {
    return _assert.assert;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function get() {
    return _globals.isBrowser;
  }
});
Object.defineProperty(exports, "isWorker", {
  enumerable: true,
  get: function get() {
    return _globals.isWorker;
  }
});
Object.defineProperty(exports, "nodeVersion", {
  enumerable: true,
  get: function get() {
    return _globals.nodeVersion;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function get() {
    return _globals.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function get() {
    return _globals.window;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function get() {
    return _globals.global;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function get() {
    return _globals.document;
  }
});
Object.defineProperty(exports, "createLoaderWorker", {
  enumerable: true,
  get: function get() {
    return _createLoaderWorker.createLoaderWorker;
  }
});
Object.defineProperty(exports, "parseWithWorker", {
  enumerable: true,
  get: function get() {
    return _parseWithWorker.parseWithWorker;
  }
});
Object.defineProperty(exports, "canParseWithWorker", {
  enumerable: true,
  get: function get() {
    return _parseWithWorker.canParseWithWorker;
  }
});
Object.defineProperty(exports, "parseJSON", {
  enumerable: true,
  get: function get() {
    return _parseJson.parseJSON;
  }
});
Object.defineProperty(exports, "toArrayBuffer", {
  enumerable: true,
  get: function get() {
    return _arrayBufferUtils.toArrayBuffer;
  }
});
Object.defineProperty(exports, "sliceArrayBuffer", {
  enumerable: true,
  get: function get() {
    return _arrayBufferUtils.sliceArrayBuffer;
  }
});
Object.defineProperty(exports, "concatenateArrayBuffers", {
  enumerable: true,
  get: function get() {
    return _arrayBufferUtils.concatenateArrayBuffers;
  }
});
Object.defineProperty(exports, "concatenateTypedArrays", {
  enumerable: true,
  get: function get() {
    return _arrayBufferUtils.concatenateTypedArrays;
  }
});
Object.defineProperty(exports, "compareArrayBuffers", {
  enumerable: true,
  get: function get() {
    return _arrayBufferUtils.compareArrayBuffers;
  }
});
Object.defineProperty(exports, "padToNBytes", {
  enumerable: true,
  get: function get() {
    return _memoryCopyUtils.padToNBytes;
  }
});
Object.defineProperty(exports, "copyToArray", {
  enumerable: true,
  get: function get() {
    return _memoryCopyUtils.copyToArray;
  }
});
Object.defineProperty(exports, "copyArrayBuffer", {
  enumerable: true,
  get: function get() {
    return _memoryCopyUtils.copyArrayBuffer;
  }
});
Object.defineProperty(exports, "copyPaddedArrayBufferToDataView", {
  enumerable: true,
  get: function get() {
    return _binaryCopyUtils.copyPaddedArrayBufferToDataView;
  }
});
Object.defineProperty(exports, "copyPaddedStringToDataView", {
  enumerable: true,
  get: function get() {
    return _binaryCopyUtils.copyPaddedStringToDataView;
  }
});
Object.defineProperty(exports, "padStringToByteAlignment", {
  enumerable: true,
  get: function get() {
    return _encodeUtils.padStringToByteAlignment;
  }
});
Object.defineProperty(exports, "copyStringToDataView", {
  enumerable: true,
  get: function get() {
    return _encodeUtils.copyStringToDataView;
  }
});
Object.defineProperty(exports, "copyBinaryToDataView", {
  enumerable: true,
  get: function get() {
    return _encodeUtils.copyBinaryToDataView;
  }
});
Object.defineProperty(exports, "getFirstCharacters", {
  enumerable: true,
  get: function get() {
    return _getFirstCharacters.getFirstCharacters;
  }
});
Object.defineProperty(exports, "getMagicString", {
  enumerable: true,
  get: function get() {
    return _getFirstCharacters.getMagicString;
  }
});
Object.defineProperty(exports, "makeTextEncoderIterator", {
  enumerable: true,
  get: function get() {
    return _textIterators.makeTextEncoderIterator;
  }
});
Object.defineProperty(exports, "makeTextDecoderIterator", {
  enumerable: true,
  get: function get() {
    return _textIterators.makeTextDecoderIterator;
  }
});
Object.defineProperty(exports, "makeLineIterator", {
  enumerable: true,
  get: function get() {
    return _textIterators.makeLineIterator;
  }
});
Object.defineProperty(exports, "makeNumberedLineIterator", {
  enumerable: true,
  get: function get() {
    return _textIterators.makeNumberedLineIterator;
  }
});
Object.defineProperty(exports, "forEach", {
  enumerable: true,
  get: function get() {
    return _asyncIteration.forEach;
  }
});
Object.defineProperty(exports, "concatenateArrayBuffersAsync", {
  enumerable: true,
  get: function get() {
    return _asyncIteration.concatenateArrayBuffersAsync;
  }
});
Object.defineProperty(exports, "RequestScheduler", {
  enumerable: true,
  get: function get() {
    return _requestScheduler.default;
  }
});
Object.defineProperty(exports, "setPathPrefix", {
  enumerable: true,
  get: function get() {
    return _fileAliases.setPathPrefix;
  }
});
Object.defineProperty(exports, "getPathPrefix", {
  enumerable: true,
  get: function get() {
    return _fileAliases.getPathPrefix;
  }
});
Object.defineProperty(exports, "resolvePath", {
  enumerable: true,
  get: function get() {
    return _fileAliases.resolvePath;
  }
});
Object.defineProperty(exports, "_addAliases", {
  enumerable: true,
  get: function get() {
    return _fileAliases.addAliases;
  }
});
Object.defineProperty(exports, "isBuffer", {
  enumerable: true,
  get: function get() {
    return _bufferUtils.isBuffer;
  }
});
Object.defineProperty(exports, "toBuffer", {
  enumerable: true,
  get: function get() {
    return _bufferUtils.toBuffer;
  }
});
Object.defineProperty(exports, "bufferToArrayBuffer", {
  enumerable: true,
  get: function get() {
    return _bufferUtils.bufferToArrayBuffer;
  }
});
Object.defineProperty(exports, "JSONLoader", {
  enumerable: true,
  get: function get() {
    return _jsonLoader.JSONLoader;
  }
});
exports.fs = exports.path = void 0;

var _assert = require("./lib/env-utils/assert");

var _globals = require("./lib/env-utils/globals");

var _createLoaderWorker = require("./lib/worker-loader-utils/create-loader-worker");

var _parseWithWorker = require("./lib/worker-loader-utils/parse-with-worker");

var _parseJson = require("./lib/parser-utils/parse-json");

var _arrayBufferUtils = require("./lib/binary-utils/array-buffer-utils");

var _memoryCopyUtils = require("./lib/binary-utils/memory-copy-utils");

var _binaryCopyUtils = require("./lib/binary-utils/binary-copy-utils");

var _encodeUtils = require("./lib/binary-utils/encode-utils");

var _getFirstCharacters = require("./lib/binary-utils/get-first-characters");

var _textIterators = require("./lib/iterators/text-iterators");

var _asyncIteration = require("./lib/iterators/async-iteration");

var _requestScheduler = _interopRequireDefault(require("./lib/request-utils/request-scheduler"));

var path = _interopRequireWildcard(require("./lib/path-utils/path"));

exports.path = path;

var _fileAliases = require("./lib/path-utils/file-aliases");

var fs = _interopRequireWildcard(require("./lib/node/fs"));

exports.fs = fs;

var _bufferUtils = require("./lib/binary-utils/buffer-utils");

var _jsonLoader = require("./json-loader");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

},{"./json-loader":74,"./lib/binary-utils/array-buffer-utils":75,"./lib/binary-utils/binary-copy-utils":76,"./lib/binary-utils/buffer-utils":77,"./lib/binary-utils/encode-utils":78,"./lib/binary-utils/get-first-characters":79,"./lib/binary-utils/memory-copy-utils":80,"./lib/env-utils/assert":81,"./lib/env-utils/globals":82,"./lib/iterators/async-iteration":83,"./lib/iterators/text-iterators":84,"./lib/node/fs":130,"./lib/parser-utils/parse-json":85,"./lib/path-utils/file-aliases":86,"./lib/path-utils/path":87,"./lib/request-utils/request-scheduler":88,"./lib/worker-loader-utils/create-loader-worker":89,"./lib/worker-loader-utils/parse-with-worker":90,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29}],74:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._typecheckJSONLoader = exports.JSONLoader = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var VERSION = typeof "3.0.9" !== 'undefined' ? "3.0.9" : 'latest';
var JSONLoader = {
  name: 'JSON',
  id: 'json',
  module: 'json',
  version: VERSION,
  extensions: ['json', 'geojson'],
  mimeTypes: ['application/json'],
  category: 'json',
  text: true,
  parseTextSync: parseTextSync,
  parse: function () {
    var _parse = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(arrayBuffer) {
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", parseTextSync(new TextDecoder().decode(arrayBuffer)));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function parse(_x) {
      return _parse.apply(this, arguments);
    }

    return parse;
  }(),
  options: {}
};
exports.JSONLoader = JSONLoader;

function parseTextSync(text) {
  return JSON.parse(text);
}

var _typecheckJSONLoader = JSONLoader;
exports._typecheckJSONLoader = _typecheckJSONLoader;

},{"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],75:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof3 = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toArrayBuffer = toArrayBuffer;
exports.compareArrayBuffers = compareArrayBuffers;
exports.concatenateArrayBuffers = concatenateArrayBuffers;
exports.concatenateTypedArrays = concatenateTypedArrays;
exports.sliceArrayBuffer = sliceArrayBuffer;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var node = _interopRequireWildcard(require("../node/buffer-utils.node"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof3(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function toArrayBuffer(data) {
  if (node.toArrayBuffer) {
    data = node.toArrayBuffer(data);
  }

  if (data instanceof ArrayBuffer) {
    return data;
  }

  if (ArrayBuffer.isView(data)) {
    return data.buffer;
  }

  if (typeof data === 'string') {
    var text = data;
    var uint8Array = new TextEncoder().encode(text);
    return uint8Array.buffer;
  }

  if (data && (0, _typeof2.default)(data) === 'object' && data._toArrayBuffer) {
    return data._toArrayBuffer();
  }

  throw new Error('toArrayBuffer');
}

function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {
  byteLength = byteLength || arrayBuffer1.byteLength;

  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {
    return false;
  }

  var array1 = new Uint8Array(arrayBuffer1);
  var array2 = new Uint8Array(arrayBuffer2);

  for (var i = 0; i < array1.length; ++i) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }

  return true;
}

function concatenateArrayBuffers() {
  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
    sources[_key] = arguments[_key];
  }

  var sourceArrays = sources.map(function (source2) {
    return source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2;
  });
  var byteLength = sourceArrays.reduce(function (length, typedArray) {
    return length + typedArray.byteLength;
  }, 0);
  var result = new Uint8Array(byteLength);
  var offset = 0;

  var _iterator = _createForOfIteratorHelper(sourceArrays),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var sourceArray = _step.value;
      result.set(sourceArray, offset);
      offset += sourceArray.byteLength;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return result.buffer;
}

function concatenateTypedArrays() {
  for (var _len2 = arguments.length, typedArrays = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    typedArrays[_key2] = arguments[_key2];
  }

  var arrays = typedArrays;
  var TypedArrayConstructor = arrays && arrays.length > 1 && arrays[0].constructor || null;

  if (!TypedArrayConstructor) {
    throw new Error('"concatenateTypedArrays" - incorrect quantity of arguments or arguments have incompatible data types');
  }

  var sumLength = arrays.reduce(function (acc, value) {
    return acc + value.length;
  }, 0);
  var result = new TypedArrayConstructor(sumLength);
  var offset = 0;

  for (var _i = 0, _arrays = arrays; _i < _arrays.length; _i++) {
    var array = _arrays[_i];
    result.set(array, offset);
    offset += array.length;
  }

  return result;
}

function sliceArrayBuffer(arrayBuffer, byteOffset, byteLength) {
  var subArray = byteLength !== undefined ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer).subarray(byteOffset);
  var arrayCopy = new Uint8Array(subArray);
  return arrayCopy.buffer;
}

},{"../node/buffer-utils.node":130,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29}],76:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.copyPaddedArrayBufferToDataView = copyPaddedArrayBufferToDataView;
exports.copyPaddedStringToDataView = copyPaddedStringToDataView;

var _memoryCopyUtils = require("./memory-copy-utils");

function copyPaddedArrayBufferToDataView(dataView, byteOffset, sourceBuffer, padding) {
  var paddedLength = (0, _memoryCopyUtils.padToNBytes)(sourceBuffer.byteLength, padding);
  var padLength = paddedLength - sourceBuffer.byteLength;

  if (dataView) {
    var targetArray = new Uint8Array(dataView.buffer, dataView.byteOffset + byteOffset, sourceBuffer.byteLength);
    var sourceArray = new Uint8Array(sourceBuffer);
    targetArray.set(sourceArray);

    for (var i = 0; i < padLength; ++i) {
      dataView.setUint8(byteOffset + sourceBuffer.byteLength + i, 0x20);
    }
  }

  byteOffset += paddedLength;
  return byteOffset;
}

function copyPaddedStringToDataView(dataView, byteOffset, string, padding) {
  var textEncoder = new TextEncoder();
  var stringBuffer = textEncoder.encode(string);
  byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, stringBuffer, padding);
  return byteOffset;
}

},{"./memory-copy-utils":80}],77:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof3 = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isBuffer = isBuffer;
exports.toBuffer = toBuffer;
exports.bufferToArrayBuffer = bufferToArrayBuffer;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var node = _interopRequireWildcard(require("../node/buffer-utils.node"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof3(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function isBuffer(value) {
  return value && (0, _typeof2.default)(value) === 'object' && value.isBuffer;
}

function toBuffer(data) {
  return node.toBuffer ? node.toBuffer(data) : data;
}

function bufferToArrayBuffer(data) {
  if (node.toArrayBuffer) {
    return node.toArrayBuffer(data);
  }

  return data;
}

},{"../node/buffer-utils.node":130,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29}],78:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.padStringToByteAlignment = padStringToByteAlignment;
exports.copyStringToDataView = copyStringToDataView;
exports.copyBinaryToDataView = copyBinaryToDataView;

function padStringToByteAlignment(string, byteAlignment) {
  var length = string.length;
  var paddedLength = Math.ceil(length / byteAlignment) * byteAlignment;
  var padding = paddedLength - length;
  var whitespace = '';

  for (var i = 0; i < padding; ++i) {
    whitespace += ' ';
  }

  return string + whitespace;
}

function copyStringToDataView(dataView, byteOffset, string, byteLength) {
  if (dataView) {
    for (var i = 0; i < byteLength; i++) {
      dataView.setUint8(byteOffset + i, string.charCodeAt(i));
    }
  }

  return byteOffset + byteLength;
}

function copyBinaryToDataView(dataView, byteOffset, binary, byteLength) {
  if (dataView) {
    for (var i = 0; i < byteLength; i++) {
      dataView.setUint8(byteOffset + i, binary[i]);
    }
  }

  return byteOffset + byteLength;
}

},{}],79:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFirstCharacters = getFirstCharacters;
exports.getMagicString = getMagicString;

function getFirstCharacters(data) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;

  if (typeof data === 'string') {
    return data.slice(0, length);
  } else if (ArrayBuffer.isView(data)) {
    return getMagicString(data.buffer, data.byteOffset, length);
  } else if (data instanceof ArrayBuffer) {
    var byteOffset = 0;
    return getMagicString(data, byteOffset, length);
  }

  return '';
}

function getMagicString(arrayBuffer, byteOffset, length) {
  if (arrayBuffer.byteLength <= byteOffset + length) {
    return '';
  }

  var dataView = new DataView(arrayBuffer);
  var magic = '';

  for (var i = 0; i < length; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }

  return magic;
}

},{}],80:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.padToNBytes = padToNBytes;
exports.copyArrayBuffer = copyArrayBuffer;
exports.copyToArray = copyToArray;

var _assert = require("../env-utils/assert");

function padToNBytes(byteLength, padding) {
  (0, _assert.assert)(byteLength >= 0);
  (0, _assert.assert)(padding > 0);
  return byteLength + (padding - 1) & ~(padding - 1);
}

function copyArrayBuffer(targetBuffer, sourceBuffer, byteOffset) {
  var byteLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : sourceBuffer.byteLength;
  var targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);
  var sourceArray = new Uint8Array(sourceBuffer);
  targetArray.set(sourceArray);
  return targetBuffer;
}

function copyToArray(source, target, targetOffset) {
  var sourceArray;

  if (source instanceof ArrayBuffer) {
    sourceArray = new Uint8Array(source);
  } else {
    var srcByteOffset = source.byteOffset;
    var srcByteLength = source.byteLength;
    sourceArray = new Uint8Array(source.buffer || source.arrayBuffer, srcByteOffset, srcByteLength);
  }

  target.set(sourceArray, targetOffset);
  return targetOffset + padToNBytes(sourceArray.byteLength, 4);
}

},{"../env-utils/assert":81}],81:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assert = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'loader assertion failed.');
  }
}

},{}],82:[function(require,module,exports){
(function (process,global){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nodeVersion = exports.isWorker = exports.isBrowser = exports.document = exports.global = exports.window = exports.self = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};
var self_ = globals.self || globals.window || globals.global || {};
exports.self = self_;
var window_ = globals.window || globals.self || globals.global || {};
exports.window = window_;
var global_ = globals.global || globals.self || globals.window || {};
exports.global = global_;
var document_ = globals.document || {};
exports.document = document_;
var isBrowser = (typeof process === "undefined" ? "undefined" : (0, _typeof2.default)(process)) !== 'object' || String(process) !== '[object process]' || process.browser;
exports.isBrowser = isBrowser;
var isWorker = typeof importScripts === 'function';
exports.isWorker = isWorker;
var matches = typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);
var nodeVersion = matches && parseFloat(matches[1]) || 0;
exports.nodeVersion = nodeVersion;

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"_process":153}],83:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.forEach = forEach;
exports.concatenateArrayBuffersAsync = concatenateArrayBuffersAsync;
exports.concatenateStringsAsync = concatenateStringsAsync;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

var _arrayBufferUtils = require("../binary-utils/array-buffer-utils");

function forEach(_x, _x2) {
  return _forEach.apply(this, arguments);
}

function _forEach() {
  _forEach = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(iterator, visitor) {
    var _yield$iterator$next, done, value, cancel;

    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!true) {
              _context.next = 14;
              break;
            }

            _context.next = 3;
            return iterator.next();

          case 3:
            _yield$iterator$next = _context.sent;
            done = _yield$iterator$next.done;
            value = _yield$iterator$next.value;

            if (!done) {
              _context.next = 9;
              break;
            }

            iterator.return();
            return _context.abrupt("return");

          case 9:
            cancel = visitor(value);

            if (!cancel) {
              _context.next = 12;
              break;
            }

            return _context.abrupt("return");

          case 12:
            _context.next = 0;
            break;

          case 14:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _forEach.apply(this, arguments);
}

function concatenateArrayBuffersAsync(_x3) {
  return _concatenateArrayBuffersAsync.apply(this, arguments);
}

function _concatenateArrayBuffersAsync() {
  _concatenateArrayBuffersAsync = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(asyncIterator) {
    var arrayBuffers, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk;

    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            arrayBuffers = [];
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _context2.prev = 3;
            _iterator = (0, _asyncIterator2.default)(asyncIterator);

          case 5:
            _context2.next = 7;
            return _iterator.next();

          case 7:
            _step = _context2.sent;
            _iteratorNormalCompletion = _step.done;
            _context2.next = 11;
            return _step.value;

          case 11:
            _value = _context2.sent;

            if (_iteratorNormalCompletion) {
              _context2.next = 18;
              break;
            }

            chunk = _value;
            arrayBuffers.push(chunk);

          case 15:
            _iteratorNormalCompletion = true;
            _context2.next = 5;
            break;

          case 18:
            _context2.next = 24;
            break;

          case 20:
            _context2.prev = 20;
            _context2.t0 = _context2["catch"](3);
            _didIteratorError = true;
            _iteratorError = _context2.t0;

          case 24:
            _context2.prev = 24;
            _context2.prev = 25;

            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
              _context2.next = 29;
              break;
            }

            _context2.next = 29;
            return _iterator.return();

          case 29:
            _context2.prev = 29;

            if (!_didIteratorError) {
              _context2.next = 32;
              break;
            }

            throw _iteratorError;

          case 32:
            return _context2.finish(29);

          case 33:
            return _context2.finish(24);

          case 34:
            return _context2.abrupt("return", _arrayBufferUtils.concatenateArrayBuffers.apply(void 0, arrayBuffers));

          case 35:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[3, 20, 24, 34], [25,, 29, 33]]);
  }));
  return _concatenateArrayBuffersAsync.apply(this, arguments);
}

function concatenateStringsAsync(_x4) {
  return _concatenateStringsAsync.apply(this, arguments);
}

function _concatenateStringsAsync() {
  _concatenateStringsAsync = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(asyncIterator) {
    var strings, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, chunk;

    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            strings = [];
            _iteratorNormalCompletion2 = true;
            _didIteratorError2 = false;
            _context3.prev = 3;
            _iterator2 = (0, _asyncIterator2.default)(asyncIterator);

          case 5:
            _context3.next = 7;
            return _iterator2.next();

          case 7:
            _step2 = _context3.sent;
            _iteratorNormalCompletion2 = _step2.done;
            _context3.next = 11;
            return _step2.value;

          case 11:
            _value2 = _context3.sent;

            if (_iteratorNormalCompletion2) {
              _context3.next = 18;
              break;
            }

            chunk = _value2;
            strings.push(chunk);

          case 15:
            _iteratorNormalCompletion2 = true;
            _context3.next = 5;
            break;

          case 18:
            _context3.next = 24;
            break;

          case 20:
            _context3.prev = 20;
            _context3.t0 = _context3["catch"](3);
            _didIteratorError2 = true;
            _iteratorError2 = _context3.t0;

          case 24:
            _context3.prev = 24;
            _context3.prev = 25;

            if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {
              _context3.next = 29;
              break;
            }

            _context3.next = 29;
            return _iterator2.return();

          case 29:
            _context3.prev = 29;

            if (!_didIteratorError2) {
              _context3.next = 32;
              break;
            }

            throw _iteratorError2;

          case 32:
            return _context3.finish(29);

          case 33:
            return _context3.finish(24);

          case 34:
            return _context3.abrupt("return", strings.join(''));

          case 35:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[3, 20, 24, 34], [25,, 29, 33]]);
  }));
  return _concatenateStringsAsync.apply(this, arguments);
}

},{"../binary-utils/array-buffer-utils":75,"@babel/runtime/helpers/asyncIterator":9,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],84:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeTextDecoderIterator = makeTextDecoderIterator;
exports.makeTextEncoderIterator = makeTextEncoderIterator;
exports.makeLineIterator = makeLineIterator;
exports.makeNumberedLineIterator = makeNumberedLineIterator;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _awaitAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/awaitAsyncGenerator"));

var _wrapAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapAsyncGenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

function makeTextDecoderIterator(_x) {
  return _makeTextDecoderIterator.apply(this, arguments);
}

function _makeTextDecoderIterator() {
  _makeTextDecoderIterator = (0, _wrapAsyncGenerator2.default)(_regenerator.default.mark(function _callee(arrayBufferIterator) {
    var options,
        textDecoder,
        _iteratorNormalCompletion,
        _didIteratorError,
        _iteratorError,
        _iterator,
        _step,
        _value,
        arrayBuffer,
        _args = arguments;

    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
            textDecoder = new TextDecoder(undefined, options);
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _context.prev = 4;
            _iterator = (0, _asyncIterator2.default)(arrayBufferIterator);

          case 6:
            _context.next = 8;
            return (0, _awaitAsyncGenerator2.default)(_iterator.next());

          case 8:
            _step = _context.sent;
            _iteratorNormalCompletion = _step.done;
            _context.next = 12;
            return (0, _awaitAsyncGenerator2.default)(_step.value);

          case 12:
            _value = _context.sent;

            if (_iteratorNormalCompletion) {
              _context.next = 20;
              break;
            }

            arrayBuffer = _value;
            _context.next = 17;
            return typeof arrayBuffer === 'string' ? arrayBuffer : textDecoder.decode(arrayBuffer, {
              stream: true
            });

          case 17:
            _iteratorNormalCompletion = true;
            _context.next = 6;
            break;

          case 20:
            _context.next = 26;
            break;

          case 22:
            _context.prev = 22;
            _context.t0 = _context["catch"](4);
            _didIteratorError = true;
            _iteratorError = _context.t0;

          case 26:
            _context.prev = 26;
            _context.prev = 27;

            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
              _context.next = 31;
              break;
            }

            _context.next = 31;
            return (0, _awaitAsyncGenerator2.default)(_iterator.return());

          case 31:
            _context.prev = 31;

            if (!_didIteratorError) {
              _context.next = 34;
              break;
            }

            throw _iteratorError;

          case 34:
            return _context.finish(31);

          case 35:
            return _context.finish(26);

          case 36:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[4, 22, 26, 36], [27,, 31, 35]]);
  }));
  return _makeTextDecoderIterator.apply(this, arguments);
}

function makeTextEncoderIterator(_x2) {
  return _makeTextEncoderIterator.apply(this, arguments);
}

function _makeTextEncoderIterator() {
  _makeTextEncoderIterator = (0, _wrapAsyncGenerator2.default)(_regenerator.default.mark(function _callee2(textIterator) {
    var textEncoder, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, text;

    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            textEncoder = new TextEncoder();
            _iteratorNormalCompletion2 = true;
            _didIteratorError2 = false;
            _context2.prev = 3;
            _iterator2 = (0, _asyncIterator2.default)(textIterator);

          case 5:
            _context2.next = 7;
            return (0, _awaitAsyncGenerator2.default)(_iterator2.next());

          case 7:
            _step2 = _context2.sent;
            _iteratorNormalCompletion2 = _step2.done;
            _context2.next = 11;
            return (0, _awaitAsyncGenerator2.default)(_step2.value);

          case 11:
            _value2 = _context2.sent;

            if (_iteratorNormalCompletion2) {
              _context2.next = 19;
              break;
            }

            text = _value2;
            _context2.next = 16;
            return typeof text === 'string' ? textEncoder.encode(text) : text;

          case 16:
            _iteratorNormalCompletion2 = true;
            _context2.next = 5;
            break;

          case 19:
            _context2.next = 25;
            break;

          case 21:
            _context2.prev = 21;
            _context2.t0 = _context2["catch"](3);
            _didIteratorError2 = true;
            _iteratorError2 = _context2.t0;

          case 25:
            _context2.prev = 25;
            _context2.prev = 26;

            if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {
              _context2.next = 30;
              break;
            }

            _context2.next = 30;
            return (0, _awaitAsyncGenerator2.default)(_iterator2.return());

          case 30:
            _context2.prev = 30;

            if (!_didIteratorError2) {
              _context2.next = 33;
              break;
            }

            throw _iteratorError2;

          case 33:
            return _context2.finish(30);

          case 34:
            return _context2.finish(25);

          case 35:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[3, 21, 25, 35], [26,, 30, 34]]);
  }));
  return _makeTextEncoderIterator.apply(this, arguments);
}

function makeLineIterator(_x3) {
  return _makeLineIterator.apply(this, arguments);
}

function _makeLineIterator() {
  _makeLineIterator = (0, _wrapAsyncGenerator2.default)(_regenerator.default.mark(function _callee3(textIterator) {
    var previous, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _value3, textChunk, eolIndex, line;

    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            previous = '';
            _iteratorNormalCompletion3 = true;
            _didIteratorError3 = false;
            _context3.prev = 3;
            _iterator3 = (0, _asyncIterator2.default)(textIterator);

          case 5:
            _context3.next = 7;
            return (0, _awaitAsyncGenerator2.default)(_iterator3.next());

          case 7:
            _step3 = _context3.sent;
            _iteratorNormalCompletion3 = _step3.done;
            _context3.next = 11;
            return (0, _awaitAsyncGenerator2.default)(_step3.value);

          case 11:
            _value3 = _context3.sent;

            if (_iteratorNormalCompletion3) {
              _context3.next = 26;
              break;
            }

            textChunk = _value3;
            previous += textChunk;
            eolIndex = void 0;

          case 16:
            if (!((eolIndex = previous.indexOf('\n')) >= 0)) {
              _context3.next = 23;
              break;
            }

            line = previous.slice(0, eolIndex + 1);
            previous = previous.slice(eolIndex + 1);
            _context3.next = 21;
            return line;

          case 21:
            _context3.next = 16;
            break;

          case 23:
            _iteratorNormalCompletion3 = true;
            _context3.next = 5;
            break;

          case 26:
            _context3.next = 32;
            break;

          case 28:
            _context3.prev = 28;
            _context3.t0 = _context3["catch"](3);
            _didIteratorError3 = true;
            _iteratorError3 = _context3.t0;

          case 32:
            _context3.prev = 32;
            _context3.prev = 33;

            if (!(!_iteratorNormalCompletion3 && _iterator3.return != null)) {
              _context3.next = 37;
              break;
            }

            _context3.next = 37;
            return (0, _awaitAsyncGenerator2.default)(_iterator3.return());

          case 37:
            _context3.prev = 37;

            if (!_didIteratorError3) {
              _context3.next = 40;
              break;
            }

            throw _iteratorError3;

          case 40:
            return _context3.finish(37);

          case 41:
            return _context3.finish(32);

          case 42:
            if (!(previous.length > 0)) {
              _context3.next = 45;
              break;
            }

            _context3.next = 45;
            return previous;

          case 45:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[3, 28, 32, 42], [33,, 37, 41]]);
  }));
  return _makeLineIterator.apply(this, arguments);
}

function makeNumberedLineIterator(_x4) {
  return _makeNumberedLineIterator.apply(this, arguments);
}

function _makeNumberedLineIterator() {
  _makeNumberedLineIterator = (0, _wrapAsyncGenerator2.default)(_regenerator.default.mark(function _callee4(lineIterator) {
    var counter, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, _value4, line;

    return _regenerator.default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            counter = 1;
            _iteratorNormalCompletion4 = true;
            _didIteratorError4 = false;
            _context4.prev = 3;
            _iterator4 = (0, _asyncIterator2.default)(lineIterator);

          case 5:
            _context4.next = 7;
            return (0, _awaitAsyncGenerator2.default)(_iterator4.next());

          case 7:
            _step4 = _context4.sent;
            _iteratorNormalCompletion4 = _step4.done;
            _context4.next = 11;
            return (0, _awaitAsyncGenerator2.default)(_step4.value);

          case 11:
            _value4 = _context4.sent;

            if (_iteratorNormalCompletion4) {
              _context4.next = 20;
              break;
            }

            line = _value4;
            _context4.next = 16;
            return {
              counter: counter,
              line: line
            };

          case 16:
            counter++;

          case 17:
            _iteratorNormalCompletion4 = true;
            _context4.next = 5;
            break;

          case 20:
            _context4.next = 26;
            break;

          case 22:
            _context4.prev = 22;
            _context4.t0 = _context4["catch"](3);
            _didIteratorError4 = true;
            _iteratorError4 = _context4.t0;

          case 26:
            _context4.prev = 26;
            _context4.prev = 27;

            if (!(!_iteratorNormalCompletion4 && _iterator4.return != null)) {
              _context4.next = 31;
              break;
            }

            _context4.next = 31;
            return (0, _awaitAsyncGenerator2.default)(_iterator4.return());

          case 31:
            _context4.prev = 31;

            if (!_didIteratorError4) {
              _context4.next = 34;
              break;
            }

            throw _iteratorError4;

          case 34:
            return _context4.finish(31);

          case 35:
            return _context4.finish(26);

          case 36:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, null, [[3, 22, 26, 36], [27,, 31, 35]]);
  }));
  return _makeNumberedLineIterator.apply(this, arguments);
}

},{"@babel/runtime/helpers/asyncIterator":9,"@babel/runtime/helpers/awaitAsyncGenerator":11,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/wrapAsyncGenerator":31,"@babel/runtime/regenerator":33}],85:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseJSON = parseJSON;

var _getFirstCharacters = require("../binary-utils/get-first-characters");

function parseJSON(string) {
  try {
    return JSON.parse(string);
  } catch (_) {
    throw new Error("Failed to parse JSON from data starting with \"".concat((0, _getFirstCharacters.getFirstCharacters)(string), "\""));
  }
}

},{"../binary-utils/get-first-characters":79}],86:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setPathPrefix = setPathPrefix;
exports.getPathPrefix = getPathPrefix;
exports.addAliases = addAliases;
exports.resolvePath = resolvePath;
var pathPrefix = '';
var fileAliases = {};

function setPathPrefix(prefix) {
  pathPrefix = prefix;
}

function getPathPrefix() {
  return pathPrefix;
}

function addAliases(aliases) {
  Object.assign(fileAliases, aliases);
}

function resolvePath(filename) {
  for (var alias in fileAliases) {
    if (filename.startsWith(alias)) {
      var replacement = fileAliases[alias];
      filename = filename.replace(alias, replacement);
    }
  }

  if (!filename.startsWith('http://') && !filename.startsWith('https://')) {
    filename = "".concat(pathPrefix).concat(filename);
  }

  return filename;
}

},{}],87:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dirname = dirname;
exports.join = join;

function dirname(url) {
  var slashIndex = url && url.lastIndexOf('/');
  return slashIndex >= 0 ? url.substr(0, slashIndex) : '';
}

function join() {
  for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
    parts[_key] = arguments[_key];
  }

  var separator = '/';
  parts = parts.map(function (part, index) {
    if (index) {
      part = part.replace(new RegExp("^".concat(separator)), '');
    }

    if (index !== parts.length - 1) {
      part = part.replace(new RegExp("".concat(separator, "$")), '');
    }

    return part;
  });
  return parts.join(separator);
}

},{}],88:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _stats = require("@probe.gl/stats");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var STAT_QUEUED_REQUESTS = 'Queued Requests';
var STAT_ACTIVE_REQUESTS = 'Active Requests';
var STAT_CANCELLED_REQUESTS = 'Cancelled Requests';
var STAT_QUEUED_REQUESTS_EVER = 'Queued Requests Ever';
var STAT_ACTIVE_REQUESTS_EVER = 'Active Requests Ever';
var DEFAULT_PROPS = {
  id: 'request-scheduler',
  throttleRequests: true,
  maxRequests: 6
};

var RequestScheduler = function () {
  function RequestScheduler() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, RequestScheduler);
    (0, _defineProperty2.default)(this, "props", void 0);
    (0, _defineProperty2.default)(this, "stats", void 0);
    (0, _defineProperty2.default)(this, "activeRequestCount", 0);
    (0, _defineProperty2.default)(this, "requestQueue", []);
    (0, _defineProperty2.default)(this, "requestMap", new Map());
    (0, _defineProperty2.default)(this, "deferredUpdate", null);
    this.props = _objectSpread(_objectSpread({}, DEFAULT_PROPS), props);
    this.stats = new _stats.Stats({
      id: this.props.id
    });
    this.stats.get(STAT_QUEUED_REQUESTS);
    this.stats.get(STAT_ACTIVE_REQUESTS);
    this.stats.get(STAT_CANCELLED_REQUESTS);
    this.stats.get(STAT_QUEUED_REQUESTS_EVER);
    this.stats.get(STAT_ACTIVE_REQUESTS_EVER);
  }

  (0, _createClass2.default)(RequestScheduler, [{
    key: "scheduleRequest",
    value: function scheduleRequest(handle) {
      var getPriority = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
        return 0;
      };

      if (!this.props.throttleRequests) {
        return Promise.resolve({
          done: function done() {}
        });
      }

      if (this.requestMap.has(handle)) {
        return this.requestMap.get(handle);
      }

      var request = {
        handle: handle,
        priority: 0,
        getPriority: getPriority
      };
      var promise = new Promise(function (resolve) {
        request.resolve = resolve;
        return request;
      });
      this.requestQueue.push(request);
      this.requestMap.set(handle, promise);

      this._issueNewRequests();

      return promise;
    }
  }, {
    key: "_issueRequest",
    value: function _issueRequest(request) {
      var _this = this;

      var handle = request.handle,
          resolve = request.resolve;
      var isDone = false;

      var done = function done() {
        if (!isDone) {
          isDone = true;

          _this.requestMap.delete(handle);

          _this.activeRequestCount--;

          _this._issueNewRequests();
        }
      };

      this.activeRequestCount++;
      return resolve ? resolve({
        done: done
      }) : Promise.resolve({
        done: done
      });
    }
  }, {
    key: "_issueNewRequests",
    value: function _issueNewRequests() {
      var _this2 = this;

      if (!this.deferredUpdate) {
        this.deferredUpdate = setTimeout(function () {
          return _this2._issueNewRequestsAsync();
        }, 0);
      }
    }
  }, {
    key: "_issueNewRequestsAsync",
    value: function _issueNewRequestsAsync() {
      this.deferredUpdate = null;
      var freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);

      if (freeSlots === 0) {
        return;
      }

      this._updateAllRequests();

      for (var i = 0; i < freeSlots; ++i) {
        var request = this.requestQueue.shift();

        if (request) {
          this._issueRequest(request);
        }
      }
    }
  }, {
    key: "_updateAllRequests",
    value: function _updateAllRequests() {
      var requestQueue = this.requestQueue;

      for (var i = 0; i < requestQueue.length; ++i) {
        var request = requestQueue[i];

        if (!this._updateRequest(request)) {
          requestQueue.splice(i, 1);
          this.requestMap.delete(request.handle);
          i--;
        }
      }

      requestQueue.sort(function (a, b) {
        return a.priority - b.priority;
      });
    }
  }, {
    key: "_updateRequest",
    value: function _updateRequest(request) {
      request.priority = request.getPriority(request.handle);

      if (request.priority < 0) {
        request.resolve(null);
        return false;
      }

      return true;
    }
  }]);
  return RequestScheduler;
}();

exports.default = RequestScheduler;

},{"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@probe.gl/stats":126}],89:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createLoaderWorker = createLoaderWorker;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _workerUtils = require("@loaders.gl/worker-utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var requestId = 0;

function createLoaderWorker(loader) {
  if (typeof self === 'undefined') {
    return;
  }

  _workerUtils.WorkerBody.onmessage = function () {
    var _ref = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(type, payload) {
      var input, _payload$options, options, result, message;

      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.t0 = type;
              _context.next = _context.t0 === 'process' ? 3 : 16;
              break;

            case 3:
              _context.prev = 3;
              input = payload.input, _payload$options = payload.options, options = _payload$options === void 0 ? {} : _payload$options;
              _context.next = 7;
              return parseData({
                loader: loader,
                arrayBuffer: input,
                options: options,
                context: {
                  parse: parseOnMainThread
                }
              });

            case 7:
              result = _context.sent;

              _workerUtils.WorkerBody.postMessage('done', {
                result: result
              });

              _context.next = 15;
              break;

            case 11:
              _context.prev = 11;
              _context.t1 = _context["catch"](3);
              message = _context.t1 instanceof Error ? _context.t1.message : '';

              _workerUtils.WorkerBody.postMessage('error', {
                error: message
              });

            case 15:
              return _context.abrupt("break", 16);

            case 16:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[3, 11]]);
    }));

    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();
}

function parseOnMainThread(arrayBuffer, options) {
  return new Promise(function (resolve, reject) {
    var id = requestId++;

    var onMessage = function onMessage(type, payload) {
      if (payload.id !== id) {
        return;
      }

      switch (type) {
        case 'done':
          _workerUtils.WorkerBody.removeEventListener(onMessage);

          resolve(payload.result);
          break;

        case 'error':
          _workerUtils.WorkerBody.removeEventListener(onMessage);

          reject(payload.error);
          break;

        default:
      }
    };

    _workerUtils.WorkerBody.addEventListener(onMessage);

    var payload = {
      id: id,
      input: arrayBuffer,
      options: options
    };

    _workerUtils.WorkerBody.postMessage('process', payload);
  });
}

function parseData(_x3) {
  return _parseData.apply(this, arguments);
}

function _parseData() {
  _parseData = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(_ref2) {
    var loader, arrayBuffer, options, context, data, parser, textDecoder;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            loader = _ref2.loader, arrayBuffer = _ref2.arrayBuffer, options = _ref2.options, context = _ref2.context;

            if (!(loader.parseSync || loader.parse)) {
              _context2.next = 6;
              break;
            }

            data = arrayBuffer;
            parser = loader.parseSync || loader.parse;
            _context2.next = 13;
            break;

          case 6:
            if (!loader.parseTextSync) {
              _context2.next = 12;
              break;
            }

            textDecoder = new TextDecoder();
            data = textDecoder.decode(arrayBuffer);
            parser = loader.parseTextSync;
            _context2.next = 13;
            break;

          case 12:
            throw new Error("Could not load data with ".concat(loader.name, " loader"));

          case 13:
            options = _objectSpread(_objectSpread({}, options), {}, {
              modules: loader && loader.options && loader.options.modules || {},
              worker: false
            });
            _context2.next = 16;
            return parser(data, _objectSpread({}, options), context, loader);

          case 16:
            return _context2.abrupt("return", _context2.sent);

          case 17:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _parseData.apply(this, arguments);
}

},{"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33,"@loaders.gl/worker-utils":108}],90:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.canParseWithWorker = canParseWithWorker;
exports.parseWithWorker = parseWithWorker;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _workerUtils = require("@loaders.gl/worker-utils");

function canParseWithWorker(loader, options) {
  if (!_workerUtils.WorkerFarm.isSupported()) {
    return false;
  }

  return loader.worker && (options === null || options === void 0 ? void 0 : options.worker);
}

function parseWithWorker(_x, _x2, _x3, _x4, _x5) {
  return _parseWithWorker.apply(this, arguments);
}

function _parseWithWorker() {
  _parseWithWorker = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(loader, data, options, context, parseOnMainThread) {
    var name, url, workerFarm, workerPool, job, result;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            name = loader.id;
            url = (0, _workerUtils.getWorkerURL)(loader, options);
            workerFarm = _workerUtils.WorkerFarm.getWorkerFarm(options);
            workerPool = workerFarm.getWorkerPool({
              name: name,
              url: url
            });
            options = JSON.parse(JSON.stringify(options));
            _context.next = 7;
            return workerPool.startJob('process-on-worker', onMessage.bind(null, parseOnMainThread));

          case 7:
            job = _context.sent;
            job.postMessage('process', {
              input: data,
              options: options
            });
            _context.next = 11;
            return job.result;

          case 11:
            result = _context.sent;
            _context.next = 14;
            return result.result;

          case 14:
            return _context.abrupt("return", _context.sent);

          case 15:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _parseWithWorker.apply(this, arguments);
}

function onMessage(_x6, _x7, _x8, _x9) {
  return _onMessage.apply(this, arguments);
}

function _onMessage() {
  _onMessage = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(parseOnMainThread, job, type, payload) {
    var id, input, options, result, message;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.t0 = type;
            _context2.next = _context2.t0 === 'done' ? 3 : _context2.t0 === 'error' ? 5 : _context2.t0 === 'process' ? 7 : 20;
            break;

          case 3:
            job.done(payload);
            return _context2.abrupt("break", 21);

          case 5:
            job.error(payload.error);
            return _context2.abrupt("break", 21);

          case 7:
            id = payload.id, input = payload.input, options = payload.options;
            _context2.prev = 8;
            _context2.next = 11;
            return parseOnMainThread(input, options);

          case 11:
            result = _context2.sent;
            job.postMessage('done', {
              id: id,
              result: result
            });
            _context2.next = 19;
            break;

          case 15:
            _context2.prev = 15;
            _context2.t1 = _context2["catch"](8);
            message = _context2.t1 instanceof Error ? _context2.t1.message : 'unknown error';
            job.postMessage('error', {
              id: id,
              error: message
            });

          case 19:
            return _context2.abrupt("break", 21);

          case 20:
            console.warn("parse-with-worker unknown message ".concat(type));

          case 21:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[8, 15]]);
  }));
  return _onMessage.apply(this, arguments);
}

},{"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33,"@loaders.gl/worker-utils":108}],91:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMeshSize = getMeshSize;
exports.getMeshBoundingBox = getMeshBoundingBox;

function getMeshSize(attributes) {
  var size = 0;

  for (var attributeName in attributes) {
    var attribute = attributes[attributeName];

    if (ArrayBuffer.isView(attribute)) {
      size += attribute.byteLength * attribute.BYTES_PER_ELEMENT;
    }
  }

  return size;
}

function getMeshBoundingBox(attributes) {
  var minX = Infinity;
  var minY = Infinity;
  var minZ = Infinity;
  var maxX = -Infinity;
  var maxY = -Infinity;
  var maxZ = -Infinity;
  var positions = attributes.POSITION ? attributes.POSITION.value : [];
  var len = positions && positions.length;

  for (var i = 0; i < len; i += 3) {
    var x = positions[i];
    var y = positions[i + 1];
    var z = positions[i + 2];
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    minZ = z < minZ ? z : minZ;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    maxZ = z > maxZ ? z : maxZ;
  }

  return [[minX, minY, minZ], [maxX, maxY, maxZ]];
}

},{}],92:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "TableBatchBuilder", {
  enumerable: true,
  get: function get() {
    return _tableBatchBuilder.default;
  }
});
Object.defineProperty(exports, "RowTableBatchAggregator", {
  enumerable: true,
  get: function get() {
    return _rowTableBatchAggregator.default;
  }
});
Object.defineProperty(exports, "ColumnarTableBatchAggregator", {
  enumerable: true,
  get: function get() {
    return _columnarTableBatchAggregator.default;
  }
});
Object.defineProperty(exports, "convertToObjectRow", {
  enumerable: true,
  get: function get() {
    return _rowUtils.convertToObjectRow;
  }
});
Object.defineProperty(exports, "convertToArrayRow", {
  enumerable: true,
  get: function get() {
    return _rowUtils.convertToArrayRow;
  }
});
Object.defineProperty(exports, "getMeshSize", {
  enumerable: true,
  get: function get() {
    return _meshUtils.getMeshSize;
  }
});
Object.defineProperty(exports, "getMeshBoundingBox", {
  enumerable: true,
  get: function get() {
    return _meshUtils.getMeshBoundingBox;
  }
});
Object.defineProperty(exports, "Schema", {
  enumerable: true,
  get: function get() {
    return _schema.Schema;
  }
});
Object.defineProperty(exports, "Field", {
  enumerable: true,
  get: function get() {
    return _schema.Field;
  }
});
Object.defineProperty(exports, "DataType", {
  enumerable: true,
  get: function get() {
    return _schema.DataType;
  }
});
Object.defineProperty(exports, "Null", {
  enumerable: true,
  get: function get() {
    return _schema.Null;
  }
});
Object.defineProperty(exports, "Binary", {
  enumerable: true,
  get: function get() {
    return _schema.Binary;
  }
});
Object.defineProperty(exports, "Bool", {
  enumerable: true,
  get: function get() {
    return _schema.Bool;
  }
});
Object.defineProperty(exports, "Int", {
  enumerable: true,
  get: function get() {
    return _schema.Int;
  }
});
Object.defineProperty(exports, "Int8", {
  enumerable: true,
  get: function get() {
    return _schema.Int8;
  }
});
Object.defineProperty(exports, "Int16", {
  enumerable: true,
  get: function get() {
    return _schema.Int16;
  }
});
Object.defineProperty(exports, "Int32", {
  enumerable: true,
  get: function get() {
    return _schema.Int32;
  }
});
Object.defineProperty(exports, "Int64", {
  enumerable: true,
  get: function get() {
    return _schema.Int64;
  }
});
Object.defineProperty(exports, "Uint8", {
  enumerable: true,
  get: function get() {
    return _schema.Uint8;
  }
});
Object.defineProperty(exports, "Uint16", {
  enumerable: true,
  get: function get() {
    return _schema.Uint16;
  }
});
Object.defineProperty(exports, "Uint32", {
  enumerable: true,
  get: function get() {
    return _schema.Uint32;
  }
});
Object.defineProperty(exports, "Uint64", {
  enumerable: true,
  get: function get() {
    return _schema.Uint64;
  }
});
Object.defineProperty(exports, "Float", {
  enumerable: true,
  get: function get() {
    return _schema.Float;
  }
});
Object.defineProperty(exports, "Float16", {
  enumerable: true,
  get: function get() {
    return _schema.Float16;
  }
});
Object.defineProperty(exports, "Float32", {
  enumerable: true,
  get: function get() {
    return _schema.Float32;
  }
});
Object.defineProperty(exports, "Float64", {
  enumerable: true,
  get: function get() {
    return _schema.Float64;
  }
});
Object.defineProperty(exports, "Utf8", {
  enumerable: true,
  get: function get() {
    return _schema.Utf8;
  }
});
Object.defineProperty(exports, "Date", {
  enumerable: true,
  get: function get() {
    return _schema.Date;
  }
});
Object.defineProperty(exports, "DateDay", {
  enumerable: true,
  get: function get() {
    return _schema.DateDay;
  }
});
Object.defineProperty(exports, "DateMillisecond", {
  enumerable: true,
  get: function get() {
    return _schema.DateMillisecond;
  }
});
Object.defineProperty(exports, "Time", {
  enumerable: true,
  get: function get() {
    return _schema.Time;
  }
});
Object.defineProperty(exports, "TimeMillisecond", {
  enumerable: true,
  get: function get() {
    return _schema.TimeMillisecond;
  }
});
Object.defineProperty(exports, "TimeSecond", {
  enumerable: true,
  get: function get() {
    return _schema.TimeSecond;
  }
});
Object.defineProperty(exports, "Timestamp", {
  enumerable: true,
  get: function get() {
    return _schema.Timestamp;
  }
});
Object.defineProperty(exports, "TimestampSecond", {
  enumerable: true,
  get: function get() {
    return _schema.TimestampSecond;
  }
});
Object.defineProperty(exports, "TimestampMillisecond", {
  enumerable: true,
  get: function get() {
    return _schema.TimestampMillisecond;
  }
});
Object.defineProperty(exports, "TimestampMicrosecond", {
  enumerable: true,
  get: function get() {
    return _schema.TimestampMicrosecond;
  }
});
Object.defineProperty(exports, "TimestampNanosecond", {
  enumerable: true,
  get: function get() {
    return _schema.TimestampNanosecond;
  }
});
Object.defineProperty(exports, "Interval", {
  enumerable: true,
  get: function get() {
    return _schema.Interval;
  }
});
Object.defineProperty(exports, "IntervalDayTime", {
  enumerable: true,
  get: function get() {
    return _schema.IntervalDayTime;
  }
});
Object.defineProperty(exports, "IntervalYearMonth", {
  enumerable: true,
  get: function get() {
    return _schema.IntervalYearMonth;
  }
});
Object.defineProperty(exports, "FixedSizeList", {
  enumerable: true,
  get: function get() {
    return _schema.FixedSizeList;
  }
});
Object.defineProperty(exports, "deduceTableSchema", {
  enumerable: true,
  get: function get() {
    return _deduceTableSchema.deduceTableSchema;
  }
});
Object.defineProperty(exports, "getTypeInfo", {
  enumerable: true,
  get: function get() {
    return _getTypeInfo.getTypeInfo;
  }
});
Object.defineProperty(exports, "getArrowTypeFromTypedArray", {
  enumerable: true,
  get: function get() {
    return _typeUtils.getArrowTypeFromTypedArray;
  }
});
Object.defineProperty(exports, "AsyncQueue", {
  enumerable: true,
  get: function get() {
    return _asyncQueue.default;
  }
});

var _tableBatchBuilder = _interopRequireDefault(require("./lib/table/table-batch-builder"));

var _rowTableBatchAggregator = _interopRequireDefault(require("./lib/table/row-table-batch-aggregator"));

var _columnarTableBatchAggregator = _interopRequireDefault(require("./lib/table/columnar-table-batch-aggregator"));

var _rowUtils = require("./lib/utils/row-utils");

var _meshUtils = require("./category/mesh/mesh-utils");

var _schema = require("./lib/schema");

var _deduceTableSchema = require("./lib/schema-utils/deduce-table-schema");

var _getTypeInfo = require("./lib/schema-utils/get-type-info");

var _typeUtils = require("./lib/schema-utils/type-utils");

var _asyncQueue = _interopRequireDefault(require("./lib/utils/async-queue"));

},{"./category/mesh/mesh-utils":91,"./lib/schema":100,"./lib/schema-utils/deduce-table-schema":93,"./lib/schema-utils/get-type-info":94,"./lib/schema-utils/type-utils":95,"./lib/table/columnar-table-batch-aggregator":102,"./lib/table/row-table-batch-aggregator":103,"./lib/table/table-batch-builder":104,"./lib/utils/async-queue":106,"./lib/utils/row-utils":107,"@babel/runtime/helpers/interopRequireDefault":18}],93:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deduceTableSchema = deduceTableSchema;

function deduceTableSchema(table, schema) {
  var deducedSchema = Array.isArray(table) ? deduceSchemaForRowTable(table) : deduceSchemaForColumnarTable(table);
  return Object.assign(deducedSchema, schema);
}

function deduceSchemaForColumnarTable(columnarTable) {
  var schema = {};

  for (var field in columnarTable) {
    var column = columnarTable[field];

    if (ArrayBuffer.isView(column)) {
      schema[field] = column.constructor;
    } else if (column.length) {
      var value = column[0];
      schema[field] = deduceTypeFromValue(value);
    }

    schema[field] = schema[field] || null;
  }

  return schema;
}

function deduceSchemaForRowTable(rowTable) {
  var schema = {};

  if (rowTable.length) {
    var row = rowTable[0];

    for (var field in row) {
      var value = row[field];
      schema[field] = deduceTypeFromValue(value);
    }
  }

  return schema;
}

function deduceTypeFromValue(value) {
  if (value instanceof Date) {
    return Date;
  } else if (value instanceof Number) {
    return Float32Array;
  } else if (typeof value === 'string') {
    return String;
  }

  return null;
}

},{}],94:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTypeInfo = getTypeInfo;

var _schema = require("../schema");

function getTypeInfo(arrowTypeLike) {
  return {
    typeId: arrowTypeLike.typeId,
    ArrayType: arrowTypeLike.ArrayType,
    typeName: arrowTypeLike.toString(),
    typeEnumName: getTypeKey(arrowTypeLike.typeId),
    precision: arrowTypeLike.precision
  };
}

var ReverseType = null;

function getTypeKey(typeKey) {
  if (!ReverseType) {
    ReverseType = {};

    for (var _key in _schema.Type) {
      ReverseType[_schema.Type[_key]] = _key;
    }
  }

  return ReverseType[typeKey];
}

},{"../schema":100}],95:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getArrowTypeFromTypedArray = getArrowTypeFromTypedArray;

var _schema = require("../schema");

function getArrowTypeFromTypedArray(array) {
  switch (array.constructor) {
    case Int8Array:
      return new _schema.Int8();

    case Uint8Array:
      return new _schema.Uint8();

    case Int16Array:
      return new _schema.Int16();

    case Uint16Array:
      return new _schema.Uint16();

    case Int32Array:
      return new _schema.Int32();

    case Uint32Array:
      return new _schema.Uint32();

    case Float32Array:
      return new _schema.Float32();

    case Float64Array:
      return new _schema.Float64();

    default:
      throw new Error('array type not supported');
  }
}

},{"../schema":100}],96:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Type = void 0;
var Type;
exports.Type = Type;

(function (Type) {
  Type[Type["NONE"] = 0] = "NONE";
  Type[Type["Null"] = 1] = "Null";
  Type[Type["Int"] = 2] = "Int";
  Type[Type["Float"] = 3] = "Float";
  Type[Type["Binary"] = 4] = "Binary";
  Type[Type["Utf8"] = 5] = "Utf8";
  Type[Type["Bool"] = 6] = "Bool";
  Type[Type["Decimal"] = 7] = "Decimal";
  Type[Type["Date"] = 8] = "Date";
  Type[Type["Time"] = 9] = "Time";
  Type[Type["Timestamp"] = 10] = "Timestamp";
  Type[Type["Interval"] = 11] = "Interval";
  Type[Type["List"] = 12] = "List";
  Type[Type["Struct"] = 13] = "Struct";
  Type[Type["Union"] = 14] = "Union";
  Type[Type["FixedSizeBinary"] = 15] = "FixedSizeBinary";
  Type[Type["FixedSizeList"] = 16] = "FixedSizeList";
  Type[Type["Map"] = 17] = "Map";
  Type[Type["Dictionary"] = -1] = "Dictionary";
  Type[Type["Int8"] = -2] = "Int8";
  Type[Type["Int16"] = -3] = "Int16";
  Type[Type["Int32"] = -4] = "Int32";
  Type[Type["Int64"] = -5] = "Int64";
  Type[Type["Uint8"] = -6] = "Uint8";
  Type[Type["Uint16"] = -7] = "Uint16";
  Type[Type["Uint32"] = -8] = "Uint32";
  Type[Type["Uint64"] = -9] = "Uint64";
  Type[Type["Float16"] = -10] = "Float16";
  Type[Type["Float32"] = -11] = "Float32";
  Type[Type["Float64"] = -12] = "Float64";
  Type[Type["DateDay"] = -13] = "DateDay";
  Type[Type["DateMillisecond"] = -14] = "DateMillisecond";
  Type[Type["TimestampSecond"] = -15] = "TimestampSecond";
  Type[Type["TimestampMillisecond"] = -16] = "TimestampMillisecond";
  Type[Type["TimestampMicrosecond"] = -17] = "TimestampMicrosecond";
  Type[Type["TimestampNanosecond"] = -18] = "TimestampNanosecond";
  Type[Type["TimeSecond"] = -19] = "TimeSecond";
  Type[Type["TimeMillisecond"] = -20] = "TimeMillisecond";
  Type[Type["TimeMicrosecond"] = -21] = "TimeMicrosecond";
  Type[Type["TimeNanosecond"] = -22] = "TimeNanosecond";
  Type[Type["DenseUnion"] = -23] = "DenseUnion";
  Type[Type["SparseUnion"] = -24] = "SparseUnion";
  Type[Type["IntervalDayTime"] = -25] = "IntervalDayTime";
  Type[Type["IntervalYearMonth"] = -26] = "IntervalYearMonth";
})(Type || (exports.Type = Type = {}));

},{}],97:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var Field = function () {
  function Field(name, type) {
    var nullable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var metadata = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Map();
    (0, _classCallCheck2.default)(this, Field);
    (0, _defineProperty2.default)(this, "name", void 0);
    (0, _defineProperty2.default)(this, "type", void 0);
    (0, _defineProperty2.default)(this, "nullable", void 0);
    (0, _defineProperty2.default)(this, "metadata", void 0);
    this.name = name;
    this.type = type;
    this.nullable = nullable;
    this.metadata = metadata;
  }

  (0, _createClass2.default)(Field, [{
    key: "typeId",
    get: function get() {
      return this.type && this.type.typeId;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new Field(this.name, this.type, this.nullable, this.metadata);
    }
  }, {
    key: "compareTo",
    value: function compareTo(other) {
      return this.name === other.name && this.type === other.type && this.nullable === other.nullable && this.metadata === other.metadata;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "".concat(this.type).concat(this.nullable ? ', nullable' : '').concat(this.metadata ? ", metadata: ".concat(this.metadata) : '');
    }
  }]);
  return Field;
}();

exports.default = Field;

},{"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18}],98:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _assert = require("../../utils/assert");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var Schema = function () {
  function Schema(fields, metadata) {
    (0, _classCallCheck2.default)(this, Schema);
    (0, _defineProperty2.default)(this, "fields", void 0);
    (0, _defineProperty2.default)(this, "metadata", void 0);
    (0, _assert.assert)(Array.isArray(fields));
    checkNames(fields);
    this.fields = fields;
    this.metadata = metadata || new Map();
  }

  (0, _createClass2.default)(Schema, [{
    key: "compareTo",
    value: function compareTo(other) {
      if (this.metadata !== other.metadata) {
        return false;
      }

      if (this.fields.length !== other.fields.length) {
        return false;
      }

      for (var i = 0; i < this.fields.length; ++i) {
        if (!this.fields[i].compareTo(other.fields[i])) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "select",
    value: function select() {
      var nameMap = Object.create(null);

      for (var _len = arguments.length, columnNames = new Array(_len), _key = 0; _key < _len; _key++) {
        columnNames[_key] = arguments[_key];
      }

      for (var _i = 0, _columnNames = columnNames; _i < _columnNames.length; _i++) {
        var name = _columnNames[_i];
        nameMap[name] = true;
      }

      var selectedFields = this.fields.filter(function (field) {
        return nameMap[field.name];
      });
      return new Schema(selectedFields, this.metadata);
    }
  }, {
    key: "selectAt",
    value: function selectAt() {
      var _this = this;

      for (var _len2 = arguments.length, columnIndices = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        columnIndices[_key2] = arguments[_key2];
      }

      var selectedFields = columnIndices.map(function (index) {
        return _this.fields[index];
      }).filter(Boolean);
      return new Schema(selectedFields, this.metadata);
    }
  }, {
    key: "assign",
    value: function assign(schemaOrFields) {
      var fields;
      var metadata = this.metadata;

      if (schemaOrFields instanceof Schema) {
        var otherSchema = schemaOrFields;
        fields = otherSchema.fields;
        metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);
      } else {
        fields = schemaOrFields;
      }

      var fieldMap = Object.create(null);

      var _iterator = _createForOfIteratorHelper(this.fields),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var field = _step.value;
          fieldMap[field.name] = field;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var _iterator2 = _createForOfIteratorHelper(fields),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _field = _step2.value;
          fieldMap[_field.name] = _field;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      var mergedFields = Object.values(fieldMap);
      return new Schema(mergedFields, metadata);
    }
  }]);
  return Schema;
}();

exports.default = Schema;

function checkNames(fields) {
  var usedNames = {};

  var _iterator3 = _createForOfIteratorHelper(fields),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var field = _step3.value;

      if (usedNames[field.name]) {
        console.warn('Schema: duplicated field name', field.name, field);
      }

      usedNames[field.name] = true;
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
}

function mergeMaps(m1, m2) {
  return new Map([].concat((0, _toConsumableArray2.default)(m1 || new Map()), (0, _toConsumableArray2.default)(m2 || new Map())));
}

},{"../../utils/assert":105,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/toConsumableArray":28}],99:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Type", {
  enumerable: true,
  get: function get() {
    return _enum.Type;
  }
});
exports.FixedSizeList = exports.IntervalYearMonth = exports.IntervalDayTime = exports.Interval = exports.TimestampNanosecond = exports.TimestampMicrosecond = exports.TimestampMillisecond = exports.TimestampSecond = exports.Timestamp = exports.TimeMillisecond = exports.TimeSecond = exports.Time = exports.DateMillisecond = exports.DateDay = exports.Date = exports.Utf8 = exports.Binary = exports.Float64 = exports.Float32 = exports.Float16 = exports.Float = exports.Uint64 = exports.Uint32 = exports.Uint16 = exports.Uint8 = exports.Int64 = exports.Int32 = exports.Int16 = exports.Int8 = exports.Int = exports.Bool = exports.Null = exports.DataType = void 0;

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _enum = require("./enum");

var _Symbol$toStringTag, _Symbol$toStringTag2, _Symbol$toStringTag3, _Symbol$toStringTag4, _Symbol$toStringTag5, _Symbol$toStringTag6, _Symbol$toStringTag7;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var DataType = function () {
  function DataType() {
    (0, _classCallCheck2.default)(this, DataType);
  }

  (0, _createClass2.default)(DataType, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.NONE;
    }
  }, {
    key: "compareTo",
    value: function compareTo(other) {
      return this === other;
    }
  }], [{
    key: "isNull",
    value: function isNull(x) {
      return x && x.typeId === _enum.Type.Null;
    }
  }, {
    key: "isInt",
    value: function isInt(x) {
      return x && x.typeId === _enum.Type.Int;
    }
  }, {
    key: "isFloat",
    value: function isFloat(x) {
      return x && x.typeId === _enum.Type.Float;
    }
  }, {
    key: "isBinary",
    value: function isBinary(x) {
      return x && x.typeId === _enum.Type.Binary;
    }
  }, {
    key: "isUtf8",
    value: function isUtf8(x) {
      return x && x.typeId === _enum.Type.Utf8;
    }
  }, {
    key: "isBool",
    value: function isBool(x) {
      return x && x.typeId === _enum.Type.Bool;
    }
  }, {
    key: "isDecimal",
    value: function isDecimal(x) {
      return x && x.typeId === _enum.Type.Decimal;
    }
  }, {
    key: "isDate",
    value: function isDate(x) {
      return x && x.typeId === _enum.Type.Date;
    }
  }, {
    key: "isTime",
    value: function isTime(x) {
      return x && x.typeId === _enum.Type.Time;
    }
  }, {
    key: "isTimestamp",
    value: function isTimestamp(x) {
      return x && x.typeId === _enum.Type.Timestamp;
    }
  }, {
    key: "isInterval",
    value: function isInterval(x) {
      return x && x.typeId === _enum.Type.Interval;
    }
  }, {
    key: "isList",
    value: function isList(x) {
      return x && x.typeId === _enum.Type.List;
    }
  }, {
    key: "isStruct",
    value: function isStruct(x) {
      return x && x.typeId === _enum.Type.Struct;
    }
  }, {
    key: "isUnion",
    value: function isUnion(x) {
      return x && x.typeId === _enum.Type.Union;
    }
  }, {
    key: "isFixedSizeBinary",
    value: function isFixedSizeBinary(x) {
      return x && x.typeId === _enum.Type.FixedSizeBinary;
    }
  }, {
    key: "isFixedSizeList",
    value: function isFixedSizeList(x) {
      return x && x.typeId === _enum.Type.FixedSizeList;
    }
  }, {
    key: "isMap",
    value: function isMap(x) {
      return x && x.typeId === _enum.Type.Map;
    }
  }, {
    key: "isDictionary",
    value: function isDictionary(x) {
      return x && x.typeId === _enum.Type.Dictionary;
    }
  }]);
  return DataType;
}();

exports.DataType = DataType;

var Null = function (_DataType) {
  (0, _inherits2.default)(Null, _DataType);

  var _super = _createSuper(Null);

  function Null() {
    (0, _classCallCheck2.default)(this, Null);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(Null, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.Null;
    }
  }, {
    key: Symbol.toStringTag,
    get: function get() {
      return 'Null';
    }
  }, {
    key: "toString",
    value: function toString() {
      return 'Null';
    }
  }]);
  return Null;
}(DataType);

exports.Null = Null;

var Bool = function (_DataType2) {
  (0, _inherits2.default)(Bool, _DataType2);

  var _super2 = _createSuper(Bool);

  function Bool() {
    (0, _classCallCheck2.default)(this, Bool);
    return _super2.apply(this, arguments);
  }

  (0, _createClass2.default)(Bool, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.Bool;
    }
  }, {
    key: Symbol.toStringTag,
    get: function get() {
      return 'Bool';
    }
  }, {
    key: "toString",
    value: function toString() {
      return 'Bool';
    }
  }]);
  return Bool;
}(DataType);

exports.Bool = Bool;
_Symbol$toStringTag = Symbol.toStringTag;

var Int = function (_DataType3) {
  (0, _inherits2.default)(Int, _DataType3);

  var _super3 = _createSuper(Int);

  function Int(isSigned, bitWidth) {
    var _this;

    (0, _classCallCheck2.default)(this, Int);
    _this = _super3.call(this);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "isSigned", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "bitWidth", void 0);
    _this.isSigned = isSigned;
    _this.bitWidth = bitWidth;
    return _this;
  }

  (0, _createClass2.default)(Int, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.Int;
    }
  }, {
    key: _Symbol$toStringTag,
    get: function get() {
      return 'Int';
    }
  }, {
    key: "toString",
    value: function toString() {
      return "".concat(this.isSigned ? 'I' : 'Ui', "nt").concat(this.bitWidth);
    }
  }]);
  return Int;
}(DataType);

exports.Int = Int;

var Int8 = function (_Int) {
  (0, _inherits2.default)(Int8, _Int);

  var _super4 = _createSuper(Int8);

  function Int8() {
    (0, _classCallCheck2.default)(this, Int8);
    return _super4.call(this, true, 8);
  }

  return Int8;
}(Int);

exports.Int8 = Int8;

var Int16 = function (_Int2) {
  (0, _inherits2.default)(Int16, _Int2);

  var _super5 = _createSuper(Int16);

  function Int16() {
    (0, _classCallCheck2.default)(this, Int16);
    return _super5.call(this, true, 16);
  }

  return Int16;
}(Int);

exports.Int16 = Int16;

var Int32 = function (_Int3) {
  (0, _inherits2.default)(Int32, _Int3);

  var _super6 = _createSuper(Int32);

  function Int32() {
    (0, _classCallCheck2.default)(this, Int32);
    return _super6.call(this, true, 32);
  }

  return Int32;
}(Int);

exports.Int32 = Int32;

var Int64 = function (_Int4) {
  (0, _inherits2.default)(Int64, _Int4);

  var _super7 = _createSuper(Int64);

  function Int64() {
    (0, _classCallCheck2.default)(this, Int64);
    return _super7.call(this, true, 64);
  }

  return Int64;
}(Int);

exports.Int64 = Int64;

var Uint8 = function (_Int5) {
  (0, _inherits2.default)(Uint8, _Int5);

  var _super8 = _createSuper(Uint8);

  function Uint8() {
    (0, _classCallCheck2.default)(this, Uint8);
    return _super8.call(this, false, 8);
  }

  return Uint8;
}(Int);

exports.Uint8 = Uint8;

var Uint16 = function (_Int6) {
  (0, _inherits2.default)(Uint16, _Int6);

  var _super9 = _createSuper(Uint16);

  function Uint16() {
    (0, _classCallCheck2.default)(this, Uint16);
    return _super9.call(this, false, 16);
  }

  return Uint16;
}(Int);

exports.Uint16 = Uint16;

var Uint32 = function (_Int7) {
  (0, _inherits2.default)(Uint32, _Int7);

  var _super10 = _createSuper(Uint32);

  function Uint32() {
    (0, _classCallCheck2.default)(this, Uint32);
    return _super10.call(this, false, 32);
  }

  return Uint32;
}(Int);

exports.Uint32 = Uint32;

var Uint64 = function (_Int8) {
  (0, _inherits2.default)(Uint64, _Int8);

  var _super11 = _createSuper(Uint64);

  function Uint64() {
    (0, _classCallCheck2.default)(this, Uint64);
    return _super11.call(this, false, 64);
  }

  return Uint64;
}(Int);

exports.Uint64 = Uint64;
var Precision = {
  HALF: 16,
  SINGLE: 32,
  DOUBLE: 64
};
_Symbol$toStringTag2 = Symbol.toStringTag;

var Float = function (_DataType4) {
  (0, _inherits2.default)(Float, _DataType4);

  var _super12 = _createSuper(Float);

  function Float(precision) {
    var _this2;

    (0, _classCallCheck2.default)(this, Float);
    _this2 = _super12.call(this);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this2), "precision", void 0);
    _this2.precision = precision;
    return _this2;
  }

  (0, _createClass2.default)(Float, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.Float;
    }
  }, {
    key: _Symbol$toStringTag2,
    get: function get() {
      return 'Float';
    }
  }, {
    key: "toString",
    value: function toString() {
      return "Float".concat(this.precision);
    }
  }]);
  return Float;
}(DataType);

exports.Float = Float;

var Float16 = function (_Float) {
  (0, _inherits2.default)(Float16, _Float);

  var _super13 = _createSuper(Float16);

  function Float16() {
    (0, _classCallCheck2.default)(this, Float16);
    return _super13.call(this, Precision.HALF);
  }

  return Float16;
}(Float);

exports.Float16 = Float16;

var Float32 = function (_Float2) {
  (0, _inherits2.default)(Float32, _Float2);

  var _super14 = _createSuper(Float32);

  function Float32() {
    (0, _classCallCheck2.default)(this, Float32);
    return _super14.call(this, Precision.SINGLE);
  }

  return Float32;
}(Float);

exports.Float32 = Float32;

var Float64 = function (_Float3) {
  (0, _inherits2.default)(Float64, _Float3);

  var _super15 = _createSuper(Float64);

  function Float64() {
    (0, _classCallCheck2.default)(this, Float64);
    return _super15.call(this, Precision.DOUBLE);
  }

  return Float64;
}(Float);

exports.Float64 = Float64;

var Binary = function (_DataType5) {
  (0, _inherits2.default)(Binary, _DataType5);

  var _super16 = _createSuper(Binary);

  function Binary() {
    (0, _classCallCheck2.default)(this, Binary);
    return _super16.call(this);
  }

  (0, _createClass2.default)(Binary, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.Binary;
    }
  }, {
    key: "toString",
    value: function toString() {
      return 'Binary';
    }
  }, {
    key: Symbol.toStringTag,
    get: function get() {
      return 'Binary';
    }
  }]);
  return Binary;
}(DataType);

exports.Binary = Binary;

var Utf8 = function (_DataType6) {
  (0, _inherits2.default)(Utf8, _DataType6);

  var _super17 = _createSuper(Utf8);

  function Utf8() {
    (0, _classCallCheck2.default)(this, Utf8);
    return _super17.apply(this, arguments);
  }

  (0, _createClass2.default)(Utf8, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.Utf8;
    }
  }, {
    key: Symbol.toStringTag,
    get: function get() {
      return 'Utf8';
    }
  }, {
    key: "toString",
    value: function toString() {
      return 'Utf8';
    }
  }]);
  return Utf8;
}(DataType);

exports.Utf8 = Utf8;
var DateUnit = {
  DAY: 0,
  MILLISECOND: 1
};
_Symbol$toStringTag3 = Symbol.toStringTag;

var Date = function (_DataType7) {
  (0, _inherits2.default)(Date, _DataType7);

  var _super18 = _createSuper(Date);

  function Date(unit) {
    var _this3;

    (0, _classCallCheck2.default)(this, Date);
    _this3 = _super18.call(this);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this3), "unit", void 0);
    _this3.unit = unit;
    return _this3;
  }

  (0, _createClass2.default)(Date, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.Date;
    }
  }, {
    key: _Symbol$toStringTag3,
    get: function get() {
      return 'Date';
    }
  }, {
    key: "toString",
    value: function toString() {
      return "Date".concat((this.unit + 1) * 32, "<").concat(DateUnit[this.unit], ">");
    }
  }]);
  return Date;
}(DataType);

exports.Date = Date;

var DateDay = function (_Date) {
  (0, _inherits2.default)(DateDay, _Date);

  var _super19 = _createSuper(DateDay);

  function DateDay() {
    (0, _classCallCheck2.default)(this, DateDay);
    return _super19.call(this, DateUnit.DAY);
  }

  return DateDay;
}(Date);

exports.DateDay = DateDay;

var DateMillisecond = function (_Date2) {
  (0, _inherits2.default)(DateMillisecond, _Date2);

  var _super20 = _createSuper(DateMillisecond);

  function DateMillisecond() {
    (0, _classCallCheck2.default)(this, DateMillisecond);
    return _super20.call(this, DateUnit.MILLISECOND);
  }

  return DateMillisecond;
}(Date);

exports.DateMillisecond = DateMillisecond;
var TimeUnit = {
  SECOND: 1,
  MILLISECOND: 1e3,
  MICROSECOND: 1e6,
  NANOSECOND: 1e9
};
_Symbol$toStringTag4 = Symbol.toStringTag;

var Time = function (_DataType8) {
  (0, _inherits2.default)(Time, _DataType8);

  var _super21 = _createSuper(Time);

  function Time(unit, bitWidth) {
    var _this4;

    (0, _classCallCheck2.default)(this, Time);
    _this4 = _super21.call(this);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this4), "unit", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this4), "bitWidth", void 0);
    _this4.unit = unit;
    _this4.bitWidth = bitWidth;
    return _this4;
  }

  (0, _createClass2.default)(Time, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.Time;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "Time".concat(this.bitWidth, "<").concat(TimeUnit[this.unit], ">");
    }
  }, {
    key: _Symbol$toStringTag4,
    get: function get() {
      return 'Time';
    }
  }]);
  return Time;
}(DataType);

exports.Time = Time;

var TimeSecond = function (_Time) {
  (0, _inherits2.default)(TimeSecond, _Time);

  var _super22 = _createSuper(TimeSecond);

  function TimeSecond() {
    (0, _classCallCheck2.default)(this, TimeSecond);
    return _super22.call(this, TimeUnit.SECOND, 32);
  }

  return TimeSecond;
}(Time);

exports.TimeSecond = TimeSecond;

var TimeMillisecond = function (_Time2) {
  (0, _inherits2.default)(TimeMillisecond, _Time2);

  var _super23 = _createSuper(TimeMillisecond);

  function TimeMillisecond() {
    (0, _classCallCheck2.default)(this, TimeMillisecond);
    return _super23.call(this, TimeUnit.MILLISECOND, 32);
  }

  return TimeMillisecond;
}(Time);

exports.TimeMillisecond = TimeMillisecond;
_Symbol$toStringTag5 = Symbol.toStringTag;

var Timestamp = function (_DataType9) {
  (0, _inherits2.default)(Timestamp, _DataType9);

  var _super24 = _createSuper(Timestamp);

  function Timestamp(unit) {
    var _this5;

    var timezone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    (0, _classCallCheck2.default)(this, Timestamp);
    _this5 = _super24.call(this);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this5), "unit", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this5), "timezone", void 0);
    _this5.unit = unit;
    _this5.timezone = timezone;
    return _this5;
  }

  (0, _createClass2.default)(Timestamp, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.Timestamp;
    }
  }, {
    key: _Symbol$toStringTag5,
    get: function get() {
      return 'Timestamp';
    }
  }, {
    key: "toString",
    value: function toString() {
      return "Timestamp<".concat(TimeUnit[this.unit]).concat(this.timezone ? ", ".concat(this.timezone) : '', ">");
    }
  }]);
  return Timestamp;
}(DataType);

exports.Timestamp = Timestamp;

var TimestampSecond = function (_Timestamp) {
  (0, _inherits2.default)(TimestampSecond, _Timestamp);

  var _super25 = _createSuper(TimestampSecond);

  function TimestampSecond() {
    var timezone = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    (0, _classCallCheck2.default)(this, TimestampSecond);
    return _super25.call(this, TimeUnit.SECOND, timezone);
  }

  return TimestampSecond;
}(Timestamp);

exports.TimestampSecond = TimestampSecond;

var TimestampMillisecond = function (_Timestamp2) {
  (0, _inherits2.default)(TimestampMillisecond, _Timestamp2);

  var _super26 = _createSuper(TimestampMillisecond);

  function TimestampMillisecond() {
    var timezone = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    (0, _classCallCheck2.default)(this, TimestampMillisecond);
    return _super26.call(this, TimeUnit.MILLISECOND, timezone);
  }

  return TimestampMillisecond;
}(Timestamp);

exports.TimestampMillisecond = TimestampMillisecond;

var TimestampMicrosecond = function (_Timestamp3) {
  (0, _inherits2.default)(TimestampMicrosecond, _Timestamp3);

  var _super27 = _createSuper(TimestampMicrosecond);

  function TimestampMicrosecond() {
    var timezone = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    (0, _classCallCheck2.default)(this, TimestampMicrosecond);
    return _super27.call(this, TimeUnit.MICROSECOND, timezone);
  }

  return TimestampMicrosecond;
}(Timestamp);

exports.TimestampMicrosecond = TimestampMicrosecond;

var TimestampNanosecond = function (_Timestamp4) {
  (0, _inherits2.default)(TimestampNanosecond, _Timestamp4);

  var _super28 = _createSuper(TimestampNanosecond);

  function TimestampNanosecond() {
    var timezone = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    (0, _classCallCheck2.default)(this, TimestampNanosecond);
    return _super28.call(this, TimeUnit.NANOSECOND, timezone);
  }

  return TimestampNanosecond;
}(Timestamp);

exports.TimestampNanosecond = TimestampNanosecond;
var IntervalUnit = {
  DAY_TIME: 0,
  YEAR_MONTH: 1
};
_Symbol$toStringTag6 = Symbol.toStringTag;

var Interval = function (_DataType10) {
  (0, _inherits2.default)(Interval, _DataType10);

  var _super29 = _createSuper(Interval);

  function Interval(unit) {
    var _this6;

    (0, _classCallCheck2.default)(this, Interval);
    _this6 = _super29.call(this);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this6), "unit", void 0);
    _this6.unit = unit;
    return _this6;
  }

  (0, _createClass2.default)(Interval, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.Interval;
    }
  }, {
    key: _Symbol$toStringTag6,
    get: function get() {
      return 'Interval';
    }
  }, {
    key: "toString",
    value: function toString() {
      return "Interval<".concat(IntervalUnit[this.unit], ">");
    }
  }]);
  return Interval;
}(DataType);

exports.Interval = Interval;

var IntervalDayTime = function (_Interval) {
  (0, _inherits2.default)(IntervalDayTime, _Interval);

  var _super30 = _createSuper(IntervalDayTime);

  function IntervalDayTime() {
    (0, _classCallCheck2.default)(this, IntervalDayTime);
    return _super30.call(this, IntervalUnit.DAY_TIME);
  }

  return IntervalDayTime;
}(Interval);

exports.IntervalDayTime = IntervalDayTime;

var IntervalYearMonth = function (_Interval2) {
  (0, _inherits2.default)(IntervalYearMonth, _Interval2);

  var _super31 = _createSuper(IntervalYearMonth);

  function IntervalYearMonth() {
    (0, _classCallCheck2.default)(this, IntervalYearMonth);
    return _super31.call(this, IntervalUnit.YEAR_MONTH);
  }

  return IntervalYearMonth;
}(Interval);

exports.IntervalYearMonth = IntervalYearMonth;
_Symbol$toStringTag7 = Symbol.toStringTag;

var FixedSizeList = function (_DataType11) {
  (0, _inherits2.default)(FixedSizeList, _DataType11);

  var _super32 = _createSuper(FixedSizeList);

  function FixedSizeList(listSize, child) {
    var _this7;

    (0, _classCallCheck2.default)(this, FixedSizeList);
    _this7 = _super32.call(this);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this7), "listSize", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this7), "children", void 0);
    _this7.listSize = listSize;
    _this7.children = [child];
    return _this7;
  }

  (0, _createClass2.default)(FixedSizeList, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.FixedSizeList;
    }
  }, {
    key: "valueType",
    get: function get() {
      return this.children[0].type;
    }
  }, {
    key: "valueField",
    get: function get() {
      return this.children[0];
    }
  }, {
    key: _Symbol$toStringTag7,
    get: function get() {
      return 'FixedSizeList';
    }
  }, {
    key: "toString",
    value: function toString() {
      return "FixedSizeList[".concat(this.listSize, "]<").concat(this.valueType, ">");
    }
  }]);
  return FixedSizeList;
}(DataType);

exports.FixedSizeList = FixedSizeList;

},{"./enum":96,"@babel/runtime/helpers/assertThisInitialized":7,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/getPrototypeOf":16,"@babel/runtime/helpers/inherits":17,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/possibleConstructorReturn":25}],100:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Schema", {
  enumerable: true,
  get: function get() {
    return _schema.default;
  }
});
Object.defineProperty(exports, "Field", {
  enumerable: true,
  get: function get() {
    return _field.default;
  }
});
Object.defineProperty(exports, "Type", {
  enumerable: true,
  get: function get() {
    return _type.Type;
  }
});
Object.defineProperty(exports, "DataType", {
  enumerable: true,
  get: function get() {
    return _type.DataType;
  }
});
Object.defineProperty(exports, "Null", {
  enumerable: true,
  get: function get() {
    return _type.Null;
  }
});
Object.defineProperty(exports, "Bool", {
  enumerable: true,
  get: function get() {
    return _type.Bool;
  }
});
Object.defineProperty(exports, "Int", {
  enumerable: true,
  get: function get() {
    return _type.Int;
  }
});
Object.defineProperty(exports, "Int8", {
  enumerable: true,
  get: function get() {
    return _type.Int8;
  }
});
Object.defineProperty(exports, "Int16", {
  enumerable: true,
  get: function get() {
    return _type.Int16;
  }
});
Object.defineProperty(exports, "Int32", {
  enumerable: true,
  get: function get() {
    return _type.Int32;
  }
});
Object.defineProperty(exports, "Int64", {
  enumerable: true,
  get: function get() {
    return _type.Int64;
  }
});
Object.defineProperty(exports, "Uint8", {
  enumerable: true,
  get: function get() {
    return _type.Uint8;
  }
});
Object.defineProperty(exports, "Uint16", {
  enumerable: true,
  get: function get() {
    return _type.Uint16;
  }
});
Object.defineProperty(exports, "Uint32", {
  enumerable: true,
  get: function get() {
    return _type.Uint32;
  }
});
Object.defineProperty(exports, "Uint64", {
  enumerable: true,
  get: function get() {
    return _type.Uint64;
  }
});
Object.defineProperty(exports, "Float", {
  enumerable: true,
  get: function get() {
    return _type.Float;
  }
});
Object.defineProperty(exports, "Float16", {
  enumerable: true,
  get: function get() {
    return _type.Float16;
  }
});
Object.defineProperty(exports, "Float32", {
  enumerable: true,
  get: function get() {
    return _type.Float32;
  }
});
Object.defineProperty(exports, "Float64", {
  enumerable: true,
  get: function get() {
    return _type.Float64;
  }
});
Object.defineProperty(exports, "Binary", {
  enumerable: true,
  get: function get() {
    return _type.Binary;
  }
});
Object.defineProperty(exports, "Utf8", {
  enumerable: true,
  get: function get() {
    return _type.Utf8;
  }
});
Object.defineProperty(exports, "Date", {
  enumerable: true,
  get: function get() {
    return _type.Date;
  }
});
Object.defineProperty(exports, "DateDay", {
  enumerable: true,
  get: function get() {
    return _type.DateDay;
  }
});
Object.defineProperty(exports, "DateMillisecond", {
  enumerable: true,
  get: function get() {
    return _type.DateMillisecond;
  }
});
Object.defineProperty(exports, "Time", {
  enumerable: true,
  get: function get() {
    return _type.Time;
  }
});
Object.defineProperty(exports, "TimeSecond", {
  enumerable: true,
  get: function get() {
    return _type.TimeSecond;
  }
});
Object.defineProperty(exports, "TimeMillisecond", {
  enumerable: true,
  get: function get() {
    return _type.TimeMillisecond;
  }
});
Object.defineProperty(exports, "Timestamp", {
  enumerable: true,
  get: function get() {
    return _type.Timestamp;
  }
});
Object.defineProperty(exports, "TimestampSecond", {
  enumerable: true,
  get: function get() {
    return _type.TimestampSecond;
  }
});
Object.defineProperty(exports, "TimestampMillisecond", {
  enumerable: true,
  get: function get() {
    return _type.TimestampMillisecond;
  }
});
Object.defineProperty(exports, "TimestampMicrosecond", {
  enumerable: true,
  get: function get() {
    return _type.TimestampMicrosecond;
  }
});
Object.defineProperty(exports, "TimestampNanosecond", {
  enumerable: true,
  get: function get() {
    return _type.TimestampNanosecond;
  }
});
Object.defineProperty(exports, "Interval", {
  enumerable: true,
  get: function get() {
    return _type.Interval;
  }
});
Object.defineProperty(exports, "IntervalDayTime", {
  enumerable: true,
  get: function get() {
    return _type.IntervalDayTime;
  }
});
Object.defineProperty(exports, "IntervalYearMonth", {
  enumerable: true,
  get: function get() {
    return _type.IntervalYearMonth;
  }
});
Object.defineProperty(exports, "FixedSizeList", {
  enumerable: true,
  get: function get() {
    return _type.FixedSizeList;
  }
});

var _schema = _interopRequireDefault(require("./impl/schema"));

var _field = _interopRequireDefault(require("./impl/field"));

var _type = require("./impl/type");

},{"./impl/field":97,"./impl/schema":98,"./impl/type":99,"@babel/runtime/helpers/interopRequireDefault":18}],101:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var DEFAULT_ROW_COUNT = 100;

var RowTableBatchAggregator = function () {
  function RowTableBatchAggregator(schema, options) {
    (0, _classCallCheck2.default)(this, RowTableBatchAggregator);
    (0, _defineProperty2.default)(this, "schema", void 0);
    (0, _defineProperty2.default)(this, "options", void 0);
    (0, _defineProperty2.default)(this, "length", 0);
    (0, _defineProperty2.default)(this, "rows", null);
    (0, _defineProperty2.default)(this, "cursor", 0);
    (0, _defineProperty2.default)(this, "_headers", []);
    this.options = options;
    this.schema = schema;

    if (!Array.isArray(schema)) {
      this._headers = [];

      for (var key in schema) {
        this._headers[schema[key].index] = schema[key].name;
      }
    }
  }

  (0, _createClass2.default)(RowTableBatchAggregator, [{
    key: "rowCount",
    value: function rowCount() {
      return this.length;
    }
  }, {
    key: "addArrayRow",
    value: function addArrayRow(row, cursor) {
      if (Number.isFinite(cursor)) {
        this.cursor = cursor;
      }

      this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);
      this.rows[this.length] = row;
      this.length++;
    }
  }, {
    key: "addObjectRow",
    value: function addObjectRow(row, cursor) {
      if (Number.isFinite(cursor)) {
        this.cursor = cursor;
      }

      this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);
      this.rows[this.length] = row;
      this.length++;
    }
  }, {
    key: "getBatch",
    value: function getBatch() {
      var rows = this.rows;

      if (!rows) {
        return null;
      }

      rows = rows.slice(0, this.length);
      this.rows = null;
      var batch = {
        shape: this.options.shape,
        batchType: 'data',
        data: rows,
        length: this.length,
        schema: this.schema,
        cursor: this.cursor
      };
      return batch;
    }
  }]);
  return RowTableBatchAggregator;
}();

exports.default = RowTableBatchAggregator;

},{"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18}],102:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var DEFAULT_ROW_COUNT = 100;

var ColumnarTableBatchAggregator = function () {
  function ColumnarTableBatchAggregator(schema, options) {
    (0, _classCallCheck2.default)(this, ColumnarTableBatchAggregator);
    (0, _defineProperty2.default)(this, "schema", void 0);
    (0, _defineProperty2.default)(this, "length", 0);
    (0, _defineProperty2.default)(this, "allocated", 0);
    (0, _defineProperty2.default)(this, "columns", {});
    this.schema = schema;

    this._reallocateColumns();
  }

  (0, _createClass2.default)(ColumnarTableBatchAggregator, [{
    key: "rowCount",
    value: function rowCount() {
      return this.length;
    }
  }, {
    key: "addArrayRow",
    value: function addArrayRow(row) {
      this._reallocateColumns();

      var i = 0;

      for (var fieldName in this.columns) {
        this.columns[fieldName][this.length] = row[i++];
      }

      this.length++;
    }
  }, {
    key: "addObjectRow",
    value: function addObjectRow(row) {
      this._reallocateColumns();

      for (var fieldName in row) {
        this.columns[fieldName][this.length] = row[fieldName];
      }

      this.length++;
    }
  }, {
    key: "getBatch",
    value: function getBatch() {
      this._pruneColumns();

      var columns = Array.isArray(this.schema) ? this.columns : {};

      if (!Array.isArray(this.schema)) {
        for (var fieldName in this.schema) {
          var field = this.schema[fieldName];
          columns[field.name] = this.columns[field.index];
        }
      }

      this.columns = {};
      var batch = {
        shape: 'columnar-table',
        batchType: 'data',
        data: columns,
        schema: this.schema,
        length: this.length
      };
      return batch;
    }
  }, {
    key: "_reallocateColumns",
    value: function _reallocateColumns() {
      if (this.length < this.allocated) {
        return;
      }

      this.allocated = this.allocated > 0 ? this.allocated *= 2 : DEFAULT_ROW_COUNT;
      this.columns = {};

      for (var fieldName in this.schema) {
        var field = this.schema[fieldName];
        var ArrayType = field.type || Float32Array;
        var oldColumn = this.columns[field.index];

        if (oldColumn && ArrayBuffer.isView(oldColumn)) {
          var typedArray = new ArrayType(this.allocated);
          typedArray.set(oldColumn);
          this.columns[field.index] = typedArray;
        } else if (oldColumn) {
          oldColumn.length = this.allocated;
          this.columns[field.index] = oldColumn;
        } else {
          this.columns[field.index] = new ArrayType(this.allocated);
        }
      }
    }
  }, {
    key: "_pruneColumns",
    value: function _pruneColumns() {
      for (var _i = 0, _Object$entries = Object.entries(this.columns); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = (0, _slicedToArray2.default)(_Object$entries[_i], 2),
            _columnName = _Object$entries$_i[0],
            column = _Object$entries$_i[1];

        this.columns[_columnName] = column.slice(0, this.length);
      }
    }
  }]);
  return ColumnarTableBatchAggregator;
}();

exports.default = ColumnarTableBatchAggregator;

},{"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/slicedToArray":27}],103:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _rowUtils = require("../utils/row-utils");

var DEFAULT_ROW_COUNT = 100;

var RowTableBatchAggregator = function () {
  function RowTableBatchAggregator(schema, options) {
    (0, _classCallCheck2.default)(this, RowTableBatchAggregator);
    (0, _defineProperty2.default)(this, "schema", void 0);
    (0, _defineProperty2.default)(this, "options", void 0);
    (0, _defineProperty2.default)(this, "length", 0);
    (0, _defineProperty2.default)(this, "objectRows", null);
    (0, _defineProperty2.default)(this, "arrayRows", null);
    (0, _defineProperty2.default)(this, "cursor", 0);
    (0, _defineProperty2.default)(this, "_headers", []);
    this.options = options;
    this.schema = schema;

    if (!Array.isArray(schema)) {
      this._headers = [];

      for (var key in schema) {
        this._headers[schema[key].index] = schema[key].name;
      }
    }
  }

  (0, _createClass2.default)(RowTableBatchAggregator, [{
    key: "rowCount",
    value: function rowCount() {
      return this.length;
    }
  }, {
    key: "addArrayRow",
    value: function addArrayRow(row, cursor) {
      if (Number.isFinite(cursor)) {
        this.cursor = cursor;
      }

      switch (this.options.shape) {
        case 'object-row-table':
          var rowObject = (0, _rowUtils.convertToObjectRow)(row, this._headers);
          this.addObjectRow(rowObject, cursor);
          break;

        case 'array-row-table':
          this.arrayRows = this.arrayRows || new Array(DEFAULT_ROW_COUNT);
          this.arrayRows[this.length] = row;
          this.length++;
          break;
      }
    }
  }, {
    key: "addObjectRow",
    value: function addObjectRow(row, cursor) {
      if (Number.isFinite(cursor)) {
        this.cursor = cursor;
      }

      switch (this.options.shape) {
        case 'array-row-table':
          var rowArray = (0, _rowUtils.convertToArrayRow)(row, this._headers);
          this.addArrayRow(rowArray, cursor);
          break;

        case 'object-row-table':
          this.objectRows = this.objectRows || new Array(DEFAULT_ROW_COUNT);
          this.objectRows[this.length] = row;
          this.length++;
          break;
      }
    }
  }, {
    key: "getBatch",
    value: function getBatch() {
      var rows = this.arrayRows || this.objectRows;

      if (!rows) {
        return null;
      }

      rows = rows.slice(0, this.length);
      this.arrayRows = null;
      this.objectRows = null;
      return {
        shape: this.options.shape,
        batchType: 'data',
        data: rows,
        length: this.length,
        schema: this.schema,
        cursor: this.cursor
      };
    }
  }]);
  return RowTableBatchAggregator;
}();

exports.default = RowTableBatchAggregator;

},{"../utils/row-utils":107,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18}],104:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _baseTableBatchAggregator = _interopRequireDefault(require("./base-table-batch-aggregator"));

var _rowTableBatchAggregator = _interopRequireDefault(require("./row-table-batch-aggregator"));

var _columnarTableBatchAggregator = _interopRequireDefault(require("./columnar-table-batch-aggregator"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var DEFAULT_OPTIONS = {
  shape: 'array-row-table',
  batchSize: 'auto',
  batchDebounceMs: 0,
  limit: 0,
  _limitMB: 0
};
var ERR_MESSAGE = 'TableBatchBuilder';

var TableBatchBuilder = function () {
  function TableBatchBuilder(schema, options) {
    (0, _classCallCheck2.default)(this, TableBatchBuilder);
    (0, _defineProperty2.default)(this, "schema", void 0);
    (0, _defineProperty2.default)(this, "options", void 0);
    (0, _defineProperty2.default)(this, "aggregator", null);
    (0, _defineProperty2.default)(this, "batchCount", 0);
    (0, _defineProperty2.default)(this, "bytesUsed", 0);
    (0, _defineProperty2.default)(this, "isChunkComplete", false);
    (0, _defineProperty2.default)(this, "lastBatchEmittedMs", Date.now());
    (0, _defineProperty2.default)(this, "totalLength", 0);
    (0, _defineProperty2.default)(this, "totalBytes", 0);
    (0, _defineProperty2.default)(this, "rowBytes", 0);
    this.schema = schema;
    this.options = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS), options);
  }

  (0, _createClass2.default)(TableBatchBuilder, [{
    key: "limitReached",
    value: function limitReached() {
      var _this$options, _this$options2;

      if (Boolean((_this$options = this.options) === null || _this$options === void 0 ? void 0 : _this$options.limit) && this.totalLength >= this.options.limit) {
        return true;
      }

      if (Boolean((_this$options2 = this.options) === null || _this$options2 === void 0 ? void 0 : _this$options2._limitMB) && this.totalBytes / 1e6 >= this.options._limitMB) {
        return true;
      }

      return false;
    }
  }, {
    key: "addRow",
    value: function addRow(row) {
      if (this.limitReached()) {
        return;
      }

      this.totalLength++;
      this.rowBytes = this.rowBytes || this._estimateRowMB(row);
      this.totalBytes += this.rowBytes;

      if (Array.isArray(row)) {
        this.addArrayRow(row);
      } else {
        this.addObjectRow(row);
      }
    }
  }, {
    key: "addArrayRow",
    value: function addArrayRow(row) {
      if (!this.aggregator) {
        var TableBatchType = this._getTableBatchType();

        this.aggregator = new TableBatchType(this.schema, this.options);
      }

      this.aggregator.addArrayRow(row);
    }
  }, {
    key: "addObjectRow",
    value: function addObjectRow(row) {
      if (!this.aggregator) {
        var TableBatchType = this._getTableBatchType();

        this.aggregator = new TableBatchType(this.schema, this.options);
      }

      this.aggregator.addObjectRow(row);
    }
  }, {
    key: "chunkComplete",
    value: function chunkComplete(chunk) {
      if (chunk instanceof ArrayBuffer) {
        this.bytesUsed += chunk.byteLength;
      }

      if (typeof chunk === 'string') {
        this.bytesUsed += chunk.length;
      }

      this.isChunkComplete = true;
    }
  }, {
    key: "getFullBatch",
    value: function getFullBatch(options) {
      return this._isFull() ? this._getBatch(options) : null;
    }
  }, {
    key: "getFinalBatch",
    value: function getFinalBatch(options) {
      return this._getBatch(options);
    }
  }, {
    key: "_estimateRowMB",
    value: function _estimateRowMB(row) {
      return Array.isArray(row) ? row.length * 8 : Object.keys(row).length * 8;
    }
  }, {
    key: "_isFull",
    value: function _isFull() {
      if (!this.aggregator || this.aggregator.rowCount() === 0) {
        return false;
      }

      if (this.options.batchSize === 'auto') {
        if (!this.isChunkComplete) {
          return false;
        }
      } else if (this.options.batchSize > this.aggregator.rowCount()) {
        return false;
      }

      if (this.options.batchDebounceMs > Date.now() - this.lastBatchEmittedMs) {
        return false;
      }

      this.isChunkComplete = false;
      this.lastBatchEmittedMs = Date.now();
      return true;
    }
  }, {
    key: "_getBatch",
    value: function _getBatch(options) {
      if (!this.aggregator) {
        return null;
      }

      if (options !== null && options !== void 0 && options.bytesUsed) {
        this.bytesUsed = options.bytesUsed;
      }

      var normalizedBatch = this.aggregator.getBatch();
      normalizedBatch.count = this.batchCount;
      normalizedBatch.bytesUsed = this.bytesUsed;
      Object.assign(normalizedBatch, options);
      this.batchCount++;
      this.aggregator = null;
      return normalizedBatch;
    }
  }, {
    key: "_getTableBatchType",
    value: function _getTableBatchType() {
      switch (this.options.shape) {
        case 'row-table':
          return _baseTableBatchAggregator.default;

        case 'array-row-table':
        case 'object-row-table':
          return _rowTableBatchAggregator.default;

        case 'columnar-table':
          return _columnarTableBatchAggregator.default;

        case 'arrow-table':
          if (!TableBatchBuilder.ArrowBatch) {
            throw new Error(ERR_MESSAGE);
          }

          return TableBatchBuilder.ArrowBatch;

        default:
          throw new Error(ERR_MESSAGE);
      }
    }
  }]);
  return TableBatchBuilder;
}();

exports.default = TableBatchBuilder;
(0, _defineProperty2.default)(TableBatchBuilder, "ArrowBatch", void 0);

},{"./base-table-batch-aggregator":101,"./columnar-table-batch-aggregator":102,"./row-table-batch-aggregator":103,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18}],105:[function(require,module,exports){
arguments[4][81][0].apply(exports,arguments)
},{"dup":81}],106:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.takeAsync = takeAsync;
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));

var _Symbol$asyncIterator;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var ArrayQueue = function (_Array) {
  (0, _inherits2.default)(ArrayQueue, _Array);

  var _super = _createSuper(ArrayQueue);

  function ArrayQueue() {
    (0, _classCallCheck2.default)(this, ArrayQueue);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(ArrayQueue, [{
    key: "enqueue",
    value: function enqueue(value) {
      return this.push(value);
    }
  }, {
    key: "dequeue",
    value: function dequeue() {
      return this.shift();
    }
  }]);
  return ArrayQueue;
}((0, _wrapNativeSuper2.default)(Array));

_Symbol$asyncIterator = Symbol.asyncIterator;

var AsyncQueue = function () {
  function AsyncQueue() {
    (0, _classCallCheck2.default)(this, AsyncQueue);
    (0, _defineProperty2.default)(this, "_values", void 0);
    (0, _defineProperty2.default)(this, "_settlers", void 0);
    (0, _defineProperty2.default)(this, "_closed", void 0);
    this._values = new ArrayQueue();
    this._settlers = new ArrayQueue();
    this._closed = false;
  }

  (0, _createClass2.default)(AsyncQueue, [{
    key: "close",
    value: function close() {
      while (this._settlers.length > 0) {
        this._settlers.dequeue().resolve({
          done: true
        });
      }

      this._closed = true;
    }
  }, {
    key: _Symbol$asyncIterator,
    value: function value() {
      return this;
    }
  }, {
    key: "enqueue",
    value: function enqueue(value) {
      if (this._closed) {
        throw new Error('Closed');
      }

      if (this._settlers.length > 0) {
        if (this._values.length > 0) {
          throw new Error('Illegal internal state');
        }

        var settler = this._settlers.dequeue();

        if (value instanceof Error) {
          settler.reject(value);
        } else {
          settler.resolve({
            value: value
          });
        }
      } else {
        this._values.enqueue(value);
      }
    }
  }, {
    key: "next",
    value: function next() {
      var _this = this;

      if (this._values.length > 0) {
        var value = this._values.dequeue();

        if (value instanceof Error) {
          return Promise.reject(value);
        }

        return Promise.resolve({
          value: value
        });
      }

      if (this._closed) {
        if (this._settlers.length > 0) {
          throw new Error('Illegal internal state');
        }

        return Promise.resolve({
          done: true
        });
      }

      return new Promise(function (resolve, reject) {
        _this._settlers.enqueue({
          resolve: resolve,
          reject: reject
        });
      });
    }
  }]);
  return AsyncQueue;
}();

exports.default = AsyncQueue;

function takeAsync(_x) {
  return _takeAsync.apply(this, arguments);
}

function _takeAsync() {
  _takeAsync = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(asyncIterable) {
    var count,
        result,
        iterator,
        _yield$iterator$next,
        value,
        done,
        _args = arguments;

    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            count = _args.length > 1 && _args[1] !== undefined ? _args[1] : Infinity;
            result = [];
            iterator = asyncIterable[Symbol.asyncIterator]();

          case 3:
            if (!(result.length < count)) {
              _context.next = 14;
              break;
            }

            _context.next = 6;
            return iterator.next();

          case 6:
            _yield$iterator$next = _context.sent;
            value = _yield$iterator$next.value;
            done = _yield$iterator$next.done;

            if (!done) {
              _context.next = 11;
              break;
            }

            return _context.abrupt("break", 14);

          case 11:
            result.push(value);
            _context.next = 3;
            break;

          case 14:
            return _context.abrupt("return", result);

          case 15:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _takeAsync.apply(this, arguments);
}

},{"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/getPrototypeOf":16,"@babel/runtime/helpers/inherits":17,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/possibleConstructorReturn":25,"@babel/runtime/helpers/wrapNativeSuper":32,"@babel/runtime/regenerator":33}],107:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertToObjectRow = convertToObjectRow;
exports.convertToArrayRow = convertToArrayRow;

function convertToObjectRow(arrayRow, headers) {
  if (!arrayRow) {
    throw new Error('null row');
  }

  if (!headers) {
    throw new Error('no headers');
  }

  var objectRow = {};

  for (var i = 0; i < headers.length; i++) {
    objectRow[headers[i]] = arrayRow[i];
  }

  return objectRow;
}

function convertToArrayRow(objectRow, headers) {
  if (!objectRow) {
    throw new Error('null row');
  }

  if (!headers) {
    throw new Error('no headers');
  }

  var arrayRow = new Array(headers.length);

  for (var i = 0; i < headers.length; i++) {
    arrayRow[i] = objectRow[headers[i]];
  }

  return arrayRow;
}

},{}],108:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function get() {
    return _assert.assert;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function get() {
    return _globals.isBrowser;
  }
});
Object.defineProperty(exports, "isWorker", {
  enumerable: true,
  get: function get() {
    return _globals.isWorker;
  }
});
Object.defineProperty(exports, "WorkerJob", {
  enumerable: true,
  get: function get() {
    return _workerJob.default;
  }
});
Object.defineProperty(exports, "WorkerThread", {
  enumerable: true,
  get: function get() {
    return _workerThread.default;
  }
});
Object.defineProperty(exports, "WorkerFarm", {
  enumerable: true,
  get: function get() {
    return _workerFarm.default;
  }
});
Object.defineProperty(exports, "WorkerPool", {
  enumerable: true,
  get: function get() {
    return _workerPool.default;
  }
});
Object.defineProperty(exports, "WorkerBody", {
  enumerable: true,
  get: function get() {
    return _workerBody.default;
  }
});
Object.defineProperty(exports, "processOnWorker", {
  enumerable: true,
  get: function get() {
    return _processOnWorker.processOnWorker;
  }
});
Object.defineProperty(exports, "canProcessOnWorker", {
  enumerable: true,
  get: function get() {
    return _processOnWorker.canProcessOnWorker;
  }
});
Object.defineProperty(exports, "createWorker", {
  enumerable: true,
  get: function get() {
    return _createWorker.createWorker;
  }
});
Object.defineProperty(exports, "getWorkerURL", {
  enumerable: true,
  get: function get() {
    return _getWorkerUrl.getWorkerURL;
  }
});
Object.defineProperty(exports, "validateWorkerVersion", {
  enumerable: true,
  get: function get() {
    return _validateWorkerVersion.validateWorkerVersion;
  }
});
Object.defineProperty(exports, "getTransferList", {
  enumerable: true,
  get: function get() {
    return _getTransferList.getTransferList;
  }
});
Object.defineProperty(exports, "getLibraryUrl", {
  enumerable: true,
  get: function get() {
    return _libraryUtils.getLibraryUrl;
  }
});
Object.defineProperty(exports, "loadLibrary", {
  enumerable: true,
  get: function get() {
    return _libraryUtils.loadLibrary;
  }
});
Object.defineProperty(exports, "AsyncQueue", {
  enumerable: true,
  get: function get() {
    return _asyncQueue.default;
  }
});
Object.defineProperty(exports, "ChildProcessProxy", {
  enumerable: true,
  get: function get() {
    return _childProcessProxy.default;
  }
});
exports.NullWorker = void 0;

var _version = require("./lib/env-utils/version");

var _assert = require("./lib/env-utils/assert");

var _globals = require("./lib/env-utils/globals");

var _workerJob = _interopRequireDefault(require("./lib/worker-farm/worker-job"));

var _workerThread = _interopRequireDefault(require("./lib/worker-farm/worker-thread"));

var _workerFarm = _interopRequireDefault(require("./lib/worker-farm/worker-farm"));

var _workerPool = _interopRequireDefault(require("./lib/worker-farm/worker-pool"));

var _workerBody = _interopRequireDefault(require("./lib/worker-farm/worker-body"));

var _processOnWorker = require("./lib/worker-api/process-on-worker");

var _createWorker = require("./lib/worker-api/create-worker");

var _getWorkerUrl = require("./lib/worker-api/get-worker-url");

var _validateWorkerVersion = require("./lib/worker-api/validate-worker-version");

var _getTransferList = require("./lib/worker-utils/get-transfer-list");

var _libraryUtils = require("./lib/library-utils/library-utils");

var _asyncQueue = _interopRequireDefault(require("./lib/async-queue/async-queue"));

var _childProcessProxy = _interopRequireDefault(require("./lib/process-utils/child-process-proxy"));

var NullWorker = {
  id: 'null',
  name: 'null',
  module: 'worker-utils',
  version: _version.VERSION,
  options: {
    null: {}
  }
};
exports.NullWorker = NullWorker;

},{"./lib/async-queue/async-queue":109,"./lib/env-utils/assert":110,"./lib/env-utils/globals":111,"./lib/env-utils/version":112,"./lib/library-utils/library-utils":113,"./lib/process-utils/child-process-proxy":130,"./lib/worker-api/create-worker":114,"./lib/worker-api/get-worker-url":115,"./lib/worker-api/process-on-worker":116,"./lib/worker-api/validate-worker-version":117,"./lib/worker-farm/worker-body":118,"./lib/worker-farm/worker-farm":119,"./lib/worker-farm/worker-job":120,"./lib/worker-farm/worker-pool":121,"./lib/worker-farm/worker-thread":122,"./lib/worker-utils/get-transfer-list":124,"@babel/runtime/helpers/interopRequireDefault":18}],109:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _Symbol$asyncIterator;

_Symbol$asyncIterator = Symbol.asyncIterator;

var AsyncQueue = function () {
  function AsyncQueue() {
    (0, _classCallCheck2.default)(this, AsyncQueue);
    (0, _defineProperty2.default)(this, "_values", void 0);
    (0, _defineProperty2.default)(this, "_settlers", void 0);
    (0, _defineProperty2.default)(this, "_closed", void 0);
    this._values = [];
    this._settlers = [];
    this._closed = false;
  }

  (0, _createClass2.default)(AsyncQueue, [{
    key: _Symbol$asyncIterator,
    value: function value() {
      return this;
    }
  }, {
    key: "push",
    value: function push(value) {
      return this.enqueue(value);
    }
  }, {
    key: "enqueue",
    value: function enqueue(value) {
      if (this._closed) {
        throw new Error('Closed');
      }

      if (this._settlers.length > 0) {
        if (this._values.length > 0) {
          throw new Error('Illegal internal state');
        }

        var settler = this._settlers.shift();

        if (value instanceof Error) {
          settler.reject(value);
        } else {
          settler.resolve({
            value: value
          });
        }
      } else {
        this._values.push(value);
      }
    }
  }, {
    key: "close",
    value: function close() {
      while (this._settlers.length > 0) {
        var settler = this._settlers.shift();

        settler.resolve({
          done: true
        });
      }

      this._closed = true;
    }
  }, {
    key: "next",
    value: function next() {
      var _this = this;

      if (this._values.length > 0) {
        var value = this._values.shift();

        if (value instanceof Error) {
          return Promise.reject(value);
        }

        return Promise.resolve({
          done: false,
          value: value
        });
      }

      if (this._closed) {
        if (this._settlers.length > 0) {
          throw new Error('Illegal internal state');
        }

        return Promise.resolve({
          done: true,
          value: undefined
        });
      }

      return new Promise(function (resolve, reject) {
        _this._settlers.push({
          resolve: resolve,
          reject: reject
        });
      });
    }
  }]);
  return AsyncQueue;
}();

exports.default = AsyncQueue;

},{"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18}],110:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assert = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'loaders.gl assertion failed.');
  }
}

},{}],111:[function(require,module,exports){
(function (process,global){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nodeVersion = exports.isMobile = exports.isWorker = exports.isBrowser = exports.document = exports.global = exports.window = exports.self = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};
var self_ = globals.self || globals.window || globals.global || {};
exports.self = self_;
var window_ = globals.window || globals.self || globals.global || {};
exports.window = window_;
var global_ = globals.global || globals.self || globals.window || {};
exports.global = global_;
var document_ = globals.document || {};
exports.document = document_;
var isBrowser = (typeof process === "undefined" ? "undefined" : (0, _typeof2.default)(process)) !== 'object' || String(process) !== '[object process]' || process.browser;
exports.isBrowser = isBrowser;
var isWorker = typeof importScripts === 'function';
exports.isWorker = isWorker;
var isMobile = typeof window !== 'undefined' && typeof window.orientation !== 'undefined';
exports.isMobile = isMobile;
var matches = typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);
var nodeVersion = matches && parseFloat(matches[1]) || 0;
exports.nodeVersion = nodeVersion;

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"_process":153}],112:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VERSION = void 0;
var DEFAULT_VERSION = 'beta';
var VERSION = typeof "3.0.9" !== 'undefined' ? "3.0.9" : DEFAULT_VERSION;
exports.VERSION = VERSION;

if (typeof "3.0.9" === 'undefined') {
  console.error('loaders.gl: The __VERSION__ variable is not injected using babel plugin. Latest unstable workers would be fetched from the CDN.');
}

},{}],113:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadLibrary = loadLibrary;
exports.getLibraryUrl = getLibraryUrl;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _globals = require("../env-utils/globals");

var node = _interopRequireWildcard(require("../node/require-utils.node"));

var _assert = require("../env-utils/assert");

var _version = require("../env-utils/version");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var LATEST = 'beta';
var VERSION = typeof "3.0.9" !== 'undefined' ? "3.0.9" : LATEST;
var loadLibraryPromises = {};

function loadLibrary(_x) {
  return _loadLibrary.apply(this, arguments);
}

function _loadLibrary() {
  _loadLibrary = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(libraryUrl) {
    var moduleName,
        options,
        _args = arguments;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            moduleName = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;
            options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};

            if (moduleName) {
              libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);
            }

            loadLibraryPromises[libraryUrl] = loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);
            _context.next = 6;
            return loadLibraryPromises[libraryUrl];

          case 6:
            return _context.abrupt("return", _context.sent);

          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _loadLibrary.apply(this, arguments);
}

function getLibraryUrl(library, moduleName, options) {
  if (library.startsWith('http')) {
    return library;
  }

  var modules = options.modules || {};

  if (modules[library]) {
    return modules[library];
  }

  if (!_globals.isBrowser) {
    return "modules/".concat(moduleName, "/dist/libs/").concat(library);
  }

  if (options.CDN) {
    (0, _assert.assert)(options.CDN.startsWith('http'));
    return "".concat(options.CDN, "/").concat(moduleName, "@").concat(VERSION, "/dist/libs/").concat(library);
  }

  if (_globals.isWorker) {
    return "../src/libs/".concat(library);
  }

  return "modules/".concat(moduleName, "/src/libs/").concat(library);
}

function loadLibraryFromFile(_x2) {
  return _loadLibraryFromFile.apply(this, arguments);
}

function _loadLibraryFromFile() {
  _loadLibraryFromFile = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(libraryUrl) {
    var _response, response, scriptSource;

    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!libraryUrl.endsWith('wasm')) {
              _context2.next = 7;
              break;
            }

            _context2.next = 3;
            return fetch(libraryUrl);

          case 3:
            _response = _context2.sent;
            _context2.next = 6;
            return _response.arrayBuffer();

          case 6:
            return _context2.abrupt("return", _context2.sent);

          case 7:
            if (_globals.isBrowser) {
              _context2.next = 14;
              break;
            }

            _context2.t0 = node.requireFromFile;

            if (!_context2.t0) {
              _context2.next = 13;
              break;
            }

            _context2.next = 12;
            return node.requireFromFile(libraryUrl);

          case 12:
            _context2.t0 = _context2.sent;

          case 13:
            return _context2.abrupt("return", _context2.t0);

          case 14:
            if (!_globals.isWorker) {
              _context2.next = 16;
              break;
            }

            return _context2.abrupt("return", importScripts(libraryUrl));

          case 16:
            _context2.next = 18;
            return fetch(libraryUrl);

          case 18:
            response = _context2.sent;
            _context2.next = 21;
            return response.text();

          case 21:
            scriptSource = _context2.sent;
            return _context2.abrupt("return", loadLibraryFromString(scriptSource, libraryUrl));

          case 23:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _loadLibraryFromFile.apply(this, arguments);
}

function loadLibraryFromString(scriptSource, id) {
  if (!_globals.isBrowser) {
    return node.requireFromString && node.requireFromString(scriptSource, id);
  }

  if (_globals.isWorker) {
    eval.call(_globals.global, scriptSource);
    return null;
  }

  var script = document.createElement('script');
  script.id = id;

  try {
    script.appendChild(document.createTextNode(scriptSource));
  } catch (e) {
    script.text = scriptSource;
  }

  document.body.appendChild(script);
  return null;
}

},{"../env-utils/assert":110,"../env-utils/globals":111,"../env-utils/version":112,"../node/require-utils.node":130,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"@babel/runtime/regenerator":33}],114:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createWorker = createWorker;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

var _asyncQueue = _interopRequireDefault(require("../async-queue/async-queue"));

var _workerBody = _interopRequireDefault(require("../worker-farm/worker-body"));

var requestId = 0;
var inputBatches;
var options;

function createWorker(process, processInBatches) {
  if (typeof self === 'undefined') {
    return;
  }

  var context = {
    process: processOnMainThread
  };

  _workerBody.default.onmessage = function () {
    var _ref = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(type, payload) {
      var result, resultIterator, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, batch, message;

      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.t0 = type;
              _context.next = _context.t0 === 'process' ? 4 : _context.t0 === 'process-in-batches' ? 11 : _context.t0 === 'input-batch' ? 51 : _context.t0 === 'input-done' ? 53 : 55;
              break;

            case 4:
              if (process) {
                _context.next = 6;
                break;
              }

              throw new Error('Worker does not support atomic processing');

            case 6:
              _context.next = 8;
              return process(payload.input, payload.options || {}, context);

            case 8:
              result = _context.sent;

              _workerBody.default.postMessage('done', {
                result: result
              });

              return _context.abrupt("break", 55);

            case 11:
              if (processInBatches) {
                _context.next = 13;
                break;
              }

              throw new Error('Worker does not support batched processing');

            case 13:
              inputBatches = new _asyncQueue.default();
              options = payload.options || {};
              resultIterator = processInBatches(inputBatches, options, context === null || context === void 0 ? void 0 : context.processInBatches);
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _context.prev = 18;
              _iterator = (0, _asyncIterator2.default)(resultIterator);

            case 20:
              _context.next = 22;
              return _iterator.next();

            case 22:
              _step = _context.sent;
              _iteratorNormalCompletion = _step.done;
              _context.next = 26;
              return _step.value;

            case 26:
              _value = _context.sent;

              if (_iteratorNormalCompletion) {
                _context.next = 33;
                break;
              }

              batch = _value;

              _workerBody.default.postMessage('output-batch', {
                result: batch
              });

            case 30:
              _iteratorNormalCompletion = true;
              _context.next = 20;
              break;

            case 33:
              _context.next = 39;
              break;

            case 35:
              _context.prev = 35;
              _context.t1 = _context["catch"](18);
              _didIteratorError = true;
              _iteratorError = _context.t1;

            case 39:
              _context.prev = 39;
              _context.prev = 40;

              if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
                _context.next = 44;
                break;
              }

              _context.next = 44;
              return _iterator.return();

            case 44:
              _context.prev = 44;

              if (!_didIteratorError) {
                _context.next = 47;
                break;
              }

              throw _iteratorError;

            case 47:
              return _context.finish(44);

            case 48:
              return _context.finish(39);

            case 49:
              _workerBody.default.postMessage('done', {});

              return _context.abrupt("break", 55);

            case 51:
              inputBatches.push(payload.input);
              return _context.abrupt("break", 55);

            case 53:
              inputBatches.close();
              return _context.abrupt("break", 55);

            case 55:
              _context.next = 61;
              break;

            case 57:
              _context.prev = 57;
              _context.t2 = _context["catch"](0);
              message = _context.t2 instanceof Error ? _context.t2.message : '';

              _workerBody.default.postMessage('error', {
                error: message
              });

            case 61:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[0, 57], [18, 35, 39, 49], [40,, 44, 48]]);
    }));

    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();
}

function processOnMainThread(arrayBuffer) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return new Promise(function (resolve, reject) {
    var id = requestId++;

    var onMessage = function onMessage(type, payload) {
      if (payload.id !== id) {
        return;
      }

      switch (type) {
        case 'done':
          _workerBody.default.removeEventListener(onMessage);

          resolve(payload.result);
          break;

        case 'error':
          _workerBody.default.removeEventListener(onMessage);

          reject(payload.error);
          break;

        default:
      }
    };

    _workerBody.default.addEventListener(onMessage);

    var payload = {
      id: id,
      input: arrayBuffer,
      options: options
    };

    _workerBody.default.postMessage('process', payload);
  });
}

},{"../async-queue/async-queue":109,"../worker-farm/worker-body":118,"@babel/runtime/helpers/asyncIterator":9,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],115:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getWorkerName = getWorkerName;
exports.getWorkerURL = getWorkerURL;

var _assert = require("../env-utils/assert");

var _version = require("../env-utils/version");

var NPM_TAG = 'latest';
var VERSION = typeof "3.0.9" !== 'undefined' ? "3.0.9" : NPM_TAG;

function getWorkerName(worker) {
  var warning = worker.version !== VERSION ? " (worker-utils@".concat(VERSION, ")") : '';
  return "".concat(worker.name, "@").concat(worker.version).concat(warning);
}

function getWorkerURL(worker) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var workerOptions = options[worker.id] || {};
  var workerFile = "".concat(worker.id, "-worker.js");
  var url = workerOptions.workerUrl;

  if (options._workerType === 'test') {
    url = "modules/".concat(worker.module, "/dist/").concat(workerFile);
  }

  if (!url) {
    var version = worker.version;

    if (version === 'latest') {
      version = NPM_TAG;
    }

    var versionTag = version ? "@".concat(version) : '';
    url = "https://unpkg.com/@loaders.gl/".concat(worker.module).concat(versionTag, "/dist/").concat(workerFile);
  }

  (0, _assert.assert)(url);
  return url;
}

},{"../env-utils/assert":110,"../env-utils/version":112}],116:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.canProcessOnWorker = canProcessOnWorker;
exports.processOnWorker = processOnWorker;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _workerFarm = _interopRequireDefault(require("../worker-farm/worker-farm"));

var _removeNontransferableOptions = require("../worker-utils/remove-nontransferable-options");

var _getWorkerUrl = require("./get-worker-url");

function canProcessOnWorker(worker, options) {
  if (!_workerFarm.default.isSupported()) {
    return false;
  }

  return worker.worker && (options === null || options === void 0 ? void 0 : options.worker);
}

function processOnWorker(_x, _x2) {
  return _processOnWorker.apply(this, arguments);
}

function _processOnWorker() {
  _processOnWorker = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(worker, data) {
    var options,
        context,
        name,
        url,
        workerFarm,
        workerPool,
        jobName,
        job,
        transferableOptions,
        result,
        _args = arguments;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
            context = _args.length > 3 && _args[3] !== undefined ? _args[3] : {};
            name = (0, _getWorkerUrl.getWorkerName)(worker);
            url = (0, _getWorkerUrl.getWorkerURL)(worker, options);
            workerFarm = _workerFarm.default.getWorkerFarm(options);
            workerPool = workerFarm.getWorkerPool({
              name: name,
              url: url
            });
            jobName = options.jobName || worker.name;
            _context.next = 9;
            return workerPool.startJob(jobName, onMessage.bind(null, context));

          case 9:
            job = _context.sent;
            transferableOptions = (0, _removeNontransferableOptions.removeNontransferableOptions)(options);
            job.postMessage('process', {
              input: data,
              options: transferableOptions
            });
            _context.next = 14;
            return job.result;

          case 14:
            result = _context.sent;
            return _context.abrupt("return", result.result);

          case 16:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _processOnWorker.apply(this, arguments);
}

function onMessage(_x3, _x4, _x5, _x6) {
  return _onMessage.apply(this, arguments);
}

function _onMessage() {
  _onMessage = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(context, job, type, payload) {
    var id, input, options, result, message;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.t0 = type;
            _context2.next = _context2.t0 === 'done' ? 3 : _context2.t0 === 'error' ? 5 : _context2.t0 === 'process' ? 7 : 23;
            break;

          case 3:
            job.done(payload);
            return _context2.abrupt("break", 24);

          case 5:
            job.error(payload.error);
            return _context2.abrupt("break", 24);

          case 7:
            id = payload.id, input = payload.input, options = payload.options;
            _context2.prev = 8;

            if (context.process) {
              _context2.next = 12;
              break;
            }

            job.postMessage('error', {
              id: id,
              error: 'Worker not set up to process on main thread'
            });
            return _context2.abrupt("return");

          case 12:
            _context2.next = 14;
            return context.process(input, options);

          case 14:
            result = _context2.sent;
            job.postMessage('done', {
              id: id,
              result: result
            });
            _context2.next = 22;
            break;

          case 18:
            _context2.prev = 18;
            _context2.t1 = _context2["catch"](8);
            message = _context2.t1 instanceof Error ? _context2.t1.message : 'unknown error';
            job.postMessage('error', {
              id: id,
              error: message
            });

          case 22:
            return _context2.abrupt("break", 24);

          case 23:
            console.warn("process-on-worker: unknown message ".concat(type));

          case 24:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[8, 18]]);
  }));
  return _onMessage.apply(this, arguments);
}

},{"../worker-farm/worker-farm":119,"../worker-utils/remove-nontransferable-options":125,"./get-worker-url":115,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],117:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateWorkerVersion = validateWorkerVersion;

var _assert = require("../env-utils/assert");

var _version = require("../env-utils/version");

function validateWorkerVersion(worker) {
  var coreVersion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _version.VERSION;
  (0, _assert.assert)(worker, 'no worker provided');
  var workerVersion = worker.version;

  if (!coreVersion || !workerVersion) {
    return false;
  }

  return true;
}

function parseVersion(version) {
  var parts = version.split('.').map(Number);
  return {
    major: parts[0],
    minor: parts[1]
  };
}

},{"../env-utils/assert":110,"../env-utils/version":112}],118:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _getTransferList = require("../worker-utils/get-transfer-list");

var onMessageWrapperMap = new Map();

var WorkerBody = function () {
  function WorkerBody() {
    (0, _classCallCheck2.default)(this, WorkerBody);
  }

  (0, _createClass2.default)(WorkerBody, null, [{
    key: "onmessage",
    set: function set(onMessage) {
      self.onmessage = function (message) {
        if (!isKnownMessage(message)) {
          return;
        }

        var _message$data = message.data,
            type = _message$data.type,
            payload = _message$data.payload;
        onMessage(type, payload);
      };
    }
  }, {
    key: "addEventListener",
    value: function addEventListener(onMessage) {
      var onMessageWrapper = onMessageWrapperMap.get(onMessage);

      if (!onMessageWrapper) {
        onMessageWrapper = function onMessageWrapper(message) {
          if (!isKnownMessage(message)) {
            return;
          }

          var _message$data2 = message.data,
              type = _message$data2.type,
              payload = _message$data2.payload;
          onMessage(type, payload);
        };
      }

      self.addEventListener('message', onMessageWrapper);
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(onMessage) {
      var onMessageWrapper = onMessageWrapperMap.get(onMessage);
      onMessageWrapperMap.delete(onMessage);
      self.removeEventListener('message', onMessageWrapper);
    }
  }, {
    key: "postMessage",
    value: function postMessage(type, payload) {
      if (self) {
        var data = {
          source: 'loaders.gl',
          type: type,
          payload: payload
        };
        var transferList = (0, _getTransferList.getTransferList)(payload);
        self.postMessage(data, transferList);
      }
    }
  }]);
  return WorkerBody;
}();

exports.default = WorkerBody;

function isKnownMessage(message) {
  var type = message.type,
      data = message.data;
  return type === 'message' && data && typeof data.source === 'string' && data.source.startsWith('loaders.gl');
}

},{"../worker-utils/get-transfer-list":124,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/interopRequireDefault":18}],119:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _workerPool = _interopRequireDefault(require("./worker-pool"));

var _workerThread = _interopRequireDefault(require("./worker-thread"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var DEFAULT_PROPS = {
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  onDebug: function onDebug() {},
  reuseWorkers: true
};

var WorkerFarm = function () {
  function WorkerFarm(props) {
    (0, _classCallCheck2.default)(this, WorkerFarm);
    (0, _defineProperty2.default)(this, "props", void 0);
    (0, _defineProperty2.default)(this, "workerPools", new Map());
    this.props = _objectSpread({}, DEFAULT_PROPS);
    this.setProps(props);
    this.workerPools = new Map();
  }

  (0, _createClass2.default)(WorkerFarm, [{
    key: "destroy",
    value: function destroy() {
      var _iterator = _createForOfIteratorHelper(this.workerPools.values()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var workerPool = _step.value;
          workerPool.destroy();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      this.props = _objectSpread(_objectSpread({}, this.props), props);

      var _iterator2 = _createForOfIteratorHelper(this.workerPools.values()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var workerPool = _step2.value;
          workerPool.setProps(this._getWorkerPoolProps());
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }, {
    key: "getWorkerPool",
    value: function getWorkerPool(options) {
      var name = options.name,
          source = options.source,
          url = options.url;
      var workerPool = this.workerPools.get(name);

      if (!workerPool) {
        workerPool = new _workerPool.default({
          name: name,
          source: source,
          url: url
        });
        workerPool.setProps(this._getWorkerPoolProps());
        this.workerPools.set(name, workerPool);
      }

      return workerPool;
    }
  }, {
    key: "_getWorkerPoolProps",
    value: function _getWorkerPoolProps() {
      return {
        maxConcurrency: this.props.maxConcurrency,
        maxMobileConcurrency: this.props.maxMobileConcurrency,
        reuseWorkers: this.props.reuseWorkers,
        onDebug: this.props.onDebug
      };
    }
  }], [{
    key: "isSupported",
    value: function isSupported() {
      return _workerThread.default.isSupported();
    }
  }, {
    key: "getWorkerFarm",
    value: function getWorkerFarm() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      WorkerFarm._workerFarm = WorkerFarm._workerFarm || new WorkerFarm({});

      WorkerFarm._workerFarm.setProps(props);

      return WorkerFarm._workerFarm;
    }
  }]);
  return WorkerFarm;
}();

exports.default = WorkerFarm;
(0, _defineProperty2.default)(WorkerFarm, "_workerFarm", void 0);

},{"./worker-pool":121,"./worker-thread":122,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18}],120:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _assert = require("../env-utils/assert");

var WorkerJob = function () {
  function WorkerJob(jobName, workerThread) {
    var _this = this;

    (0, _classCallCheck2.default)(this, WorkerJob);
    (0, _defineProperty2.default)(this, "name", void 0);
    (0, _defineProperty2.default)(this, "workerThread", void 0);
    (0, _defineProperty2.default)(this, "isRunning", void 0);
    (0, _defineProperty2.default)(this, "result", void 0);
    (0, _defineProperty2.default)(this, "_resolve", void 0);
    (0, _defineProperty2.default)(this, "_reject", void 0);
    this.name = jobName;
    this.workerThread = workerThread;
    this.isRunning = true;

    this._resolve = function () {};

    this._reject = function () {};

    this.result = new Promise(function (resolve, reject) {
      _this._resolve = resolve;
      _this._reject = reject;
    });
  }

  (0, _createClass2.default)(WorkerJob, [{
    key: "postMessage",
    value: function postMessage(type, payload) {
      this.workerThread.postMessage({
        source: 'loaders.gl',
        type: type,
        payload: payload
      });
    }
  }, {
    key: "done",
    value: function done(value) {
      (0, _assert.assert)(this.isRunning);
      this.isRunning = false;

      this._resolve(value);
    }
  }, {
    key: "error",
    value: function error(_error) {
      (0, _assert.assert)(this.isRunning);
      this.isRunning = false;

      this._reject(_error);
    }
  }]);
  return WorkerJob;
}();

exports.default = WorkerJob;

},{"../env-utils/assert":110,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18}],121:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _globals = require("../env-utils/globals");

var _workerThread = _interopRequireDefault(require("./worker-thread"));

var _workerJob = _interopRequireDefault(require("./worker-job"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var WorkerPool = function () {
  function WorkerPool(props) {
    (0, _classCallCheck2.default)(this, WorkerPool);
    (0, _defineProperty2.default)(this, "name", 'unnamed');
    (0, _defineProperty2.default)(this, "source", void 0);
    (0, _defineProperty2.default)(this, "url", void 0);
    (0, _defineProperty2.default)(this, "maxConcurrency", 1);
    (0, _defineProperty2.default)(this, "maxMobileConcurrency", 1);
    (0, _defineProperty2.default)(this, "onDebug", function () {});
    (0, _defineProperty2.default)(this, "reuseWorkers", true);
    (0, _defineProperty2.default)(this, "props", {});
    (0, _defineProperty2.default)(this, "jobQueue", []);
    (0, _defineProperty2.default)(this, "idleQueue", []);
    (0, _defineProperty2.default)(this, "count", 0);
    (0, _defineProperty2.default)(this, "isDestroyed", false);
    this.source = props.source;
    this.url = props.url;
    this.setProps(props);
  }

  (0, _createClass2.default)(WorkerPool, [{
    key: "destroy",
    value: function destroy() {
      this.idleQueue.forEach(function (worker) {
        return worker.destroy();
      });
      this.isDestroyed = true;
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      this.props = _objectSpread(_objectSpread({}, this.props), props);

      if (props.name !== undefined) {
        this.name = props.name;
      }

      if (props.maxConcurrency !== undefined) {
        this.maxConcurrency = props.maxConcurrency;
      }

      if (props.maxMobileConcurrency !== undefined) {
        this.maxMobileConcurrency = props.maxMobileConcurrency;
      }

      if (props.reuseWorkers !== undefined) {
        this.reuseWorkers = props.reuseWorkers;
      }

      if (props.onDebug !== undefined) {
        this.onDebug = props.onDebug;
      }
    }
  }, {
    key: "startJob",
    value: function () {
      var _startJob = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(name) {
        var _this = this;

        var onMessage,
            onError,
            startPromise,
            _args = arguments;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                onMessage = _args.length > 1 && _args[1] !== undefined ? _args[1] : function (job, type, data) {
                  return job.done(data);
                };
                onError = _args.length > 2 && _args[2] !== undefined ? _args[2] : function (job, error) {
                  return job.error(error);
                };
                startPromise = new Promise(function (onStart) {
                  _this.jobQueue.push({
                    name: name,
                    onMessage: onMessage,
                    onError: onError,
                    onStart: onStart
                  });

                  return _this;
                });

                this._startQueuedJob();

                _context.next = 6;
                return startPromise;

              case 6:
                return _context.abrupt("return", _context.sent);

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function startJob(_x) {
        return _startJob.apply(this, arguments);
      }

      return startJob;
    }()
  }, {
    key: "_startQueuedJob",
    value: function () {
      var _startQueuedJob2 = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2() {
        var workerThread, queuedJob, _job;

        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this.jobQueue.length) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return");

              case 2:
                workerThread = this._getAvailableWorker();

                if (workerThread) {
                  _context2.next = 5;
                  break;
                }

                return _context2.abrupt("return");

              case 5:
                queuedJob = this.jobQueue.shift();

                if (!queuedJob) {
                  _context2.next = 18;
                  break;
                }

                this.onDebug({
                  message: 'Starting job',
                  name: queuedJob.name,
                  workerThread: workerThread,
                  backlog: this.jobQueue.length
                });
                _job = new _workerJob.default(queuedJob.name, workerThread);

                workerThread.onMessage = function (data) {
                  return queuedJob.onMessage(_job, data.type, data.payload);
                };

                workerThread.onError = function (error) {
                  return queuedJob.onError(_job, error);
                };

                queuedJob.onStart(_job);
                _context2.prev = 12;
                _context2.next = 15;
                return _job.result;

              case 15:
                _context2.prev = 15;
                this.returnWorkerToQueue(workerThread);
                return _context2.finish(15);

              case 18:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[12,, 15, 18]]);
      }));

      function _startQueuedJob() {
        return _startQueuedJob2.apply(this, arguments);
      }

      return _startQueuedJob;
    }()
  }, {
    key: "returnWorkerToQueue",
    value: function returnWorkerToQueue(worker) {
      var shouldDestroyWorker = this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();

      if (shouldDestroyWorker) {
        worker.destroy();
        this.count--;
      } else {
        this.idleQueue.push(worker);
      }

      if (!this.isDestroyed) {
        this._startQueuedJob();
      }
    }
  }, {
    key: "_getAvailableWorker",
    value: function _getAvailableWorker() {
      if (this.idleQueue.length > 0) {
        return this.idleQueue.shift() || null;
      }

      if (this.count < this._getMaxConcurrency()) {
        this.count++;
        var name = "".concat(this.name.toLowerCase(), " (#").concat(this.count, " of ").concat(this.maxConcurrency, ")");
        return new _workerThread.default({
          name: name,
          source: this.source,
          url: this.url
        });
      }

      return null;
    }
  }, {
    key: "_getMaxConcurrency",
    value: function _getMaxConcurrency() {
      return _globals.isMobile ? this.maxMobileConcurrency : this.maxConcurrency;
    }
  }]);
  return WorkerPool;
}();

exports.default = WorkerPool;

},{"../env-utils/globals":111,"./worker-job":120,"./worker-thread":122,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],122:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _assert = require("../env-utils/assert");

var _getLoadableWorkerUrl = require("../worker-utils/get-loadable-worker-url");

var _getTransferList = require("../worker-utils/get-transfer-list");

var NOOP = function NOOP() {};

var WorkerThread = function () {
  function WorkerThread(props) {
    (0, _classCallCheck2.default)(this, WorkerThread);
    (0, _defineProperty2.default)(this, "name", void 0);
    (0, _defineProperty2.default)(this, "source", void 0);
    (0, _defineProperty2.default)(this, "url", void 0);
    (0, _defineProperty2.default)(this, "terminated", false);
    (0, _defineProperty2.default)(this, "worker", void 0);
    (0, _defineProperty2.default)(this, "onMessage", void 0);
    (0, _defineProperty2.default)(this, "onError", void 0);
    (0, _defineProperty2.default)(this, "_loadableURL", '');
    var name = props.name,
        source = props.source,
        url = props.url;
    (0, _assert.assert)(source || url);
    this.name = name;
    this.source = source;
    this.url = url;
    this.onMessage = NOOP;

    this.onError = function (error) {
      return console.log(error);
    };

    this.worker = this._createBrowserWorker();
  }

  (0, _createClass2.default)(WorkerThread, [{
    key: "destroy",
    value: function destroy() {
      this.onMessage = NOOP;
      this.onError = NOOP;
      this.worker.terminate();
      this.terminated = true;
    }
  }, {
    key: "isRunning",
    get: function get() {
      return Boolean(this.onMessage);
    }
  }, {
    key: "postMessage",
    value: function postMessage(data, transferList) {
      transferList = transferList || (0, _getTransferList.getTransferList)(data);
      this.worker.postMessage(data, transferList);
    }
  }, {
    key: "_getErrorFromErrorEvent",
    value: function _getErrorFromErrorEvent(event) {
      var message = 'Failed to load ';
      message += "worker ".concat(this.name, ". ");

      if (event.message) {
        message += "".concat(event.message, " in ");
      }

      if (event.lineno) {
        message += ":".concat(event.lineno, ":").concat(event.colno);
      }

      return new Error(message);
    }
  }, {
    key: "_createBrowserWorker",
    value: function _createBrowserWorker() {
      var _this = this;

      this._loadableURL = (0, _getLoadableWorkerUrl.getLoadableWorkerURL)({
        source: this.source,
        url: this.url
      });
      var worker = new Worker(this._loadableURL, {
        name: this.name
      });

      worker.onmessage = function (event) {
        if (!event.data) {
          _this.onError(new Error('No data received'));
        } else {
          _this.onMessage(event.data);
        }
      };

      worker.onerror = function (error) {
        _this.onError(_this._getErrorFromErrorEvent(error));

        _this.terminated = true;
      };

      worker.onmessageerror = function (event) {
        return console.error(event);
      };

      return worker;
    }
  }], [{
    key: "isSupported",
    value: function isSupported() {
      return typeof Worker !== 'undefined';
    }
  }]);
  return WorkerThread;
}();

exports.default = WorkerThread;

},{"../env-utils/assert":110,"../worker-utils/get-loadable-worker-url":123,"../worker-utils/get-transfer-list":124,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18}],123:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLoadableWorkerURL = getLoadableWorkerURL;

var _assert = require("../env-utils/assert");

var workerURLCache = new Map();

function getLoadableWorkerURL(props) {
  (0, _assert.assert)(props.source && !props.url || !props.source && props.url);
  var workerURL = workerURLCache.get(props.source || props.url);

  if (!workerURL) {
    if (props.url) {
      workerURL = getLoadableWorkerURLFromURL(props.url);
      workerURLCache.set(props.url, workerURL);
    }

    if (props.source) {
      workerURL = getLoadableWorkerURLFromSource(props.source);
      workerURLCache.set(props.source, workerURL);
    }
  }

  (0, _assert.assert)(workerURL);
  return workerURL;
}

function getLoadableWorkerURLFromURL(url) {
  if (!url.startsWith('http')) {
    return url;
  }

  var workerSource = buildScriptSource(url);
  return getLoadableWorkerURLFromSource(workerSource);
}

function getLoadableWorkerURLFromSource(workerSource) {
  var blob = new Blob([workerSource], {
    type: 'application/javascript'
  });
  return URL.createObjectURL(blob);
}

function buildScriptSource(workerUrl) {
  return "try {\n  importScripts('".concat(workerUrl, "');\n} catch (error) {\n  console.error(error);\n  throw error;\n}");
}

},{"../env-utils/assert":110}],124:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTransferList = getTransferList;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

function getTransferList(object) {
  var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var transfers = arguments.length > 2 ? arguments[2] : undefined;
  var transfersSet = transfers || new Set();

  if (!object) {} else if (isTransferable(object)) {
    transfersSet.add(object);
  } else if (isTransferable(object.buffer)) {
    transfersSet.add(object.buffer);
  } else if (ArrayBuffer.isView(object)) {} else if (recursive && (0, _typeof2.default)(object) === 'object') {
    for (var key in object) {
      getTransferList(object[key], recursive, transfersSet);
    }
  }

  return transfers === undefined ? Array.from(transfersSet) : [];
}

function isTransferable(object) {
  if (!object) {
    return false;
  }

  if (object instanceof ArrayBuffer) {
    return true;
  }

  if (typeof MessagePort !== 'undefined' && object instanceof MessagePort) {
    return true;
  }

  if (typeof ImageBitmap !== 'undefined' && object instanceof ImageBitmap) {
    return true;
  }

  if (typeof OffscreenCanvas !== 'undefined' && object instanceof OffscreenCanvas) {
    return true;
  }

  return false;
}

},{"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29}],125:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeNontransferableOptions = removeNontransferableOptions;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

function removeNontransferableOptions(object) {
  return JSON.parse(stringifyJSON(object));
}

function stringifyJSON(v) {
  var cache = new Set();
  return JSON.stringify(v, function (key, value) {
    if ((0, _typeof2.default)(value) === 'object' && value !== null) {
      if (cache.has(value)) {
        try {
          return JSON.parse(JSON.stringify(value));
        } catch (err) {
          return undefined;
        }
      }

      cache.add(value);
    }

    return value;
  });
}

},{"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29}],126:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Stats", {
  enumerable: true,
  get: function get() {
    return _stats.default;
  }
});
Object.defineProperty(exports, "Stat", {
  enumerable: true,
  get: function get() {
    return _stat.default;
  }
});
Object.defineProperty(exports, "_getHiResTimestamp", {
  enumerable: true,
  get: function get() {
    return _hiResTimestamp.default;
  }
});

var _stats = _interopRequireDefault(require("./lib/stats"));

var _stat = _interopRequireDefault(require("./lib/stat"));

var _hiResTimestamp = _interopRequireDefault(require("./utils/hi-res-timestamp"));

},{"./lib/stat":127,"./lib/stats":128,"./utils/hi-res-timestamp":129,"@babel/runtime/helpers/interopRequireDefault":18}],127:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _hiResTimestamp = _interopRequireDefault(require("../utils/hi-res-timestamp"));

var Stat = function () {
  function Stat(name, type) {
    (0, _classCallCheck2.default)(this, Stat);
    this.name = name;
    this.type = type;
    this.sampleSize = 1;
    this.reset();
  }

  (0, _createClass2.default)(Stat, [{
    key: "setSampleSize",
    value: function setSampleSize(samples) {
      this.sampleSize = samples;
      return this;
    }
  }, {
    key: "incrementCount",
    value: function incrementCount() {
      this.addCount(1);
      return this;
    }
  }, {
    key: "decrementCount",
    value: function decrementCount() {
      this.subtractCount(1);
      return this;
    }
  }, {
    key: "addCount",
    value: function addCount(value) {
      this._count += value;
      this._samples++;

      this._checkSampling();

      return this;
    }
  }, {
    key: "subtractCount",
    value: function subtractCount(value) {
      this._count -= value;
      this._samples++;

      this._checkSampling();

      return this;
    }
  }, {
    key: "addTime",
    value: function addTime(time) {
      this._time += time;
      this.lastTiming = time;
      this._samples++;

      this._checkSampling();

      return this;
    }
  }, {
    key: "timeStart",
    value: function timeStart() {
      this._startTime = (0, _hiResTimestamp.default)();
      this._timerPending = true;
      return this;
    }
  }, {
    key: "timeEnd",
    value: function timeEnd() {
      if (!this._timerPending) {
        return this;
      }

      this.addTime((0, _hiResTimestamp.default)() - this._startTime);
      this._timerPending = false;

      this._checkSampling();

      return this;
    }
  }, {
    key: "getSampleAverageCount",
    value: function getSampleAverageCount() {
      return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
    }
  }, {
    key: "getSampleAverageTime",
    value: function getSampleAverageTime() {
      return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
    }
  }, {
    key: "getSampleHz",
    value: function getSampleHz() {
      return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1000) : 0;
    }
  }, {
    key: "getAverageCount",
    value: function getAverageCount() {
      return this.samples > 0 ? this.count / this.samples : 0;
    }
  }, {
    key: "getAverageTime",
    value: function getAverageTime() {
      return this.samples > 0 ? this.time / this.samples : 0;
    }
  }, {
    key: "getHz",
    value: function getHz() {
      return this.time > 0 ? this.samples / (this.time / 1000) : 0;
    }
  }, {
    key: "reset",
    value: function reset() {
      this.time = 0;
      this.count = 0;
      this.samples = 0;
      this.lastTiming = 0;
      this.lastSampleTime = 0;
      this.lastSampleCount = 0;
      this._count = 0;
      this._time = 0;
      this._samples = 0;
      this._startTime = 0;
      this._timerPending = false;
      return this;
    }
  }, {
    key: "_checkSampling",
    value: function _checkSampling() {
      if (this._samples === this.sampleSize) {
        this.lastSampleTime = this._time;
        this.lastSampleCount = this._count;
        this.count += this._count;
        this.time += this._time;
        this.samples += this._samples;
        this._time = 0;
        this._count = 0;
        this._samples = 0;
      }
    }
  }]);
  return Stat;
}();

exports.default = Stat;

},{"../utils/hi-res-timestamp":129,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/interopRequireDefault":18}],128:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _stat = _interopRequireDefault(require("./stat"));

var Stats = function () {
  function Stats(_ref) {
    var id = _ref.id,
        stats = _ref.stats;
    (0, _classCallCheck2.default)(this, Stats);
    this.id = id;
    this.stats = {};

    this._initializeStats(stats);

    Object.seal(this);
  }

  (0, _createClass2.default)(Stats, [{
    key: "get",
    value: function get(name) {
      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'count';
      return this._getOrCreate({
        name: name,
        type: type
      });
    }
  }, {
    key: "size",
    get: function get() {
      return Object.keys(this.stats).length;
    }
  }, {
    key: "reset",
    value: function reset() {
      for (var key in this.stats) {
        this.stats[key].reset();
      }

      return this;
    }
  }, {
    key: "forEach",
    value: function forEach(fn) {
      for (var key in this.stats) {
        fn(this.stats[key]);
      }
    }
  }, {
    key: "getTable",
    value: function getTable() {
      var table = {};
      this.forEach(function (stat) {
        table[stat.name] = {
          time: stat.time || 0,
          count: stat.count || 0,
          average: stat.getAverageTime() || 0,
          hz: stat.getHz() || 0
        };
      });
      return table;
    }
  }, {
    key: "_initializeStats",
    value: function _initializeStats() {
      var _this = this;

      var stats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      stats.forEach(function (stat) {
        return _this._getOrCreate(stat);
      });
    }
  }, {
    key: "_getOrCreate",
    value: function _getOrCreate(stat) {
      if (!stat || !stat.name) {
        return null;
      }

      var name = stat.name,
          type = stat.type;

      if (!this.stats[name]) {
        if (stat instanceof _stat.default) {
          this.stats[name] = stat;
        } else {
          this.stats[name] = new _stat.default(name, type);
        }
      }

      return this.stats[name];
    }
  }]);
  return Stats;
}();

exports.default = Stats;

},{"./stat":127,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/interopRequireDefault":18}],129:[function(require,module,exports){
(function (process){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getHiResTimestamp;

function getHiResTimestamp() {
  var timestamp;

  if (typeof window !== 'undefined' && window.performance) {
    timestamp = window.performance.now();
  } else if (typeof process !== 'undefined' && process.hrtime) {
    var timeParts = process.hrtime();
    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }

  return timestamp;
}

}).call(this)}).call(this,require('_process'))

},{"_process":153}],130:[function(require,module,exports){

},{}],131:[function(require,module,exports){
module.exports = attributeToProperty

var transform = {
  'class': 'className',
  'for': 'htmlFor',
  'http-equiv': 'httpEquiv'
}

function attributeToProperty (h) {
  return function (tagName, attrs, children) {
    for (var attr in attrs) {
      if (attr in transform) {
        attrs[transform[attr]] = attrs[attr]
        delete attrs[attr]
      }
    }
    return h(tagName, attrs, children)
  }
}

},{}],132:[function(require,module,exports){
var attrToProp = require('hyperscript-attribute-to-property')

var VAR = 0, TEXT = 1, OPEN = 2, CLOSE = 3, ATTR = 4
var ATTR_KEY = 5, ATTR_KEY_W = 6
var ATTR_VALUE_W = 7, ATTR_VALUE = 8
var ATTR_VALUE_SQ = 9, ATTR_VALUE_DQ = 10
var ATTR_EQ = 11, ATTR_BREAK = 12
var COMMENT = 13

module.exports = function (h, opts) {
  if (!opts) opts = {}
  var concat = opts.concat || function (a, b) {
    return String(a) + String(b)
  }
  if (opts.attrToProp !== false) {
    h = attrToProp(h)
  }

  return function (strings) {
    var state = TEXT, reg = ''
    var arglen = arguments.length
    var parts = []

    for (var i = 0; i < strings.length; i++) {
      if (i < arglen - 1) {
        var arg = arguments[i+1]
        var p = parse(strings[i])
        var xstate = state
        if (xstate === ATTR_VALUE_DQ) xstate = ATTR_VALUE
        if (xstate === ATTR_VALUE_SQ) xstate = ATTR_VALUE
        if (xstate === ATTR_VALUE_W) xstate = ATTR_VALUE
        if (xstate === ATTR) xstate = ATTR_KEY
        if (xstate === OPEN) {
          if (reg === '/') {
            p.push([ OPEN, '/', arg ])
            reg = ''
          } else {
            p.push([ OPEN, arg ])
          }
        } else if (xstate === COMMENT && opts.comments) {
          reg += String(arg)
        } else if (xstate !== COMMENT) {
          p.push([ VAR, xstate, arg ])
        }
        parts.push.apply(parts, p)
      } else parts.push.apply(parts, parse(strings[i]))
    }

    var tree = [null,{},[]]
    var stack = [[tree,-1]]
    for (var i = 0; i < parts.length; i++) {
      var cur = stack[stack.length-1][0]
      var p = parts[i], s = p[0]
      if (s === OPEN && /^\//.test(p[1])) {
        var ix = stack[stack.length-1][1]
        if (stack.length > 1) {
          stack.pop()
          stack[stack.length-1][0][2][ix] = h(
            cur[0], cur[1], cur[2].length ? cur[2] : undefined
          )
        }
      } else if (s === OPEN) {
        var c = [p[1],{},[]]
        cur[2].push(c)
        stack.push([c,cur[2].length-1])
      } else if (s === ATTR_KEY || (s === VAR && p[1] === ATTR_KEY)) {
        var key = ''
        var copyKey
        for (; i < parts.length; i++) {
          if (parts[i][0] === ATTR_KEY) {
            key = concat(key, parts[i][1])
          } else if (parts[i][0] === VAR && parts[i][1] === ATTR_KEY) {
            if (typeof parts[i][2] === 'object' && !key) {
              for (copyKey in parts[i][2]) {
                if (parts[i][2].hasOwnProperty(copyKey) && !cur[1][copyKey]) {
                  cur[1][copyKey] = parts[i][2][copyKey]
                }
              }
            } else {
              key = concat(key, parts[i][2])
            }
          } else break
        }
        if (parts[i][0] === ATTR_EQ) i++
        var j = i
        for (; i < parts.length; i++) {
          if (parts[i][0] === ATTR_VALUE || parts[i][0] === ATTR_KEY) {
            if (!cur[1][key]) cur[1][key] = strfn(parts[i][1])
            else parts[i][1]==="" || (cur[1][key] = concat(cur[1][key], parts[i][1]));
          } else if (parts[i][0] === VAR
          && (parts[i][1] === ATTR_VALUE || parts[i][1] === ATTR_KEY)) {
            if (!cur[1][key]) cur[1][key] = strfn(parts[i][2])
            else parts[i][2]==="" || (cur[1][key] = concat(cur[1][key], parts[i][2]));
          } else {
            if (key.length && !cur[1][key] && i === j
            && (parts[i][0] === CLOSE || parts[i][0] === ATTR_BREAK)) {
              // https://html.spec.whatwg.org/multipage/infrastructure.html#boolean-attributes
              // empty string is falsy, not well behaved value in browser
              cur[1][key] = key.toLowerCase()
            }
            if (parts[i][0] === CLOSE) {
              i--
            }
            break
          }
        }
      } else if (s === ATTR_KEY) {
        cur[1][p[1]] = true
      } else if (s === VAR && p[1] === ATTR_KEY) {
        cur[1][p[2]] = true
      } else if (s === CLOSE) {
        if (selfClosing(cur[0]) && stack.length) {
          var ix = stack[stack.length-1][1]
          stack.pop()
          stack[stack.length-1][0][2][ix] = h(
            cur[0], cur[1], cur[2].length ? cur[2] : undefined
          )
        }
      } else if (s === VAR && p[1] === TEXT) {
        if (p[2] === undefined || p[2] === null) p[2] = ''
        else if (!p[2]) p[2] = concat('', p[2])
        if (Array.isArray(p[2][0])) {
          cur[2].push.apply(cur[2], p[2])
        } else {
          cur[2].push(p[2])
        }
      } else if (s === TEXT) {
        cur[2].push(p[1])
      } else if (s === ATTR_EQ || s === ATTR_BREAK) {
        // no-op
      } else {
        throw new Error('unhandled: ' + s)
      }
    }

    if (tree[2].length > 1 && /^\s*$/.test(tree[2][0])) {
      tree[2].shift()
    }

    if (tree[2].length > 2
    || (tree[2].length === 2 && /\S/.test(tree[2][1]))) {
      if (opts.createFragment) return opts.createFragment(tree[2])
      throw new Error(
        'multiple root elements must be wrapped in an enclosing tag'
      )
    }
    if (Array.isArray(tree[2][0]) && typeof tree[2][0][0] === 'string'
    && Array.isArray(tree[2][0][2])) {
      tree[2][0] = h(tree[2][0][0], tree[2][0][1], tree[2][0][2])
    }
    return tree[2][0]

    function parse (str) {
      var res = []
      if (state === ATTR_VALUE_W) state = ATTR
      for (var i = 0; i < str.length; i++) {
        var c = str.charAt(i)
        if (state === TEXT && c === '<') {
          if (reg.length) res.push([TEXT, reg])
          reg = ''
          state = OPEN
        } else if (c === '>' && !quot(state) && state !== COMMENT) {
          if (state === OPEN && reg.length) {
            res.push([OPEN,reg])
          } else if (state === ATTR_KEY) {
            res.push([ATTR_KEY,reg])
          } else if (state === ATTR_VALUE && reg.length) {
            res.push([ATTR_VALUE,reg])
          }
          res.push([CLOSE])
          reg = ''
          state = TEXT
        } else if (state === COMMENT && /-$/.test(reg) && c === '-') {
          if (opts.comments) {
            res.push([ATTR_VALUE,reg.substr(0, reg.length - 1)])
          }
          reg = ''
          state = TEXT
        } else if (state === OPEN && /^!--$/.test(reg)) {
          if (opts.comments) {
            res.push([OPEN, reg],[ATTR_KEY,'comment'],[ATTR_EQ])
          }
          reg = c
          state = COMMENT
        } else if (state === TEXT || state === COMMENT) {
          reg += c
        } else if (state === OPEN && c === '/' && reg.length) {
          // no-op, self closing tag without a space <br/>
        } else if (state === OPEN && /\s/.test(c)) {
          if (reg.length) {
            res.push([OPEN, reg])
          }
          reg = ''
          state = ATTR
        } else if (state === OPEN) {
          reg += c
        } else if (state === ATTR && /[^\s"'=/]/.test(c)) {
          state = ATTR_KEY
          reg = c
        } else if (state === ATTR && /\s/.test(c)) {
          if (reg.length) res.push([ATTR_KEY,reg])
          res.push([ATTR_BREAK])
        } else if (state === ATTR_KEY && /\s/.test(c)) {
          res.push([ATTR_KEY,reg])
          reg = ''
          state = ATTR_KEY_W
        } else if (state === ATTR_KEY && c === '=') {
          res.push([ATTR_KEY,reg],[ATTR_EQ])
          reg = ''
          state = ATTR_VALUE_W
        } else if (state === ATTR_KEY) {
          reg += c
        } else if ((state === ATTR_KEY_W || state === ATTR) && c === '=') {
          res.push([ATTR_EQ])
          state = ATTR_VALUE_W
        } else if ((state === ATTR_KEY_W || state === ATTR) && !/\s/.test(c)) {
          res.push([ATTR_BREAK])
          if (/[\w-]/.test(c)) {
            reg += c
            state = ATTR_KEY
          } else state = ATTR
        } else if (state === ATTR_VALUE_W && c === '"') {
          state = ATTR_VALUE_DQ
        } else if (state === ATTR_VALUE_W && c === "'") {
          state = ATTR_VALUE_SQ
        } else if (state === ATTR_VALUE_DQ && c === '"') {
          res.push([ATTR_VALUE,reg],[ATTR_BREAK])
          reg = ''
          state = ATTR
        } else if (state === ATTR_VALUE_SQ && c === "'") {
          res.push([ATTR_VALUE,reg],[ATTR_BREAK])
          reg = ''
          state = ATTR
        } else if (state === ATTR_VALUE_W && !/\s/.test(c)) {
          state = ATTR_VALUE
          i--
        } else if (state === ATTR_VALUE && /\s/.test(c)) {
          res.push([ATTR_VALUE,reg],[ATTR_BREAK])
          reg = ''
          state = ATTR
        } else if (state === ATTR_VALUE || state === ATTR_VALUE_SQ
        || state === ATTR_VALUE_DQ) {
          reg += c
        }
      }
      if (state === TEXT && reg.length) {
        res.push([TEXT,reg])
        reg = ''
      } else if (state === ATTR_VALUE && reg.length) {
        res.push([ATTR_VALUE,reg])
        reg = ''
      } else if (state === ATTR_VALUE_DQ && reg.length) {
        res.push([ATTR_VALUE,reg])
        reg = ''
      } else if (state === ATTR_VALUE_SQ && reg.length) {
        res.push([ATTR_VALUE,reg])
        reg = ''
      } else if (state === ATTR_KEY) {
        res.push([ATTR_KEY,reg])
        reg = ''
      }
      return res
    }
  }

  function strfn (x) {
    if (typeof x === 'function') return x
    else if (typeof x === 'string') return x
    else if (x && typeof x === 'object') return x
    else if (x === null || x === undefined) return x
    else return concat('', x)
  }
}

function quot (state) {
  return state === ATTR_VALUE_SQ || state === ATTR_VALUE_DQ
}

var closeRE = RegExp('^(' + [
  'area', 'base', 'basefont', 'bgsound', 'br', 'col', 'command', 'embed',
  'frame', 'hr', 'img', 'input', 'isindex', 'keygen', 'link', 'meta', 'param',
  'source', 'track', 'wbr', '!--',
  // SVG TAGS
  'animate', 'animateTransform', 'circle', 'cursor', 'desc', 'ellipse',
  'feBlend', 'feColorMatrix', 'feComposite',
  'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap',
  'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR',
  'feGaussianBlur', 'feImage', 'feMergeNode', 'feMorphology',
  'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile',
  'feTurbulence', 'font-face-format', 'font-face-name', 'font-face-uri',
  'glyph', 'glyphRef', 'hkern', 'image', 'line', 'missing-glyph', 'mpath',
  'path', 'polygon', 'polyline', 'rect', 'set', 'stop', 'tref', 'use', 'view',
  'vkern'
].join('|') + ')(?:[\.#][a-zA-Z0-9\u007F-\uFFFF_:-]+)*$')
function selfClosing (tag) { return closeRE.test(tag) }

},{"hyperscript-attribute-to-property":131}],133:[function(require,module,exports){
'use strict'

var trailingNewlineRegex = /\n[\s]+$/
var leadingNewlineRegex = /^\n[\s]+/
var trailingSpaceRegex = /[\s]+$/
var leadingSpaceRegex = /^[\s]+/
var multiSpaceRegex = /[\n\s]+/g

var TEXT_TAGS = [
  'a', 'abbr', 'b', 'bdi', 'bdo', 'br', 'cite', 'data', 'dfn', 'em', 'i',
  'kbd', 'mark', 'q', 'rp', 'rt', 'rtc', 'ruby', 's', 'amp', 'small', 'span',
  'strong', 'sub', 'sup', 'time', 'u', 'var', 'wbr'
]

var VERBATIM_TAGS = [
  'code', 'pre', 'textarea'
]

module.exports = function appendChild (el, childs) {
  if (!Array.isArray(childs)) return

  var nodeName = el.nodeName.toLowerCase()

  var hadText = false
  var value, leader

  for (var i = 0, len = childs.length; i < len; i++) {
    var node = childs[i]
    if (Array.isArray(node)) {
      appendChild(el, node)
      continue
    }

    if (typeof node === 'number' ||
      typeof node === 'boolean' ||
      typeof node === 'function' ||
      node instanceof Date ||
      node instanceof RegExp) {
      node = node.toString()
    }

    var lastChild = el.childNodes[el.childNodes.length - 1]

    // Iterate over text nodes
    if (typeof node === 'string') {
      hadText = true

      // If we already had text, append to the existing text
      if (lastChild && lastChild.nodeName === '#text') {
        lastChild.nodeValue += node

      // We didn't have a text node yet, create one
      } else {
        node = el.ownerDocument.createTextNode(node)
        el.appendChild(node)
        lastChild = node
      }

      // If this is the last of the child nodes, make sure we close it out
      // right
      if (i === len - 1) {
        hadText = false
        // Trim the child text nodes if the current node isn't a
        // node where whitespace matters.
        if (TEXT_TAGS.indexOf(nodeName) === -1 &&
          VERBATIM_TAGS.indexOf(nodeName) === -1) {
          value = lastChild.nodeValue
            .replace(leadingNewlineRegex, '')
            .replace(trailingSpaceRegex, '')
            .replace(trailingNewlineRegex, '')
            .replace(multiSpaceRegex, ' ')
          if (value === '') {
            el.removeChild(lastChild)
          } else {
            lastChild.nodeValue = value
          }
        } else if (VERBATIM_TAGS.indexOf(nodeName) === -1) {
          // The very first node in the list should not have leading
          // whitespace. Sibling text nodes should have whitespace if there
          // was any.
          leader = i === 0 ? '' : ' '
          value = lastChild.nodeValue
            .replace(leadingNewlineRegex, leader)
            .replace(leadingSpaceRegex, ' ')
            .replace(trailingSpaceRegex, '')
            .replace(trailingNewlineRegex, '')
            .replace(multiSpaceRegex, ' ')
          lastChild.nodeValue = value
        }
      }

    // Iterate over DOM nodes
    } else if (node && node.nodeType) {
      // If the last node was a text node, make sure it is properly closed out
      if (hadText) {
        hadText = false

        // Trim the child text nodes if the current node isn't a
        // text node or a code node
        if (TEXT_TAGS.indexOf(nodeName) === -1 &&
          VERBATIM_TAGS.indexOf(nodeName) === -1) {
          value = lastChild.nodeValue
            .replace(leadingNewlineRegex, '')
            .replace(trailingNewlineRegex, ' ')
            .replace(multiSpaceRegex, ' ')

          // Remove empty text nodes, append otherwise
          if (value === '') {
            el.removeChild(lastChild)
          } else {
            lastChild.nodeValue = value
          }
        // Trim the child nodes but preserve the appropriate whitespace
        } else if (VERBATIM_TAGS.indexOf(nodeName) === -1) {
          value = lastChild.nodeValue
            .replace(leadingSpaceRegex, ' ')
            .replace(leadingNewlineRegex, '')
            .replace(trailingNewlineRegex, ' ')
            .replace(multiSpaceRegex, ' ')
          lastChild.nodeValue = value
        }
      }

      // Store the last nodename
      var _nodeName = node.nodeName
      if (_nodeName) nodeName = _nodeName.toLowerCase()

      // Append the node to the DOM
      el.appendChild(node)
    }
  }
}

},{}],134:[function(require,module,exports){
'use strict'

module.exports = [
  'async', 'autofocus', 'autoplay', 'checked', 'controls', 'default',
  'defaultchecked', 'defer', 'disabled', 'formnovalidate', 'hidden',
  'ismap', 'loop', 'multiple', 'muted', 'novalidate', 'open', 'playsinline',
  'readonly', 'required', 'reversed', 'selected'
]

},{}],135:[function(require,module,exports){
module.exports = require('./dom')(document)

},{"./dom":137}],136:[function(require,module,exports){
'use strict'

module.exports = [
  'indeterminate'
]

},{}],137:[function(require,module,exports){
'use strict'

var hyperx = require('hyperx')
var appendChild = require('./append-child')
var SVG_TAGS = require('./svg-tags')
var BOOL_PROPS = require('./bool-props')
// Props that need to be set directly rather than with el.setAttribute()
var DIRECT_PROPS = require('./direct-props')

var SVGNS = 'http://www.w3.org/2000/svg'
var XLINKNS = 'http://www.w3.org/1999/xlink'

var COMMENT_TAG = '!--'

module.exports = function (document) {
  function nanoHtmlCreateElement (tag, props, children) {
    var el

    // If an svg tag, it needs a namespace
    if (SVG_TAGS.indexOf(tag) !== -1) {
      props.namespace = SVGNS
    }

    // If we are using a namespace
    var ns = false
    if (props.namespace) {
      ns = props.namespace
      delete props.namespace
    }

    // If we are extending a builtin element
    var isCustomElement = false
    if (props.is) {
      isCustomElement = props.is
      delete props.is
    }

    // Create the element
    if (ns) {
      if (isCustomElement) {
        el = document.createElementNS(ns, tag, { is: isCustomElement })
      } else {
        el = document.createElementNS(ns, tag)
      }
    } else if (tag === COMMENT_TAG) {
      return document.createComment(props.comment)
    } else if (isCustomElement) {
      el = document.createElement(tag, { is: isCustomElement })
    } else {
      el = document.createElement(tag)
    }

    // Create the properties
    for (var p in props) {
      if (props.hasOwnProperty(p)) {
        var key = p.toLowerCase()
        var val = props[p]
        // Normalize className
        if (key === 'classname') {
          key = 'class'
          p = 'class'
        }
        // The for attribute gets transformed to htmlFor, but we just set as for
        if (p === 'htmlFor') {
          p = 'for'
        }
        // If a property is boolean, set itself to the key
        if (BOOL_PROPS.indexOf(key) !== -1) {
          if (String(val) === 'true') val = key
          else if (String(val) === 'false') continue
        }
        // If a property prefers being set directly vs setAttribute
        if (key.slice(0, 2) === 'on' || DIRECT_PROPS.indexOf(key) !== -1) {
          el[p] = val
        } else {
          if (ns) {
            if (p === 'xlink:href') {
              el.setAttributeNS(XLINKNS, p, val)
            } else if (/^xmlns($|:)/i.test(p)) {
              // skip xmlns definitions
            } else {
              el.setAttributeNS(null, p, val)
            }
          } else {
            el.setAttribute(p, val)
          }
        }
      }
    }

    appendChild(el, children)
    return el
  }

  function createFragment (nodes) {
    var fragment = document.createDocumentFragment()
    for (var i = 0; i < nodes.length; i++) {
      if (nodes[i] == null) continue
      if (Array.isArray(nodes[i])) {
        fragment.appendChild(createFragment(nodes[i]))
      } else {
        if (typeof nodes[i] === 'string') nodes[i] = document.createTextNode(nodes[i])
        fragment.appendChild(nodes[i])
      }
    }
    return fragment
  }

  var exports = hyperx(nanoHtmlCreateElement, {
    comments: true,
    createFragment: createFragment
  })
  exports.default = exports
  exports.createComment = nanoHtmlCreateElement
  return exports
}

},{"./append-child":133,"./bool-props":134,"./direct-props":136,"./svg-tags":138,"hyperx":132}],138:[function(require,module,exports){
'use strict'

module.exports = [
  'svg', 'altGlyph', 'altGlyphDef', 'altGlyphItem', 'animate', 'animateColor',
  'animateMotion', 'animateTransform', 'circle', 'clipPath', 'color-profile',
  'cursor', 'defs', 'desc', 'ellipse', 'feBlend', 'feColorMatrix',
  'feComponentTransfer', 'feComposite', 'feConvolveMatrix',
  'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood',
  'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage',
  'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight',
  'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence', 'filter',
  'font', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src',
  'font-face-uri', 'foreignObject', 'g', 'glyph', 'glyphRef', 'hkern', 'image',
  'line', 'linearGradient', 'marker', 'mask', 'metadata', 'missing-glyph',
  'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect',
  'set', 'stop', 'switch', 'symbol', 'text', 'textPath', 'title', 'tref',
  'tspan', 'use', 'view', 'vkern'
]

},{}],139:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isMobile = isMobile;
exports.default = getBrowser;

var _globals = require("./globals");

var _isBrowser = _interopRequireDefault(require("./is-browser"));

var _isElectron = _interopRequireDefault(require("./is-electron"));

function isMobile() {
  return typeof _globals.window.orientation !== 'undefined';
}

function getBrowser(mockUserAgent) {
  if (!mockUserAgent && !(0, _isBrowser.default)()) {
    return 'Node';
  }

  if ((0, _isElectron.default)(mockUserAgent)) {
    return 'Electron';
  }

  var navigator_ = typeof navigator !== 'undefined' ? navigator : {};
  var userAgent = mockUserAgent || navigator_.userAgent || '';

  if (userAgent.indexOf('Edge') > -1) {
    return 'Edge';
  }

  var isMSIE = userAgent.indexOf('MSIE ') !== -1;
  var isTrident = userAgent.indexOf('Trident/') !== -1;

  if (isMSIE || isTrident) {
    return 'IE';
  }

  if (_globals.window.chrome) {
    return 'Chrome';
  }

  if (_globals.window.safari) {
    return 'Safari';
  }

  if (_globals.window.mozInnerScreenX) {
    return 'Firefox';
  }

  return 'Unknown';
}

},{"./globals":140,"./is-browser":141,"./is-electron":142,"@babel/runtime/helpers/interopRequireDefault":18}],140:[function(require,module,exports){
(function (process,global){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.console = exports.process = exports.document = exports.global = exports.window = exports.self = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document,
  process: (typeof process === "undefined" ? "undefined" : (0, _typeof2.default)(process)) === 'object' && process
};
var self_ = globals.self || globals.window || globals.global;
exports.self = self_;
var window_ = globals.window || globals.self || globals.global;
exports.window = window_;
var global_ = globals.global || globals.self || globals.window;
exports.global = global_;
var document_ = globals.document || {};
exports.document = document_;
var process_ = globals.process || {};
exports.process = process_;
var console_ = console;
exports.console = console_;

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"_process":153}],141:[function(require,module,exports){
(function (process){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isBrowser;
exports.isBrowserMainThread = isBrowserMainThread;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _isElectron = _interopRequireDefault(require("./is-electron"));

function isBrowser() {
  var isNode = (typeof process === "undefined" ? "undefined" : (0, _typeof2.default)(process)) === 'object' && String(process) === '[object process]' && !process.browser;
  return !isNode || (0, _isElectron.default)();
}

function isBrowserMainThread() {
  return isBrowser() && typeof document !== 'undefined';
}

}).call(this)}).call(this,require('_process'))

},{"./is-electron":142,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"_process":153}],142:[function(require,module,exports){
(function (process){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isElectron;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

function isElectron(mockUserAgent) {
  if (typeof window !== 'undefined' && (0, _typeof2.default)(window.process) === 'object' && window.process.type === 'renderer') {
    return true;
  }

  if (typeof process !== 'undefined' && (0, _typeof2.default)(process.versions) === 'object' && Boolean(process.versions.electron)) {
    return true;
  }

  var realUserAgent = (typeof navigator === "undefined" ? "undefined" : (0, _typeof2.default)(navigator)) === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent;
  var userAgent = mockUserAgent || realUserAgent;

  if (userAgent && userAgent.indexOf('Electron') >= 0) {
    return true;
  }

  return false;
}

}).call(this)}).call(this,require('_process'))

},{"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"_process":153}],143:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Log", {
  enumerable: true,
  get: function get() {
    return _log.default;
  }
});
Object.defineProperty(exports, "VERSION", {
  enumerable: true,
  get: function get() {
    return _globals.VERSION;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function get() {
    return _globals2.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function get() {
    return _globals2.window;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function get() {
    return _globals2.global;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function get() {
    return _globals2.document;
  }
});
Object.defineProperty(exports, "process", {
  enumerable: true,
  get: function get() {
    return _globals2.process;
  }
});
Object.defineProperty(exports, "console", {
  enumerable: true,
  get: function get() {
    return _globals2.console;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function get() {
    return _isBrowser.default;
  }
});
Object.defineProperty(exports, "isBrowserMainThread", {
  enumerable: true,
  get: function get() {
    return _isBrowser.isBrowserMainThread;
  }
});
Object.defineProperty(exports, "getBrowser", {
  enumerable: true,
  get: function get() {
    return _getBrowser.default;
  }
});
Object.defineProperty(exports, "isMobile", {
  enumerable: true,
  get: function get() {
    return _getBrowser.isMobile;
  }
});
Object.defineProperty(exports, "isElectron", {
  enumerable: true,
  get: function get() {
    return _isElectron.default;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function get() {
    return _assert.default;
  }
});
Object.defineProperty(exports, "COLOR", {
  enumerable: true,
  get: function get() {
    return _color.COLOR;
  }
});
Object.defineProperty(exports, "addColor", {
  enumerable: true,
  get: function get() {
    return _color.addColor;
  }
});
Object.defineProperty(exports, "leftPad", {
  enumerable: true,
  get: function get() {
    return _formatters.leftPad;
  }
});
Object.defineProperty(exports, "rightPad", {
  enumerable: true,
  get: function get() {
    return _formatters.rightPad;
  }
});
Object.defineProperty(exports, "autobind", {
  enumerable: true,
  get: function get() {
    return _autobind.autobind;
  }
});
Object.defineProperty(exports, "LocalStorage", {
  enumerable: true,
  get: function get() {
    return _localStorage.default;
  }
});
Object.defineProperty(exports, "getHiResTimestamp", {
  enumerable: true,
  get: function get() {
    return _hiResTimestamp.default;
  }
});
Object.defineProperty(exports, "Stats", {
  enumerable: true,
  get: function get() {
    return _stats.Stats;
  }
});
Object.defineProperty(exports, "Stat", {
  enumerable: true,
  get: function get() {
    return _stats.Stat;
  }
});
exports.default = void 0;

require("./init");

var _log = _interopRequireDefault(require("./lib/log"));

var _globals = require("./utils/globals");

var _globals2 = require("./env/globals");

var _isBrowser = _interopRequireWildcard(require("./env/is-browser"));

var _getBrowser = _interopRequireWildcard(require("./env/get-browser"));

var _isElectron = _interopRequireDefault(require("./env/is-electron"));

var _assert = _interopRequireDefault(require("./utils/assert"));

var _color = require("./utils/color");

var _formatters = require("./utils/formatters");

var _autobind = require("./utils/autobind");

var _localStorage = _interopRequireDefault(require("./utils/local-storage"));

var _hiResTimestamp = _interopRequireDefault(require("./utils/hi-res-timestamp"));

var _stats = require("@probe.gl/stats");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var _default = new _log.default({
  id: 'probe.gl'
});

exports.default = _default;

},{"./env/get-browser":139,"./env/globals":140,"./env/is-browser":141,"./env/is-electron":142,"./init":144,"./lib/log":145,"./utils/assert":146,"./utils/autobind":147,"./utils/color":148,"./utils/formatters":149,"./utils/globals":150,"./utils/hi-res-timestamp":151,"./utils/local-storage":152,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"@probe.gl/stats":126}],144:[function(require,module,exports){
"use strict";

var _globals = require("./utils/globals");

_globals.global.probe = {};

},{"./utils/globals":150}],145:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalizeArguments = normalizeArguments;
exports.default = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _globals = require("../utils/globals");

var _localStorage = _interopRequireDefault(require("../utils/local-storage"));

var _formatters = require("../utils/formatters");

var _color = require("../utils/color");

var _autobind = require("../utils/autobind");

var _assert2 = _interopRequireDefault(require("../utils/assert"));

var _hiResTimestamp = _interopRequireDefault(require("../utils/hi-res-timestamp"));

var originalConsole = {
  debug: _globals.isBrowser ? console.debug || console.log : console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
};
var DEFAULT_SETTINGS = {
  enabled: true,
  level: 0
};

function noop() {}

var cache = {};
var ONCE = {
  once: true
};

function getTableHeader(table) {
  for (var key in table) {
    for (var title in table[key]) {
      return title || 'untitled';
    }
  }

  return 'empty';
}

var Log = function () {
  function Log() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      id: ''
    },
        id = _ref.id;

    (0, _classCallCheck2.default)(this, Log);
    this.id = id;
    this.VERSION = _globals.VERSION;
    this._startTs = (0, _hiResTimestamp.default)();
    this._deltaTs = (0, _hiResTimestamp.default)();
    this.LOG_THROTTLE_TIMEOUT = 0;
    this._storage = new _localStorage.default("__probe-".concat(this.id, "__"), DEFAULT_SETTINGS);
    this.userData = {};
    this.timeStamp("".concat(this.id, " started"));
    (0, _autobind.autobind)(this);
    Object.seal(this);
  }

  (0, _createClass2.default)(Log, [{
    key: "level",
    get: function get() {
      return this.getLevel();
    },
    set: function set(newLevel) {
      this.setLevel(newLevel);
    }
  }, {
    key: "isEnabled",
    value: function isEnabled() {
      return this._storage.config.enabled;
    }
  }, {
    key: "getLevel",
    value: function getLevel() {
      return this._storage.config.level;
    }
  }, {
    key: "getTotal",
    value: function getTotal() {
      return Number(((0, _hiResTimestamp.default)() - this._startTs).toPrecision(10));
    }
  }, {
    key: "getDelta",
    value: function getDelta() {
      return Number(((0, _hiResTimestamp.default)() - this._deltaTs).toPrecision(10));
    }
  }, {
    key: "priority",
    get: function get() {
      return this.level;
    },
    set: function set(newPriority) {
      this.level = newPriority;
    }
  }, {
    key: "getPriority",
    value: function getPriority() {
      return this.level;
    }
  }, {
    key: "enable",
    value: function enable() {
      var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this._storage.updateConfiguration({
        enabled: enabled
      });

      return this;
    }
  }, {
    key: "setLevel",
    value: function setLevel(level) {
      this._storage.updateConfiguration({
        level: level
      });

      return this;
    }
  }, {
    key: "assert",
    value: function assert(condition, message) {
      (0, _assert2.default)(condition, message);
    }
  }, {
    key: "warn",
    value: function warn(message) {
      return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);
    }
  }, {
    key: "error",
    value: function error(message) {
      return this._getLogFunction(0, message, originalConsole.error, arguments);
    }
  }, {
    key: "deprecated",
    value: function deprecated(oldUsage, newUsage) {
      return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
    }
  }, {
    key: "removed",
    value: function removed(oldUsage, newUsage) {
      return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
    }
  }, {
    key: "probe",
    value: function probe(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {
        time: true,
        once: true
      });
    }
  }, {
    key: "log",
    value: function log(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);
    }
  }, {
    key: "info",
    value: function info(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.info, arguments);
    }
  }, {
    key: "once",
    value: function once(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole.debug || originalConsole.info, arguments, ONCE);
    }
  }, {
    key: "table",
    value: function table(logLevel, _table, columns) {
      if (_table) {
        return this._getLogFunction(logLevel, _table, console.table || noop, columns && [columns], {
          tag: getTableHeader(_table)
        });
      }

      return noop;
    }
  }, {
    key: "image",
    value: function image(_ref2) {
      var logLevel = _ref2.logLevel,
          priority = _ref2.priority,
          _image = _ref2.image,
          _ref2$message = _ref2.message,
          message = _ref2$message === void 0 ? '' : _ref2$message,
          _ref2$scale = _ref2.scale,
          scale = _ref2$scale === void 0 ? 1 : _ref2$scale;

      if (!this._shouldLog(logLevel || priority)) {
        return noop;
      }

      return _globals.isBrowser ? logImageInBrowser({
        image: _image,
        message: message,
        scale: scale
      }) : logImageInNode({
        image: _image,
        message: message,
        scale: scale
      });
    }
  }, {
    key: "settings",
    value: function settings() {
      if (console.table) {
        console.table(this._storage.config);
      } else {
        console.log(this._storage.config);
      }
    }
  }, {
    key: "get",
    value: function get(setting) {
      return this._storage.config[setting];
    }
  }, {
    key: "set",
    value: function set(setting, value) {
      this._storage.updateConfiguration((0, _defineProperty2.default)({}, setting, value));
    }
  }, {
    key: "time",
    value: function time(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
    }
  }, {
    key: "timeEnd",
    value: function timeEnd(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
    }
  }, {
    key: "timeStamp",
    value: function timeStamp(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.timeStamp || noop);
    }
  }, {
    key: "group",
    value: function group(logLevel, message) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
        collapsed: false
      };
      opts = normalizeArguments({
        logLevel: logLevel,
        message: message,
        opts: opts
      });
      var _opts = opts,
          collapsed = _opts.collapsed;
      opts.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
      return this._getLogFunction(opts);
    }
  }, {
    key: "groupCollapsed",
    value: function groupCollapsed(logLevel, message) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return this.group(logLevel, message, Object.assign({}, opts, {
        collapsed: true
      }));
    }
  }, {
    key: "groupEnd",
    value: function groupEnd(logLevel) {
      return this._getLogFunction(logLevel, '', console.groupEnd || noop);
    }
  }, {
    key: "withGroup",
    value: function withGroup(logLevel, message, func) {
      this.group(logLevel, message)();

      try {
        func();
      } finally {
        this.groupEnd(logLevel)();
      }
    }
  }, {
    key: "trace",
    value: function trace() {
      if (console.trace) {
        console.trace();
      }
    }
  }, {
    key: "_shouldLog",
    value: function _shouldLog(logLevel) {
      return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
    }
  }, {
    key: "_getLogFunction",
    value: function _getLogFunction(logLevel, message, method) {
      var args = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
      var opts = arguments.length > 4 ? arguments[4] : undefined;

      if (this._shouldLog(logLevel)) {
        var _method;

        opts = normalizeArguments({
          logLevel: logLevel,
          message: message,
          args: args,
          opts: opts
        });
        method = method || opts.method;
        (0, _assert2.default)(method);
        opts.total = this.getTotal();
        opts.delta = this.getDelta();
        this._deltaTs = (0, _hiResTimestamp.default)();
        var tag = opts.tag || opts.message;

        if (opts.once) {
          if (!cache[tag]) {
            cache[tag] = (0, _hiResTimestamp.default)();
          } else {
            return noop;
          }
        }

        message = decorateMessage(this.id, opts.message, opts);
        return (_method = method).bind.apply(_method, [console, message].concat((0, _toConsumableArray2.default)(opts.args)));
      }

      return noop;
    }
  }]);
  return Log;
}();

exports.default = Log;
Log.VERSION = _globals.VERSION;

function normalizeLogLevel(logLevel) {
  if (!logLevel) {
    return 0;
  }

  var resolvedLevel;

  switch ((0, _typeof2.default)(logLevel)) {
    case 'number':
      resolvedLevel = logLevel;
      break;

    case 'object':
      resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
      break;

    default:
      return 0;
  }

  (0, _assert2.default)(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
  return resolvedLevel;
}

function normalizeArguments(opts) {
  var logLevel = opts.logLevel,
      message = opts.message;
  opts.logLevel = normalizeLogLevel(logLevel);
  var args = opts.args ? Array.from(opts.args) : [];

  while (args.length && args.shift() !== message) {}

  opts.args = args;

  switch ((0, _typeof2.default)(logLevel)) {
    case 'string':
    case 'function':
      if (message !== undefined) {
        args.unshift(message);
      }

      opts.message = logLevel;
      break;

    case 'object':
      Object.assign(opts, logLevel);
      break;

    default:
  }

  if (typeof opts.message === 'function') {
    opts.message = opts.message();
  }

  var messageType = (0, _typeof2.default)(opts.message);
  (0, _assert2.default)(messageType === 'string' || messageType === 'object');
  return Object.assign(opts, opts.opts);
}

function decorateMessage(id, message, opts) {
  if (typeof message === 'string') {
    var time = opts.time ? (0, _formatters.leftPad)((0, _formatters.formatTime)(opts.total)) : '';
    message = opts.time ? "".concat(id, ": ").concat(time, "  ").concat(message) : "".concat(id, ": ").concat(message);
    message = (0, _color.addColor)(message, opts.color, opts.background);
  }

  return message;
}

function logImageInNode(_ref3) {
  var image = _ref3.image,
      _ref3$message = _ref3.message,
      message = _ref3$message === void 0 ? '' : _ref3$message,
      _ref3$scale = _ref3.scale,
      scale = _ref3$scale === void 0 ? 1 : _ref3$scale;
  var asciify = null;

  try {
    asciify = module.require('asciify-image');
  } catch (error) {}

  if (asciify) {
    return function () {
      return asciify(image, {
        fit: 'box',
        width: "".concat(Math.round(80 * scale), "%")
      }).then(function (data) {
        return console.log(data);
      });
    };
  }

  return noop;
}

function logImageInBrowser(_ref4) {
  var image = _ref4.image,
      _ref4$message = _ref4.message,
      message = _ref4$message === void 0 ? '' : _ref4$message,
      _ref4$scale = _ref4.scale,
      scale = _ref4$scale === void 0 ? 1 : _ref4$scale;

  if (typeof image === 'string') {
    var img = new Image();

    img.onload = function () {
      var _console;

      var args = (0, _formatters.formatImage)(img, message, scale);

      (_console = console).log.apply(_console, (0, _toConsumableArray2.default)(args));
    };

    img.src = image;
    return noop;
  }

  var element = image.nodeName || '';

  if (element.toLowerCase() === 'img') {
    var _console2;

    (_console2 = console).log.apply(_console2, (0, _toConsumableArray2.default)((0, _formatters.formatImage)(image, message, scale)));

    return noop;
  }

  if (element.toLowerCase() === 'canvas') {
    var _img = new Image();

    _img.onload = function () {
      var _console3;

      return (_console3 = console).log.apply(_console3, (0, _toConsumableArray2.default)((0, _formatters.formatImage)(_img, message, scale)));
    };

    _img.src = image.toDataURL();
    return noop;
  }

  return noop;
}

},{"../utils/assert":146,"../utils/autobind":147,"../utils/color":148,"../utils/formatters":149,"../utils/globals":150,"../utils/hi-res-timestamp":151,"../utils/local-storage":152,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/toConsumableArray":28,"@babel/runtime/helpers/typeof":29}],146:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'Assertion failed');
  }
}

},{}],147:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.autobind = autobind;

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function autobind(obj) {
  var predefined = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['constructor'];
  var proto = Object.getPrototypeOf(obj);
  var propNames = Object.getOwnPropertyNames(proto);

  var _iterator = _createForOfIteratorHelper(propNames),
      _step;

  try {
    var _loop = function _loop() {
      var key = _step.value;

      if (typeof obj[key] === 'function') {
        if (!predefined.find(function (name) {
          return key === name;
        })) {
          obj[key] = obj[key].bind(obj);
        }
      }
    };

    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      _loop();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}

},{}],148:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addColor = addColor;
exports.COLOR = void 0;

var _globals = require("./globals");

var COLOR = {
  BLACK: 30,
  RED: 31,
  GREEN: 32,
  YELLOW: 33,
  BLUE: 34,
  MAGENTA: 35,
  CYAN: 36,
  WHITE: 37,
  BRIGHT_BLACK: 90,
  BRIGHT_RED: 91,
  BRIGHT_GREEN: 92,
  BRIGHT_YELLOW: 93,
  BRIGHT_BLUE: 94,
  BRIGHT_MAGENTA: 95,
  BRIGHT_CYAN: 96,
  BRIGHT_WHITE: 97
};
exports.COLOR = COLOR;

function getColor(color) {
  return typeof color === 'string' ? COLOR[color.toUpperCase()] || COLOR.WHITE : color;
}

function addColor(string, color, background) {
  if (!_globals.isBrowser && typeof string === 'string') {
    if (color) {
      color = getColor(color);
      string = "\x1B[".concat(color, "m").concat(string, "\x1B[39m");
    }

    if (background) {
      color = getColor(background);
      string = "\x1B[".concat(background + 10, "m").concat(string, "\x1B[49m");
    }
  }

  return string;
}

},{"./globals":150}],149:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatTime = formatTime;
exports.leftPad = leftPad;
exports.rightPad = rightPad;
exports.formatValue = formatValue;
exports.formatImage = formatImage;

function formatTime(ms) {
  var formatted;

  if (ms < 10) {
    formatted = "".concat(ms.toFixed(2), "ms");
  } else if (ms < 100) {
    formatted = "".concat(ms.toFixed(1), "ms");
  } else if (ms < 1000) {
    formatted = "".concat(ms.toFixed(0), "ms");
  } else {
    formatted = "".concat((ms / 1000).toFixed(2), "s");
  }

  return formatted;
}

function leftPad(string) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  var padLength = Math.max(length - string.length, 0);
  return "".concat(' '.repeat(padLength)).concat(string);
}

function rightPad(string) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  var padLength = Math.max(length - string.length, 0);
  return "".concat(string).concat(' '.repeat(padLength));
}

function formatValue(v) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var EPSILON = 1e-16;
  var _opts$isInteger = opts.isInteger,
      isInteger = _opts$isInteger === void 0 ? false : _opts$isInteger;

  if (Array.isArray(v) || ArrayBuffer.isView(v)) {
    return formatArrayValue(v, opts);
  }

  if (!Number.isFinite(v)) {
    return String(v);
  }

  if (Math.abs(v) < EPSILON) {
    return isInteger ? '0' : '0.';
  }

  if (isInteger) {
    return v.toFixed(0);
  }

  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {
    return v.toFixed(0);
  }

  var string = v.toPrecision(2);
  var decimal = string.indexOf('.0');
  return decimal === string.length - 2 ? string.slice(0, -1) : string;
}

function formatArrayValue(v, opts) {
  var _opts$maxElts = opts.maxElts,
      maxElts = _opts$maxElts === void 0 ? 16 : _opts$maxElts,
      _opts$size = opts.size,
      size = _opts$size === void 0 ? 1 : _opts$size;
  var string = '[';

  for (var i = 0; i < v.length && i < maxElts; ++i) {
    if (i > 0) {
      string += ",".concat(i % size === 0 ? ' ' : '');
    }

    string += formatValue(v[i], opts);
  }

  var terminator = v.length > maxElts ? '...' : ']';
  return "".concat(string).concat(terminator);
}

function formatImage(image, message, scale) {
  var maxWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 600;
  var imageUrl = image.src.replace(/\(/g, '%28').replace(/\)/g, '%29');

  if (image.width > maxWidth) {
    scale = Math.min(scale, maxWidth / image.width);
  }

  var width = image.width * scale;
  var height = image.height * scale;
  var style = ['font-size:1px;', "padding:".concat(Math.floor(height / 2), "px ").concat(Math.floor(width / 2), "px;"), "line-height:".concat(height, "px;"), "background:url(".concat(imageUrl, ");"), "background-size:".concat(width, "px ").concat(height, "px;"), 'color:transparent;'].join('');
  return ["".concat(message, " %c+"), style];
}

},{}],150:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function get() {
    return _globals.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function get() {
    return _globals.window;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function get() {
    return _globals.global;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function get() {
    return _globals.document;
  }
});
Object.defineProperty(exports, "process", {
  enumerable: true,
  get: function get() {
    return _globals.process;
  }
});
Object.defineProperty(exports, "console", {
  enumerable: true,
  get: function get() {
    return _globals.console;
  }
});
exports.isBrowser = exports.VERSION = void 0;

var _isBrowser = _interopRequireDefault(require("../env/is-browser"));

var _globals = require("../env/globals");

var VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'untranspiled source';
exports.VERSION = VERSION;
var isBrowser = (0, _isBrowser.default)();
exports.isBrowser = isBrowser;

},{"../env/globals":140,"../env/is-browser":141,"@babel/runtime/helpers/interopRequireDefault":18}],151:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getHiResTimestamp;

var _globals = require("./globals");

function getHiResTimestamp() {
  var timestamp;

  if (_globals.isBrowser && _globals.window.performance) {
    timestamp = _globals.window.performance.now();
  } else if (_globals.process.hrtime) {
    var timeParts = _globals.process.hrtime();

    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }

  return timestamp;
}

},{"./globals":150}],152:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function getStorage(type) {
  try {
    var storage = window[type];
    var x = '__storage_test__';
    storage.setItem(x, x);
    storage.removeItem(x);
    return storage;
  } catch (e) {
    return null;
  }
}

var LocalStorage = function () {
  function LocalStorage(id, defaultSettings) {
    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'sessionStorage';
    (0, _classCallCheck2.default)(this, LocalStorage);
    this.storage = getStorage(type);
    this.id = id;
    this.config = {};
    Object.assign(this.config, defaultSettings);

    this._loadConfiguration();
  }

  (0, _createClass2.default)(LocalStorage, [{
    key: "getConfiguration",
    value: function getConfiguration() {
      return this.config;
    }
  }, {
    key: "setConfiguration",
    value: function setConfiguration(configuration) {
      this.config = {};
      return this.updateConfiguration(configuration);
    }
  }, {
    key: "updateConfiguration",
    value: function updateConfiguration(configuration) {
      Object.assign(this.config, configuration);

      if (this.storage) {
        var serialized = JSON.stringify(this.config);
        this.storage.setItem(this.id, serialized);
      }

      return this;
    }
  }, {
    key: "_loadConfiguration",
    value: function _loadConfiguration() {
      var configuration = {};

      if (this.storage) {
        var serializedConfiguration = this.storage.getItem(this.id);
        configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
      }

      Object.assign(this.config, configuration);
      return this;
    }
  }]);
  return LocalStorage;
}();

exports.default = LocalStorage;

},{"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/interopRequireDefault":18}],153:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],154:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  define(Gp, "constructor", GeneratorFunctionPrototype);
  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  define(Gp, iteratorSymbol, function() {
    return this;
  });

  define(Gp, "toString", function() {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  typeof module === "object" ? module.exports : {}
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJleGFtcGxlLWRhdGEtbG9hZGluZy9zY3JpcHQuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9Bc3luY0dlbmVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL0F3YWl0VmFsdWUuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRoSG9sZXMuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jR2VuZXJhdG9yRGVsZWdhdGUuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY0l0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2F3YWl0QXN5bmNHZW5lcmF0b3IuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NvbnN0cnVjdC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXNOYXRpdmVGdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVSZXN0LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVTcHJlYWQuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2V0UHJvdG90eXBlT2YuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3dyYXBBc3luY0dlbmVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3dyYXBOYXRpdmVTdXBlci5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvaXRlcmF0b3JzL21ha2UtaXRlcmF0b3IvbWFrZS1hcnJheS1idWZmZXItaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9pdGVyYXRvcnMvbWFrZS1pdGVyYXRvci9tYWtlLWJsb2ItaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9pdGVyYXRvcnMvbWFrZS1pdGVyYXRvci9tYWtlLWl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvaXRlcmF0b3JzL21ha2UtaXRlcmF0b3IvbWFrZS1zdHJlYW0taXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9pdGVyYXRvcnMvbWFrZS1pdGVyYXRvci9tYWtlLXN0cmluZy1pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2l0ZXJhdG9ycy9tYWtlLXN0cmVhbS9tYWtlLWRvbS1zdHJlYW0uanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9pdGVyYXRvcnMvbWFrZS1zdHJlYW0vbWFrZS1zdHJlYW0uanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9qYXZhc2NyaXB0LXV0aWxzL2lzLXR5cGUuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9saWIvYXBpL2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2xpYi9hcGkvbG9hZC1pbi1iYXRjaGVzLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvbGliL2FwaS9sb2FkLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvbGliL2FwaS9wYXJzZS1pbi1iYXRjaGVzLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvbGliL2FwaS9wYXJzZS1zeW5jLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvbGliL2FwaS9wYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2xpYi9hcGkvcmVnaXN0ZXItbG9hZGVycy5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2xpYi9hcGkvc2F2ZS5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2xpYi9hcGkvc2VsZWN0LWxvYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2xpYi9hcGkvc2V0LWxvYWRlci1vcHRpb25zLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvbGliL2ZldGNoL2ZldGNoLWZpbGUuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9saWIvZmV0Y2gvcmVhZC1hcnJheS1idWZmZXIuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9saWIvZmV0Y2gvcmVhZC1maWxlLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvbGliL2ZldGNoL3dyaXRlLWZpbGUuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9saWIvZmlsZXN5c3RlbXMvYnJvd3Nlci1maWxlc3lzdGVtLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvbGliL2xvYWRlci11dGlscy9nZXQtZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2xpYi9sb2FkZXItdXRpbHMvbG9hZGVyLWNvbnRleHQuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9saWIvbG9hZGVyLXV0aWxzL2xvZ2dlcnMuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9saWIvbG9hZGVyLXV0aWxzL25vcm1hbGl6ZS1sb2FkZXIuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9saWIvbG9hZGVyLXV0aWxzL29wdGlvbi1kZWZhdWx0cy5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2xpYi9sb2FkZXItdXRpbHMvb3B0aW9uLXV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvbGliL3Byb2dyZXNzL2ZldGNoLXByb2dyZXNzLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvbGliL3V0aWxzL21pbWUtdHlwZS11dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2xpYi91dGlscy9yZXNvdXJjZS11dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2xpYi91dGlscy9yZXNwb25zZS11dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L251bGwtbG9hZGVyLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2Nzdi9kaXN0L2VzNS9jc3YtbG9hZGVyLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2Nzdi9kaXN0L2VzNS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jc3YvZGlzdC9lczUvbGliL2FzeW5jLWl0ZXJhdG9yLXN0cmVhbWVyLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2Nzdi9kaXN0L2VzNS9saWJzL3BhcGFwYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9lczUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzL2Rpc3QvZXM1L2pzb24tbG9hZGVyLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscy9kaXN0L2VzNS9saWIvYmluYXJ5LXV0aWxzL2FycmF5LWJ1ZmZlci11dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9lczUvbGliL2JpbmFyeS11dGlscy9iaW5hcnktY29weS11dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9lczUvbGliL2JpbmFyeS11dGlscy9idWZmZXItdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzL2Rpc3QvZXM1L2xpYi9iaW5hcnktdXRpbHMvZW5jb2RlLXV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscy9kaXN0L2VzNS9saWIvYmluYXJ5LXV0aWxzL2dldC1maXJzdC1jaGFyYWN0ZXJzLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscy9kaXN0L2VzNS9saWIvYmluYXJ5LXV0aWxzL21lbW9yeS1jb3B5LXV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscy9kaXN0L2VzNS9saWIvZW52LXV0aWxzL2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9lczUvbGliL2Vudi11dGlscy9nbG9iYWxzLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscy9kaXN0L2VzNS9saWIvaXRlcmF0b3JzL2FzeW5jLWl0ZXJhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9lczUvbGliL2l0ZXJhdG9ycy90ZXh0LWl0ZXJhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9lczUvbGliL3BhcnNlci11dGlscy9wYXJzZS1qc29uLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscy9kaXN0L2VzNS9saWIvcGF0aC11dGlscy9maWxlLWFsaWFzZXMuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzL2Rpc3QvZXM1L2xpYi9wYXRoLXV0aWxzL3BhdGguanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzL2Rpc3QvZXM1L2xpYi9yZXF1ZXN0LXV0aWxzL3JlcXVlc3Qtc2NoZWR1bGVyLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscy9kaXN0L2VzNS9saWIvd29ya2VyLWxvYWRlci11dGlscy9jcmVhdGUtbG9hZGVyLXdvcmtlci5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9lczUvbGliL3dvcmtlci1sb2FkZXItdXRpbHMvcGFyc2Utd2l0aC13b3JrZXIuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvc2NoZW1hL2Rpc3QvZXM1L2NhdGVnb3J5L21lc2gvbWVzaC11dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9zY2hlbWEvZGlzdC9lczUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvc2NoZW1hL2Rpc3QvZXM1L2xpYi9zY2hlbWEtdXRpbHMvZGVkdWNlLXRhYmxlLXNjaGVtYS5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9zY2hlbWEvZGlzdC9lczUvbGliL3NjaGVtYS11dGlscy9nZXQtdHlwZS1pbmZvLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3NjaGVtYS9kaXN0L2VzNS9saWIvc2NoZW1hLXV0aWxzL3R5cGUtdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvc2NoZW1hL2Rpc3QvZXM1L2xpYi9zY2hlbWEvaW1wbC9lbnVtLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3NjaGVtYS9kaXN0L2VzNS9saWIvc2NoZW1hL2ltcGwvZmllbGQuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvc2NoZW1hL2Rpc3QvZXM1L2xpYi9zY2hlbWEvaW1wbC9zY2hlbWEuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvc2NoZW1hL2Rpc3QvZXM1L2xpYi9zY2hlbWEvaW1wbC90eXBlLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3NjaGVtYS9kaXN0L2VzNS9saWIvc2NoZW1hL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3NjaGVtYS9kaXN0L2VzNS9saWIvdGFibGUvYmFzZS10YWJsZS1iYXRjaC1hZ2dyZWdhdG9yLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3NjaGVtYS9kaXN0L2VzNS9saWIvdGFibGUvY29sdW1uYXItdGFibGUtYmF0Y2gtYWdncmVnYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9zY2hlbWEvZGlzdC9lczUvbGliL3RhYmxlL3Jvdy10YWJsZS1iYXRjaC1hZ2dyZWdhdG9yLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3NjaGVtYS9kaXN0L2VzNS9saWIvdGFibGUvdGFibGUtYmF0Y2gtYnVpbGRlci5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9zY2hlbWEvZGlzdC9lczUvbGliL3V0aWxzL2FzeW5jLXF1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3NjaGVtYS9kaXN0L2VzNS9saWIvdXRpbHMvcm93LXV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2VzNS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9lczUvbGliL2FzeW5jLXF1ZXVlL2FzeW5jLXF1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2VzNS9saWIvZW52LXV0aWxzL2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9lczUvbGliL2Vudi11dGlscy9nbG9iYWxzLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2VzNS9saWIvZW52LXV0aWxzL3ZlcnNpb24uanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvd29ya2VyLXV0aWxzL2Rpc3QvZXM1L2xpYi9saWJyYXJ5LXV0aWxzL2xpYnJhcnktdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvd29ya2VyLXV0aWxzL2Rpc3QvZXM1L2xpYi93b3JrZXItYXBpL2NyZWF0ZS13b3JrZXIuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvd29ya2VyLXV0aWxzL2Rpc3QvZXM1L2xpYi93b3JrZXItYXBpL2dldC13b3JrZXItdXJsLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2VzNS9saWIvd29ya2VyLWFwaS9wcm9jZXNzLW9uLXdvcmtlci5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9lczUvbGliL3dvcmtlci1hcGkvdmFsaWRhdGUtd29ya2VyLXZlcnNpb24uanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvd29ya2VyLXV0aWxzL2Rpc3QvZXM1L2xpYi93b3JrZXItZmFybS93b3JrZXItYm9keS5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9lczUvbGliL3dvcmtlci1mYXJtL3dvcmtlci1mYXJtLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2VzNS9saWIvd29ya2VyLWZhcm0vd29ya2VyLWpvYi5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9lczUvbGliL3dvcmtlci1mYXJtL3dvcmtlci1wb29sLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2VzNS9saWIvd29ya2VyLWZhcm0vd29ya2VyLXRocmVhZC5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9lczUvbGliL3dvcmtlci11dGlscy9nZXQtbG9hZGFibGUtd29ya2VyLXVybC5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9lczUvbGliL3dvcmtlci11dGlscy9nZXQtdHJhbnNmZXItbGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9lczUvbGliL3dvcmtlci11dGlscy9yZW1vdmUtbm9udHJhbnNmZXJhYmxlLW9wdGlvbnMuanMiLCJub2RlX21vZHVsZXMvQHByb2JlLmdsL3N0YXRzL2Rpc3QvZXM1L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0Bwcm9iZS5nbC9zdGF0cy9kaXN0L2VzNS9saWIvc3RhdC5qcyIsIm5vZGVfbW9kdWxlcy9AcHJvYmUuZ2wvc3RhdHMvZGlzdC9lczUvbGliL3N0YXRzLmpzIiwibm9kZV9tb2R1bGVzL0Bwcm9iZS5nbC9zdGF0cy9kaXN0L2VzNS91dGlscy9oaS1yZXMtdGltZXN0YW1wLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9oeXBlcnNjcmlwdC1hdHRyaWJ1dGUtdG8tcHJvcGVydHkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaHlwZXJ4L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL25hbm9odG1sL2xpYi9hcHBlbmQtY2hpbGQuanMiLCJub2RlX21vZHVsZXMvbmFub2h0bWwvbGliL2Jvb2wtcHJvcHMuanMiLCJub2RlX21vZHVsZXMvbmFub2h0bWwvbGliL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvbmFub2h0bWwvbGliL2RpcmVjdC1wcm9wcy5qcyIsIm5vZGVfbW9kdWxlcy9uYW5vaHRtbC9saWIvZG9tLmpzIiwibm9kZV9tb2R1bGVzL25hbm9odG1sL2xpYi9zdmctdGFncy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9iZS5nbC9kaXN0L2VzNS9lbnYvZ2V0LWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHJvYmUuZ2wvZGlzdC9lczUvZW52L2dsb2JhbHMuanMiLCJub2RlX21vZHVsZXMvcHJvYmUuZ2wvZGlzdC9lczUvZW52L2lzLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHJvYmUuZ2wvZGlzdC9lczUvZW52L2lzLWVsZWN0cm9uLmpzIiwibm9kZV9tb2R1bGVzL3Byb2JlLmdsL2Rpc3QvZXM1L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb2JlLmdsL2Rpc3QvZXM1L2luaXQuanMiLCJub2RlX21vZHVsZXMvcHJvYmUuZ2wvZGlzdC9lczUvbGliL2xvZy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9iZS5nbC9kaXN0L2VzNS91dGlscy9hc3NlcnQuanMiLCJub2RlX21vZHVsZXMvcHJvYmUuZ2wvZGlzdC9lczUvdXRpbHMvYXV0b2JpbmQuanMiLCJub2RlX21vZHVsZXMvcHJvYmUuZ2wvZGlzdC9lczUvdXRpbHMvY29sb3IuanMiLCJub2RlX21vZHVsZXMvcHJvYmUuZ2wvZGlzdC9lczUvdXRpbHMvZm9ybWF0dGVycy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9iZS5nbC9kaXN0L2VzNS91dGlscy9nbG9iYWxzLmpzIiwibm9kZV9tb2R1bGVzL3Byb2JlLmdsL2Rpc3QvZXM1L3V0aWxzL2hpLXJlcy10aW1lc3RhbXAuanMiLCJub2RlX21vZHVsZXMvcHJvYmUuZ2wvZGlzdC9lczUvdXRpbHMvbG9jYWwtc3RvcmFnZS5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUNnQkE7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7OztBQWxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBMkIsSUFBM0I7QUFBQSxJQUFPLE1BQVAsU0FBTyxNQUFQO0FBQUEsSUFBZSxRQUFmLFNBQWUsUUFBZixDLENBQ0E7O0FBS0EsSUFBSSxHQUFKO0FBQ0EsSUFBSSxTQUFKO0FBQ0EsSUFBSSxPQUFPLEdBQUcsVUFBZDtBQUVBLElBQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyxRQUFQLENBQWdCLElBQWhCLENBQXFCLE9BQXJCLENBQTZCLHdCQUE3QixFQUF1RCxFQUF2RCxDQUFoQjtBQUVBLElBQU0sV0FBVywyQkFBakI7QUFFQSxJQUFNLFdBQVcsMkJBQWpCLEMsQ0FFQTs7QUFDQSxJQUFNLFFBQVEsR0FBRyxDQUFDO0FBQ2hCLEVBQUEsS0FBSyxFQUFFLFdBRFM7QUFDSTtBQUNwQixFQUFBLEVBQUUsRUFBRSxXQUZZO0FBRUE7QUFDaEIsRUFBQSxHQUFHLEVBQUUsV0FIVztBQUloQixFQUFBLFVBQVUsRUFBRSxLQUpJO0FBS2hCLEVBQUEsUUFBUSxFQUFFLGNBTE0sQ0FLUzs7QUFMVCxDQUFELEVBTWQ7QUFDRCxFQUFBLEtBQUssRUFBRSxRQUROO0FBRUQsRUFBQSxFQUFFLEVBQUUsUUFGSDtBQUdELEVBQUEsR0FBRyxFQUFFLFFBSEo7QUFJRCxFQUFBLFVBQVUsRUFBRTtBQUpYLENBTmMsRUFZaEI7QUFDQyxFQUFBLEtBQUssRUFBRSxTQURSO0FBRUMsRUFBQSxFQUFFLEVBQUUsU0FGTDtBQUdDLEVBQUEsR0FBRyxFQUFFLFNBSE47QUFJQyxFQUFBLFVBQVUsRUFBRTtBQUpiLENBWmdCLENBQWpCO0FBb0JBLElBQU0sUUFBUSxHQUFHLENBQUM7QUFDaEIsRUFBQSxLQUFLLEVBQUUsa0JBRFM7QUFFaEIsRUFBQSxFQUFFLEVBQUUsVUFGWTtBQUdoQixFQUFBLEdBQUcsRUFBRSxFQUhXO0FBSWhCLEVBQUEsU0FBUyxFQUFFLFlBSks7QUFLaEIsRUFBQSxPQUFPLEVBQUUsWUFMTztBQU1oQixFQUFBLFFBQVEsRUFBRSxDQUFDLFlBQUQsRUFBZSxXQUFmLEVBQTRCLGNBQTVCO0FBTk0sQ0FBRCxDQUFqQjtBQVNBLFFBQVEsQ0FBQyxPQUFULENBQWlCLFVBQUMsT0FBRCxFQUFVLENBQVYsRUFBZ0I7QUFDL0IsTUFBTSxHQUFHLGFBQU0sT0FBTixTQUFnQixXQUFoQixTQUE4QixPQUFPLENBQUMsR0FBdEMscUJBQVQ7QUFDQSxFQUFBLE9BQU8sQ0FBQyxLQUFSLEdBQWdCLENBQUUsR0FBRixDQUFoQjtBQUNBLEVBQUEsT0FBTyxDQUFDLFFBQVIsR0FBbUIsS0FBbkI7QUFDQSxFQUFBLE9BQU8sQ0FBQyxRQUFSLEdBQW1CLElBQUksS0FBSixDQUFVLE9BQU8sQ0FBQyxVQUFsQixFQUE4QixJQUE5QixDQUFtQyxDQUFuQyxFQUFzQyxHQUF0QyxDQUEwQyxVQUFDLENBQUQsRUFBSSxDQUFKO0FBQUEsV0FBVSxJQUFJLENBQUMsTUFBTCxFQUFWO0FBQUEsR0FBMUMsQ0FBbkI7QUFDRCxDQUxEO0FBT0EsSUFBTSxRQUFRLEdBQUcsR0FBakI7QUFDQSxJQUFJLGdCQUFnQixHQUFHLENBQXZCO0FBQ0EsY0FBYyxDQUFDLFdBQUQsQ0FBZCxDLENBQ0E7O0FBRUEsT0FBTyxDQUFDLEdBQVIsQ0FBWSxVQUFaLEVBQXdCLFFBQXhCLEVBQWtDLFNBQWxDO0FBRUEsSUFBTSxNQUFNLE9BQUcsb0JBQUgsNklBQVo7O0FBQ0EsSUFBTSxZQUFZLEdBQUcsU0FBZixZQUFlO0FBQUEsTUFBQyxJQUFELHVFQUFRLElBQVI7QUFBQSwyRkFBMEYsSUFBMUY7QUFBQSxDQUFyQjs7QUFDQSxJQUFNLE1BQU0sR0FBRyxRQUFRLENBQUMsYUFBVCxDQUF1QixLQUF2QixDQUFmO0FBRUEsSUFBTSxTQUFTLE9BQUcsb0JBQUgsME1BQ3FCLFVBQUMsQ0FBRCxFQUFPO0FBQUUsRUFBQSxjQUFjLENBQUMsQ0FBQyxDQUFDLE1BQUYsQ0FBUyxLQUFWLENBQWQ7QUFBK0IsQ0FEN0QsRUFFWixRQUFRLENBQUMsR0FBVCxDQUFhLFVBQUMsT0FBRDtBQUFBLGFBQWEsb0JBQWIsa0hBQW1DLE9BQU8sQ0FBQyxFQUEzQyxFQUFrRCxPQUFPLENBQUMsRUFBUixLQUFlLFNBQVMsQ0FBQyxFQUF6QixHQUE0QixVQUE1QixHQUF1QyxFQUF6RixFQUErRixPQUFPLENBQUMsS0FBdkc7QUFBQSxDQUFiLENBRlksQ0FBZjtBQUtBLE1BQU0sQ0FBQyxXQUFQLENBQW1CLFNBQW5CO0FBQ0EsTUFBTSxDQUFDLFdBQVAsQ0FBbUIsTUFBbkIsRSxDQUdBO0FBQ0E7QUFDQTtBQUNBOztTQUNlLE87Ozs7O3FFQUFmO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNFLFlBQUEsZ0JBQWdCO0FBQ2hCLGdCQUFHLGdCQUFnQixHQUFHLFFBQXRCLEVBQWdDLGdCQUFnQixHQUFHLENBQW5CO0FBQzFCLFlBQUEsQ0FIUixHQUdZLElBQUksSUFBSixFQUhaO0FBSUUsWUFBQSxDQUFDLENBQUMsT0FBRixDQUFVLENBQUMsUUFBRCxHQUFZLGdCQUF0QjtBQUNNLFlBQUEsT0FMUixHQUtrQixDQUFDLENBQUMsa0JBQUYsQ0FBcUIsT0FBckIsQ0FMbEIsRUFLZ0Q7O0FBQzlDLFlBQUEsTUFBTSxDQUFDLFNBQVAsR0FBbUIsWUFBWSxDQUFDLE9BQUQsQ0FBL0I7QUFORjtBQUFBLG1CQU93QiwwQkFBUSxPQUFSLFNBQWtCLFdBQWxCLFNBQWdDLE9BQWhDLGNBQTJDLFNBQVMsQ0FBQyxFQUFyRCw2QkFBMEUsT0FBMUUsV0FBeUYsY0FBekYsQ0FQeEI7O0FBQUE7QUFPUSxZQUFBLE9BUFI7QUFRRTtBQUNBLFlBQUEsU0FBUyxDQUFDLFFBQVYsR0FBc0IsU0FBUyxDQUFDLFFBQVYsQ0FBbUIsR0FBbkIsQ0FBdUIsVUFBQyxDQUFELEVBQUksQ0FBSjtBQUFBLHFCQUFVLE9BQU8sQ0FBQyxDQUFELENBQVAsQ0FBVyxRQUFyQjtBQUFBLGFBQXZCLENBQXRCLENBVEYsQ0FVQTtBQUNBOztBQUNFLFlBQUEsTUFBTTs7QUFaUjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHOzs7O0FBY0EsT0FBTzs7QUFFUCxTQUFTLGNBQVQsQ0FBeUIsRUFBekIsRUFBNkI7QUFDM0IsRUFBQSxRQUFRLENBQUMsT0FBVCxDQUFpQixVQUFDLE9BQUQsRUFBYTtBQUM1QixRQUFHLE9BQU8sQ0FBQyxFQUFSLEtBQWUsRUFBbEIsRUFBc0I7QUFDcEIsTUFBQSxPQUFPLENBQUMsT0FBUixHQUFrQixJQUFsQjtBQUNBLE1BQUEsU0FBUyxHQUFHLE9BQVo7QUFDRCxLQUhELE1BR087QUFDTCxNQUFBLE9BQU8sQ0FBQyxPQUFSLEdBQWtCLEtBQWxCO0FBQ0Q7QUFDRixHQVBEO0FBUUQ7O0FBRUQsU0FBUyxNQUFULEdBQW1CO0FBQ2pCO0FBQ0EsTUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLEdBQVQsQ0FBYSxVQUFDLE9BQUQ7QUFBQSxXQUFhLElBQUksUUFBSixDQUFhO0FBQ3BEO0FBQ0EsTUFBQSxFQUFFLEVBQUUsT0FBTyxDQUFDLEVBRndDO0FBR3BELE1BQUEsSUFBSSxFQUFFLE9BQU8sQ0FBQyxLQUhzQztBQUlwRCxNQUFBLFFBQVEsRUFBRSxPQUFPLENBQUMsT0FKa0M7QUFLcEQsTUFBQSxZQUFZLEVBQUUsc0JBQUMsR0FBRCxFQUFTO0FBQ3JCO0FBQ0EsWUFBTSxDQUFDLEdBQUcsT0FBTyxDQUFDLFFBQVIsQ0FBaUIsR0FBRyxDQUFDLEVBQXJCLENBQVY7QUFDRCxlQUFPLENBQUMsQ0FBQyxHQUFHLEdBQUwsRUFBVSxDQUFDLEdBQUcsR0FBZCxFQUFtQixDQUFDLEdBQUcsR0FBdkIsQ0FBUCxDQUhzQixDQUl0QjtBQUNBLE9BVm1EO0FBV3BELE1BQUEsWUFBWSxFQUFFLENBWHNDO0FBWXRELE1BQUEsV0FBVyxFQUFFO0FBQ1gsUUFBQSxZQUFZLEVBQUU7QUFESCxPQVp5QztBQWV0RCxNQUFBLGNBQWMsRUFBRTtBQUNkO0FBQ0EsUUFBQSxZQUFZLEVBQUUsQ0FBQyxnQkFBRDtBQUZBLE9BZnNDO0FBbUJ0RCxNQUFBLE9BQU8sRUFBRSxPQUFPLENBQUMsT0FuQnFDO0FBb0J0RCxNQUFBLGtCQUFrQixFQUFFLENBcEJrQztBQXFCdEQsTUFBQSxPQUFPLEVBQUUsRUFyQjZDO0FBc0J0RCxNQUFBLE9BQU8sRUFBRTtBQXRCNkMsS0FBYixDQUFiO0FBQUEsR0FBYixDQUFmO0FBeUJBLEVBQUEsR0FBRyxDQUFDLFFBQUosQ0FBYTtBQUFDLElBQUEsTUFBTSxFQUFFO0FBQVQsR0FBYjtBQUNEOztBQUNELEdBQUcsR0FBRyxJQUFJLE1BQUosQ0FBVztBQUVmLEVBQUEsZ0JBQWdCLEVBQUU7QUFDaEI7QUFDQSxJQUFBLFFBQVEsRUFBRSxpQkFGTTtBQUdoQixJQUFBLFNBQVMsRUFBRSxnQkFISztBQUloQjtBQUNEO0FBQ0M7QUFDQSxJQUFBLElBQUksRUFBRSxDQVBVO0FBUWhCLElBQUEsT0FBTyxFQUFFLEVBUk87QUFTaEIsSUFBQSxLQUFLLEVBQUUsRUFUUztBQVVoQixJQUFBLE9BQU8sRUFBRTtBQVZPLEdBRkg7QUFjZixFQUFBLFVBQVUsRUFBRSxJQWRHO0FBZWYsRUFBQSxVQUFVLEVBQUUsMEJBQWdCO0FBQUEsUUFBYixNQUFhLFFBQWIsTUFBYTs7QUFDMUIsUUFBRyxNQUFILEVBQVc7QUFDVCxNQUFBLE9BQU8sQ0FBQyxHQUFSLENBQVksTUFBWjtBQUVBLHVCQUFVLE1BQU0sQ0FBQyxVQUFQLENBQWtCLEdBQTVCLHVCQUE0QyxTQUFTLENBQUMsUUFBVixDQUFtQixNQUFNLENBQUMsRUFBMUIsQ0FBNUM7QUFDRDs7QUFDRCxXQUFPLElBQVA7QUFDRCxHQXRCYyxDQXVCZjs7QUF2QmUsQ0FBWCxDQUFOO0FBMEJBLFdBQVcsQ0FBQyxZQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0YsRUFBQSxPQUFPLEdBUlcsQ0FTakI7QUFDQSxDQVZVLEVBVVIsSUFWUSxDQUFYO0FBYUEsUUFBUSxDQUFDLElBQVQsQ0FBYyxXQUFkLENBQTBCLE1BQTFCLEUsQ0FFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9TQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5a0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2piQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2M0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyQkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIi8qXG4qIFRvIGRvOlxuKiAtIGhvdyB0byB1cGRhdGUgdG9vbHRpcCB3aGVuIGRhdGUgaXMgdXBkYXRlZD8gXG4qIC0gZGVmaW5pdGlvbiBmaWxlIGZvciBkYXRhc2V0c1xuKiAtIG1ha2UgZGF0YXNldCBmaWxlcyB0aGF0IG9ubHkgY29udGFpbiB2YWx1ZXMsIG5vdCBnZW9pZFxuKiAtIGltcGxlbWVudCBzdGFydCBkYXRlIGFuZCBlbmQgZGF0ZVxuKiAtIGFkZCBzYW1wbGUgZGF0YSBmb3IgdGltZXNlcmllc1xuKiAtIGxvYWRpbmcgc3Bpbm5lciB3aGlsZSBkYXRhIGlzIGxvYWRpbmdcbiogLSBzaG93IHNlbGVjdGVkIGVsZW1lbnRzIGFzIHNlcGFyYXRlIGFycmF5XG4qIFxuKiBhc3N1bXB0aW9uczogZ2VvIGlkIGluIHRpbGVzZXQgcmVmZXJzIHRvIGRhdGEgb3JkZXIgKD8pXG4qIGFyZSB0aGVyZSBkYXRhc2V0cyB0aGF0IG9ubHkgZXhpc3QgYXQgY2VydGFpbiBnZW9sZXZlbHM/XG4qIGh0dHBzOi8vZGVjay5nbC9kb2NzL2FwaS1yZWZlcmVuY2UvZ2VvLWxheWVycy9tdnQtbGF5ZXJcbiovXG5jb25zdCB7RGVja0dMLCBNVlRMYXllcn0gPSBkZWNrO1xuLy9pbXBvcnQgeyBjc3YgfSBmcm9tICdkMydcbmltcG9ydCB7bG9hZH0gZnJvbSAnQGxvYWRlcnMuZ2wvY29yZSc7XG5pbXBvcnQge0NTVkxvYWRlcn0gZnJvbSAnQGxvYWRlcnMuZ2wvY3N2JztcbmltcG9ydCBodG1sIGZyb20gJ25hbm9odG1sJ1xuXG5sZXQgdml6XG5sZXQgZ2VvUmVnaW9uXG5sZXQgZGF0YXNldCA9ICdtb2JpbGl0eSdcblxuY29uc3QgYmFzZVVSTCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLnJlcGxhY2UoJy9leGFtcGxlLWRhdGEtbG9hZGluZy8nLCAnJylcblxuY29uc3QgZGF0YXNldFBhdGggPSBgL3NhbXBsZS1kYXRhL2RhdGFzZXRzL2BcblxuY29uc3QgdGlsZXNldFBhdGggPSBgL3NhbXBsZS1kYXRhL3RpbGVzZXRzL2BcblxuLy8gc2V0cyBvZiB2ZWN0b3IgdGlsZXNldHMgcmVwcmVzZW50aW5nIGRpZmZlcmVudCBnZW8tcmVnaW9uc1xuY29uc3QgdGlsZXNldHMgPSBbe1xuICBsYWJlbDogJ2dlbWVpbmRlbicsIC8vIFxuICBpZDogJ2dlbWVpbmRlbicsLy8gXG4gIHVybDogJ2dlbWVpbmRlbicsXG4gIG51bUVudHJpZXM6IDExNDMxLFxuICBpZExvb2t1cDogJ215TG9va3VwLmNzdicgLy8gbm90IHlldCBpbXBsZW1lbnRlZCwgYSBjc3YgZmlsZSB3aXRoIGFuIGFycmF5LCB3aGVyZSBlYWNoIHZhbHVlIGluIHRoZSBhcnJheSBpcyBhIGdlb2dyYXBoaWNJZC4gQWxsIGRhdGFzZXRzIHRoYXQgdXNlIHRoaXMgZ2VvZGF0YSBzaG91bGQgaGF2ZSB2YWx1ZXMgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhpcyBhcnJheS5cbn0sIHtcbiAgbGFiZWw6ICdrcmVpc2UnLFxuICBpZDogJ2tyZWlzZScsXG4gIHVybDogJ2tyZWlzZScsXG4gIG51bUVudHJpZXM6IDQzMlxufSxcbiB7XG4gIGxhYmVsOiAnbGFlbmRlcicsXG4gIGlkOiAnbGFlbmRlcicsXG4gIHVybDogJ2xhZW5kZXInLFxuICBudW1FbnRyaWVzOiAzNFxufVxuXVxuXG5jb25zdCBkYXRhc2V0cyA9IFt7XG4gIGxhYmVsOiAnTW9iaWxpdHkgYnkgRGF0ZScsXG4gIGlkOiAnbW9iaWxpdHknLFxuICB1cmw6ICcnLFxuICBzdGFydERhdGU6ICcyMDIxLTA1LTIzJyxcbiAgZW5kRGF0ZTogJzIwMjEtMDgtMzAnLFxuICB0aWxlc2V0czogWydsYWVuZGVyZ2VvJywgJ2tyZWlzZWdlbycsICdnZW1laW5kZW5nZW8nXVxufV1cblxudGlsZXNldHMuZm9yRWFjaCgodGlsZXNldCwgaSkgPT4ge1xuICBjb25zdCBVUkwgPSBgJHtiYXNlVVJMfSR7dGlsZXNldFBhdGh9JHt0aWxlc2V0LnVybH0ve3p9L3t4fS97eX0ucGJmYFxuICB0aWxlc2V0LnRpbGVzID0gWyBVUkwgXVxuICB0aWxlc2V0LnZpc2liaWxlID0gZmFsc2VcbiAgdGlsZXNldC5tb2JpbGl0eSA9IG5ldyBBcnJheSh0aWxlc2V0Lm51bUVudHJpZXMpLmZpbGwoMCkubWFwKChfLCBpKSA9PiBNYXRoLnJhbmRvbSgpKVxufSlcblxuY29uc3QgbnVtRGF0ZXMgPSAxMDBcbmxldCBjdXJyZW50RGF0ZUluZGV4ID0gMFxuc2VsZWN0R2VvTGV2ZWwoJ2dlbWVpbmRlbicpXG4vL2dlb1JlZ2lvbiA9IHRpbGVzZXRzWzBdXG5cbmNvbnNvbGUubG9nKCdiYXNlIHVybCcsIHRpbGVzZXRzLCBnZW9SZWdpb24pXG5cbmNvbnN0IGZvb3RlciA9IGh0bWxgPGRpdiBzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlO2JvdHRvbTowcHg7cmlnaHQ6MHB4O3dpZHRoOjEwMCVcIj48L2Rpdj5gXG5jb25zdCBnZW5lcmF0ZURhdGUgPSAoZGF0ZSA9ICdoaScpID0+IGA8ZGl2IHN0eWxlPVwiZm9udC1zaXplOjRyZW07Y29sb3I6d2hpdGU7YmFja2dyb3VuZDpyZ2JhKDAsIDAsIDAsIDAuNClcIj4ke2RhdGV9PC9kaXY+YFxuY29uc3QgZGF0ZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcblxuY29uc3QgZ2VvU2VsZWN0ID0gaHRtbGA8bGFiZWwgZm9yPVwiZ2VvbGV2ZWxcIj5TZWxlY3QgbWFwIGdlbyBsZXZlbDwvbGFiZWw+XG48c2VsZWN0IGxhYmVsPVwiZ2VvbGV2ZWxcIiBvbmNoYW5nZT0keyhlKSA9PiB7IHNlbGVjdEdlb0xldmVsKGUudGFyZ2V0LnZhbHVlKX19IGlkPVwiZ2VvbGV2ZWxcIj5cbiAke3RpbGVzZXRzLm1hcCgodGlsZXNldCkgPT4gaHRtbGA8b3B0aW9uIHZhbHVlPVwiJHt0aWxlc2V0LmlkfVwiICR7dGlsZXNldC5pZCA9PT0gZ2VvUmVnaW9uLmlkPydzZWxlY3RlZCc6Jyd9PiR7dGlsZXNldC5sYWJlbH08L29wdGlvbj5gKX1cbjwvc2VsZWN0PmBcblxuZm9vdGVyLmFwcGVuZENoaWxkKGdlb1NlbGVjdClcbmZvb3Rlci5hcHBlbmRDaGlsZChkYXRlRWwpXG5cblxuLy8gb3B0aW1pemF0aW9ucyBmb3IgdGhpczogbG9hZCBkaXJlY3RseSBhcyBhbiBhcnJheSBhbmQgZG8gbm90IHBhcnNlIGludG8gb2JqZWN0c1xuLy8gc3RvcmUgYWxyZWFkeSBsb2FkZWQgZGF0YSBpbiBzb21lIHdheSBhbmQgb25seSBsb2FkIG5ldyBkYXRhIGFzIG5lY2Vzc2FyeVxuLy8gcmVhZCBtb3JlIGFib3V0IGRlY2tnbCAvIHdlYmdsIHBlcmZvcm1hbmNlXG4vLyBzaG93IGxvYWRpbmcgYW5pbWF0aW9uIHdoaWxlIGxvYWRpbmdcbmFzeW5jIGZ1bmN0aW9uIGdldERhdGEoKSB7XG4gIGN1cnJlbnREYXRlSW5kZXgrK1xuICBpZihjdXJyZW50RGF0ZUluZGV4ID4gbnVtRGF0ZXMpIGN1cnJlbnREYXRlSW5kZXggPSAwXG4gIGNvbnN0IGQgPSBuZXcgRGF0ZSgpXG4gIGQuc2V0RGF0ZSgtbnVtRGF0ZXMgKyBjdXJyZW50RGF0ZUluZGV4KVxuICBjb25zdCBkYXRlU3RyID0gZC50b0xvY2FsZURhdGVTdHJpbmcoJ2VuLUNBJykgLy9kYXRlLmZvcm1hdChkLCAnWVlZWS1NTS1ERCcpXG4gIGRhdGVFbC5pbm5lckhUTUwgPSBnZW5lcmF0ZURhdGUoZGF0ZVN0cilcbiAgY29uc3QgbmV3RGF0YSA9IGF3YWl0IGxvYWQoYCR7YmFzZVVSTH0ke2RhdGFzZXRQYXRofSR7ZGF0YXNldH0vJHtnZW9SZWdpb24uaWR9L3ZhbHVlcy1ieS1kYXRlLyR7ZGF0ZVN0cn0uY3N2YCwgQ1NWTG9hZGVyKTtcbiAgLy8gY29uc29sZS5sb2coJ2xvYWRlZCcsIG5ld0RhdGEsIGdlb1JlZ2lvbilcbiAgZ2VvUmVnaW9uLm1vYmlsaXR5ID0gIGdlb1JlZ2lvbi5tb2JpbGl0eS5tYXAoKF8sIGkpID0+IG5ld0RhdGFbaV0ubW9iaWxpdHkpXG4vL2dlbWVpbmRlbjogbmV3IEFycmF5KDExNDMxKS5maWxsKDApLm1hcCgoXywgaSkgPT4gTWF0aC5yYW5kb20oKSksXG4vL2tyZWlzZTogbmV3IEFycmF5KDQzMikuZmlsbCgwKS5tYXAoKF8sIGkpID0+IE1hdGgucmFuZG9tKCkpXG4gIHJlbmRlcigpXG59XG5nZXREYXRhKClcblxuZnVuY3Rpb24gc2VsZWN0R2VvTGV2ZWwgKGlkKSB7XG4gIHRpbGVzZXRzLmZvckVhY2goKHRpbGVzZXQpID0+IHtcbiAgICBpZih0aWxlc2V0LmlkID09PSBpZCkge1xuICAgICAgdGlsZXNldC52aXNpYmxlID0gdHJ1ZVxuICAgICAgZ2VvUmVnaW9uID0gdGlsZXNldFxuICAgIH0gZWxzZSB7XG4gICAgICB0aWxlc2V0LnZpc2libGUgPSBmYWxzZVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgLy8gY29uc29sZS5sb2codGlsZXNldHMsICd0aWxlc2V0cycpXG4gIGNvbnN0IGxheWVycyA9IHRpbGVzZXRzLm1hcCgodGlsZXNldCkgPT4gbmV3IE1WVExheWVyKHtcbiAgICAvLyBpZDogdGlsZXNldC5pZCxcbiAgICBpZDogdGlsZXNldC5pZCxcbiAgICBkYXRhOiB0aWxlc2V0LnRpbGVzLFxuICAgIHBpY2thYmxlOiB0aWxlc2V0LnZpc2libGUsXG4gICAgZ2V0RmlsbENvbG9yOiAob2JqKSA9PiB7XG4gICAgICAvL2NvbnNvbGUubG9nKCdnZXR0aW5nIG1vYmlsaXR5IGF0Jywgb2JqLmlkLCB0aWxlc2V0Lm1vYmlsaXR5KVxuICAgICAgY29uc3QgaiA9IHRpbGVzZXQubW9iaWxpdHlbb2JqLmlkXVxuICAgICByZXR1cm4gW2ogKiAyNTUsIGogKiAyNTUsIGogKiAyNTVdXG4gICAgIC8vcmV0dXJuIFtNYXRoLnJhbmRvbSgpICogMjU1LCBNYXRoLnJhbmRvbSgpICogMjU1LCBNYXRoLnJhbmRvbSgpICogMjU1XVxuICAgIH0sIFxuICAgIGdldExpbmVXaWR0aDogNCxcbiAgdHJhbnNpdGlvbnM6IHtcbiAgICBnZXRGaWxsQ29sb3I6IDEwMCxcbiAgfSxcbiAgdXBkYXRlVHJpZ2dlcnM6IHtcbiAgICAvLyBpZiBjdXJyZW50RGF0ZUluZGV4IGNoYW5nZXMsIHJlY29tcHV0ZSBnZXRGaWxsQ29sb3IgZm9yIGVhY2ggcG9pbnRcbiAgICBnZXRGaWxsQ29sb3I6IFtjdXJyZW50RGF0ZUluZGV4XVxuICB9LFxuICB2aXNpYmxlOiB0aWxlc2V0LnZpc2libGUsXG4gIGxpbmVXaWR0aE1pblBpeGVsczogMCxcbiAgbWF4Wm9vbTogMTMsXG4gIG1pblpvb206IDAsXG59KSlcblxuICB2aXouc2V0UHJvcHMoe2xheWVyczogbGF5ZXJzfSlcbn1cbnZpeiA9IG5ldyBEZWNrR0woe1xuICBcbiAgaW5pdGlhbFZpZXdTdGF0ZToge1xuICAgIC8vIGxvbmdpdHVkZTogLTEyMi40LFxuICAgIGxhdGl0dWRlOiA1MS42NjQwMzc4MTY1ODEyMSxcbiAgICBsb25naXR1ZGU6IDEwLjY0NjA5NTI3NTg3ODksXG4gICAgLy8gbGF0aXR1ZGU6IDM3Ljc0LFxuICAgLy8gbG9uZ2l0dWRlOiAxMy43NjU4NjksXG4gICAgLy8xMy43NjU4NjksNTQuMTE3MzgyXG4gICAgem9vbTogNixcbiAgICBtYXhab29tOiAyMCxcbiAgICBwaXRjaDogMzAsXG4gICAgYmVhcmluZzogMFxuICB9LFxuICBjb250cm9sbGVyOiB0cnVlLFxuICBnZXRUb29sdGlwOiAoeyBvYmplY3QgfSkgPT4geyBcbiAgICBpZihvYmplY3QpIHtcbiAgICAgIGNvbnNvbGUubG9nKG9iamVjdClcblxuICAgICAgcmV0dXJuIGAke29iamVjdC5wcm9wZXJ0aWVzLkdFTn0gbW9iaWxpdHkgJHtnZW9SZWdpb24ubW9iaWxpdHlbb2JqZWN0LmlkXX1gXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cbiAgLy9sYXllcnM6IFtsYXllcl1cbn0pO1xuICBcbnNldEludGVydmFsKCgpID0+IHtcbi8vICBjb25zb2xlLmxvZyhzaG91bGRVcGRhdGUpXG4vLyBmYWtlRGF0YS5sYWVuZGVyID0gZmFrZURhdGEubGFlbmRlci5tYXAoKF8sIGkpID0+IE1hdGgucmFuZG9tKCkpXG4vLyBmYWtlRGF0YS5rcmVpc2UgPSBmYWtlRGF0YS5rcmVpc2UubWFwKChfLCBpKSA9PiBNYXRoLnJhbmRvbSgpKVxuLy9mYWtlRGF0YVtnZW9SZWdpb25dID0gZmFrZURhdGFbZ2VvUmVnaW9uXS5tYXAoKF8sIGkpID0+IE1hdGgucmFuZG9tKCkpXG4vL2dlbWVpbmRlbjogbmV3IEFycmF5KDExNDMxKS5maWxsKDApLm1hcCgoXywgaSkgPT4gTWF0aC5yYW5kb20oKSksXG4vL2tyZWlzZTogbmV3IEFycmF5KDQzMikuZmlsbCgwKS5tYXAoKF8sIGkpID0+IE1hdGgucmFuZG9tKCkpXG4gIC8vcmVuZGVyKClcbmdldERhdGEoKVxuIC8vIHNob3VsZFVwZGF0ZSArK1xufSwgMjAwMClcblxuXG5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvb3RlcilcblxuLy8gICBjb25zdCB0aWxlVVJMID0gYCR7d2luZG93LmxvY2F0aW9uLm9yaWdpbn0vZ2VtZWluZGVuLXo3LXVuY29tcHJlc3NlZC97en0ve3h9L3t5fS5wYmZgXG5cbi8vIGNvbnN0IERBVEEgPSBbXG4vLyAgICAgdGlsZVVSTFxuLy8gICAgIC8vJ2h0dHBzOi8vdGlsZXMtYS5iYXNlbWFwcy5jYXJ0b2Nkbi5jb20vdmVjdG9ydGlsZXMvY2FydG8uc3RyZWV0cy92MS97en0ve3h9L3t5fS5tdnQnXG4vLyAgIF1cblxuLy8gZnVuY3Rpb24gcmVuZGVyICgpIHtcbi8vIGNvbnN0IGdlbWVpbmRlbiA9IG5ldyBNVlRMYXllcih7XG4vLyAgIGlkOiAnZ2VtZWluZGVuZ2VvJyxcbi8vICAgZGF0YTogREFUQSxcbi8vICAgcGlja2FibGU6IHRydWUsXG4vLyAgIGdldEZpbGxDb2xvcjogKCkgPT4ge1xuLy8gICAgLy8gY29uc29sZS5sb2coc2hvdWxkVXBkYXRlKVxuLy8gICAgcmV0dXJuIFtNYXRoLnJhbmRvbSgpICogMjU1LCBNYXRoLnJhbmRvbSgpICogMjU1LCBNYXRoLnJhbmRvbSgpICogMjU1XVxuLy8gICB9LFxuLy8gICBnZXRMaW5lQ29sb3I6ICgpID0+IFtNYXRoLnJhbmRvbSgpICogMjU1LCBNYXRoLnJhbmRvbSgpICogMjU1LCBNYXRoLnJhbmRvbSgpICogMjU1XSxcbi8vICAgZ2V0TGluZVdpZHRoOiA0LFxuLy8gICB0cmFuc2l0aW9uczoge1xuLy8gICAgIGdldEZpbGxDb2xvcjogMTAwLFxuLy8gICB9LFxuLy8gICB1cGRhdGVUcmlnZ2Vyczoge1xuLy8gICAgIC8vIGlmIHNob3dMaWJyYXJpZXMgY2hhbmdlcywgcmVjb21wdXRlIGdldEZpbGxDb2xvciBmb3IgZWFjaCBwb2ludFxuLy8gICAgIGdldEZpbGxDb2xvcjogW3Nob3VsZFVwZGF0ZV1cbi8vICAgfSxcbi8vICAgbGluZVdpZHRoTWluUGl4ZWxzOiAxLFxuICBcbi8vICAgLyogcHJvcHMgZnJvbSBNVlRMYXllciBjbGFzcyAqL1xuICBcbi8vICAgLy8gYmluYXJ5OiBmYWxzZSxcbi8vICAgLy8gaGlnaGxpZ2h0ZWRGZWF0dXJlSWQ6IG51bGwsXG4vLyAgIC8vIGxvYWRlcnM6ICxcbi8vICAgLy8gdW5pcXVlSWRQcm9wZXJ0eTogJycsXG4gIFxuLy8gICAvKiBwcm9wcyBpbmhlcml0ZWQgZnJvbSBUaWxlTGF5ZXIgY2xhc3MgKi9cbiAgXG4vLyAgIC8vIGV4dGVudDogbnVsbCxcbi8vICAgLy8gZ2V0VGlsZURhdGE6IG51bGwsXG4vLyAgIC8vIG1heENhY2hlQnl0ZVNpemU6IG51bGwsXG4vLyAgIC8vIG1heENhY2hlU2l6ZTogbnVsbCxcbi8vICAgLy8gbWF4UmVxdWVzdHM6IDYsXG4vLyAgIG1heFpvb206IDEzLFxuLy8gICBtaW5ab29tOiA3LFxuLy8gICAvLyBvblRpbGVFcnJvcjogbnVsbCxcbi8vICAgLy8gb25UaWxlTG9hZDogbnVsbCxcbi8vICAgLy8gb25UaWxlVW5sb2FkOiBudWxsLFxuLy8gICAvLyBvblZpZXdwb3J0TG9hZDogbnVsbCxcbi8vICAgLy8gcmVmaW5lbWVudFN0cmF0ZWd5OiAnYmVzdC1hdmFpbGFibGUnLFxuLy8gICAvLyByZW5kZXJTdWJMYXllcnM6IG51bGwsXG4vLyAgIC8vIHRpbGVTaXplOiA1MTIsXG4vLyAgIC8vIHpSYW5nZTogbnVsbCxcbiAgXG4vLyAgIC8qIHByb3BzIGluaGVyaXRlZCBmcm9tIExheWVyIGNsYXNzICovXG4gIFxuLy8gICAvLyBhdXRvSGlnaGxpZ2h0OiBmYWxzZSxcbi8vICAgLy8gY29vcmRpbmF0ZU9yaWdpbjogWzAsIDAsIDBdLFxuLy8gICAvLyBjb29yZGluYXRlU3lzdGVtOiBDT09SRElOQVRFX1NZU1RFTS5MTkdMQVQsXG4vLyAgIC8vIGhpZ2hsaWdodENvbG9yOiBbMCwgMCwgMTI4LCAxMjhdLFxuLy8gICAvLyBtb2RlbE1hdHJpeDogbnVsbCxcbi8vICAgLy8gb3BhY2l0eTogMSxcbi8vICAgLy8gcGlja2FibGU6IGZhbHNlLFxuLy8gICAvLyB2aXNpYmxlOiB0cnVlLFxuLy8gICAvLyB3cmFwTG9uZ2l0dWRlOiBmYWxzZSxcbi8vIH0pOyIsInZhciBBd2FpdFZhbHVlID0gcmVxdWlyZShcIi4vQXdhaXRWYWx1ZS5qc1wiKTtcblxuZnVuY3Rpb24gQXN5bmNHZW5lcmF0b3IoZ2VuKSB7XG4gIHZhciBmcm9udCwgYmFjaztcblxuICBmdW5jdGlvbiBzZW5kKGtleSwgYXJnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZXF1ZXN0ID0ge1xuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgYXJnOiBhcmcsXG4gICAgICAgIHJlc29sdmU6IHJlc29sdmUsXG4gICAgICAgIHJlamVjdDogcmVqZWN0LFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuXG4gICAgICBpZiAoYmFjaykge1xuICAgICAgICBiYWNrID0gYmFjay5uZXh0ID0gcmVxdWVzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyb250ID0gYmFjayA9IHJlcXVlc3Q7XG4gICAgICAgIHJlc3VtZShrZXksIGFyZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXN1bWUoa2V5LCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHJlc3VsdCA9IGdlbltrZXldKGFyZyk7XG4gICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICB2YXIgd3JhcHBlZEF3YWl0ID0gdmFsdWUgaW5zdGFuY2VvZiBBd2FpdFZhbHVlO1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKHdyYXBwZWRBd2FpdCA/IHZhbHVlLndyYXBwZWQgOiB2YWx1ZSkudGhlbihmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIGlmICh3cmFwcGVkQXdhaXQpIHtcbiAgICAgICAgICByZXN1bWUoa2V5ID09PSBcInJldHVyblwiID8gXCJyZXR1cm5cIiA6IFwibmV4dFwiLCBhcmcpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldHRsZShyZXN1bHQuZG9uZSA/IFwicmV0dXJuXCIgOiBcIm5vcm1hbFwiLCBhcmcpO1xuICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICByZXN1bWUoXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBzZXR0bGUoXCJ0aHJvd1wiLCBlcnIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldHRsZSh0eXBlLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcInJldHVyblwiOlxuICAgICAgICBmcm9udC5yZXNvbHZlKHtcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJ0aHJvd1wiOlxuICAgICAgICBmcm9udC5yZWplY3QodmFsdWUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZnJvbnQucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBmcm9udCA9IGZyb250Lm5leHQ7XG5cbiAgICBpZiAoZnJvbnQpIHtcbiAgICAgIHJlc3VtZShmcm9udC5rZXksIGZyb250LmFyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhY2sgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2ludm9rZSA9IHNlbmQ7XG5cbiAgaWYgKHR5cGVvZiBnZW5bXCJyZXR1cm5cIl0gIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRoaXNbXCJyZXR1cm5cIl0gPSB1bmRlZmluZWQ7XG4gIH1cbn1cblxuQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlW3R5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiXSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Bc3luY0dlbmVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIHRoaXMuX2ludm9rZShcIm5leHRcIiwgYXJnKTtcbn07XG5cbkFzeW5jR2VuZXJhdG9yLnByb3RvdHlwZVtcInRocm93XCJdID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gdGhpcy5faW52b2tlKFwidGhyb3dcIiwgYXJnKTtcbn07XG5cbkFzeW5jR2VuZXJhdG9yLnByb3RvdHlwZVtcInJldHVyblwiXSA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIHRoaXMuX2ludm9rZShcInJldHVyblwiLCBhcmcpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBc3luY0dlbmVyYXRvcjtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfQXdhaXRWYWx1ZSh2YWx1ZSkge1xuICB0aGlzLndyYXBwZWQgPSB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfQXdhaXRWYWx1ZTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5TGlrZVRvQXJyYXk7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhIb2xlcztcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXkuanNcIik7XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRob3V0SG9sZXM7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9hc3luY0dlbmVyYXRvckRlbGVnYXRlKGlubmVyLCBhd2FpdFdyYXApIHtcbiAgdmFyIGl0ZXIgPSB7fSxcbiAgICAgIHdhaXRpbmcgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBwdW1wKGtleSwgdmFsdWUpIHtcbiAgICB3YWl0aW5nID0gdHJ1ZTtcbiAgICB2YWx1ZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKGlubmVyW2tleV0odmFsdWUpKTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZG9uZTogZmFsc2UsXG4gICAgICB2YWx1ZTogYXdhaXRXcmFwKHZhbHVlKVxuICAgIH07XG4gIH1cblxuICA7XG5cbiAgaXRlclt0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgaXRlci5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHVtcChcIm5leHRcIiwgdmFsdWUpO1xuICB9O1xuXG4gIGlmICh0eXBlb2YgaW5uZXJbXCJ0aHJvd1wiXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgaXRlcltcInRocm93XCJdID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAod2FpdGluZykge1xuICAgICAgICB3YWl0aW5nID0gZmFsc2U7XG4gICAgICAgIHRocm93IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHVtcChcInRocm93XCIsIHZhbHVlKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbm5lcltcInJldHVyblwiXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgaXRlcltcInJldHVyblwiXSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHdhaXRpbmcpIHtcbiAgICAgICAgd2FpdGluZyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwdW1wKFwicmV0dXJuXCIsIHZhbHVlKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGl0ZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FzeW5jR2VuZXJhdG9yRGVsZWdhdGU7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX2FzeW5jSXRlcmF0b3IoaXRlcmFibGUpIHtcbiAgdmFyIG1ldGhvZDtcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGlmIChTeW1ib2wuYXN5bmNJdGVyYXRvcikgbWV0aG9kID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdO1xuICAgIGlmIChtZXRob2QgPT0gbnVsbCAmJiBTeW1ib2wuaXRlcmF0b3IpIG1ldGhvZCA9IGl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl07XG4gIH1cblxuICBpZiAobWV0aG9kID09IG51bGwpIG1ldGhvZCA9IGl0ZXJhYmxlW1wiQEBhc3luY0l0ZXJhdG9yXCJdO1xuICBpZiAobWV0aG9kID09IG51bGwpIG1ldGhvZCA9IGl0ZXJhYmxlW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKG1ldGhvZCA9PSBudWxsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGlzIG5vdCBhc3luYyBpdGVyYWJsZVwiKTtcbiAgcmV0dXJuIG1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXN5bmNJdGVyYXRvcjtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXN5bmNUb0dlbmVyYXRvcjtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgQXdhaXRWYWx1ZSA9IHJlcXVpcmUoXCIuL0F3YWl0VmFsdWUuanNcIik7XG5cbmZ1bmN0aW9uIF9hd2FpdEFzeW5jR2VuZXJhdG9yKHZhbHVlKSB7XG4gIHJldHVybiBuZXcgQXdhaXRWYWx1ZSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2F3YWl0QXN5bmNHZW5lcmF0b3I7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY2xhc3NDYWxsQ2hlY2s7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwidmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2YuanNcIik7XG5cbnZhciBpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSByZXF1aXJlKFwiLi9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QuanNcIik7XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICBpZiAoaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDtcbiAgICBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICB2YXIgYSA9IFtudWxsXTtcbiAgICAgIGEucHVzaC5hcHBseShhLCBhcmdzKTtcbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgaWYgKENsYXNzKSBzZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3M7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmluZVByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mLmpzXCIpO1xuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBzZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2luaGVyaXRzO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgXCJkZWZhdWx0XCI6IG9ialxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQ7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHtcbiAgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXNOYXRpdmVGdW5jdGlvbjtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgdmFyIF9pID0gYXJyID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdO1xuXG4gIGlmIChfaSA9PSBudWxsKSByZXR1cm47XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuXG4gIHZhciBfcywgX2U7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5TGltaXQ7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVSZXN0O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlU3ByZWFkO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsInZhciBfdHlwZW9mID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpW1wiZGVmYXVsdFwiXTtcblxudmFyIGFzc2VydFRoaXNJbml0aWFsaXplZCA9IHJlcXVpcmUoXCIuL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qc1wiKTtcblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuXG4gIHJldHVybiBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm47XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZjtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgYXJyYXlXaXRoSG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhIb2xlcy5qc1wiKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheUxpbWl0ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5TGltaXQuanNcIik7XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzXCIpO1xuXG52YXIgbm9uSXRlcmFibGVSZXN0ID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVSZXN0LmpzXCIpO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIGFycmF5V2l0aEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zbGljZWRUb0FycmF5O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsInZhciBhcnJheVdpdGhvdXRIb2xlcyA9IHJlcXVpcmUoXCIuL2FycmF5V2l0aG91dEhvbGVzLmpzXCIpO1xuXG52YXIgaXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5LmpzXCIpO1xuXG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qc1wiKTtcblxudmFyIG5vbkl0ZXJhYmxlU3ByZWFkID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVTcHJlYWQuanNcIik7XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aG91dEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90b0NvbnN1bWFibGVBcnJheTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2Y7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5LmpzXCIpO1xuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgQXN5bmNHZW5lcmF0b3IgPSByZXF1aXJlKFwiLi9Bc3luY0dlbmVyYXRvci5qc1wiKTtcblxuZnVuY3Rpb24gX3dyYXBBc3luY0dlbmVyYXRvcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgQXN5bmNHZW5lcmF0b3IoZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3dyYXBBc3luY0dlbmVyYXRvcjtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9nZXRQcm90b3R5cGVPZi5qc1wiKTtcblxudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2YuanNcIik7XG5cbnZhciBpc05hdGl2ZUZ1bmN0aW9uID0gcmVxdWlyZShcIi4vaXNOYXRpdmVGdW5jdGlvbi5qc1wiKTtcblxudmFyIGNvbnN0cnVjdCA9IHJlcXVpcmUoXCIuL2NvbnN0cnVjdC5qc1wiKTtcblxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgICBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIWlzTmF0aXZlRnVuY3Rpb24oQ2xhc3MpKSByZXR1cm4gQ2xhc3M7XG5cbiAgICBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKF9jYWNoZS5oYXMoQ2xhc3MpKSByZXR1cm4gX2NhY2hlLmdldChDbGFzcyk7XG5cbiAgICAgIF9jYWNoZS5zZXQoQ2xhc3MsIFdyYXBwZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFdyYXBwZXIoKSB7XG4gICAgICByZXR1cm4gY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIGdldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbiAgICBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogV3JhcHBlcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbiAgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF93cmFwTmF0aXZlU3VwZXI7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZldGNoRmlsZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZmV0Y2hGaWxlLmZldGNoRmlsZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWFkQXJyYXlCdWZmZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3JlYWRBcnJheUJ1ZmZlci5yZWFkQXJyYXlCdWZmZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVhZEZpbGVTeW5jXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9yZWFkRmlsZS5yZWFkRmlsZVN5bmM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwid3JpdGVGaWxlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF93cml0ZUZpbGUud3JpdGVGaWxlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIndyaXRlRmlsZVN5bmNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3dyaXRlRmlsZS53cml0ZUZpbGVTeW5jO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNldExvYWRlck9wdGlvbnNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NldExvYWRlck9wdGlvbnMuc2V0TG9hZGVyT3B0aW9ucztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWdpc3RlckxvYWRlcnNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3JlZ2lzdGVyTG9hZGVycy5yZWdpc3RlckxvYWRlcnM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX3VucmVnaXN0ZXJMb2FkZXJzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9yZWdpc3RlckxvYWRlcnMuX3VucmVnaXN0ZXJMb2FkZXJzO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNlbGVjdExvYWRlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2VsZWN0TG9hZGVyLnNlbGVjdExvYWRlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzZWxlY3RMb2FkZXJTeW5jXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zZWxlY3RMb2FkZXIuc2VsZWN0TG9hZGVyU3luYztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfcGFyc2UucGFyc2U7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VTeW5jXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9wYXJzZVN5bmMucGFyc2VTeW5jO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlSW5CYXRjaGVzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9wYXJzZUluQmF0Y2hlcy5wYXJzZUluQmF0Y2hlcztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJsb2FkXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9sb2FkLmxvYWQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibG9hZEluQmF0Y2hlc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbG9hZEluQmF0Y2hlcy5sb2FkSW5CYXRjaGVzO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZW5jb2RlLmVuY29kZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVTeW5jXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9lbmNvZGUuZW5jb2RlU3luYztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVJbkJhdGNoZXNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2VuY29kZS5lbmNvZGVJbkJhdGNoZXM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlVGV4dFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZW5jb2RlLmVuY29kZVRleHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlVVJMdG9VUkxcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2VuY29kZS5lbmNvZGVVUkx0b1VSTDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzYXZlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zYXZlLnNhdmU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2F2ZVN5bmNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NhdmUuc2F2ZVN5bmM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2V0UGF0aFByZWZpeFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbG9hZGVyVXRpbHMuc2V0UGF0aFByZWZpeDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRQYXRoUHJlZml4XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9sb2FkZXJVdGlscy5nZXRQYXRoUHJlZml4O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlc29sdmVQYXRoXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9sb2FkZXJVdGlscy5yZXNvbHZlUGF0aDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXF1ZXN0U2NoZWR1bGVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9sb2FkZXJVdGlscy5SZXF1ZXN0U2NoZWR1bGVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkpTT05Mb2FkZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2xvYWRlclV0aWxzLkpTT05Mb2FkZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNCcm93c2VyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9sb2FkZXJVdGlscy5pc0Jyb3dzZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNXb3JrZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2xvYWRlclV0aWxzLmlzV29ya2VyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNlbGZcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2xvYWRlclV0aWxzLnNlbGY7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwid2luZG93XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9sb2FkZXJVdGlscy53aW5kb3c7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2xvYmFsXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9sb2FkZXJVdGlscy5nbG9iYWw7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZG9jdW1lbnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2xvYWRlclV0aWxzLmRvY3VtZW50O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzc2VydFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbG9hZGVyVXRpbHMuYXNzZXJ0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZvckVhY2hcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2xvYWRlclV0aWxzLmZvckVhY2g7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnNBc3luY1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbG9hZGVyVXRpbHMuY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnNBc3luYztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYWtlVGV4dERlY29kZXJJdGVyYXRvclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbG9hZGVyVXRpbHMubWFrZVRleHREZWNvZGVySXRlcmF0b3I7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWFrZVRleHRFbmNvZGVySXRlcmF0b3JcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2xvYWRlclV0aWxzLm1ha2VUZXh0RW5jb2Rlckl0ZXJhdG9yO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1ha2VMaW5lSXRlcmF0b3JcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2xvYWRlclV0aWxzLm1ha2VMaW5lSXRlcmF0b3I7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWFrZU51bWJlcmVkTGluZUl0ZXJhdG9yXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9sb2FkZXJVdGlscy5tYWtlTnVtYmVyZWRMaW5lSXRlcmF0b3I7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWFrZUl0ZXJhdG9yXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9tYWtlSXRlcmF0b3IubWFrZUl0ZXJhdG9yO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1ha2VTdHJlYW1cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX21ha2VTdHJlYW0ubWFrZVN0cmVhbTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYWtlRE9NU3RyZWFtXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9tYWtlRG9tU3RyZWFtLm1ha2VET01TdHJlYW07XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWFrZU5vZGVTdHJlYW1cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX21ha2VOb2RlU3RyZWFtLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTnVsbFdvcmtlckxvYWRlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbnVsbExvYWRlci5OdWxsV29ya2VyTG9hZGVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk51bGxMb2FkZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX251bGxMb2FkZXIuTnVsbExvYWRlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfZmV0Y2hQcm9ncmVzc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZmV0Y2hQcm9ncmVzcy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9Ccm93c2VyRmlsZVN5c3RlbVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYnJvd3NlckZpbGVzeXN0ZW0uZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1B1cmVPYmplY3RcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2lzVHlwZS5pc1B1cmVPYmplY3Q7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNQcm9taXNlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pc1R5cGUuaXNQcm9taXNlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzSXRlcmFibGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2lzVHlwZS5pc0l0ZXJhYmxlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzQXN5bmNJdGVyYWJsZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaXNUeXBlLmlzQXN5bmNJdGVyYWJsZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0l0ZXJhdG9yXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pc1R5cGUuaXNJdGVyYXRvcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1Jlc3BvbnNlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pc1R5cGUuaXNSZXNwb25zZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1JlYWRhYmxlU3RyZWFtXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pc1R5cGUuaXNSZWFkYWJsZVN0cmVhbTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1dyaXRhYmxlU3RyZWFtXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pc1R5cGUuaXNXcml0YWJsZVN0cmVhbTtcbiAgfVxufSk7XG5cbnZhciBfZmV0Y2hGaWxlID0gcmVxdWlyZShcIi4vbGliL2ZldGNoL2ZldGNoLWZpbGVcIik7XG5cbnZhciBfcmVhZEFycmF5QnVmZmVyID0gcmVxdWlyZShcIi4vbGliL2ZldGNoL3JlYWQtYXJyYXktYnVmZmVyXCIpO1xuXG52YXIgX3JlYWRGaWxlID0gcmVxdWlyZShcIi4vbGliL2ZldGNoL3JlYWQtZmlsZVwiKTtcblxudmFyIF93cml0ZUZpbGUgPSByZXF1aXJlKFwiLi9saWIvZmV0Y2gvd3JpdGUtZmlsZVwiKTtcblxudmFyIF9zZXRMb2FkZXJPcHRpb25zID0gcmVxdWlyZShcIi4vbGliL2FwaS9zZXQtbG9hZGVyLW9wdGlvbnNcIik7XG5cbnZhciBfcmVnaXN0ZXJMb2FkZXJzID0gcmVxdWlyZShcIi4vbGliL2FwaS9yZWdpc3Rlci1sb2FkZXJzXCIpO1xuXG52YXIgX3NlbGVjdExvYWRlciA9IHJlcXVpcmUoXCIuL2xpYi9hcGkvc2VsZWN0LWxvYWRlclwiKTtcblxudmFyIF9wYXJzZSA9IHJlcXVpcmUoXCIuL2xpYi9hcGkvcGFyc2VcIik7XG5cbnZhciBfcGFyc2VTeW5jID0gcmVxdWlyZShcIi4vbGliL2FwaS9wYXJzZS1zeW5jXCIpO1xuXG52YXIgX3BhcnNlSW5CYXRjaGVzID0gcmVxdWlyZShcIi4vbGliL2FwaS9wYXJzZS1pbi1iYXRjaGVzXCIpO1xuXG52YXIgX2xvYWQgPSByZXF1aXJlKFwiLi9saWIvYXBpL2xvYWRcIik7XG5cbnZhciBfbG9hZEluQmF0Y2hlcyA9IHJlcXVpcmUoXCIuL2xpYi9hcGkvbG9hZC1pbi1iYXRjaGVzXCIpO1xuXG52YXIgX2VuY29kZSA9IHJlcXVpcmUoXCIuL2xpYi9hcGkvZW5jb2RlXCIpO1xuXG52YXIgX3NhdmUgPSByZXF1aXJlKFwiLi9saWIvYXBpL3NhdmVcIik7XG5cbnZhciBfbG9hZGVyVXRpbHMgPSByZXF1aXJlKFwiQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzXCIpO1xuXG52YXIgX21ha2VJdGVyYXRvciA9IHJlcXVpcmUoXCIuL2l0ZXJhdG9ycy9tYWtlLWl0ZXJhdG9yL21ha2UtaXRlcmF0b3JcIik7XG5cbnZhciBfbWFrZVN0cmVhbSA9IHJlcXVpcmUoXCIuL2l0ZXJhdG9ycy9tYWtlLXN0cmVhbS9tYWtlLXN0cmVhbVwiKTtcblxudmFyIF9tYWtlRG9tU3RyZWFtID0gcmVxdWlyZShcIi4vaXRlcmF0b3JzL21ha2Utc3RyZWFtL21ha2UtZG9tLXN0cmVhbVwiKTtcblxudmFyIF9tYWtlTm9kZVN0cmVhbSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaXRlcmF0b3JzL21ha2Utc3RyZWFtL21ha2Utbm9kZS1zdHJlYW1cIikpO1xuXG52YXIgX251bGxMb2FkZXIgPSByZXF1aXJlKFwiLi9udWxsLWxvYWRlclwiKTtcblxudmFyIF9mZXRjaFByb2dyZXNzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvcHJvZ3Jlc3MvZmV0Y2gtcHJvZ3Jlc3NcIikpO1xuXG52YXIgX2Jyb3dzZXJGaWxlc3lzdGVtID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvZmlsZXN5c3RlbXMvYnJvd3Nlci1maWxlc3lzdGVtXCIpKTtcblxudmFyIF9pc1R5cGUgPSByZXF1aXJlKFwiLi9qYXZhc2NyaXB0LXV0aWxzL2lzLXR5cGVcIik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm1ha2VBcnJheUJ1ZmZlckl0ZXJhdG9yID0gbWFrZUFycmF5QnVmZmVySXRlcmF0b3I7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfbWFya2VkID0gX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhtYWtlQXJyYXlCdWZmZXJJdGVyYXRvcik7XG5cbnZhciBERUZBVUxUX0NIVU5LX1NJWkUgPSAyNTYgKiAxMDI0O1xuXG5mdW5jdGlvbiBtYWtlQXJyYXlCdWZmZXJJdGVyYXRvcihhcnJheUJ1ZmZlcikge1xuICB2YXIgb3B0aW9ucyxcbiAgICAgIF9vcHRpb25zJGNodW5rU2l6ZSxcbiAgICAgIGNodW5rU2l6ZSxcbiAgICAgIGJ5dGVPZmZzZXQsXG4gICAgICBjaHVua0J5dGVMZW5ndGgsXG4gICAgICBjaHVuayxcbiAgICAgIHNvdXJjZUFycmF5LFxuICAgICAgY2h1bmtBcnJheSxcbiAgICAgIF9hcmdzID0gYXJndW1lbnRzO1xuXG4gIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIG1ha2VBcnJheUJ1ZmZlckl0ZXJhdG9yJChfY29udGV4dCkge1xuICAgIHdoaWxlICgxKSB7XG4gICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBvcHRpb25zID0gX2FyZ3MubGVuZ3RoID4gMSAmJiBfYXJnc1sxXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3NbMV0gOiB7fTtcbiAgICAgICAgICBfb3B0aW9ucyRjaHVua1NpemUgPSBvcHRpb25zLmNodW5rU2l6ZSwgY2h1bmtTaXplID0gX29wdGlvbnMkY2h1bmtTaXplID09PSB2b2lkIDAgPyBERUZBVUxUX0NIVU5LX1NJWkUgOiBfb3B0aW9ucyRjaHVua1NpemU7XG4gICAgICAgICAgYnl0ZU9mZnNldCA9IDA7XG5cbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGlmICghKGJ5dGVPZmZzZXQgPCBhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKSkge1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2h1bmtCeXRlTGVuZ3RoID0gTWF0aC5taW4oYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCAtIGJ5dGVPZmZzZXQsIGNodW5rU2l6ZSk7XG4gICAgICAgICAgY2h1bmsgPSBuZXcgQXJyYXlCdWZmZXIoY2h1bmtCeXRlTGVuZ3RoKTtcbiAgICAgICAgICBzb3VyY2VBcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyLCBieXRlT2Zmc2V0LCBjaHVua0J5dGVMZW5ndGgpO1xuICAgICAgICAgIGNodW5rQXJyYXkgPSBuZXcgVWludDhBcnJheShjaHVuayk7XG4gICAgICAgICAgY2h1bmtBcnJheS5zZXQoc291cmNlQXJyYXkpO1xuICAgICAgICAgIGJ5dGVPZmZzZXQgKz0gY2h1bmtCeXRlTGVuZ3RoO1xuICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMjtcbiAgICAgICAgICByZXR1cm4gY2h1bms7XG5cbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDE0OlxuICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIF9tYXJrZWQpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFrZS1hcnJheS1idWZmZXItaXRlcmF0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5tYWtlQmxvYkl0ZXJhdG9yID0gbWFrZUJsb2JJdGVyYXRvcjtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hd2FpdEFzeW5jR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXdhaXRBc3luY0dlbmVyYXRvclwiKSk7XG5cbnZhciBfd3JhcEFzeW5jR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvd3JhcEFzeW5jR2VuZXJhdG9yXCIpKTtcblxudmFyIERFRkFVTFRfQ0hVTktfU0laRSA9IDEwMjQgKiAxMDI0O1xuXG5mdW5jdGlvbiBtYWtlQmxvYkl0ZXJhdG9yKF94LCBfeDIpIHtcbiAgcmV0dXJuIF9tYWtlQmxvYkl0ZXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9tYWtlQmxvYkl0ZXJhdG9yKCkge1xuICBfbWFrZUJsb2JJdGVyYXRvciA9ICgwLCBfd3JhcEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoYmxvYiwgb3B0aW9ucykge1xuICAgIHZhciBjaHVua1NpemUsIG9mZnNldCwgZW5kLCBjaHVuaztcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNodW5rU2l6ZSA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2h1bmtTaXplKSB8fCBERUZBVUxUX0NIVU5LX1NJWkU7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgaWYgKCEob2Zmc2V0IDwgYmxvYi5zaXplKSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbmQgPSBvZmZzZXQgKyBjaHVua1NpemU7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2F3YWl0QXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKGJsb2Iuc2xpY2Uob2Zmc2V0LCBlbmQpLmFycmF5QnVmZmVyKCkpO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgY2h1bmsgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEwO1xuICAgICAgICAgICAgcmV0dXJuIGNodW5rO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlKTtcbiAgfSkpO1xuICByZXR1cm4gX21ha2VCbG9iSXRlcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ha2UtYmxvYi1pdGVyYXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubWFrZUl0ZXJhdG9yID0gbWFrZUl0ZXJhdG9yO1xuXG52YXIgX21ha2VTdHJpbmdJdGVyYXRvciA9IHJlcXVpcmUoXCIuL21ha2Utc3RyaW5nLWl0ZXJhdG9yXCIpO1xuXG52YXIgX21ha2VBcnJheUJ1ZmZlckl0ZXJhdG9yID0gcmVxdWlyZShcIi4vbWFrZS1hcnJheS1idWZmZXItaXRlcmF0b3JcIik7XG5cbnZhciBfbWFrZUJsb2JJdGVyYXRvciA9IHJlcXVpcmUoXCIuL21ha2UtYmxvYi1pdGVyYXRvclwiKTtcblxudmFyIF9tYWtlU3RyZWFtSXRlcmF0b3IgPSByZXF1aXJlKFwiLi9tYWtlLXN0cmVhbS1pdGVyYXRvclwiKTtcblxudmFyIF9pc1R5cGUgPSByZXF1aXJlKFwiLi4vLi4vamF2YXNjcmlwdC11dGlscy9pcy10eXBlXCIpO1xuXG5mdW5jdGlvbiBtYWtlSXRlcmF0b3IoZGF0YSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuICgwLCBfbWFrZVN0cmluZ0l0ZXJhdG9yLm1ha2VTdHJpbmdJdGVyYXRvcikoZGF0YSwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuICgwLCBfbWFrZUFycmF5QnVmZmVySXRlcmF0b3IubWFrZUFycmF5QnVmZmVySXRlcmF0b3IpKGRhdGEsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKCgwLCBfaXNUeXBlLmlzQmxvYikoZGF0YSkpIHtcbiAgICByZXR1cm4gKDAsIF9tYWtlQmxvYkl0ZXJhdG9yLm1ha2VCbG9iSXRlcmF0b3IpKGRhdGEsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKCgwLCBfaXNUeXBlLmlzUmVhZGFibGVTdHJlYW0pKGRhdGEpKSB7XG4gICAgcmV0dXJuICgwLCBfbWFrZVN0cmVhbUl0ZXJhdG9yLm1ha2VTdHJlYW1JdGVyYXRvcikoZGF0YSwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoKDAsIF9pc1R5cGUuaXNSZXNwb25zZSkoZGF0YSkpIHtcbiAgICB2YXIgcmVzcG9uc2UgPSBkYXRhO1xuICAgIHJldHVybiAoMCwgX21ha2VTdHJlYW1JdGVyYXRvci5tYWtlU3RyZWFtSXRlcmF0b3IpKHJlc3BvbnNlLmJvZHksIG9wdGlvbnMpO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdtYWtlSXRlcmF0b3InKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ha2UtaXRlcmF0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5tYWtlU3RyZWFtSXRlcmF0b3IgPSBtYWtlU3RyZWFtSXRlcmF0b3I7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNJdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jSXRlcmF0b3JcIikpO1xuXG52YXIgX2F3YWl0QXN5bmNHZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hd2FpdEFzeW5jR2VuZXJhdG9yXCIpKTtcblxudmFyIF93cmFwQXN5bmNHZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy93cmFwQXN5bmNHZW5lcmF0b3JcIikpO1xuXG52YXIgX2xvYWRlclV0aWxzID0gcmVxdWlyZShcIkBsb2FkZXJzLmdsL2xvYWRlci11dGlsc1wiKTtcblxuZnVuY3Rpb24gbWFrZVN0cmVhbUl0ZXJhdG9yKHN0cmVhbSwgb3B0aW9ucykge1xuICByZXR1cm4gX2xvYWRlclV0aWxzLmlzQnJvd3NlciA/IG1ha2VCcm93c2VyU3RyZWFtSXRlcmF0b3Ioc3RyZWFtLCBvcHRpb25zKSA6IG1ha2VOb2RlU3RyZWFtSXRlcmF0b3Ioc3RyZWFtLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gbWFrZUJyb3dzZXJTdHJlYW1JdGVyYXRvcihfeCwgX3gyKSB7XG4gIHJldHVybiBfbWFrZUJyb3dzZXJTdHJlYW1JdGVyYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfbWFrZUJyb3dzZXJTdHJlYW1JdGVyYXRvcigpIHtcbiAgX21ha2VCcm93c2VyU3RyZWFtSXRlcmF0b3IgPSAoMCwgX3dyYXBBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKHN0cmVhbSwgb3B0aW9ucykge1xuICAgIHZhciByZWFkZXIsIG5leHRCYXRjaFByb21pc2UsIGN1cnJlbnRCYXRjaFByb21pc2UsIF95aWVsZCRfYXdhaXRBc3luY0dlbiwgZG9uZSwgdmFsdWU7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgaWYgKCF0cnVlKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnRCYXRjaFByb21pc2UgPSBuZXh0QmF0Y2hQcm9taXNlIHx8IHJlYWRlci5yZWFkKCk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCAmJiBvcHRpb25zLl9zdHJlYW1SZWFkQWhlYWQpIHtcbiAgICAgICAgICAgICAgbmV4dEJhdGNoUHJvbWlzZSA9IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3O1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfYXdhaXRBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoY3VycmVudEJhdGNoUHJvbWlzZSk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBfeWllbGQkX2F3YWl0QXN5bmNHZW4gPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgZG9uZSA9IF95aWVsZCRfYXdhaXRBc3luY0dlbi5kb25lO1xuICAgICAgICAgICAgdmFsdWUgPSBfeWllbGQkX2F3YWl0QXN5bmNHZW4udmFsdWU7XG5cbiAgICAgICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNDtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2xvYWRlclV0aWxzLnRvQXJyYXlCdWZmZXIpKHZhbHVlKTtcblxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyMTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxODtcbiAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgxKTtcbiAgICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuXG4gICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSwgbnVsbCwgW1sxLCAxOF1dKTtcbiAgfSkpO1xuICByZXR1cm4gX21ha2VCcm93c2VyU3RyZWFtSXRlcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gbWFrZU5vZGVTdHJlYW1JdGVyYXRvcihfeDMsIF94NCkge1xuICByZXR1cm4gX21ha2VOb2RlU3RyZWFtSXRlcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX21ha2VOb2RlU3RyZWFtSXRlcmF0b3IoKSB7XG4gIF9tYWtlTm9kZVN0cmVhbUl0ZXJhdG9yID0gKDAsIF93cmFwQXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoc3RyZWFtLCBvcHRpb25zKSB7XG4gICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24sIF9kaWRJdGVyYXRvckVycm9yLCBfaXRlcmF0b3JFcnJvciwgX2l0ZXJhdG9yLCBfc3RlcCwgX3ZhbHVlLCBjaHVuaztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMjtcbiAgICAgICAgICAgIF9pdGVyYXRvciA9ICgwLCBfYXN5bmNJdGVyYXRvcjIuZGVmYXVsdCkoc3RyZWFtKTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNjtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2F3YWl0QXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKF9pdGVyYXRvci5uZXh0KCkpO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgX3N0ZXAgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSBfc3RlcC5kb25lO1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMDtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2F3YWl0QXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKF9zdGVwLnZhbHVlKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBfdmFsdWUgPSBfY29udGV4dDIuc2VudDtcblxuICAgICAgICAgICAgaWYgKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24pIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNodW5rID0gX3ZhbHVlO1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2xvYWRlclV0aWxzLnRvQXJyYXlCdWZmZXIpKGNodW5rKTtcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDIwO1xuICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gX2NvbnRleHQyW1wiY2F0Y2hcIl0oMik7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IF9jb250ZXh0Mi50MDtcblxuICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDI0O1xuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAyNTtcblxuICAgICAgICAgICAgaWYgKCEoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyOTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2F3YWl0QXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKF9pdGVyYXRvci5yZXR1cm4oKSk7XG5cbiAgICAgICAgICBjYXNlIDI5OlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAyOTtcblxuICAgICAgICAgICAgaWYgKCFfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDMyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG5cbiAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5maW5pc2goMjkpO1xuXG4gICAgICAgICAgY2FzZSAzMzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuZmluaXNoKDI0KTtcblxuICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMiwgbnVsbCwgW1syLCAyMCwgMjQsIDM0XSwgWzI1LCwgMjksIDMzXV0pO1xuICB9KSk7XG4gIHJldHVybiBfbWFrZU5vZGVTdHJlYW1JdGVyYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFrZS1zdHJlYW0taXRlcmF0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5tYWtlU3RyaW5nSXRlcmF0b3IgPSBtYWtlU3RyaW5nSXRlcmF0b3I7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfbWFya2VkID0gX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhtYWtlU3RyaW5nSXRlcmF0b3IpO1xuXG52YXIgREVGQVVMVF9DSFVOS19TSVpFID0gMjU2ICogMTAyNDtcblxuZnVuY3Rpb24gbWFrZVN0cmluZ0l0ZXJhdG9yKHN0cmluZywgb3B0aW9ucykge1xuICB2YXIgY2h1bmtTaXplLCBvZmZzZXQsIHRleHRFbmNvZGVyLCBjaHVua0xlbmd0aCwgY2h1bms7XG4gIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIG1ha2VTdHJpbmdJdGVyYXRvciQoX2NvbnRleHQpIHtcbiAgICB3aGlsZSAoMSkge1xuICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgY2h1bmtTaXplID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jaHVua1NpemUpIHx8IERFRkFVTFRfQ0hVTktfU0laRTtcbiAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgIHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5cbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGlmICghKG9mZnNldCA8IHN0cmluZy5sZW5ndGgpKSB7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaHVua0xlbmd0aCA9IE1hdGgubWluKHN0cmluZy5sZW5ndGggLSBvZmZzZXQsIGNodW5rU2l6ZSk7XG4gICAgICAgICAgY2h1bmsgPSBzdHJpbmcuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBjaHVua0xlbmd0aCk7XG4gICAgICAgICAgb2Zmc2V0ICs9IGNodW5rTGVuZ3RoO1xuICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA5O1xuICAgICAgICAgIHJldHVybiB0ZXh0RW5jb2Rlci5lbmNvZGUoY2h1bmspO1xuXG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDExOlxuICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIF9tYXJrZWQpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFrZS1zdHJpbmctaXRlcmF0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5tYWtlRE9NU3RyZWFtID0gbWFrZURPTVN0cmVhbTtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBtYWtlRE9NU3RyZWFtKHNvdXJjZSwgb3B0aW9ucykge1xuICB2YXIgaXRlcmF0b3IgPSBzb3VyY2VbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID8gc291cmNlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIDogc291cmNlW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgdHlwZTogJ2J5dGVzJyxcbiAgICBwdWxsOiBmdW5jdGlvbiBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIHJldHVybiAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgICAgdmFyIF95aWVsZCRpdGVyYXRvciRuZXh0LCBkb25lLCB2YWx1ZTtcblxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMDtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0b3IubmV4dCgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBfeWllbGQkaXRlcmF0b3IkbmV4dCA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgICAgZG9uZSA9IF95aWVsZCRpdGVyYXRvciRuZXh0LmRvbmU7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBfeWllbGQkaXRlcmF0b3IkbmV4dC52YWx1ZTtcblxuICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShuZXcgVWludDhBcnJheSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoX2NvbnRleHQudDApO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgbnVsbCwgW1swLCA5XV0pO1xuICAgICAgfSkpKCk7XG4gICAgfSxcbiAgICBjYW5jZWw6IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgIHJldHVybiAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICAgIHZhciBfaXRlcmF0b3IkcmV0dXJuO1xuXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yID09PSBudWxsIHx8IGl0ZXJhdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2l0ZXJhdG9yJHJldHVybiA9IGl0ZXJhdG9yLnJldHVybikgPT09IG51bGwgfHwgX2l0ZXJhdG9yJHJldHVybiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2l0ZXJhdG9yJHJldHVybi5jYWxsKGl0ZXJhdG9yKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyKTtcbiAgICAgIH0pKSgpO1xuICAgIH1cbiAgfSwgX29iamVjdFNwcmVhZCh7XG4gICAgaGlnaFdhdGVyTWFyazogTWF0aC5wb3coMiwgMjQpXG4gIH0sIG9wdGlvbnMpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ha2UtZG9tLXN0cmVhbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm1ha2VTdHJlYW0gPSBtYWtlU3RyZWFtO1xuXG52YXIgX2xvYWRlclV0aWxzID0gcmVxdWlyZShcIkBsb2FkZXJzLmdsL2xvYWRlci11dGlsc1wiKTtcblxudmFyIF9tYWtlRG9tU3RyZWFtID0gcmVxdWlyZShcIi4vbWFrZS1kb20tc3RyZWFtXCIpO1xuXG52YXIgX21ha2VOb2RlU3RyZWFtID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9tYWtlLW5vZGUtc3RyZWFtXCIpKTtcblxuZnVuY3Rpb24gbWFrZVN0cmVhbShkYXRhLCBvcHRpb25zKSB7XG4gIHJldHVybiBfbG9hZGVyVXRpbHMuaXNCcm93c2VyID8gKDAsIF9tYWtlRG9tU3RyZWFtLm1ha2VET01TdHJlYW0pKGRhdGEsIG9wdGlvbnMpIDogKDAsIF9tYWtlTm9kZVN0cmVhbS5kZWZhdWx0KShkYXRhLCBvcHRpb25zKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ha2Utc3RyZWFtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuaXNXcml0YWJsZVN0cmVhbSA9IGV4cG9ydHMuaXNSZWFkYWJsZVN0cmVhbSA9IGV4cG9ydHMuaXNSZWFkYWJsZU5vZGVTdHJlYW0gPSBleHBvcnRzLmlzV3JpdGFibGVOb2RlU3RyZWFtID0gZXhwb3J0cy5pc0J1ZmZlciA9IGV4cG9ydHMuaXNSZWFkYWJsZURPTVN0cmVhbSA9IGV4cG9ydHMuaXNXcml0YWJsZURPTVN0cmVhbSA9IGV4cG9ydHMuaXNCbG9iID0gZXhwb3J0cy5pc0ZpbGUgPSBleHBvcnRzLmlzUmVzcG9uc2UgPSBleHBvcnRzLmlzSXRlcmF0b3IgPSBleHBvcnRzLmlzQXN5bmNJdGVyYWJsZSA9IGV4cG9ydHMuaXNJdGVyYWJsZSA9IGV4cG9ydHMuaXNQcm9taXNlID0gZXhwb3J0cy5pc1B1cmVPYmplY3QgPSBleHBvcnRzLmlzT2JqZWN0ID0gdm9pZCAwO1xuXG52YXIgX3R5cGVvZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKSk7XG5cbnZhciBpc0Jvb2xlYW4gPSBmdW5jdGlvbiBpc0Jvb2xlYW4oeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdib29sZWFuJztcbn07XG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cbnZhciBpc09iamVjdCA9IGZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcbiAgcmV0dXJuIHggIT09IG51bGwgJiYgKDAsIF90eXBlb2YyLmRlZmF1bHQpKHgpID09PSAnb2JqZWN0Jztcbn07XG5cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxudmFyIGlzUHVyZU9iamVjdCA9IGZ1bmN0aW9uIGlzUHVyZU9iamVjdCh4KSB7XG4gIHJldHVybiBpc09iamVjdCh4KSAmJiB4LmNvbnN0cnVjdG9yID09PSB7fS5jb25zdHJ1Y3Rvcjtcbn07XG5cbmV4cG9ydHMuaXNQdXJlT2JqZWN0ID0gaXNQdXJlT2JqZWN0O1xuXG52YXIgaXNQcm9taXNlID0gZnVuY3Rpb24gaXNQcm9taXNlKHgpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHgpICYmIGlzRnVuY3Rpb24oeC50aGVuKTtcbn07XG5cbmV4cG9ydHMuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuXG52YXIgaXNJdGVyYWJsZSA9IGZ1bmN0aW9uIGlzSXRlcmFibGUoeCkge1xuICByZXR1cm4geCAmJiB0eXBlb2YgeFtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xufTtcblxuZXhwb3J0cy5pc0l0ZXJhYmxlID0gaXNJdGVyYWJsZTtcblxudmFyIGlzQXN5bmNJdGVyYWJsZSA9IGZ1bmN0aW9uIGlzQXN5bmNJdGVyYWJsZSh4KSB7XG4gIHJldHVybiB4ICYmIHR5cGVvZiB4W1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cbmV4cG9ydHMuaXNBc3luY0l0ZXJhYmxlID0gaXNBc3luY0l0ZXJhYmxlO1xuXG52YXIgaXNJdGVyYXRvciA9IGZ1bmN0aW9uIGlzSXRlcmF0b3IoeCkge1xuICByZXR1cm4geCAmJiBpc0Z1bmN0aW9uKHgubmV4dCk7XG59O1xuXG5leHBvcnRzLmlzSXRlcmF0b3IgPSBpc0l0ZXJhdG9yO1xuXG52YXIgaXNSZXNwb25zZSA9IGZ1bmN0aW9uIGlzUmVzcG9uc2UoeCkge1xuICByZXR1cm4gdHlwZW9mIFJlc3BvbnNlICE9PSAndW5kZWZpbmVkJyAmJiB4IGluc3RhbmNlb2YgUmVzcG9uc2UgfHwgeCAmJiB4LmFycmF5QnVmZmVyICYmIHgudGV4dCAmJiB4Lmpzb247XG59O1xuXG5leHBvcnRzLmlzUmVzcG9uc2UgPSBpc1Jlc3BvbnNlO1xuXG52YXIgaXNGaWxlID0gZnVuY3Rpb24gaXNGaWxlKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiBGaWxlICE9PSAndW5kZWZpbmVkJyAmJiB4IGluc3RhbmNlb2YgRmlsZTtcbn07XG5cbmV4cG9ydHMuaXNGaWxlID0gaXNGaWxlO1xuXG52YXIgaXNCbG9iID0gZnVuY3Rpb24gaXNCbG9iKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiB4IGluc3RhbmNlb2YgQmxvYjtcbn07XG5cbmV4cG9ydHMuaXNCbG9iID0gaXNCbG9iO1xuXG52YXIgaXNXcml0YWJsZURPTVN0cmVhbSA9IGZ1bmN0aW9uIGlzV3JpdGFibGVET01TdHJlYW0oeCkge1xuICByZXR1cm4gaXNPYmplY3QoeCkgJiYgaXNGdW5jdGlvbih4LmFib3J0KSAmJiBpc0Z1bmN0aW9uKHguZ2V0V3JpdGVyKTtcbn07XG5cbmV4cG9ydHMuaXNXcml0YWJsZURPTVN0cmVhbSA9IGlzV3JpdGFibGVET01TdHJlYW07XG5cbnZhciBpc1JlYWRhYmxlRE9NU3RyZWFtID0gZnVuY3Rpb24gaXNSZWFkYWJsZURPTVN0cmVhbSh4KSB7XG4gIHJldHVybiB0eXBlb2YgUmVhZGFibGVTdHJlYW0gIT09ICd1bmRlZmluZWQnICYmIHggaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSB8fCBpc09iamVjdCh4KSAmJiBpc0Z1bmN0aW9uKHgudGVlKSAmJiBpc0Z1bmN0aW9uKHguY2FuY2VsKSAmJiBpc0Z1bmN0aW9uKHguZ2V0UmVhZGVyKTtcbn07XG5cbmV4cG9ydHMuaXNSZWFkYWJsZURPTVN0cmVhbSA9IGlzUmVhZGFibGVET01TdHJlYW07XG5cbnZhciBpc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyKHgpIHtcbiAgcmV0dXJuIHggJiYgKDAsIF90eXBlb2YyLmRlZmF1bHQpKHgpID09PSAnb2JqZWN0JyAmJiB4LmlzQnVmZmVyO1xufTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IGlzQnVmZmVyO1xuXG52YXIgaXNXcml0YWJsZU5vZGVTdHJlYW0gPSBmdW5jdGlvbiBpc1dyaXRhYmxlTm9kZVN0cmVhbSh4KSB7XG4gIHJldHVybiBpc09iamVjdCh4KSAmJiBpc0Z1bmN0aW9uKHguZW5kKSAmJiBpc0Z1bmN0aW9uKHgud3JpdGUpICYmIGlzQm9vbGVhbih4LndyaXRhYmxlKTtcbn07XG5cbmV4cG9ydHMuaXNXcml0YWJsZU5vZGVTdHJlYW0gPSBpc1dyaXRhYmxlTm9kZVN0cmVhbTtcblxudmFyIGlzUmVhZGFibGVOb2RlU3RyZWFtID0gZnVuY3Rpb24gaXNSZWFkYWJsZU5vZGVTdHJlYW0oeCkge1xuICByZXR1cm4gaXNPYmplY3QoeCkgJiYgaXNGdW5jdGlvbih4LnJlYWQpICYmIGlzRnVuY3Rpb24oeC5waXBlKSAmJiBpc0Jvb2xlYW4oeC5yZWFkYWJsZSk7XG59O1xuXG5leHBvcnRzLmlzUmVhZGFibGVOb2RlU3RyZWFtID0gaXNSZWFkYWJsZU5vZGVTdHJlYW07XG5cbnZhciBpc1JlYWRhYmxlU3RyZWFtID0gZnVuY3Rpb24gaXNSZWFkYWJsZVN0cmVhbSh4KSB7XG4gIHJldHVybiBpc1JlYWRhYmxlRE9NU3RyZWFtKHgpIHx8IGlzUmVhZGFibGVOb2RlU3RyZWFtKHgpO1xufTtcblxuZXhwb3J0cy5pc1JlYWRhYmxlU3RyZWFtID0gaXNSZWFkYWJsZVN0cmVhbTtcblxudmFyIGlzV3JpdGFibGVTdHJlYW0gPSBmdW5jdGlvbiBpc1dyaXRhYmxlU3RyZWFtKHgpIHtcbiAgcmV0dXJuIGlzV3JpdGFibGVET01TdHJlYW0oeCkgfHwgaXNXcml0YWJsZU5vZGVTdHJlYW0oeCk7XG59O1xuXG5leHBvcnRzLmlzV3JpdGFibGVTdHJlYW0gPSBpc1dyaXRhYmxlU3RyZWFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtdHlwZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmV4cG9ydHMuZW5jb2RlU3luYyA9IGVuY29kZVN5bmM7XG5leHBvcnRzLmVuY29kZVRleHQgPSBlbmNvZGVUZXh0O1xuZXhwb3J0cy5lbmNvZGVJbkJhdGNoZXMgPSBlbmNvZGVJbkJhdGNoZXM7XG5leHBvcnRzLmVuY29kZVVSTHRvVVJMID0gZW5jb2RlVVJMdG9VUkw7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jSXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY0l0ZXJhdG9yXCIpKTtcblxudmFyIF9sb2FkZXJVdGlscyA9IHJlcXVpcmUoXCJAbG9hZGVycy5nbC9sb2FkZXItdXRpbHNcIik7XG5cbnZhciBfd3JpdGVGaWxlID0gcmVxdWlyZShcIi4uL2ZldGNoL3dyaXRlLWZpbGVcIik7XG5cbnZhciBfZmV0Y2hGaWxlID0gcmVxdWlyZShcIi4uL2ZldGNoL2ZldGNoLWZpbGVcIik7XG5cbmZ1bmN0aW9uIGVuY29kZShfeCwgX3gyLCBfeDMpIHtcbiAgcmV0dXJuIF9lbmNvZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2VuY29kZSgpIHtcbiAgX2VuY29kZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKGRhdGEsIHdyaXRlciwgb3B0aW9ucykge1xuICAgIHZhciBiYXRjaGVzLCBjaHVua3MsIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24sIF9kaWRJdGVyYXRvckVycm9yLCBfaXRlcmF0b3JFcnJvciwgX2l0ZXJhdG9yLCBfc3RlcCwgX3ZhbHVlLCBiYXRjaCwgdG1wSW5wdXRGaWxlbmFtZSwgdG1wT3V0cHV0RmlsZW5hbWUsIG91dHB1dEZpbGVuYW1lLCByZXNwb25zZTtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCF3cml0ZXIuZW5jb2RlKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyLmVuY29kZShkYXRhLCBvcHRpb25zKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBpZiAoIXdyaXRlci5lbmNvZGVTeW5jKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB3cml0ZXIuZW5jb2RlU3luYyhkYXRhLCBvcHRpb25zKSk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBpZiAoIXdyaXRlci5lbmNvZGVUZXh0KSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0LnQwID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTA7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyLmVuY29kZVRleHQoZGF0YSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgX2NvbnRleHQudDEgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dC50MC5lbmNvZGUuY2FsbChfY29udGV4dC50MCwgX2NvbnRleHQudDEpKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBpZiAoIXdyaXRlci5lbmNvZGVJbkJhdGNoZXMpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYmF0Y2hlcyA9IGVuY29kZUluQmF0Y2hlcyhkYXRhLCB3cml0ZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY2h1bmtzID0gW107XG4gICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTc7XG4gICAgICAgICAgICBfaXRlcmF0b3IgPSAoMCwgX2FzeW5jSXRlcmF0b3IyLmRlZmF1bHQpKGJhdGNoZXMpO1xuXG4gICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyMTtcbiAgICAgICAgICAgIHJldHVybiBfaXRlcmF0b3IubmV4dCgpO1xuXG4gICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgIF9zdGVwID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSBfc3RlcC5kb25lO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI1O1xuICAgICAgICAgICAgcmV0dXJuIF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgIF92YWx1ZSA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgIGlmIChfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJhdGNoID0gX3ZhbHVlO1xuICAgICAgICAgICAgY2h1bmtzLnB1c2goYmF0Y2gpO1xuXG4gICAgICAgICAgY2FzZSAyOTpcbiAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE5O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM4O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDM0O1xuICAgICAgICAgICAgX2NvbnRleHQudDIgPSBfY29udGV4dFtcImNhdGNoXCJdKDE3KTtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gX2NvbnRleHQudDI7XG5cbiAgICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDM4O1xuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDM5O1xuXG4gICAgICAgICAgICBpZiAoISghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0MztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0MztcbiAgICAgICAgICAgIHJldHVybiBfaXRlcmF0b3IucmV0dXJuKCk7XG5cbiAgICAgICAgICBjYXNlIDQzOlxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDQzO1xuXG4gICAgICAgICAgICBpZiAoIV9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0NjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuXG4gICAgICAgICAgY2FzZSA0NjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5maW5pc2goNDMpO1xuXG4gICAgICAgICAgY2FzZSA0NzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5maW5pc2goMzgpO1xuXG4gICAgICAgICAgY2FzZSA0ODpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2xvYWRlclV0aWxzLmNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzLmFwcGx5KHZvaWQgMCwgY2h1bmtzKSk7XG5cbiAgICAgICAgICBjYXNlIDQ5OlxuICAgICAgICAgICAgaWYgKCEoIV9sb2FkZXJVdGlscy5pc0Jyb3dzZXIgJiYgd3JpdGVyLmVuY29kZVVSTHRvVVJMKSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0bXBJbnB1dEZpbGVuYW1lID0gZ2V0VGVtcG9yYXJ5RmlsZW5hbWUoJ2lucHV0Jyk7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTM7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF93cml0ZUZpbGUud3JpdGVGaWxlKSh0bXBJbnB1dEZpbGVuYW1lLCBkYXRhKTtcblxuICAgICAgICAgIGNhc2UgNTM6XG4gICAgICAgICAgICB0bXBPdXRwdXRGaWxlbmFtZSA9IGdldFRlbXBvcmFyeUZpbGVuYW1lKCdvdXRwdXQnKTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA1NjtcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVVUkx0b1VSTCh0bXBJbnB1dEZpbGVuYW1lLCB0bXBPdXRwdXRGaWxlbmFtZSwgd3JpdGVyLCBvcHRpb25zKTtcblxuICAgICAgICAgIGNhc2UgNTY6XG4gICAgICAgICAgICBvdXRwdXRGaWxlbmFtZSA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9mZXRjaEZpbGUuZmV0Y2hGaWxlKShvdXRwdXRGaWxlbmFtZSk7XG5cbiAgICAgICAgICBjYXNlIDU5OlxuICAgICAgICAgICAgcmVzcG9uc2UgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCByZXNwb25zZS5hcnJheUJ1ZmZlcigpKTtcblxuICAgICAgICAgIGNhc2UgNjE6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dyaXRlciBjb3VsZCBub3QgZW5jb2RlIGRhdGEnKTtcblxuICAgICAgICAgIGNhc2UgNjI6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbMTcsIDM0LCAzOCwgNDhdLCBbMzksLCA0MywgNDddXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9lbmNvZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlU3luYyhkYXRhLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgaWYgKHdyaXRlci5lbmNvZGVTeW5jKSB7XG4gICAgcmV0dXJuIHdyaXRlci5lbmNvZGVTeW5jKGRhdGEsIG9wdGlvbnMpO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdXcml0ZXIgY291bGQgbm90IHN5bmNocm9ub3VzbHkgZW5jb2RlIGRhdGEnKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlVGV4dChfeDQsIF94NSwgX3g2KSB7XG4gIHJldHVybiBfZW5jb2RlVGV4dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZW5jb2RlVGV4dCgpIHtcbiAgX2VuY29kZVRleHQgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoZGF0YSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgdmFyIGFycmF5QnVmZmVyO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghKHdyaXRlci50ZXh0ICYmIHdyaXRlci5lbmNvZGVUZXh0KSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyLmVuY29kZVRleHQoZGF0YSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDIuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBpZiAoISh3cml0ZXIudGV4dCAmJiAod3JpdGVyLmVuY29kZSB8fCB3cml0ZXIuZW5jb2RlSW5CYXRjaGVzKSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA3O1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZShkYXRhLCB3cml0ZXIsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgYXJyYXlCdWZmZXIgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShhcnJheUJ1ZmZlcikpO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcml0ZXIgY291bGQgbm90IGVuY29kZSBkYXRhIGFzIHRleHQnKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMik7XG4gIH0pKTtcbiAgcmV0dXJuIF9lbmNvZGVUZXh0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUluQmF0Y2hlcyhkYXRhLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgaWYgKHdyaXRlci5lbmNvZGVJbkJhdGNoZXMpIHtcbiAgICB2YXIgZGF0YUl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoZGF0YSk7XG4gICAgcmV0dXJuIHdyaXRlci5lbmNvZGVJbkJhdGNoZXMoZGF0YUl0ZXJhdG9yLCBvcHRpb25zKTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignV3JpdGVyIGNvdWxkIG5vdCBlbmNvZGUgZGF0YSBpbiBiYXRjaGVzJyk7XG59XG5cbmZ1bmN0aW9uIGVuY29kZVVSTHRvVVJMKF94NywgX3g4LCBfeDksIF94MTApIHtcbiAgcmV0dXJuIF9lbmNvZGVVUkx0b1VSTC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZW5jb2RlVVJMdG9VUkwoKSB7XG4gIF9lbmNvZGVVUkx0b1VSTCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhpbnB1dFVybCwgb3V0cHV0VXJsLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICB2YXIgb3V0cHV0RmlsZW5hbWU7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaW5wdXRVcmwgPSAoMCwgX2xvYWRlclV0aWxzLnJlc29sdmVQYXRoKShpbnB1dFVybCk7XG4gICAgICAgICAgICBvdXRwdXRVcmwgPSAoMCwgX2xvYWRlclV0aWxzLnJlc29sdmVQYXRoKShvdXRwdXRVcmwpO1xuXG4gICAgICAgICAgICBpZiAoIShfbG9hZGVyVXRpbHMuaXNCcm93c2VyIHx8ICF3cml0ZXIuZW5jb2RlVVJMdG9VUkwpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA2O1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlci5lbmNvZGVVUkx0b1VSTChpbnB1dFVybCwgb3V0cHV0VXJsLCBvcHRpb25zKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIG91dHB1dEZpbGVuYW1lID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBvdXRwdXRGaWxlbmFtZSk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9lbmNvZGVVUkx0b1VSTC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRJdGVyYXRvcihkYXRhKSB7XG4gIHZhciBkYXRhSXRlcmF0b3IgPSBbe1xuICAgIHRhYmxlOiBkYXRhLFxuICAgIHN0YXJ0OiAwLFxuICAgIGVuZDogZGF0YS5sZW5ndGhcbiAgfV07XG4gIHJldHVybiBkYXRhSXRlcmF0b3I7XG59XG5cbmZ1bmN0aW9uIGdldFRlbXBvcmFyeUZpbGVuYW1lKGZpbGVuYW1lKSB7XG4gIHJldHVybiBcIi90bXAvXCIuY29uY2F0KGZpbGVuYW1lKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVuY29kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmxvYWRJbkJhdGNoZXMgPSBsb2FkSW5CYXRjaGVzO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9ub3JtYWxpemVMb2FkZXIgPSByZXF1aXJlKFwiLi4vbG9hZGVyLXV0aWxzL25vcm1hbGl6ZS1sb2FkZXJcIik7XG5cbnZhciBfb3B0aW9uVXRpbHMgPSByZXF1aXJlKFwiLi4vbG9hZGVyLXV0aWxzL29wdGlvbi11dGlsc1wiKTtcblxudmFyIF9wYXJzZUluQmF0Y2hlcyA9IHJlcXVpcmUoXCIuL3BhcnNlLWluLWJhdGNoZXNcIik7XG5cbmZ1bmN0aW9uIGxvYWRJbkJhdGNoZXMoZmlsZXMsIGxvYWRlcnMsIG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxvYWRlcnMpICYmICEoMCwgX25vcm1hbGl6ZUxvYWRlci5pc0xvYWRlck9iamVjdCkobG9hZGVycykpIHtcbiAgICBjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIG9wdGlvbnMgPSBsb2FkZXJzO1xuICAgIGxvYWRlcnMgPSBudWxsO1xuICB9XG5cbiAgdmFyIGZldGNoID0gKDAsIF9vcHRpb25VdGlscy5nZXRGZXRjaEZ1bmN0aW9uKShvcHRpb25zIHx8IHt9KTtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkoZmlsZXMpKSB7XG4gICAgcmV0dXJuIGxvYWRPbmVGaWxlSW5CYXRjaGVzKGZpbGVzLCBsb2FkZXJzLCBvcHRpb25zLCBmZXRjaCk7XG4gIH1cblxuICB2YXIgcHJvbWlzZXMgPSBmaWxlcy5tYXAoZnVuY3Rpb24gKGZpbGUpIHtcbiAgICByZXR1cm4gbG9hZE9uZUZpbGVJbkJhdGNoZXMoZmlsZSwgbG9hZGVycywgb3B0aW9ucywgZmV0Y2gpO1xuICB9KTtcbiAgcmV0dXJuIHByb21pc2VzO1xufVxuXG5mdW5jdGlvbiBsb2FkT25lRmlsZUluQmF0Y2hlcyhfeCwgX3gyLCBfeDMsIF94NCkge1xuICByZXR1cm4gX2xvYWRPbmVGaWxlSW5CYXRjaGVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9sb2FkT25lRmlsZUluQmF0Y2hlcygpIHtcbiAgX2xvYWRPbmVGaWxlSW5CYXRjaGVzID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoZmlsZSwgbG9hZGVycywgb3B0aW9ucywgZmV0Y2gpIHtcbiAgICB2YXIgdXJsLCByZXNwb25zZTtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghKHR5cGVvZiBmaWxlID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1cmwgPSBmaWxlO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2godXJsKTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJlc3BvbnNlID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3O1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfcGFyc2VJbkJhdGNoZXMucGFyc2VJbkJhdGNoZXMpKHJlc3BvbnNlLCBsb2FkZXJzLCBvcHRpb25zKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTA7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9wYXJzZUluQmF0Y2hlcy5wYXJzZUluQmF0Y2hlcykoZmlsZSwgbG9hZGVycywgb3B0aW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dC5zZW50KTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUpO1xuICB9KSk7XG4gIHJldHVybiBfbG9hZE9uZUZpbGVJbkJhdGNoZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWQtaW4tYmF0Y2hlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9pc1R5cGUgPSByZXF1aXJlKFwiLi4vLi4vamF2YXNjcmlwdC11dGlscy9pcy10eXBlXCIpO1xuXG52YXIgX25vcm1hbGl6ZUxvYWRlciA9IHJlcXVpcmUoXCIuLi9sb2FkZXItdXRpbHMvbm9ybWFsaXplLWxvYWRlclwiKTtcblxudmFyIF9vcHRpb25VdGlscyA9IHJlcXVpcmUoXCIuLi9sb2FkZXItdXRpbHMvb3B0aW9uLXV0aWxzXCIpO1xuXG52YXIgX3BhcnNlID0gcmVxdWlyZShcIi4vcGFyc2VcIik7XG5cbmZ1bmN0aW9uIGxvYWQoX3gsIF94MiwgX3gzLCBfeDQpIHtcbiAgcmV0dXJuIF9sb2FkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9sb2FkKCkge1xuICBfbG9hZCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKHVybCwgbG9hZGVycywgb3B0aW9ucywgY29udGV4dCkge1xuICAgIHZhciBmZXRjaCwgZGF0YTtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShsb2FkZXJzKSAmJiAhKDAsIF9ub3JtYWxpemVMb2FkZXIuaXNMb2FkZXJPYmplY3QpKGxvYWRlcnMpKSB7XG4gICAgICAgICAgICAgIGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIG9wdGlvbnMgPSBsb2FkZXJzO1xuICAgICAgICAgICAgICBsb2FkZXJzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmZXRjaCA9ICgwLCBfb3B0aW9uVXRpbHMuZ2V0RmV0Y2hGdW5jdGlvbikob3B0aW9ucyk7XG4gICAgICAgICAgICBkYXRhID0gdXJsO1xuXG4gICAgICAgICAgICBpZiAoISh0eXBlb2YgdXJsID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaCh1cmwpO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgZGF0YSA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBpZiAoISgwLCBfaXNUeXBlLmlzQmxvYikodXJsKSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTA7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2godXJsKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBkYXRhID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTM7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9wYXJzZS5wYXJzZSkoZGF0YSwgbG9hZGVycywgb3B0aW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dC5zZW50KTtcblxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUpO1xuICB9KSk7XG4gIHJldHVybiBfbG9hZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnBhcnNlSW5CYXRjaGVzID0gcGFyc2VJbkJhdGNoZXM7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfdHlwZW9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfd3JhcEFzeW5jR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvd3JhcEFzeW5jR2VuZXJhdG9yXCIpKTtcblxudmFyIF9hd2FpdEFzeW5jR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXdhaXRBc3luY0dlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNJdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jSXRlcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jR2VuZXJhdG9yRGVsZWdhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY0dlbmVyYXRvckRlbGVnYXRlXCIpKTtcblxudmFyIF9sb2FkZXJVdGlscyA9IHJlcXVpcmUoXCJAbG9hZGVycy5nbC9sb2FkZXItdXRpbHNcIik7XG5cbnZhciBfbm9ybWFsaXplTG9hZGVyID0gcmVxdWlyZShcIi4uL2xvYWRlci11dGlscy9ub3JtYWxpemUtbG9hZGVyXCIpO1xuXG52YXIgX29wdGlvblV0aWxzID0gcmVxdWlyZShcIi4uL2xvYWRlci11dGlscy9vcHRpb24tdXRpbHNcIik7XG5cbnZhciBfbG9hZGVyQ29udGV4dCA9IHJlcXVpcmUoXCIuLi9sb2FkZXItdXRpbHMvbG9hZGVyLWNvbnRleHRcIik7XG5cbnZhciBfZ2V0RGF0YSA9IHJlcXVpcmUoXCIuLi9sb2FkZXItdXRpbHMvZ2V0LWRhdGFcIik7XG5cbnZhciBfcmVzb3VyY2VVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy9yZXNvdXJjZS11dGlsc1wiKTtcblxudmFyIF9zZWxlY3RMb2FkZXIgPSByZXF1aXJlKFwiLi9zZWxlY3QtbG9hZGVyXCIpO1xuXG52YXIgX3BhcnNlID0gcmVxdWlyZShcIi4vcGFyc2VcIik7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBwYXJzZUluQmF0Y2hlcyhfeDIsIF94MywgX3g0LCBfeDUpIHtcbiAgcmV0dXJuIF9wYXJzZUluQmF0Y2hlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfcGFyc2VJbkJhdGNoZXMoKSB7XG4gIF9wYXJzZUluQmF0Y2hlcyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMihkYXRhLCBsb2FkZXJzLCBvcHRpb25zLCBjb250ZXh0KSB7XG4gICAgdmFyIF9nZXRSZXNvdXJjZVVybEFuZFR5cCwgdXJsLCBsb2FkZXI7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAoMCwgX2xvYWRlclV0aWxzLmFzc2VydCkoIWNvbnRleHQgfHwgKDAsIF90eXBlb2YyLmRlZmF1bHQpKGNvbnRleHQpID09PSAnb2JqZWN0Jyk7XG5cbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShsb2FkZXJzKSAmJiAhKDAsIF9ub3JtYWxpemVMb2FkZXIuaXNMb2FkZXJPYmplY3QpKGxvYWRlcnMpKSB7XG4gICAgICAgICAgICAgIGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIG9wdGlvbnMgPSBsb2FkZXJzO1xuICAgICAgICAgICAgICBsb2FkZXJzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDQ7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgX2dldFJlc291cmNlVXJsQW5kVHlwID0gKDAsIF9yZXNvdXJjZVV0aWxzLmdldFJlc291cmNlVXJsQW5kVHlwZSkoZGF0YSksIHVybCA9IF9nZXRSZXNvdXJjZVVybEFuZFR5cC51cmw7XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9zZWxlY3RMb2FkZXIuc2VsZWN0TG9hZGVyKShkYXRhLCBsb2FkZXJzLCBvcHRpb25zKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGxvYWRlciA9IF9jb250ZXh0My5zZW50O1xuXG4gICAgICAgICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBudWxsKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBvcHRpb25zID0gKDAsIF9vcHRpb25VdGlscy5ub3JtYWxpemVPcHRpb25zKShvcHRpb25zLCBsb2FkZXIsIGxvYWRlcnMsIHVybCk7XG4gICAgICAgICAgICBjb250ZXh0ID0gKDAsIF9sb2FkZXJDb250ZXh0LmdldExvYWRlckNvbnRleHQpKHtcbiAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgIHBhcnNlSW5CYXRjaGVzOiBwYXJzZUluQmF0Y2hlcyxcbiAgICAgICAgICAgICAgcGFyc2U6IF9wYXJzZS5wYXJzZSxcbiAgICAgICAgICAgICAgbG9hZGVyczogbG9hZGVyc1xuICAgICAgICAgICAgfSwgb3B0aW9ucywgY29udGV4dCk7XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDE2O1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlV2l0aExvYWRlckluQmF0Y2hlcyhsb2FkZXIsIGRhdGEsIG9wdGlvbnMsIGNvbnRleHQpO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0My5zZW50KTtcblxuICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMik7XG4gIH0pKTtcbiAgcmV0dXJuIF9wYXJzZUluQmF0Y2hlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVdpdGhMb2FkZXJJbkJhdGNoZXMobG9hZGVyLCBkYXRhLCBvcHRpb25zLCBjb250ZXh0KSB7XG4gIHZhciBvdXRwdXRJdGVyYXRvciwgbWV0YWRhdGFCYXRjaCwgbWFrZU1ldGFkYXRhQmF0Y2hJdGVyYXRvciwgX21ha2VNZXRhZGF0YUJhdGNoSXRlcmF0b3I7XG5cbiAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LmFzeW5jKGZ1bmN0aW9uIHBhcnNlV2l0aExvYWRlckluQmF0Y2hlcyQoX2NvbnRleHQpIHtcbiAgICB3aGlsZSAoMSkge1xuICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgX21ha2VNZXRhZGF0YUJhdGNoSXRlcmF0b3IgPSBmdW5jdGlvbiBfbWFrZU1ldGFkYXRhQmF0Y2hJdGUyKCkge1xuICAgICAgICAgICAgX21ha2VNZXRhZGF0YUJhdGNoSXRlcmF0b3IgPSAoMCwgX3dyYXBBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKGl0ZXJhdG9yKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0Mikge1xuICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWV0YWRhdGFCYXRjaDtcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5kZWxlZ2F0ZVlpZWxkKCgwLCBfYXN5bmNHZW5lcmF0b3JEZWxlZ2F0ZTIuZGVmYXVsdCkoKDAsIF9hc3luY0l0ZXJhdG9yMi5kZWZhdWx0KShpdGVyYXRvciksIF9hd2FpdEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KSwgXCJ0MFwiLCAzKTtcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sIF9jYWxsZWUpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIF9tYWtlTWV0YWRhdGFCYXRjaEl0ZXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIG1ha2VNZXRhZGF0YUJhdGNoSXRlcmF0b3IgPSBmdW5jdGlvbiBfbWFrZU1ldGFkYXRhQmF0Y2hJdGUoX3gpIHtcbiAgICAgICAgICAgIHJldHVybiBfbWFrZU1ldGFkYXRhQmF0Y2hJdGVyYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQuYXdyYXAocGFyc2VUb091dHB1dEl0ZXJhdG9yKGxvYWRlciwgZGF0YSwgb3B0aW9ucywgY29udGV4dCkpO1xuXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBvdXRwdXRJdGVyYXRvciA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5tZXRhZGF0YSkge1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG91dHB1dEl0ZXJhdG9yKTtcblxuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgbWV0YWRhdGFCYXRjaCA9IHtcbiAgICAgICAgICAgIGJhdGNoVHlwZTogJ21ldGFkYXRhJyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgIF9sb2FkZXI6IGxvYWRlcixcbiAgICAgICAgICAgICAgX2NvbnRleHQ6IGNvbnRleHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgIGJ5dGVzVXNlZDogMFxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBtYWtlTWV0YWRhdGFCYXRjaEl0ZXJhdG9yKG91dHB1dEl0ZXJhdG9yKSk7XG5cbiAgICAgICAgY2FzZSA5OlxuICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIG51bGwsIG51bGwsIG51bGwsIFByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVRvT3V0cHV0SXRlcmF0b3IoX3g2LCBfeDcsIF94OCwgX3g5KSB7XG4gIHJldHVybiBfcGFyc2VUb091dHB1dEl0ZXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9wYXJzZVRvT3V0cHV0SXRlcmF0b3IoKSB7XG4gIF9wYXJzZVRvT3V0cHV0SXRlcmF0b3IgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQobG9hZGVyLCBkYXRhLCBvcHRpb25zLCBjb250ZXh0KSB7XG4gICAgdmFyIGlucHV0SXRlcmF0b3IsIHRyYW5zZm9ybWVkSXRlcmF0b3IsIHBhcnNlQ2h1bmtJbkJhdGNoZXMsIF9wYXJzZUNodW5rSW5CYXRjaGVzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NSkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX3BhcnNlQ2h1bmtJbkJhdGNoZXMgPSBmdW5jdGlvbiBfcGFyc2VDaHVua0luQmF0Y2hlczMoKSB7XG4gICAgICAgICAgICAgIF9wYXJzZUNodW5rSW5CYXRjaGVzID0gKDAsIF93cmFwQXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFycmF5QnVmZmVyLCBwYXJzZWREYXRhLCBiYXRjaDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQ0KSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9hd2FpdEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KSgoMCwgX2xvYWRlclV0aWxzLmNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzQXN5bmMpKHRyYW5zZm9ybWVkSXRlcmF0b3IpKTtcblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5QnVmZmVyID0gX2NvbnRleHQ0LnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9hd2FpdEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KSgoMCwgX3BhcnNlLnBhcnNlKShhcnJheUJ1ZmZlciwgbG9hZGVyLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogbG9hZGVyLm1pbWVUeXBlc1swXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksIGNvbnRleHQpKTtcblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZERhdGEgPSBfY29udGV4dDQuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhdGNoID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogbG9hZGVyLm1pbWVUeXBlc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGU6IEFycmF5LmlzQXJyYXkocGFyc2VkRGF0YSkgPyAncm93LXRhYmxlJyA6ICd1bmtub3duJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYmF0Y2hUeXBlOiAnZGF0YScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHBhcnNlZERhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aDogQXJyYXkuaXNBcnJheShwYXJzZWREYXRhKSA/IHBhcnNlZERhdGEubGVuZ3RoIDogMVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXRjaDtcblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUzKTtcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICByZXR1cm4gX3BhcnNlQ2h1bmtJbkJhdGNoZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHBhcnNlQ2h1bmtJbkJhdGNoZXMgPSBmdW5jdGlvbiBfcGFyc2VDaHVua0luQmF0Y2hlczIoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfcGFyc2VDaHVua0luQmF0Y2hlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA0O1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfZ2V0RGF0YS5nZXRBc3luY0l0ZXJhYmxlRnJvbURhdGEpKGRhdGEsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgaW5wdXRJdGVyYXRvciA9IF9jb250ZXh0NS5zZW50O1xuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA3O1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5SW5wdXRUcmFuc2Zvcm1zKGlucHV0SXRlcmF0b3IsIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtcykgfHwgW10pO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgdHJhbnNmb3JtZWRJdGVyYXRvciA9IF9jb250ZXh0NS5zZW50O1xuXG4gICAgICAgICAgICBpZiAoIWxvYWRlci5wYXJzZUluQmF0Y2hlcykge1xuICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDEwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgbG9hZGVyLnBhcnNlSW5CYXRjaGVzKHRyYW5zZm9ybWVkSXRlcmF0b3IsIG9wdGlvbnMsIGNvbnRleHQpKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCBwYXJzZUNodW5rSW5CYXRjaGVzKCkpO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU0KTtcbiAgfSkpO1xuICByZXR1cm4gX3BhcnNlVG9PdXRwdXRJdGVyYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBhcHBseUlucHV0VHJhbnNmb3JtcyhfeDEwKSB7XG4gIHJldHVybiBfYXBwbHlJbnB1dFRyYW5zZm9ybXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2FwcGx5SW5wdXRUcmFuc2Zvcm1zKCkge1xuICBfYXBwbHlJbnB1dFRyYW5zZm9ybXMgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTUoaW5wdXRJdGVyYXRvcikge1xuICAgIHZhciB0cmFuc2Zvcm1zLFxuICAgICAgICBpdGVyYXRvckNoYWluLFxuICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uLFxuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcixcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IsXG4gICAgICAgIF9pdGVyYXRvcixcbiAgICAgICAgX3N0ZXAsXG4gICAgICAgIF92YWx1ZSxcbiAgICAgICAgdHJhbnNmb3JtQmF0Y2hlcyxcbiAgICAgICAgX2FyZ3M2ID0gYXJndW1lbnRzO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0Nikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDYucHJldiA9IF9jb250ZXh0Ni5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdHJhbnNmb3JtcyA9IF9hcmdzNi5sZW5ndGggPiAxICYmIF9hcmdzNlsxXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3M2WzFdIDogW107XG4gICAgICAgICAgICBpdGVyYXRvckNoYWluID0gaW5wdXRJdGVyYXRvcjtcbiAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgIF9jb250ZXh0Ni5wcmV2ID0gNDtcbiAgICAgICAgICAgIF9pdGVyYXRvciA9ICgwLCBfYXN5bmNJdGVyYXRvcjIuZGVmYXVsdCkodHJhbnNmb3Jtcyk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDg7XG4gICAgICAgICAgICByZXR1cm4gX2l0ZXJhdG9yLm5leHQoKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIF9zdGVwID0gX2NvbnRleHQ2LnNlbnQ7XG4gICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gX3N0ZXAuZG9uZTtcbiAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMTI7XG4gICAgICAgICAgICByZXR1cm4gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgX3ZhbHVlID0gX2NvbnRleHQ2LnNlbnQ7XG5cbiAgICAgICAgICAgIGlmIChfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMTk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cmFuc2Zvcm1CYXRjaGVzID0gX3ZhbHVlO1xuICAgICAgICAgICAgaXRlcmF0b3JDaGFpbiA9IHRyYW5zZm9ybUJhdGNoZXMoaXRlcmF0b3JDaGFpbik7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDY7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDI1O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgX2NvbnRleHQ2LnByZXYgPSAyMTtcbiAgICAgICAgICAgIF9jb250ZXh0Ni50MCA9IF9jb250ZXh0NltcImNhdGNoXCJdKDQpO1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBfY29udGV4dDYudDA7XG5cbiAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgX2NvbnRleHQ2LnByZXYgPSAyNTtcbiAgICAgICAgICAgIF9jb250ZXh0Ni5wcmV2ID0gMjY7XG5cbiAgICAgICAgICAgIGlmICghKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAzMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMzA7XG4gICAgICAgICAgICByZXR1cm4gX2l0ZXJhdG9yLnJldHVybigpO1xuXG4gICAgICAgICAgY2FzZSAzMDpcbiAgICAgICAgICAgIF9jb250ZXh0Ni5wcmV2ID0gMzA7XG5cbiAgICAgICAgICAgIGlmICghX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAzMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuXG4gICAgICAgICAgY2FzZSAzMzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuZmluaXNoKDMwKTtcblxuICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmZpbmlzaCgyNSk7XG5cbiAgICAgICAgICBjYXNlIDM1OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgaXRlcmF0b3JDaGFpbik7XG5cbiAgICAgICAgICBjYXNlIDM2OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTUsIG51bGwsIFtbNCwgMjEsIDI1LCAzNV0sIFsyNiwsIDMwLCAzNF1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2FwcGx5SW5wdXRUcmFuc2Zvcm1zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZS1pbi1iYXRjaGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucGFyc2VTeW5jID0gcGFyc2VTeW5jO1xuXG52YXIgX3R5cGVvZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKSk7XG5cbnZhciBfbG9hZGVyVXRpbHMgPSByZXF1aXJlKFwiQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzXCIpO1xuXG52YXIgX3NlbGVjdExvYWRlciA9IHJlcXVpcmUoXCIuL3NlbGVjdC1sb2FkZXJcIik7XG5cbnZhciBfbm9ybWFsaXplTG9hZGVyID0gcmVxdWlyZShcIi4uL2xvYWRlci11dGlscy9ub3JtYWxpemUtbG9hZGVyXCIpO1xuXG52YXIgX29wdGlvblV0aWxzID0gcmVxdWlyZShcIi4uL2xvYWRlci11dGlscy9vcHRpb24tdXRpbHNcIik7XG5cbnZhciBfZ2V0RGF0YSA9IHJlcXVpcmUoXCIuLi9sb2FkZXItdXRpbHMvZ2V0LWRhdGFcIik7XG5cbnZhciBfbG9hZGVyQ29udGV4dCA9IHJlcXVpcmUoXCIuLi9sb2FkZXItdXRpbHMvbG9hZGVyLWNvbnRleHRcIik7XG5cbnZhciBfcmVzb3VyY2VVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy9yZXNvdXJjZS11dGlsc1wiKTtcblxuZnVuY3Rpb24gcGFyc2VTeW5jKGRhdGEsIGxvYWRlcnMsIG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgKDAsIF9sb2FkZXJVdGlscy5hc3NlcnQpKCFjb250ZXh0IHx8ICgwLCBfdHlwZW9mMi5kZWZhdWx0KShjb250ZXh0KSA9PT0gJ29iamVjdCcpO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShsb2FkZXJzKSAmJiAhKDAsIF9ub3JtYWxpemVMb2FkZXIuaXNMb2FkZXJPYmplY3QpKGxvYWRlcnMpKSB7XG4gICAgY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICBvcHRpb25zID0gbG9hZGVycztcbiAgICBsb2FkZXJzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlZExvYWRlcnMgPSBsb2FkZXJzO1xuICB2YXIgY2FuZGlkYXRlTG9hZGVycyA9ICgwLCBfbG9hZGVyQ29udGV4dC5nZXRMb2FkZXJzRnJvbUNvbnRleHQpKHR5cGVkTG9hZGVycywgY29udGV4dCk7XG4gIHZhciBsb2FkZXIgPSAoMCwgX3NlbGVjdExvYWRlci5zZWxlY3RMb2FkZXJTeW5jKShkYXRhLCBjYW5kaWRhdGVMb2FkZXJzLCBvcHRpb25zKTtcblxuICBpZiAoIWxvYWRlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgb3B0aW9ucyA9ICgwLCBfb3B0aW9uVXRpbHMubm9ybWFsaXplT3B0aW9ucykob3B0aW9ucywgbG9hZGVyLCBjYW5kaWRhdGVMb2FkZXJzKTtcblxuICB2YXIgX2dldFJlc291cmNlVXJsQW5kVHlwID0gKDAsIF9yZXNvdXJjZVV0aWxzLmdldFJlc291cmNlVXJsQW5kVHlwZSkoZGF0YSksXG4gICAgICB1cmwgPSBfZ2V0UmVzb3VyY2VVcmxBbmRUeXAudXJsO1xuXG4gIHZhciBwYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncGFyc2VTeW5jIGNhbGxlZCBwYXJzZScpO1xuICB9O1xuXG4gIGNvbnRleHQgPSAoMCwgX2xvYWRlckNvbnRleHQuZ2V0TG9hZGVyQ29udGV4dCkoe1xuICAgIHVybDogdXJsLFxuICAgIHBhcnNlU3luYzogcGFyc2VTeW5jLFxuICAgIHBhcnNlOiBwYXJzZSxcbiAgICBsb2FkZXJzOiBsb2FkZXJzXG4gIH0sIG9wdGlvbnMpO1xuICByZXR1cm4gcGFyc2VXaXRoTG9hZGVyU3luYyhsb2FkZXIsIGRhdGEsIG9wdGlvbnMsIGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVdpdGhMb2FkZXJTeW5jKGxvYWRlciwgZGF0YSwgb3B0aW9ucywgY29udGV4dCkge1xuICBkYXRhID0gKDAsIF9nZXREYXRhLmdldEFycmF5QnVmZmVyT3JTdHJpbmdGcm9tRGF0YVN5bmMpKGRhdGEsIGxvYWRlciwgb3B0aW9ucyk7XG5cbiAgaWYgKGxvYWRlci5wYXJzZVRleHRTeW5jICYmIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBsb2FkZXIucGFyc2VUZXh0U3luYyhkYXRhLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChsb2FkZXIucGFyc2VTeW5jICYmIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBsb2FkZXIucGFyc2VTeW5jKGRhdGEsIG9wdGlvbnMsIGNvbnRleHQpO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KGxvYWRlci5uYW1lLCBcIiBsb2FkZXI6ICdwYXJzZVN5bmMnIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBsb2FkZXIsIHVzZSAncGFyc2UnIGluc3RlYWQuIFwiKS5jb25jYXQoY29udGV4dC51cmwgfHwgJycpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlLXN5bmMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX3R5cGVvZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX3dvcmtlclV0aWxzID0gcmVxdWlyZShcIkBsb2FkZXJzLmdsL3dvcmtlci11dGlsc1wiKTtcblxudmFyIF9sb2FkZXJVdGlscyA9IHJlcXVpcmUoXCJAbG9hZGVycy5nbC9sb2FkZXItdXRpbHNcIik7XG5cbnZhciBfbm9ybWFsaXplTG9hZGVyID0gcmVxdWlyZShcIi4uL2xvYWRlci11dGlscy9ub3JtYWxpemUtbG9hZGVyXCIpO1xuXG52YXIgX29wdGlvblV0aWxzID0gcmVxdWlyZShcIi4uL2xvYWRlci11dGlscy9vcHRpb24tdXRpbHNcIik7XG5cbnZhciBfZ2V0RGF0YSA9IHJlcXVpcmUoXCIuLi9sb2FkZXItdXRpbHMvZ2V0LWRhdGFcIik7XG5cbnZhciBfbG9hZGVyQ29udGV4dCA9IHJlcXVpcmUoXCIuLi9sb2FkZXItdXRpbHMvbG9hZGVyLWNvbnRleHRcIik7XG5cbnZhciBfcmVzb3VyY2VVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy9yZXNvdXJjZS11dGlsc1wiKTtcblxudmFyIF9zZWxlY3RMb2FkZXIgPSByZXF1aXJlKFwiLi9zZWxlY3QtbG9hZGVyXCIpO1xuXG5mdW5jdGlvbiBwYXJzZShfeCwgX3gyLCBfeDMsIF94NCkge1xuICByZXR1cm4gX3BhcnNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9wYXJzZSgpIHtcbiAgX3BhcnNlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoZGF0YSwgbG9hZGVycywgb3B0aW9ucywgY29udGV4dCkge1xuICAgIHZhciBfZ2V0UmVzb3VyY2VVcmxBbmRUeXAsIHVybCwgdHlwZWRMb2FkZXJzLCBjYW5kaWRhdGVMb2FkZXJzLCBsb2FkZXI7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICgwLCBfd29ya2VyVXRpbHMuYXNzZXJ0KSghY29udGV4dCB8fCAoMCwgX3R5cGVvZjIuZGVmYXVsdCkoY29udGV4dCkgPT09ICdvYmplY3QnKTtcblxuICAgICAgICAgICAgaWYgKGxvYWRlcnMgJiYgIUFycmF5LmlzQXJyYXkobG9hZGVycykgJiYgISgwLCBfbm9ybWFsaXplTG9hZGVyLmlzTG9hZGVyT2JqZWN0KShsb2FkZXJzKSkge1xuICAgICAgICAgICAgICBjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICBvcHRpb25zID0gbG9hZGVycztcbiAgICAgICAgICAgICAgbG9hZGVycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgICBfZ2V0UmVzb3VyY2VVcmxBbmRUeXAgPSAoMCwgX3Jlc291cmNlVXRpbHMuZ2V0UmVzb3VyY2VVcmxBbmRUeXBlKShkYXRhKSwgdXJsID0gX2dldFJlc291cmNlVXJsQW5kVHlwLnVybDtcbiAgICAgICAgICAgIHR5cGVkTG9hZGVycyA9IGxvYWRlcnM7XG4gICAgICAgICAgICBjYW5kaWRhdGVMb2FkZXJzID0gKDAsIF9sb2FkZXJDb250ZXh0LmdldExvYWRlcnNGcm9tQ29udGV4dCkodHlwZWRMb2FkZXJzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX3NlbGVjdExvYWRlci5zZWxlY3RMb2FkZXIpKGRhdGEsIGNhbmRpZGF0ZUxvYWRlcnMsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIGxvYWRlciA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBudWxsKTtcblxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICBvcHRpb25zID0gKDAsIF9vcHRpb25VdGlscy5ub3JtYWxpemVPcHRpb25zKShvcHRpb25zLCBsb2FkZXIsIGNhbmRpZGF0ZUxvYWRlcnMsIHVybCk7XG4gICAgICAgICAgICBjb250ZXh0ID0gKDAsIF9sb2FkZXJDb250ZXh0LmdldExvYWRlckNvbnRleHQpKHtcbiAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgIHBhcnNlOiBwYXJzZSxcbiAgICAgICAgICAgICAgbG9hZGVyczogY2FuZGlkYXRlTG9hZGVyc1xuICAgICAgICAgICAgfSwgb3B0aW9ucywgY29udGV4dCk7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTg7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VXaXRoTG9hZGVyKGxvYWRlciwgZGF0YSwgb3B0aW9ucywgY29udGV4dCk7XG5cbiAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dC5zZW50KTtcblxuICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUpO1xuICB9KSk7XG4gIHJldHVybiBfcGFyc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VXaXRoTG9hZGVyKF94NSwgX3g2LCBfeDcsIF94OCkge1xuICByZXR1cm4gX3BhcnNlV2l0aExvYWRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfcGFyc2VXaXRoTG9hZGVyKCkge1xuICBfcGFyc2VXaXRoTG9hZGVyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGxvYWRlciwgZGF0YSwgb3B0aW9ucywgY29udGV4dCkge1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICgwLCBfd29ya2VyVXRpbHMudmFsaWRhdGVXb3JrZXJWZXJzaW9uKShsb2FkZXIpO1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfZ2V0RGF0YS5nZXRBcnJheUJ1ZmZlck9yU3RyaW5nRnJvbURhdGEpKGRhdGEsIGxvYWRlciwgb3B0aW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBkYXRhID0gX2NvbnRleHQyLnNlbnQ7XG5cbiAgICAgICAgICAgIGlmICghKGxvYWRlci5wYXJzZVRleHRTeW5jICYmIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3B0aW9ucy5kYXRhVHlwZSA9ICd0ZXh0JztcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIGxvYWRlci5wYXJzZVRleHRTeW5jKGRhdGEsIG9wdGlvbnMsIGNvbnRleHQsIGxvYWRlcikpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgaWYgKCEoMCwgX2xvYWRlclV0aWxzLmNhblBhcnNlV2l0aFdvcmtlcikobG9hZGVyLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDExO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMDtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2xvYWRlclV0aWxzLnBhcnNlV2l0aFdvcmtlcikobG9hZGVyLCBkYXRhLCBvcHRpb25zLCBjb250ZXh0LCBwYXJzZSk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQyLnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIGlmICghKGxvYWRlci5wYXJzZVRleHQgJiYgdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE1O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNDtcbiAgICAgICAgICAgIHJldHVybiBsb2FkZXIucGFyc2VUZXh0KGRhdGEsIG9wdGlvbnMsIGNvbnRleHQsIGxvYWRlcik7XG5cbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQyLnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIGlmICghbG9hZGVyLnBhcnNlKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE4O1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRlci5wYXJzZShkYXRhLCBvcHRpb25zLCBjb250ZXh0LCBsb2FkZXIpO1xuXG4gICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0Mi5zZW50KTtcblxuICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAoMCwgX3dvcmtlclV0aWxzLmFzc2VydCkoIWxvYWRlci5wYXJzZVN5bmMpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KGxvYWRlci5pZCwgXCIgbG9hZGVyIC0gbm8gcGFyc2VyIGZvdW5kIGFuZCB3b3JrZXIgaXMgZGlzYWJsZWRcIikpO1xuXG4gICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyKTtcbiAgfSkpO1xuICByZXR1cm4gX3BhcnNlV2l0aExvYWRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnJlZ2lzdGVyTG9hZGVycyA9IHJlZ2lzdGVyTG9hZGVycztcbmV4cG9ydHMuZ2V0UmVnaXN0ZXJlZExvYWRlcnMgPSBnZXRSZWdpc3RlcmVkTG9hZGVycztcbmV4cG9ydHMuX3VucmVnaXN0ZXJMb2FkZXJzID0gX3VucmVnaXN0ZXJMb2FkZXJzO1xuXG52YXIgX25vcm1hbGl6ZUxvYWRlciA9IHJlcXVpcmUoXCIuLi9sb2FkZXItdXRpbHMvbm9ybWFsaXplLWxvYWRlclwiKTtcblxudmFyIF9vcHRpb25VdGlscyA9IHJlcXVpcmUoXCIuLi9sb2FkZXItdXRpbHMvb3B0aW9uLXV0aWxzXCIpO1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbnZhciBnZXRHbG9iYWxMb2FkZXJSZWdpc3RyeSA9IGZ1bmN0aW9uIGdldEdsb2JhbExvYWRlclJlZ2lzdHJ5KCkge1xuICB2YXIgc3RhdGUgPSAoMCwgX29wdGlvblV0aWxzLmdldEdsb2JhbExvYWRlclN0YXRlKSgpO1xuICBzdGF0ZS5sb2FkZXJSZWdpc3RyeSA9IHN0YXRlLmxvYWRlclJlZ2lzdHJ5IHx8IFtdO1xuICByZXR1cm4gc3RhdGUubG9hZGVyUmVnaXN0cnk7XG59O1xuXG5mdW5jdGlvbiByZWdpc3RlckxvYWRlcnMobG9hZGVycykge1xuICB2YXIgbG9hZGVyUmVnaXN0cnkgPSBnZXRHbG9iYWxMb2FkZXJSZWdpc3RyeSgpO1xuICBsb2FkZXJzID0gQXJyYXkuaXNBcnJheShsb2FkZXJzKSA/IGxvYWRlcnMgOiBbbG9hZGVyc107XG5cbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGxvYWRlcnMpLFxuICAgICAgX3N0ZXA7XG5cbiAgdHJ5IHtcbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIHZhciBsb2FkZXIgPSBfc3RlcC52YWx1ZTtcbiAgICAgIHZhciBub3JtYWxpemVkTG9hZGVyID0gKDAsIF9ub3JtYWxpemVMb2FkZXIubm9ybWFsaXplTG9hZGVyKShsb2FkZXIpO1xuXG4gICAgICBpZiAoIWxvYWRlclJlZ2lzdHJ5LmZpbmQoZnVuY3Rpb24gKHJlZ2lzdGVyZWRMb2FkZXIpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRMb2FkZXIgPT09IHJlZ2lzdGVyZWRMb2FkZXI7XG4gICAgICB9KSkge1xuICAgICAgICBsb2FkZXJSZWdpc3RyeS51bnNoaWZ0KG5vcm1hbGl6ZWRMb2FkZXIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgX2xvb3AoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSZWdpc3RlcmVkTG9hZGVycygpIHtcbiAgcmV0dXJuIGdldEdsb2JhbExvYWRlclJlZ2lzdHJ5KCk7XG59XG5cbmZ1bmN0aW9uIF91bnJlZ2lzdGVyTG9hZGVycygpIHtcbiAgdmFyIHN0YXRlID0gKDAsIF9vcHRpb25VdGlscy5nZXRHbG9iYWxMb2FkZXJTdGF0ZSkoKTtcbiAgc3RhdGUubG9hZGVyUmVnaXN0cnkgPSBbXTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZ2lzdGVyLWxvYWRlcnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMuc2F2ZVN5bmMgPSBzYXZlU3luYztcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfZW5jb2RlID0gcmVxdWlyZShcIi4vZW5jb2RlXCIpO1xuXG52YXIgX3dyaXRlRmlsZSA9IHJlcXVpcmUoXCIuLi9mZXRjaC93cml0ZS1maWxlXCIpO1xuXG5mdW5jdGlvbiBzYXZlKF94LCBfeDIsIF94MywgX3g0KSB7XG4gIHJldHVybiBfc2F2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfc2F2ZSgpIHtcbiAgX3NhdmUgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZShkYXRhLCB1cmwsIHdyaXRlciwgb3B0aW9ucykge1xuICAgIHZhciBlbmNvZGVkRGF0YTtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfZW5jb2RlLmVuY29kZSkoZGF0YSwgd3JpdGVyLCBvcHRpb25zKTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGVuY29kZWREYXRhID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA1O1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfd3JpdGVGaWxlLndyaXRlRmlsZSkodXJsLCBlbmNvZGVkRGF0YSk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0LnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlKTtcbiAgfSkpO1xuICByZXR1cm4gX3NhdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gc2F2ZVN5bmMoZGF0YSwgdXJsLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgdmFyIGVuY29kZWREYXRhID0gKDAsIF9lbmNvZGUuZW5jb2RlU3luYykoZGF0YSwgd3JpdGVyLCBvcHRpb25zKTtcbiAgcmV0dXJuICgwLCBfd3JpdGVGaWxlLndyaXRlRmlsZVN5bmMpKHVybCwgZW5jb2RlZERhdGEpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2F2ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnNlbGVjdExvYWRlciA9IHNlbGVjdExvYWRlcjtcbmV4cG9ydHMuc2VsZWN0TG9hZGVyU3luYyA9IHNlbGVjdExvYWRlclN5bmM7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfdHlwZW9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpKTtcblxudmFyIF90b0NvbnN1bWFibGVBcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5XCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfbG9hZGVyVXRpbHMgPSByZXF1aXJlKFwiQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzXCIpO1xuXG52YXIgX25vcm1hbGl6ZUxvYWRlciA9IHJlcXVpcmUoXCIuLi9sb2FkZXItdXRpbHMvbm9ybWFsaXplLWxvYWRlclwiKTtcblxudmFyIF9yZXNvdXJjZVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzL3Jlc291cmNlLXV0aWxzXCIpO1xuXG52YXIgX3JlZ2lzdGVyTG9hZGVycyA9IHJlcXVpcmUoXCIuL3JlZ2lzdGVyLWxvYWRlcnNcIik7XG5cbnZhciBfaXNUeXBlID0gcmVxdWlyZShcIi4uLy4uL2phdmFzY3JpcHQtdXRpbHMvaXMtdHlwZVwiKTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxudmFyIEVYVF9QQVRURVJOID0gL1xcLihbXi5dKykkLztcblxuZnVuY3Rpb24gc2VsZWN0TG9hZGVyKF94KSB7XG4gIHJldHVybiBfc2VsZWN0TG9hZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9zZWxlY3RMb2FkZXIoKSB7XG4gIF9zZWxlY3RMb2FkZXIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZShkYXRhKSB7XG4gICAgdmFyIGxvYWRlcnMsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGxvYWRlcixcbiAgICAgICAgX2FyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBsb2FkZXJzID0gX2FyZ3MubGVuZ3RoID4gMSAmJiBfYXJnc1sxXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3NbMV0gOiBbXTtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBfYXJncy5sZW5ndGggPiAyID8gX2FyZ3NbMl0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb250ZXh0ID0gX2FyZ3MubGVuZ3RoID4gMyA/IF9hcmdzWzNdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICBpZiAodmFsaWRIVFRQUmVzcG9uc2UoZGF0YSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG51bGwpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgbG9hZGVyID0gc2VsZWN0TG9hZGVyU3luYyhkYXRhLCBsb2FkZXJzLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgICAgICBub3Rocm93OiB0cnVlXG4gICAgICAgICAgICB9KSwgY29udGV4dCk7XG5cbiAgICAgICAgICAgIGlmICghbG9hZGVyKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBsb2FkZXIpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgaWYgKCEoMCwgX2lzVHlwZS5pc0Jsb2IpKGRhdGEpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLnNsaWNlKDAsIDEwKS5hcnJheUJ1ZmZlcigpO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgbG9hZGVyID0gc2VsZWN0TG9hZGVyU3luYyhkYXRhLCBsb2FkZXJzLCBvcHRpb25zLCBjb250ZXh0KTtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBpZiAoISghbG9hZGVyICYmICEob3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgJiYgb3B0aW9ucy5ub3Rocm93KSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE1O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGdldE5vVmFsaWRMb2FkZXJNZXNzYWdlKGRhdGEpKTtcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGxvYWRlcik7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlKTtcbiAgfSkpO1xuICByZXR1cm4gX3NlbGVjdExvYWRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3RMb2FkZXJTeW5jKGRhdGEpIHtcbiAgdmFyIGxvYWRlcnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICB2YXIgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuXG4gIGlmICghdmFsaWRIVFRQUmVzcG9uc2UoZGF0YSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChsb2FkZXJzICYmICFBcnJheS5pc0FycmF5KGxvYWRlcnMpKSB7XG4gICAgcmV0dXJuICgwLCBfbm9ybWFsaXplTG9hZGVyLm5vcm1hbGl6ZUxvYWRlcikobG9hZGVycyk7XG4gIH1cblxuICB2YXIgY2FuZGlkYXRlTG9hZGVycyA9IFtdO1xuXG4gIGlmIChsb2FkZXJzKSB7XG4gICAgY2FuZGlkYXRlTG9hZGVycyA9IGNhbmRpZGF0ZUxvYWRlcnMuY29uY2F0KGxvYWRlcnMpO1xuICB9XG5cbiAgaWYgKCEob3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgJiYgb3B0aW9ucy5pZ25vcmVSZWdpc3RlcmVkTG9hZGVycykpIHtcbiAgICB2YXIgX2NhbmRpZGF0ZUxvYWRlcnM7XG5cbiAgICAoX2NhbmRpZGF0ZUxvYWRlcnMgPSBjYW5kaWRhdGVMb2FkZXJzKS5wdXNoLmFwcGx5KF9jYW5kaWRhdGVMb2FkZXJzLCAoMCwgX3RvQ29uc3VtYWJsZUFycmF5Mi5kZWZhdWx0KSgoMCwgX3JlZ2lzdGVyTG9hZGVycy5nZXRSZWdpc3RlcmVkTG9hZGVycykoKSkpO1xuICB9XG5cbiAgbm9ybWFsaXplTG9hZGVycyhjYW5kaWRhdGVMb2FkZXJzKTtcbiAgdmFyIGxvYWRlciA9IHNlbGVjdExvYWRlckludGVybmFsKGRhdGEsIGNhbmRpZGF0ZUxvYWRlcnMsIG9wdGlvbnMsIGNvbnRleHQpO1xuXG4gIGlmICghbG9hZGVyICYmICEob3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgJiYgb3B0aW9ucy5ub3Rocm93KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihnZXROb1ZhbGlkTG9hZGVyTWVzc2FnZShkYXRhKSk7XG4gIH1cblxuICByZXR1cm4gbG9hZGVyO1xufVxuXG5mdW5jdGlvbiBzZWxlY3RMb2FkZXJJbnRlcm5hbChkYXRhLCBsb2FkZXJzLCBvcHRpb25zLCBjb250ZXh0KSB7XG4gIHZhciBfZ2V0UmVzb3VyY2VVcmxBbmRUeXAgPSAoMCwgX3Jlc291cmNlVXRpbHMuZ2V0UmVzb3VyY2VVcmxBbmRUeXBlKShkYXRhKSxcbiAgICAgIHVybCA9IF9nZXRSZXNvdXJjZVVybEFuZFR5cC51cmwsXG4gICAgICB0eXBlID0gX2dldFJlc291cmNlVXJsQW5kVHlwLnR5cGU7XG5cbiAgdmFyIHRlc3RVcmwgPSB1cmwgfHwgKGNvbnRleHQgPT09IG51bGwgfHwgY29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGV4dC51cmwpO1xuICB2YXIgbG9hZGVyID0gbnVsbDtcblxuICBpZiAob3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgJiYgb3B0aW9ucy5taW1lVHlwZSkge1xuICAgIGxvYWRlciA9IGZpbmRMb2FkZXJCeU1JTUVUeXBlKGxvYWRlcnMsIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5taW1lVHlwZSk7XG4gIH1cblxuICBsb2FkZXIgPSBsb2FkZXIgfHwgZmluZExvYWRlckJ5VXJsKGxvYWRlcnMsIHRlc3RVcmwpO1xuICBsb2FkZXIgPSBsb2FkZXIgfHwgZmluZExvYWRlckJ5TUlNRVR5cGUobG9hZGVycywgdHlwZSk7XG4gIGxvYWRlciA9IGxvYWRlciB8fCBmaW5kTG9hZGVyQnlJbml0aWFsQnl0ZXMobG9hZGVycywgZGF0YSk7XG4gIGxvYWRlciA9IGxvYWRlciB8fCBmaW5kTG9hZGVyQnlNSU1FVHlwZShsb2FkZXJzLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZmFsbGJhY2tNaW1lVHlwZSk7XG4gIHJldHVybiBsb2FkZXI7XG59XG5cbmZ1bmN0aW9uIHZhbGlkSFRUUFJlc3BvbnNlKGRhdGEpIHtcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgIGlmIChkYXRhLnN0YXR1cyA9PT0gMjA0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGdldE5vVmFsaWRMb2FkZXJNZXNzYWdlKGRhdGEpIHtcbiAgdmFyIF9nZXRSZXNvdXJjZVVybEFuZFR5cDIgPSAoMCwgX3Jlc291cmNlVXRpbHMuZ2V0UmVzb3VyY2VVcmxBbmRUeXBlKShkYXRhKSxcbiAgICAgIHVybCA9IF9nZXRSZXNvdXJjZVVybEFuZFR5cDIudXJsLFxuICAgICAgdHlwZSA9IF9nZXRSZXNvdXJjZVVybEFuZFR5cDIudHlwZTtcblxuICB2YXIgbWVzc2FnZSA9ICdObyB2YWxpZCBsb2FkZXIgZm91bmQnO1xuXG4gIGlmIChkYXRhKSB7XG4gICAgbWVzc2FnZSArPSBcIiBkYXRhOiBcXFwiXCIuY29uY2F0KGdldEZpcnN0Q2hhcmFjdGVycyhkYXRhKSwgXCJcXFwiLCBjb250ZW50VHlwZTogXFxcIlwiKS5jb25jYXQodHlwZSwgXCJcXFwiXCIpO1xuICB9XG5cbiAgaWYgKHVybCkge1xuICAgIG1lc3NhZ2UgKz0gXCIgdXJsOiBcIi5jb25jYXQodXJsKTtcbiAgfVxuXG4gIHJldHVybiBtZXNzYWdlO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVMb2FkZXJzKGxvYWRlcnMpIHtcbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGxvYWRlcnMpLFxuICAgICAgX3N0ZXA7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgdmFyIGxvYWRlciA9IF9zdGVwLnZhbHVlO1xuICAgICAgKDAsIF9ub3JtYWxpemVMb2FkZXIubm9ybWFsaXplTG9hZGVyKShsb2FkZXIpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRMb2FkZXJCeVVybChsb2FkZXJzLCB1cmwpIHtcbiAgdmFyIG1hdGNoID0gdXJsICYmIEVYVF9QQVRURVJOLmV4ZWModXJsKTtcbiAgdmFyIGV4dGVuc2lvbiA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICByZXR1cm4gZXh0ZW5zaW9uID8gZmluZExvYWRlckJ5RXh0ZW5zaW9uKGxvYWRlcnMsIGV4dGVuc2lvbikgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBmaW5kTG9hZGVyQnlFeHRlbnNpb24obG9hZGVycywgZXh0ZW5zaW9uKSB7XG4gIGV4dGVuc2lvbiA9IGV4dGVuc2lvbi50b0xvd2VyQ2FzZSgpO1xuXG4gIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobG9hZGVycyksXG4gICAgICBfc3RlcDI7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgdmFyIGxvYWRlciA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihsb2FkZXIuZXh0ZW5zaW9ucyksXG4gICAgICAgICAgX3N0ZXAzO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBsb2FkZXJFeHRlbnNpb24gPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgICAgICBpZiAobG9hZGVyRXh0ZW5zaW9uLnRvTG93ZXJDYXNlKCkgPT09IGV4dGVuc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRlcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yMi5mKCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZmluZExvYWRlckJ5TUlNRVR5cGUobG9hZGVycywgbWltZVR5cGUpIHtcbiAgdmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihsb2FkZXJzKSxcbiAgICAgIF9zdGVwNDtcblxuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yNC5zKCk7ICEoX3N0ZXA0ID0gX2l0ZXJhdG9yNC5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgbG9hZGVyID0gX3N0ZXA0LnZhbHVlO1xuXG4gICAgICBpZiAobG9hZGVyLm1pbWVUeXBlcyAmJiBsb2FkZXIubWltZVR5cGVzLmluY2x1ZGVzKG1pbWVUeXBlKSkge1xuICAgICAgICByZXR1cm4gbG9hZGVyO1xuICAgICAgfVxuXG4gICAgICBpZiAobWltZVR5cGUgPT09IFwiYXBwbGljYXRpb24veC5cIi5jb25jYXQobG9hZGVyLmlkKSkge1xuICAgICAgICByZXR1cm4gbG9hZGVyO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yNC5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yNC5mKCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZmluZExvYWRlckJ5SW5pdGlhbEJ5dGVzKGxvYWRlcnMsIGRhdGEpIHtcbiAgaWYgKCFkYXRhKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgX2l0ZXJhdG9yNSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGxvYWRlcnMpLFxuICAgICAgX3N0ZXA1O1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3I1LnMoKTsgIShfc3RlcDUgPSBfaXRlcmF0b3I1Lm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBsb2FkZXIgPSBfc3RlcDUudmFsdWU7XG5cbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHRlc3REYXRhQWdhaW5zdFRleHQoZGF0YSwgbG9hZGVyKSkge1xuICAgICAgICAgIHJldHVybiBsb2FkZXI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgICAgIGlmICh0ZXN0RGF0YUFnYWluc3RCaW5hcnkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgbG9hZGVyKSkge1xuICAgICAgICAgIHJldHVybiBsb2FkZXI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHZhciBieXRlT2Zmc2V0ID0gMDtcblxuICAgICAgICBpZiAodGVzdERhdGFBZ2FpbnN0QmluYXJ5KGRhdGEsIGJ5dGVPZmZzZXQsIGxvYWRlcikpIHtcbiAgICAgICAgICByZXR1cm4gbG9hZGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3I1LmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3I1LmYoKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiB0ZXN0RGF0YUFnYWluc3RUZXh0KGRhdGEsIGxvYWRlcikge1xuICBpZiAobG9hZGVyLnRlc3RUZXh0KSB7XG4gICAgcmV0dXJuIGxvYWRlci50ZXN0VGV4dChkYXRhKTtcbiAgfVxuXG4gIHZhciB0ZXN0cyA9IEFycmF5LmlzQXJyYXkobG9hZGVyLnRlc3RzKSA/IGxvYWRlci50ZXN0cyA6IFtsb2FkZXIudGVzdHNdO1xuICByZXR1cm4gdGVzdHMuc29tZShmdW5jdGlvbiAodGVzdCkge1xuICAgIHJldHVybiBkYXRhLnN0YXJ0c1dpdGgodGVzdCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0ZXN0RGF0YUFnYWluc3RCaW5hcnkoZGF0YSwgYnl0ZU9mZnNldCwgbG9hZGVyKSB7XG4gIHZhciB0ZXN0cyA9IEFycmF5LmlzQXJyYXkobG9hZGVyLnRlc3RzKSA/IGxvYWRlci50ZXN0cyA6IFtsb2FkZXIudGVzdHNdO1xuICByZXR1cm4gdGVzdHMuc29tZShmdW5jdGlvbiAodGVzdCkge1xuICAgIHJldHVybiB0ZXN0QmluYXJ5KGRhdGEsIGJ5dGVPZmZzZXQsIGxvYWRlciwgdGVzdCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0ZXN0QmluYXJ5KGRhdGEsIGJ5dGVPZmZzZXQsIGxvYWRlciwgdGVzdCkge1xuICBpZiAodGVzdCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuICgwLCBfbG9hZGVyVXRpbHMuY29tcGFyZUFycmF5QnVmZmVycykodGVzdCwgZGF0YSwgdGVzdC5ieXRlTGVuZ3RoKTtcbiAgfVxuXG4gIHN3aXRjaCAoKDAsIF90eXBlb2YyLmRlZmF1bHQpKHRlc3QpKSB7XG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgcmV0dXJuIHRlc3QoZGF0YSwgbG9hZGVyKTtcblxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICB2YXIgbWFnaWMgPSBnZXRNYWdpY1N0cmluZyhkYXRhLCBieXRlT2Zmc2V0LCB0ZXN0Lmxlbmd0aCk7XG4gICAgICByZXR1cm4gdGVzdCA9PT0gbWFnaWM7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEZpcnN0Q2hhcmFjdGVycyhkYXRhKSB7XG4gIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDU7XG5cbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkYXRhLnNsaWNlKDAsIGxlbmd0aCk7XG4gIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgcmV0dXJuIGdldE1hZ2ljU3RyaW5nKGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgdmFyIGJ5dGVPZmZzZXQgPSAwO1xuICAgIHJldHVybiBnZXRNYWdpY1N0cmluZyhkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRNYWdpY1N0cmluZyhhcnJheUJ1ZmZlciwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIGxlbmd0aCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG4gIHZhciBtYWdpYyA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBtYWdpYyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFWaWV3LmdldFVpbnQ4KGJ5dGVPZmZzZXQgKyBpKSk7XG4gIH1cblxuICByZXR1cm4gbWFnaWM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWxlY3QtbG9hZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5zZXRMb2FkZXJPcHRpb25zID0gc2V0TG9hZGVyT3B0aW9ucztcblxudmFyIF9vcHRpb25VdGlscyA9IHJlcXVpcmUoXCIuLi9sb2FkZXItdXRpbHMvb3B0aW9uLXV0aWxzXCIpO1xuXG5mdW5jdGlvbiBzZXRMb2FkZXJPcHRpb25zKG9wdGlvbnMpIHtcbiAgKDAsIF9vcHRpb25VdGlscy5zZXRHbG9iYWxPcHRpb25zKShvcHRpb25zKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNldC1sb2FkZXItb3B0aW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmZldGNoRmlsZSA9IGZldGNoRmlsZTtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfbG9hZGVyVXRpbHMgPSByZXF1aXJlKFwiQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzXCIpO1xuXG52YXIgX3Jlc3BvbnNlVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMvcmVzcG9uc2UtdXRpbHNcIik7XG5cbmZ1bmN0aW9uIGZldGNoRmlsZShfeCwgX3gyKSB7XG4gIHJldHVybiBfZmV0Y2hGaWxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9mZXRjaEZpbGUoKSB7XG4gIF9mZXRjaEZpbGUgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZSh1cmwsIG9wdGlvbnMpIHtcbiAgICB2YXIgZmV0Y2hPcHRpb25zO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCEodHlwZW9mIHVybCA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdXJsID0gKDAsIF9sb2FkZXJVdGlscy5yZXNvbHZlUGF0aCkodXJsKTtcbiAgICAgICAgICAgIGZldGNoT3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCAmJiBvcHRpb25zLmZldGNoICYmIHR5cGVvZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZldGNoKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBmZXRjaE9wdGlvbnMgPSBvcHRpb25zLmZldGNoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaCh1cmwsIGZldGNoT3B0aW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0LnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9yZXNwb25zZVV0aWxzLm1ha2VSZXNwb25zZSkodXJsKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlKTtcbiAgfSkpO1xuICByZXR1cm4gX2ZldGNoRmlsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmV0Y2gtZmlsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnJlYWRBcnJheUJ1ZmZlciA9IHJlYWRBcnJheUJ1ZmZlcjtcbmV4cG9ydHMucmVhZEJsb2IgPSByZWFkQmxvYjtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfbG9hZGVyVXRpbHMgPSByZXF1aXJlKFwiQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzXCIpO1xuXG5mdW5jdGlvbiByZWFkQXJyYXlCdWZmZXIoX3gsIF94MiwgX3gzKSB7XG4gIHJldHVybiBfcmVhZEFycmF5QnVmZmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9yZWFkQXJyYXlCdWZmZXIoKSB7XG4gIF9yZWFkQXJyYXlCdWZmZXIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZShmaWxlLCBzdGFydCwgbGVuZ3RoKSB7XG4gICAgdmFyIHNsaWNlO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCEodHlwZW9mIGZpbGUgPT09ICdudW1iZXInKSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIF9sb2FkZXJVdGlscy5mcy5fcmVhZFRvQXJyYXlCdWZmZXIoZmlsZSwgc3RhcnQsIGxlbmd0aCk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0LnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgaWYgKCEoZmlsZSBpbnN0YW5jZW9mIEJsb2IpKSB7XG4gICAgICAgICAgICAgIGZpbGUgPSBuZXcgQmxvYihbZmlsZV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzbGljZSA9IGZpbGUuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgbGVuZ3RoKTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA4O1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRCbG9iKHNsaWNlKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUpO1xuICB9KSk7XG4gIHJldHVybiBfcmVhZEFycmF5QnVmZmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9iKF94NCkge1xuICByZXR1cm4gX3JlYWRCbG9iLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9yZWFkQmxvYigpIHtcbiAgX3JlYWRCbG9iID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGJsb2IpIHtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICAgICAgICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2V2ZW50JHRhcmdldDtcblxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGV2ZW50ID09PSBudWxsIHx8IGV2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2V2ZW50JHRhcmdldCA9IGV2ZW50LnRhcmdldCkgPT09IG51bGwgfHwgX2V2ZW50JHRhcmdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2V2ZW50JHRhcmdldC5yZXN1bHQpO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGZpbGVSZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0Mi5zZW50KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyKTtcbiAgfSkpO1xuICByZXR1cm4gX3JlYWRCbG9iLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFkLWFycmF5LWJ1ZmZlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucmVhZEZpbGVTeW5jID0gcmVhZEZpbGVTeW5jO1xuXG52YXIgX2xvYWRlclV0aWxzID0gcmVxdWlyZShcIkBsb2FkZXJzLmdsL2xvYWRlci11dGlsc1wiKTtcblxuZnVuY3Rpb24gcmVhZEZpbGVTeW5jKHVybCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHVybCA9ICgwLCBfbG9hZGVyVXRpbHMucmVzb2x2ZVBhdGgpKHVybCk7XG5cbiAgaWYgKCFfbG9hZGVyVXRpbHMuaXNCcm93c2VyKSB7XG4gICAgdmFyIGJ1ZmZlciA9IF9sb2FkZXJVdGlscy5mcy5yZWFkRmlsZVN5bmModXJsLCBvcHRpb25zKTtcblxuICAgIHJldHVybiB0eXBlb2YgYnVmZmVyICE9PSAnc3RyaW5nJyA/ICgwLCBfbG9hZGVyVXRpbHMudG9BcnJheUJ1ZmZlcikoYnVmZmVyKSA6IGJ1ZmZlcjtcbiAgfVxuXG4gIGlmICghb3B0aW9ucy5ub3Rocm93KSB7XG4gICAgKDAsIF9sb2FkZXJVdGlscy5hc3NlcnQpKGZhbHNlKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhZC1maWxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMud3JpdGVGaWxlID0gd3JpdGVGaWxlO1xuZXhwb3J0cy53cml0ZUZpbGVTeW5jID0gd3JpdGVGaWxlU3luYztcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfbG9hZGVyVXRpbHMgPSByZXF1aXJlKFwiQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzXCIpO1xuXG5mdW5jdGlvbiB3cml0ZUZpbGUoX3gsIF94MiwgX3gzKSB7XG4gIHJldHVybiBfd3JpdGVGaWxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF93cml0ZUZpbGUoKSB7XG4gIF93cml0ZUZpbGUgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZShmaWxlUGF0aCwgYXJyYXlCdWZmZXJPclN0cmluZywgb3B0aW9ucykge1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgZmlsZVBhdGggPSAoMCwgX2xvYWRlclV0aWxzLnJlc29sdmVQYXRoKShmaWxlUGF0aCk7XG5cbiAgICAgICAgICAgIGlmIChfbG9hZGVyVXRpbHMuaXNCcm93c2VyKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XG4gICAgICAgICAgICByZXR1cm4gX2xvYWRlclV0aWxzLmZzLndyaXRlRmlsZShmaWxlUGF0aCwgKDAsIF9sb2FkZXJVdGlscy50b0J1ZmZlcikoYXJyYXlCdWZmZXJPclN0cmluZyksIHtcbiAgICAgICAgICAgICAgZmxhZzogJ3cnXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICgwLCBfbG9hZGVyVXRpbHMuYXNzZXJ0KShmYWxzZSk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUpO1xuICB9KSk7XG4gIHJldHVybiBfd3JpdGVGaWxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlRmlsZVN5bmMoZmlsZVBhdGgsIGFycmF5QnVmZmVyT3JTdHJpbmcsIG9wdGlvbnMpIHtcbiAgZmlsZVBhdGggPSAoMCwgX2xvYWRlclV0aWxzLnJlc29sdmVQYXRoKShmaWxlUGF0aCk7XG5cbiAgaWYgKCFfbG9hZGVyVXRpbHMuaXNCcm93c2VyKSB7XG4gICAgX2xvYWRlclV0aWxzLmZzLndyaXRlRmlsZVN5bmMoZmlsZVBhdGgsICgwLCBfbG9hZGVyVXRpbHMudG9CdWZmZXIpKGFycmF5QnVmZmVyT3JTdHJpbmcpLCB7XG4gICAgICBmbGFnOiAndydcbiAgICB9KTtcbiAgfVxuXG4gICgwLCBfbG9hZGVyVXRpbHMuYXNzZXJ0KShmYWxzZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13cml0ZS1maWxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBCcm93c2VyRmlsZVN5c3RlbSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnJvd3NlckZpbGVTeXN0ZW0oZmlsZXMsIG9wdGlvbnMpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBCcm93c2VyRmlsZVN5c3RlbSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJfZmV0Y2hcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcImZpbGVzXCIsIHt9KTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcImxvd2VyQ2FzZUZpbGVzXCIsIHt9KTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcInVzZWRGaWxlc1wiLCB7fSk7XG4gICAgdGhpcy5fZmV0Y2ggPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZldGNoKSB8fCBmZXRjaDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBmaWxlID0gZmlsZXNbaV07XG4gICAgICB0aGlzLmZpbGVzW2ZpbGUubmFtZV0gPSBmaWxlO1xuICAgICAgdGhpcy5sb3dlckNhc2VGaWxlc1tmaWxlLm5hbWUudG9Mb3dlckNhc2UoKV0gPSBmaWxlO1xuICAgICAgdGhpcy51c2VkRmlsZXNbZmlsZS5uYW1lXSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuZmV0Y2ggPSB0aGlzLmZldGNoLmJpbmQodGhpcyk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShCcm93c2VyRmlsZVN5c3RlbSwgW3tcbiAgICBrZXk6IFwiZmV0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9mZXRjaCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGZpbGUsIGhlYWRlcnMsIHJhbmdlLCBieXRlcywgc3RhcnQsIGVuZCwgZGF0YSwgX3Jlc3BvbnNlLCByZXNwb25zZTtcblxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBpZiAoIXBhdGguaW5jbHVkZXMoJzovLycpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5fZmV0Y2gocGF0aCwgb3B0aW9ucykpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBmaWxlID0gdGhpcy5maWxlc1twYXRoXTtcblxuICAgICAgICAgICAgICAgIGlmIChmaWxlKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbmV3IFJlc3BvbnNlKHBhdGgsIHtcbiAgICAgICAgICAgICAgICAgIHN0YXR1czogNDAwLFxuICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogJ05PVCBGT1VORCdcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBoZWFkZXJzLmdldCgnUmFuZ2UnKTtcbiAgICAgICAgICAgICAgICBieXRlcyA9IHJhbmdlICYmIC9ieXRlcz0oJDEpLSgkMikvLmV4ZWMocmFuZ2UpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFieXRlcykge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE3O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBwYXJzZUludChieXRlc1sxXSk7XG4gICAgICAgICAgICAgICAgZW5kID0gcGFyc2VJbnQoYnl0ZXNbMl0pO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMztcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZS5zbGljZShzdGFydCwgZW5kKS5hcnJheUJ1ZmZlcigpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgZGF0YSA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgICAgX3Jlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGRhdGEpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfcmVzcG9uc2UsICd1cmwnLCB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogcGF0aFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgX3Jlc3BvbnNlKTtcblxuICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGZpbGUpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNwb25zZSwgJ3VybCcsIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXRoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCByZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gZmV0Y2goX3gsIF94Mikge1xuICAgICAgICByZXR1cm4gX2ZldGNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmZXRjaDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJyZWFkZGlyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVhZGRpciA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMihkaXJuYW1lKSB7XG4gICAgICAgIHZhciBmaWxlcywgcGF0aDtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGZpbGVzID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKHBhdGggaW4gdGhpcy5maWxlcykge1xuICAgICAgICAgICAgICAgICAgZmlsZXMucHVzaChwYXRoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBmaWxlcyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlYWRkaXIoX3gzKSB7XG4gICAgICAgIHJldHVybiBfcmVhZGRpci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVhZGRpcjtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJzdGF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfc3RhdCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBmaWxlO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgZmlsZSA9IHRoaXMuZmlsZXNbcGF0aF07XG5cbiAgICAgICAgICAgICAgICBpZiAoZmlsZSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHBhdGgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgICBzaXplOiBmaWxlLnNpemVcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gc3RhdChfeDQsIF94NSkge1xuICAgICAgICByZXR1cm4gX3N0YXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXQ7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwidW5saW5rXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdW5saW5rID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZpbGVzW3BhdGhdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmxvd2VyQ2FzZUZpbGVzW3BhdGhdO1xuICAgICAgICAgICAgICAgIHRoaXMudXNlZEZpbGVzW3BhdGhdID0gdHJ1ZTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU0LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gdW5saW5rKF94Nikge1xuICAgICAgICByZXR1cm4gX3VubGluay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5saW5rO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIm9wZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9vcGVuID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KHBhdGhuYW1lLCBmbGFncywgbW9kZSkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5maWxlc1twYXRobmFtZV0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBvcGVuKF94NywgX3g4LCBfeDkpIHtcbiAgICAgICAgcmV0dXJuIF9vcGVuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcGVuO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcInJlYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWFkID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2KGZkLCBidWZmZXIpIHtcbiAgICAgICAgdmFyIG9mZnNldCxcbiAgICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgZmlsZSxcbiAgICAgICAgICAgIHN0YXJ0UG9zaXRpb24sXG4gICAgICAgICAgICBhcnJheUJ1ZmZlcixcbiAgICAgICAgICAgIF9hcmdzNiA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTYkKF9jb250ZXh0Nikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG9mZnNldCA9IF9hcmdzNi5sZW5ndGggPiAyICYmIF9hcmdzNlsyXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3M2WzJdIDogMDtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBfYXJnczYubGVuZ3RoID4gMyAmJiBfYXJnczZbM10gIT09IHVuZGVmaW5lZCA/IF9hcmdzNlszXSA6IGJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gX2FyZ3M2Lmxlbmd0aCA+IDQgJiYgX2FyZ3M2WzRdICE9PSB1bmRlZmluZWQgPyBfYXJnczZbNF0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGZpbGUgPSBmZDtcbiAgICAgICAgICAgICAgICBzdGFydFBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGUuc2xpY2Uoc3RhcnRQb3NpdGlvbiwgc3RhcnRQb3NpdGlvbiArIGxlbmd0aCkuYXJyYXlCdWZmZXIoKTtcblxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgYXJyYXlCdWZmZXIgPSBfY29udGV4dDYuc2VudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgICBieXRlc1JlYWQ6IGxlbmd0aCxcbiAgICAgICAgICAgICAgICAgIGJ1ZmZlcjogYXJyYXlCdWZmZXJcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU2KTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gcmVhZChfeDEwLCBfeDExKSB7XG4gICAgICAgIHJldHVybiBfcmVhZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVhZDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJjbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2Nsb3NlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU3KGZkKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWU3JChfY29udGV4dDcpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDcucHJldiA9IF9jb250ZXh0Ny5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTcpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBjbG9zZShfeDEyKSB7XG4gICAgICAgIHJldHVybiBfY2xvc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsb3NlO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRGaWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRGaWxlKHBhdGgsIHVzZWQpIHtcbiAgICAgIHZhciBmaWxlID0gdGhpcy5maWxlc1twYXRoXSB8fCB0aGlzLmxvd2VyQ2FzZUZpbGVzW3BhdGhdO1xuXG4gICAgICBpZiAoZmlsZSAmJiB1c2VkKSB7XG4gICAgICAgIHRoaXMudXNlZEZpbGVzW3BhdGhdID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZpbGU7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCcm93c2VyRmlsZVN5c3RlbTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQnJvd3NlckZpbGVTeXN0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icm93c2VyLWZpbGVzeXN0ZW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXRBcnJheUJ1ZmZlck9yU3RyaW5nRnJvbURhdGFTeW5jID0gZ2V0QXJyYXlCdWZmZXJPclN0cmluZ0Zyb21EYXRhU3luYztcbmV4cG9ydHMuZ2V0QXJyYXlCdWZmZXJPclN0cmluZ0Zyb21EYXRhID0gZ2V0QXJyYXlCdWZmZXJPclN0cmluZ0Zyb21EYXRhO1xuZXhwb3J0cy5nZXRBc3luY0l0ZXJhYmxlRnJvbURhdGEgPSBnZXRBc3luY0l0ZXJhYmxlRnJvbURhdGE7XG5leHBvcnRzLmdldFJlYWRhYmxlU3RyZWFtID0gZ2V0UmVhZGFibGVTdHJlYW07XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2xvYWRlclV0aWxzID0gcmVxdWlyZShcIkBsb2FkZXJzLmdsL2xvYWRlci11dGlsc1wiKTtcblxudmFyIF9pc1R5cGUgPSByZXF1aXJlKFwiLi4vLi4vamF2YXNjcmlwdC11dGlscy9pcy10eXBlXCIpO1xuXG52YXIgX21ha2VJdGVyYXRvciA9IHJlcXVpcmUoXCIuLi8uLi9pdGVyYXRvcnMvbWFrZS1pdGVyYXRvci9tYWtlLWl0ZXJhdG9yXCIpO1xuXG52YXIgX3Jlc3BvbnNlVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMvcmVzcG9uc2UtdXRpbHNcIik7XG5cbnZhciBFUlJfREFUQSA9ICdDYW5ub3QgY29udmVydCBzdXBwbGllZCBkYXRhIHR5cGUnO1xuXG5mdW5jdGlvbiBnZXRBcnJheUJ1ZmZlck9yU3RyaW5nRnJvbURhdGFTeW5jKGRhdGEsIGxvYWRlciwgb3B0aW9ucykge1xuICBpZiAobG9hZGVyLnRleHQgJiYgdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBpZiAoKDAsIF9pc1R5cGUuaXNCdWZmZXIpKGRhdGEpKSB7XG4gICAgZGF0YSA9IGRhdGEuYnVmZmVyO1xuICB9XG5cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHZhciBhcnJheUJ1ZmZlciA9IGRhdGE7XG5cbiAgICBpZiAobG9hZGVyLnRleHQgJiYgIWxvYWRlci5iaW5hcnkpIHtcbiAgICAgIHZhciB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmOCcpO1xuICAgICAgcmV0dXJuIHRleHREZWNvZGVyLmRlY29kZShhcnJheUJ1ZmZlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5QnVmZmVyO1xuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgIGlmIChsb2FkZXIudGV4dCAmJiAhbG9hZGVyLmJpbmFyeSkge1xuICAgICAgdmFyIF90ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmOCcpO1xuXG4gICAgICByZXR1cm4gX3RleHREZWNvZGVyLmRlY29kZShkYXRhKTtcbiAgICB9XG5cbiAgICB2YXIgX2FycmF5QnVmZmVyID0gZGF0YS5idWZmZXI7XG4gICAgdmFyIGJ5dGVMZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGggfHwgZGF0YS5sZW5ndGg7XG5cbiAgICBpZiAoZGF0YS5ieXRlT2Zmc2V0ICE9PSAwIHx8IGJ5dGVMZW5ndGggIT09IF9hcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICBfYXJyYXlCdWZmZXIgPSBfYXJyYXlCdWZmZXIuc2xpY2UoZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVPZmZzZXQgKyBieXRlTGVuZ3RoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2FycmF5QnVmZmVyO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKEVSUl9EQVRBKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXJyYXlCdWZmZXJPclN0cmluZ0Zyb21EYXRhKF94LCBfeDIsIF94Mykge1xuICByZXR1cm4gX2dldEFycmF5QnVmZmVyT3JTdHJpbmdGcm9tRGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0QXJyYXlCdWZmZXJPclN0cmluZ0Zyb21EYXRhKCkge1xuICBfZ2V0QXJyYXlCdWZmZXJPclN0cmluZ0Zyb21EYXRhID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoZGF0YSwgbG9hZGVyLCBvcHRpb25zKSB7XG4gICAgdmFyIGlzQXJyYXlCdWZmZXIsIHJlc3BvbnNlO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0Mykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaXNBcnJheUJ1ZmZlciA9IGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSk7XG5cbiAgICAgICAgICAgIGlmICghKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyB8fCBpc0FycmF5QnVmZmVyKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBnZXRBcnJheUJ1ZmZlck9yU3RyaW5nRnJvbURhdGFTeW5jKGRhdGEsIGxvYWRlciwgb3B0aW9ucykpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgaWYgKCEoMCwgX2lzVHlwZS5pc0Jsb2IpKGRhdGEpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNjtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX3Jlc3BvbnNlVXRpbHMubWFrZVJlc3BvbnNlKShkYXRhKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dDMuc2VudDtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGlmICghKDAsIF9pc1R5cGUuaXNSZXNwb25zZSkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAyMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3BvbnNlID0gZGF0YTtcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTE7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9yZXNwb25zZVV0aWxzLmNoZWNrUmVzcG9uc2UpKHJlc3BvbnNlKTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBpZiAoIWxvYWRlci5iaW5hcnkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxNztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcblxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICBfY29udGV4dDMudDAgPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjA7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDE5O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcblxuICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICBfY29udGV4dDMudDAgPSBfY29udGV4dDMuc2VudDtcblxuICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDMudDApO1xuXG4gICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgIGlmICgoMCwgX2lzVHlwZS5pc1JlYWRhYmxlU3RyZWFtKShkYXRhKSkge1xuICAgICAgICAgICAgICBkYXRhID0gKDAsIF9tYWtlSXRlcmF0b3IubWFrZUl0ZXJhdG9yKShkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEoKDAsIF9pc1R5cGUuaXNJdGVyYWJsZSkoZGF0YSkgfHwgKDAsIF9pc1R5cGUuaXNBc3luY0l0ZXJhYmxlKShkYXRhKSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAyNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsICgwLCBfbG9hZGVyVXRpbHMuY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnNBc3luYykoZGF0YSkpO1xuXG4gICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJfREFUQSk7XG5cbiAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRBcnJheUJ1ZmZlck9yU3RyaW5nRnJvbURhdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXN5bmNJdGVyYWJsZUZyb21EYXRhKF94NCwgX3g1KSB7XG4gIHJldHVybiBfZ2V0QXN5bmNJdGVyYWJsZUZyb21EYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRBc3luY0l0ZXJhYmxlRnJvbURhdGEoKSB7XG4gIF9nZXRBc3luY0l0ZXJhYmxlRnJvbURhdGEgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoZGF0YSwgb3B0aW9ucykge1xuICAgIHZhciByZXNwb25zZSwgYm9keTtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQ0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoISgwLCBfaXNUeXBlLmlzSXRlcmF0b3IpKGRhdGEpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIGRhdGEpO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgaWYgKCEoMCwgX2lzVHlwZS5pc1Jlc3BvbnNlKShkYXRhKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDEwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzcG9uc2UgPSBkYXRhO1xuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA2O1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfcmVzcG9uc2VVdGlscy5jaGVja1Jlc3BvbnNlKShyZXNwb25zZSk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDg7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuYm9keTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIGJvZHkgPSBfY29udGV4dDQuc2VudDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsICgwLCBfbWFrZUl0ZXJhdG9yLm1ha2VJdGVyYXRvcikoYm9keSwgb3B0aW9ucykpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIGlmICghKCgwLCBfaXNUeXBlLmlzQmxvYikoZGF0YSkgfHwgKDAsIF9pc1R5cGUuaXNSZWFkYWJsZVN0cmVhbSkoZGF0YSkpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCAoMCwgX21ha2VJdGVyYXRvci5tYWtlSXRlcmF0b3IpKGRhdGEsIG9wdGlvbnMpKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBpZiAoISgwLCBfaXNUeXBlLmlzQXN5bmNJdGVyYWJsZSkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIGRhdGFbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkpO1xuXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIGdldEl0ZXJhYmxlRnJvbURhdGEoZGF0YSkpO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldEFzeW5jSXRlcmFibGVGcm9tRGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRSZWFkYWJsZVN0cmVhbShfeDYpIHtcbiAgcmV0dXJuIF9nZXRSZWFkYWJsZVN0cmVhbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UmVhZGFibGVTdHJlYW0oKSB7XG4gIF9nZXRSZWFkYWJsZVN0cmVhbSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhkYXRhKSB7XG4gICAgdmFyIHJlc3BvbnNlO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDUpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghKDAsIF9pc1R5cGUuaXNSZWFkYWJsZVN0cmVhbSkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgZGF0YSk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBpZiAoISgwLCBfaXNUeXBlLmlzUmVzcG9uc2UpKGRhdGEpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIGRhdGEuYm9keSk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDY7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9yZXNwb25zZVV0aWxzLm1ha2VSZXNwb25zZSkoZGF0YSk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXNwb25zZSA9IF9jb250ZXh0NS5zZW50O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzcG9uc2UuYm9keSk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMyk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRSZWFkYWJsZVN0cmVhbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRJdGVyYWJsZUZyb21EYXRhKGRhdGEpIHtcbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIG9uZUNodW5rKCkge1xuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gb25lQ2h1bmskKF9jb250ZXh0KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBvbmVDaHVuayk7XG4gICAgfSkoKTtcbiAgfVxuXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBvbmVDaHVuaygpIHtcbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIG9uZUNodW5rJChfY29udGV4dDIpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIG9uZUNodW5rKTtcbiAgICB9KSgpO1xuICB9XG5cbiAgaWYgKCgwLCBfaXNUeXBlLmlzSXRlcmF0b3IpKGRhdGEpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBpZiAoKDAsIF9pc1R5cGUuaXNJdGVyYWJsZSkoZGF0YSkpIHtcbiAgICByZXR1cm4gZGF0YVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoRVJSX0RBVEEpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LWRhdGEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXRMb2FkZXJDb250ZXh0ID0gZ2V0TG9hZGVyQ29udGV4dDtcbmV4cG9ydHMuZ2V0TG9hZGVyc0Zyb21Db250ZXh0ID0gZ2V0TG9hZGVyc0Zyb21Db250ZXh0O1xuXG52YXIgX3RvQ29uc3VtYWJsZUFycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXlcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX29wdGlvblV0aWxzID0gcmVxdWlyZShcIi4vb3B0aW9uLXV0aWxzXCIpO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gZ2V0TG9hZGVyQ29udGV4dChjb250ZXh0LCBvcHRpb25zKSB7XG4gIHZhciBwcmV2aW91c0NvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG5cbiAgaWYgKHByZXZpb3VzQ29udGV4dCkge1xuICAgIHJldHVybiBwcmV2aW91c0NvbnRleHQ7XG4gIH1cblxuICB2YXIgcmVzb2x2ZWRDb250ZXh0ID0gX29iamVjdFNwcmVhZCh7XG4gICAgZmV0Y2g6ICgwLCBfb3B0aW9uVXRpbHMuZ2V0RmV0Y2hGdW5jdGlvbikob3B0aW9ucywgY29udGV4dClcbiAgfSwgY29udGV4dCk7XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KHJlc29sdmVkQ29udGV4dC5sb2FkZXJzKSkge1xuICAgIHJlc29sdmVkQ29udGV4dC5sb2FkZXJzID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiByZXNvbHZlZENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGdldExvYWRlcnNGcm9tQ29udGV4dChsb2FkZXJzLCBjb250ZXh0KSB7XG4gIGlmICghY29udGV4dCAmJiBsb2FkZXJzICYmICFBcnJheS5pc0FycmF5KGxvYWRlcnMpKSB7XG4gICAgcmV0dXJuIGxvYWRlcnM7XG4gIH1cblxuICB2YXIgY2FuZGlkYXRlTG9hZGVycztcblxuICBpZiAobG9hZGVycykge1xuICAgIGNhbmRpZGF0ZUxvYWRlcnMgPSBBcnJheS5pc0FycmF5KGxvYWRlcnMpID8gbG9hZGVycyA6IFtsb2FkZXJzXTtcbiAgfVxuXG4gIGlmIChjb250ZXh0ICYmIGNvbnRleHQubG9hZGVycykge1xuICAgIHZhciBjb250ZXh0TG9hZGVycyA9IEFycmF5LmlzQXJyYXkoY29udGV4dC5sb2FkZXJzKSA/IGNvbnRleHQubG9hZGVycyA6IFtjb250ZXh0LmxvYWRlcnNdO1xuICAgIGNhbmRpZGF0ZUxvYWRlcnMgPSBjYW5kaWRhdGVMb2FkZXJzID8gW10uY29uY2F0KCgwLCBfdG9Db25zdW1hYmxlQXJyYXkyLmRlZmF1bHQpKGNhbmRpZGF0ZUxvYWRlcnMpLCAoMCwgX3RvQ29uc3VtYWJsZUFycmF5Mi5kZWZhdWx0KShjb250ZXh0TG9hZGVycykpIDogY29udGV4dExvYWRlcnM7XG4gIH1cblxuICByZXR1cm4gY2FuZGlkYXRlTG9hZGVycyAmJiBjYW5kaWRhdGVMb2FkZXJzLmxlbmd0aCA/IGNhbmRpZGF0ZUxvYWRlcnMgOiBudWxsO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZGVyLWNvbnRleHQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Db25zb2xlTG9nID0gZXhwb3J0cy5OdWxsTG9nID0gZXhwb3J0cy5wcm9iZUxvZyA9IHZvaWQgMDtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9wcm9iZSA9IHJlcXVpcmUoXCJwcm9iZS5nbFwiKTtcblxudmFyIHByb2JlTG9nID0gbmV3IF9wcm9iZS5Mb2coe1xuICBpZDogJ2xvYWRlcnMuZ2wnXG59KTtcbmV4cG9ydHMucHJvYmVMb2cgPSBwcm9iZUxvZztcblxudmFyIE51bGxMb2cgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE51bGxMb2coKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgTnVsbExvZyk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShOdWxsTG9nLCBbe1xuICAgIGtleTogXCJsb2dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9nKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHt9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbmZvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluZm8oKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge307XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndhcm5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2FybigpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7fTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXJyb3IoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge307XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOdWxsTG9nO1xufSgpO1xuXG5leHBvcnRzLk51bGxMb2cgPSBOdWxsTG9nO1xuXG52YXIgQ29uc29sZUxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29uc29sZUxvZygpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBDb25zb2xlTG9nKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcImNvbnNvbGVcIiwgdm9pZCAwKTtcbiAgICB0aGlzLmNvbnNvbGUgPSBjb25zb2xlO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoQ29uc29sZUxvZywgW3tcbiAgICBrZXk6IFwibG9nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvZygpIHtcbiAgICAgIHZhciBfdGhpcyRjb25zb2xlJGxvZztcblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoX3RoaXMkY29uc29sZSRsb2cgPSB0aGlzLmNvbnNvbGUubG9nKS5iaW5kLmFwcGx5KF90aGlzJGNvbnNvbGUkbG9nLCBbdGhpcy5jb25zb2xlXS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbmZvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluZm8oKSB7XG4gICAgICB2YXIgX3RoaXMkY29uc29sZSRpbmZvO1xuXG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKF90aGlzJGNvbnNvbGUkaW5mbyA9IHRoaXMuY29uc29sZS5pbmZvKS5iaW5kLmFwcGx5KF90aGlzJGNvbnNvbGUkaW5mbywgW3RoaXMuY29uc29sZV0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2FyblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3YXJuKCkge1xuICAgICAgdmFyIF90aGlzJGNvbnNvbGUkd2FybjtcblxuICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChfdGhpcyRjb25zb2xlJHdhcm4gPSB0aGlzLmNvbnNvbGUud2FybikuYmluZC5hcHBseShfdGhpcyRjb25zb2xlJHdhcm4sIFt0aGlzLmNvbnNvbGVdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVycm9yKCkge1xuICAgICAgdmFyIF90aGlzJGNvbnNvbGUkZXJyb3I7XG5cbiAgICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNCksIF9rZXk0ID0gMDsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgICAgICBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoX3RoaXMkY29uc29sZSRlcnJvciA9IHRoaXMuY29uc29sZS5lcnJvcikuYmluZC5hcHBseShfdGhpcyRjb25zb2xlJGVycm9yLCBbdGhpcy5jb25zb2xlXS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ29uc29sZUxvZztcbn0oKTtcblxuZXhwb3J0cy5Db25zb2xlTG9nID0gQ29uc29sZUxvZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ2dlcnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5pc0xvYWRlck9iamVjdCA9IGlzTG9hZGVyT2JqZWN0O1xuZXhwb3J0cy5ub3JtYWxpemVMb2FkZXIgPSBub3JtYWxpemVMb2FkZXI7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfbG9hZGVyVXRpbHMgPSByZXF1aXJlKFwiQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzXCIpO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gaXNMb2FkZXJPYmplY3QobG9hZGVyKSB7XG4gIHZhciBfbG9hZGVyO1xuXG4gIGlmICghbG9hZGVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobG9hZGVyKSkge1xuICAgIGxvYWRlciA9IGxvYWRlclswXTtcbiAgfVxuXG4gIHZhciBoYXNFeHRlbnNpb25zID0gQXJyYXkuaXNBcnJheSgoX2xvYWRlciA9IGxvYWRlcikgPT09IG51bGwgfHwgX2xvYWRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2xvYWRlci5leHRlbnNpb25zKTtcbiAgcmV0dXJuIGhhc0V4dGVuc2lvbnM7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxvYWRlcihsb2FkZXIpIHtcbiAgdmFyIF9sb2FkZXIyLCBfbG9hZGVyMztcblxuICAoMCwgX2xvYWRlclV0aWxzLmFzc2VydCkobG9hZGVyLCAnbnVsbCBsb2FkZXInKTtcbiAgKDAsIF9sb2FkZXJVdGlscy5hc3NlcnQpKGlzTG9hZGVyT2JqZWN0KGxvYWRlciksICdpbnZhbGlkIGxvYWRlcicpO1xuICB2YXIgb3B0aW9ucztcblxuICBpZiAoQXJyYXkuaXNBcnJheShsb2FkZXIpKSB7XG4gICAgb3B0aW9ucyA9IGxvYWRlclsxXTtcbiAgICBsb2FkZXIgPSBsb2FkZXJbMF07XG4gICAgbG9hZGVyID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBsb2FkZXIpLCB7fSwge1xuICAgICAgb3B0aW9uczogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBsb2FkZXIub3B0aW9ucyksIG9wdGlvbnMpXG4gICAgfSk7XG4gIH1cblxuICBpZiAoKF9sb2FkZXIyID0gbG9hZGVyKSAhPT0gbnVsbCAmJiBfbG9hZGVyMiAhPT0gdm9pZCAwICYmIF9sb2FkZXIyLnBhcnNlVGV4dFN5bmMgfHwgKF9sb2FkZXIzID0gbG9hZGVyKSAhPT0gbnVsbCAmJiBfbG9hZGVyMyAhPT0gdm9pZCAwICYmIF9sb2FkZXIzLnBhcnNlVGV4dCkge1xuICAgIGxvYWRlci50ZXh0ID0gdHJ1ZTtcbiAgfVxuXG4gIGlmICghbG9hZGVyLnRleHQpIHtcbiAgICBsb2FkZXIuYmluYXJ5ID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBsb2FkZXI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3JtYWxpemUtbG9hZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5SRU1PVkVEX0xPQURFUl9PUFRJT05TID0gZXhwb3J0cy5ERUZBVUxUX0xPQURFUl9PUFRJT05TID0gdm9pZCAwO1xuXG52YXIgX2xvZ2dlcnMgPSByZXF1aXJlKFwiLi9sb2dnZXJzXCIpO1xuXG52YXIgREVGQVVMVF9MT0FERVJfT1BUSU9OUyA9IHtcbiAgZmV0Y2g6IG51bGwsXG4gIG1pbWVUeXBlOiB1bmRlZmluZWQsXG4gIG5vdGhyb3c6IGZhbHNlLFxuICBsb2c6IG5ldyBfbG9nZ2Vycy5Db25zb2xlTG9nKCksXG4gIENETjogJ2h0dHBzOi8vdW5wa2cuY29tL0Bsb2FkZXJzLmdsJyxcbiAgd29ya2VyOiB0cnVlLFxuICBtYXhDb25jdXJyZW5jeTogMyxcbiAgbWF4TW9iaWxlQ29uY3VycmVuY3k6IDEsXG4gIHJldXNlV29ya2VyczogdHJ1ZSxcbiAgX3dvcmtlclR5cGU6ICcnLFxuICBsaW1pdDogMCxcbiAgX2xpbWl0TUI6IDAsXG4gIGJhdGNoU2l6ZTogJ2F1dG8nLFxuICBiYXRjaERlYm91bmNlTXM6IDAsXG4gIG1ldGFkYXRhOiBmYWxzZSxcbiAgdHJhbnNmb3JtczogW11cbn07XG5leHBvcnRzLkRFRkFVTFRfTE9BREVSX09QVElPTlMgPSBERUZBVUxUX0xPQURFUl9PUFRJT05TO1xudmFyIFJFTU9WRURfTE9BREVSX09QVElPTlMgPSB7XG4gIHRocm93czogJ25vdGhyb3cnLFxuICBkYXRhVHlwZTogJyhubyBsb25nZXIgdXNlZCknLFxuICB1cmk6ICdiYXNlVXJpJyxcbiAgbWV0aG9kOiAnZmV0Y2gubWV0aG9kJyxcbiAgaGVhZGVyczogJ2ZldGNoLmhlYWRlcnMnLFxuICBib2R5OiAnZmV0Y2guYm9keScsXG4gIG1vZGU6ICdmZXRjaC5tb2RlJyxcbiAgY3JlZGVudGlhbHM6ICdmZXRjaC5jcmVkZW50aWFscycsXG4gIGNhY2hlOiAnZmV0Y2guY2FjaGUnLFxuICByZWRpcmVjdDogJ2ZldGNoLnJlZGlyZWN0JyxcbiAgcmVmZXJyZXI6ICdmZXRjaC5yZWZlcnJlcicsXG4gIHJlZmVycmVyUG9saWN5OiAnZmV0Y2gucmVmZXJyZXJQb2xpY3knLFxuICBpbnRlZ3JpdHk6ICdmZXRjaC5pbnRlZ3JpdHknLFxuICBrZWVwYWxpdmU6ICdmZXRjaC5rZWVwYWxpdmUnLFxuICBzaWduYWw6ICdmZXRjaC5zaWduYWwnXG59O1xuZXhwb3J0cy5SRU1PVkVEX0xPQURFUl9PUFRJT05TID0gUkVNT1ZFRF9MT0FERVJfT1BUSU9OUztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wdGlvbi1kZWZhdWx0cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldEdsb2JhbExvYWRlclN0YXRlID0gZ2V0R2xvYmFsTG9hZGVyU3RhdGU7XG5leHBvcnRzLnNldEdsb2JhbE9wdGlvbnMgPSBzZXRHbG9iYWxPcHRpb25zO1xuZXhwb3J0cy5ub3JtYWxpemVPcHRpb25zID0gbm9ybWFsaXplT3B0aW9ucztcbmV4cG9ydHMuZ2V0RmV0Y2hGdW5jdGlvbiA9IGdldEZldGNoRnVuY3Rpb247XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfbG9hZGVyVXRpbHMgPSByZXF1aXJlKFwiQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzXCIpO1xuXG52YXIgX2lzVHlwZSA9IHJlcXVpcmUoXCIuLi8uLi9qYXZhc2NyaXB0LXV0aWxzL2lzLXR5cGVcIik7XG5cbnZhciBfZmV0Y2hGaWxlID0gcmVxdWlyZShcIi4uL2ZldGNoL2ZldGNoLWZpbGVcIik7XG5cbnZhciBfbG9nZ2VycyA9IHJlcXVpcmUoXCIuL2xvZ2dlcnNcIik7XG5cbnZhciBfb3B0aW9uRGVmYXVsdHMgPSByZXF1aXJlKFwiLi9vcHRpb24tZGVmYXVsdHNcIik7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGdldEdsb2JhbExvYWRlclN0YXRlKCkge1xuICBfbG9hZGVyVXRpbHMuZ2xvYmFsLmxvYWRlcnMgPSBfbG9hZGVyVXRpbHMuZ2xvYmFsLmxvYWRlcnMgfHwge307XG4gIHZhciBsb2FkZXJzID0gX2xvYWRlclV0aWxzLmdsb2JhbC5sb2FkZXJzO1xuICBsb2FkZXJzLl9zdGF0ZSA9IGxvYWRlcnMuX3N0YXRlIHx8IHt9O1xuICByZXR1cm4gbG9hZGVycy5fc3RhdGU7XG59XG5cbnZhciBnZXRHbG9iYWxMb2FkZXJPcHRpb25zID0gZnVuY3Rpb24gZ2V0R2xvYmFsTG9hZGVyT3B0aW9ucygpIHtcbiAgdmFyIHN0YXRlID0gZ2V0R2xvYmFsTG9hZGVyU3RhdGUoKTtcbiAgc3RhdGUuZ2xvYmFsT3B0aW9ucyA9IHN0YXRlLmdsb2JhbE9wdGlvbnMgfHwgX29iamVjdFNwcmVhZCh7fSwgX29wdGlvbkRlZmF1bHRzLkRFRkFVTFRfTE9BREVSX09QVElPTlMpO1xuICByZXR1cm4gc3RhdGUuZ2xvYmFsT3B0aW9ucztcbn07XG5cbmZ1bmN0aW9uIHNldEdsb2JhbE9wdGlvbnMob3B0aW9ucykge1xuICB2YXIgc3RhdGUgPSBnZXRHbG9iYWxMb2FkZXJTdGF0ZSgpO1xuICB2YXIgZ2xvYmFsT3B0aW9ucyA9IGdldEdsb2JhbExvYWRlck9wdGlvbnMoKTtcbiAgc3RhdGUuZ2xvYmFsT3B0aW9ucyA9IG5vcm1hbGl6ZU9wdGlvbnNJbnRlcm5hbChnbG9iYWxPcHRpb25zLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplT3B0aW9ucyhvcHRpb25zLCBsb2FkZXIsIGxvYWRlcnMsIHVybCkge1xuICBsb2FkZXJzID0gbG9hZGVycyB8fCBbXTtcbiAgbG9hZGVycyA9IEFycmF5LmlzQXJyYXkobG9hZGVycykgPyBsb2FkZXJzIDogW2xvYWRlcnNdO1xuICB2YWxpZGF0ZU9wdGlvbnMob3B0aW9ucywgbG9hZGVycyk7XG4gIHJldHVybiBub3JtYWxpemVPcHRpb25zSW50ZXJuYWwobG9hZGVyLCBvcHRpb25zLCB1cmwpO1xufVxuXG5mdW5jdGlvbiBnZXRGZXRjaEZ1bmN0aW9uKG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgdmFyIGdsb2JhbE9wdGlvbnMgPSBnZXRHbG9iYWxMb2FkZXJPcHRpb25zKCk7XG4gIHZhciBmZXRjaE9wdGlvbnMgPSBvcHRpb25zIHx8IGdsb2JhbE9wdGlvbnM7XG5cbiAgaWYgKHR5cGVvZiBmZXRjaE9wdGlvbnMuZmV0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmV0Y2hPcHRpb25zLmZldGNoO1xuICB9XG5cbiAgaWYgKCgwLCBfaXNUeXBlLmlzT2JqZWN0KShmZXRjaE9wdGlvbnMuZmV0Y2gpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgIHJldHVybiAoMCwgX2ZldGNoRmlsZS5mZXRjaEZpbGUpKHVybCwgZmV0Y2hPcHRpb25zKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKGNvbnRleHQgIT09IG51bGwgJiYgY29udGV4dCAhPT0gdm9pZCAwICYmIGNvbnRleHQuZmV0Y2gpIHtcbiAgICByZXR1cm4gY29udGV4dCA9PT0gbnVsbCB8fCBjb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZXh0LmZldGNoO1xuICB9XG5cbiAgcmV0dXJuIF9mZXRjaEZpbGUuZmV0Y2hGaWxlO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbnMob3B0aW9ucywgbG9hZGVycykge1xuICB2YWxpZGF0ZU9wdGlvbnNPYmplY3Qob3B0aW9ucywgbnVsbCwgX29wdGlvbkRlZmF1bHRzLkRFRkFVTFRfTE9BREVSX09QVElPTlMsIF9vcHRpb25EZWZhdWx0cy5SRU1PVkVEX0xPQURFUl9PUFRJT05TLCBsb2FkZXJzKTtcblxuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobG9hZGVycyksXG4gICAgICBfc3RlcDtcblxuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgbG9hZGVyID0gX3N0ZXAudmFsdWU7XG4gICAgICB2YXIgaWRPcHRpb25zID0gb3B0aW9ucyAmJiBvcHRpb25zW2xvYWRlci5pZF0gfHwge307XG4gICAgICB2YXIgbG9hZGVyT3B0aW9ucyA9IGxvYWRlci5vcHRpb25zICYmIGxvYWRlci5vcHRpb25zW2xvYWRlci5pZF0gfHwge307XG4gICAgICB2YXIgZGVwcmVjYXRlZE9wdGlvbnMgPSBsb2FkZXIuZGVwcmVjYXRlZE9wdGlvbnMgJiYgbG9hZGVyLmRlcHJlY2F0ZWRPcHRpb25zW2xvYWRlci5pZF0gfHwge307XG4gICAgICB2YWxpZGF0ZU9wdGlvbnNPYmplY3QoaWRPcHRpb25zLCBsb2FkZXIuaWQsIGxvYWRlck9wdGlvbnMsIGRlcHJlY2F0ZWRPcHRpb25zLCBsb2FkZXJzKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbnNPYmplY3Qob3B0aW9ucywgaWQsIGRlZmF1bHRPcHRpb25zLCBkZXByZWNhdGVkT3B0aW9ucywgbG9hZGVycykge1xuICB2YXIgbG9hZGVyTmFtZSA9IGlkIHx8ICdUb3AgbGV2ZWwnO1xuICB2YXIgcHJlZml4ID0gaWQgPyBcIlwiLmNvbmNhdChpZCwgXCIuXCIpIDogJyc7XG5cbiAgZm9yICh2YXIgX2tleSBpbiBvcHRpb25zKSB7XG4gICAgdmFyIGlzU3ViT3B0aW9ucyA9ICFpZCAmJiAoMCwgX2lzVHlwZS5pc09iamVjdCkob3B0aW9uc1tfa2V5XSk7XG4gICAgdmFyIGlzQmFzZVVyaU9wdGlvbiA9IF9rZXkgPT09ICdiYXNlVXJpJyAmJiAhaWQ7XG4gICAgdmFyIGlzV29ya2VyVXJsT3B0aW9uID0gX2tleSA9PT0gJ3dvcmtlclVybCcgJiYgaWQ7XG5cbiAgICBpZiAoIShfa2V5IGluIGRlZmF1bHRPcHRpb25zKSAmJiAhaXNCYXNlVXJpT3B0aW9uICYmICFpc1dvcmtlclVybE9wdGlvbikge1xuICAgICAgaWYgKF9rZXkgaW4gZGVwcmVjYXRlZE9wdGlvbnMpIHtcbiAgICAgICAgX2xvZ2dlcnMucHJvYmVMb2cud2FybihcIlwiLmNvbmNhdChsb2FkZXJOYW1lLCBcIiBsb2FkZXIgb3B0aW9uICdcIikuY29uY2F0KHByZWZpeCkuY29uY2F0KF9rZXksIFwiJyBubyBsb25nZXIgc3VwcG9ydGVkLCB1c2UgJ1wiKS5jb25jYXQoZGVwcmVjYXRlZE9wdGlvbnNbX2tleV0sIFwiJ1wiKSkoKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzU3ViT3B0aW9ucykge1xuICAgICAgICB2YXIgc3VnZ2VzdGlvbiA9IGZpbmRTaW1pbGFyT3B0aW9uKF9rZXksIGxvYWRlcnMpO1xuXG4gICAgICAgIF9sb2dnZXJzLnByb2JlTG9nLndhcm4oXCJcIi5jb25jYXQobG9hZGVyTmFtZSwgXCIgbG9hZGVyIG9wdGlvbiAnXCIpLmNvbmNhdChwcmVmaXgpLmNvbmNhdChfa2V5LCBcIicgbm90IHJlY29nbml6ZWQuIFwiKS5jb25jYXQoc3VnZ2VzdGlvbikpKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRTaW1pbGFyT3B0aW9uKG9wdGlvbktleSwgbG9hZGVycykge1xuICB2YXIgbG93ZXJDYXNlT3B0aW9uS2V5ID0gb3B0aW9uS2V5LnRvTG93ZXJDYXNlKCk7XG4gIHZhciBiZXN0U3VnZ2VzdGlvbiA9ICcnO1xuXG4gIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobG9hZGVycyksXG4gICAgICBfc3RlcDI7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgdmFyIGxvYWRlciA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgZm9yICh2YXIgX2tleTIgaW4gbG9hZGVyLm9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbktleSA9PT0gX2tleTIpIHtcbiAgICAgICAgICByZXR1cm4gXCJEaWQgeW91IG1lYW4gJ1wiLmNvbmNhdChsb2FkZXIuaWQsIFwiLlwiKS5jb25jYXQoX2tleTIsIFwiJz9cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG93ZXJDYXNlS2V5ID0gX2tleTIudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICB2YXIgaXNQYXJ0aWFsTWF0Y2ggPSBsb3dlckNhc2VPcHRpb25LZXkuc3RhcnRzV2l0aChsb3dlckNhc2VLZXkpIHx8IGxvd2VyQ2FzZUtleS5zdGFydHNXaXRoKGxvd2VyQ2FzZU9wdGlvbktleSk7XG5cbiAgICAgICAgaWYgKGlzUGFydGlhbE1hdGNoKSB7XG4gICAgICAgICAgYmVzdFN1Z2dlc3Rpb24gPSBiZXN0U3VnZ2VzdGlvbiB8fCBcIkRpZCB5b3UgbWVhbiAnXCIuY29uY2F0KGxvYWRlci5pZCwgXCIuXCIpLmNvbmNhdChfa2V5MiwgXCInP1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yMi5mKCk7XG4gIH1cblxuICByZXR1cm4gYmVzdFN1Z2dlc3Rpb247XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU9wdGlvbnNJbnRlcm5hbChsb2FkZXIsIG9wdGlvbnMsIHVybCkge1xuICB2YXIgbG9hZGVyRGVmYXVsdE9wdGlvbnMgPSBsb2FkZXIub3B0aW9ucyB8fCB7fTtcblxuICB2YXIgbWVyZ2VkT3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoe30sIGxvYWRlckRlZmF1bHRPcHRpb25zKTtcblxuICBhZGRVcmxPcHRpb25zKG1lcmdlZE9wdGlvbnMsIHVybCk7XG5cbiAgaWYgKG1lcmdlZE9wdGlvbnMubG9nID09PSBudWxsKSB7XG4gICAgbWVyZ2VkT3B0aW9ucy5sb2cgPSBuZXcgX2xvZ2dlcnMuTnVsbExvZygpO1xuICB9XG5cbiAgbWVyZ2VOZXN0ZWRGaWVsZHMobWVyZ2VkT3B0aW9ucywgZ2V0R2xvYmFsTG9hZGVyT3B0aW9ucygpKTtcbiAgbWVyZ2VOZXN0ZWRGaWVsZHMobWVyZ2VkT3B0aW9ucywgb3B0aW9ucyk7XG4gIHJldHVybiBtZXJnZWRPcHRpb25zO1xufVxuXG5mdW5jdGlvbiBtZXJnZU5lc3RlZEZpZWxkcyhtZXJnZWRPcHRpb25zLCBvcHRpb25zKSB7XG4gIGZvciAodmFyIF9rZXkzIGluIG9wdGlvbnMpIHtcbiAgICBpZiAoX2tleTMgaW4gb3B0aW9ucykge1xuICAgICAgdmFyIHZhbHVlID0gb3B0aW9uc1tfa2V5M107XG5cbiAgICAgIGlmICgoMCwgX2lzVHlwZS5pc1B1cmVPYmplY3QpKHZhbHVlKSAmJiAoMCwgX2lzVHlwZS5pc1B1cmVPYmplY3QpKG1lcmdlZE9wdGlvbnNbX2tleTNdKSkge1xuICAgICAgICBtZXJnZWRPcHRpb25zW19rZXkzXSA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbWVyZ2VkT3B0aW9uc1tfa2V5M10pLCBvcHRpb25zW19rZXkzXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXJnZWRPcHRpb25zW19rZXkzXSA9IG9wdGlvbnNbX2tleTNdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRVcmxPcHRpb25zKG9wdGlvbnMsIHVybCkge1xuICBpZiAodXJsICYmICEoJ2Jhc2VVcmknIGluIG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucy5iYXNlVXJpID0gdXJsO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcHRpb24tdXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZmV0Y2hQcm9ncmVzcztcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbmZ1bmN0aW9uIGZldGNoUHJvZ3Jlc3MoX3gsIF94Mikge1xuICByZXR1cm4gX2ZldGNoUHJvZ3Jlc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2ZldGNoUHJvZ3Jlc3MoKSB7XG4gIF9mZXRjaFByb2dyZXNzID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKHJlc3BvbnNlLCBvblByb2dyZXNzKSB7XG4gICAgdmFyIG9uRG9uZSxcbiAgICAgICAgb25FcnJvcixcbiAgICAgICAgYm9keSxcbiAgICAgICAgY29udGVudExlbmd0aCxcbiAgICAgICAgdG90YWxCeXRlcyxcbiAgICAgICAgcHJvZ3Jlc3NTdHJlYW0sXG4gICAgICAgIF9hcmdzMiA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBvbkRvbmUgPSBfYXJnczIubGVuZ3RoID4gMiAmJiBfYXJnczJbMl0gIT09IHVuZGVmaW5lZCA/IF9hcmdzMlsyXSA6IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgb25FcnJvciA9IF9hcmdzMi5sZW5ndGggPiAzICYmIF9hcmdzMlszXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3MyWzNdIDogZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXNwb25zZSA9IF9jb250ZXh0Mi5zZW50O1xuXG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzcG9uc2UpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgYm9keSA9IHJlc3BvbnNlLmJvZHk7XG5cbiAgICAgICAgICAgIGlmIChib2R5KSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCByZXNwb25zZSk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgY29udGVudExlbmd0aCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LWxlbmd0aCcpIHx8IDA7XG4gICAgICAgICAgICB0b3RhbEJ5dGVzID0gY29udGVudExlbmd0aCAmJiBwYXJzZUludChjb250ZW50TGVuZ3RoKTtcblxuICAgICAgICAgICAgaWYgKGNvbnRlbnRMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCByZXNwb25zZSk7XG5cbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgaWYgKCEodHlwZW9mIFJlYWRhYmxlU3RyZWFtID09PSAndW5kZWZpbmVkJyB8fCAhYm9keS5nZXRSZWFkZXIpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCByZXNwb25zZSk7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgcHJvZ3Jlc3NTdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZWFkZXI7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkKGNvbnRyb2xsZXIsIHJlYWRlciwgMCwgdG90YWxCeXRlcywgb25Qcm9ncmVzcywgb25Eb25lLCBvbkVycm9yKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSwgX2NhbGxlZSk7XG4gICAgICAgICAgICAgICAgfSkpKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgbmV3IFJlc3BvbnNlKHByb2dyZXNzU3RyZWFtKSk7XG5cbiAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIpO1xuICB9KSk7XG4gIHJldHVybiBfZmV0Y2hQcm9ncmVzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiByZWFkKF94MywgX3g0LCBfeDUsIF94NiwgX3g3LCBfeDgsIF94OSkge1xuICByZXR1cm4gX3JlYWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3JlYWQoKSB7XG4gIF9yZWFkID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKGNvbnRyb2xsZXIsIHJlYWRlciwgbG9hZGVkQnl0ZXMsIHRvdGFsQnl0ZXMsIG9uUHJvZ3Jlc3MsIG9uRG9uZSwgb25FcnJvcikge1xuICAgIHZhciBfeWllbGQkcmVhZGVyJHJlYWQsIGRvbmUsIHZhbHVlLCBwZXJjZW50O1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAwO1xuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkKCk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBfeWllbGQkcmVhZGVyJHJlYWQgPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgIGRvbmUgPSBfeWllbGQkcmVhZGVyJHJlYWQuZG9uZTtcbiAgICAgICAgICAgIHZhbHVlID0gX3lpZWxkJHJlYWRlciRyZWFkLnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9uRG9uZSgpO1xuICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIik7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgbG9hZGVkQnl0ZXMgKz0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIHBlcmNlbnQgPSBNYXRoLnJvdW5kKGxvYWRlZEJ5dGVzIC8gdG90YWxCeXRlcyAqIDEwMCk7XG4gICAgICAgICAgICBvblByb2dyZXNzKHBlcmNlbnQsIHtcbiAgICAgICAgICAgICAgbG9hZGVkQnl0ZXM6IGxvYWRlZEJ5dGVzLFxuICAgICAgICAgICAgICB0b3RhbEJ5dGVzOiB0b3RhbEJ5dGVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDE2O1xuICAgICAgICAgICAgcmV0dXJuIHJlYWQoY29udHJvbGxlciwgcmVhZGVyLCBsb2FkZWRCeXRlcywgdG90YWxCeXRlcywgb25Qcm9ncmVzcywgb25Eb25lLCBvbkVycm9yKTtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDIyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAxODtcbiAgICAgICAgICAgIF9jb250ZXh0My50MCA9IF9jb250ZXh0M1tcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihfY29udGV4dDMudDApO1xuICAgICAgICAgICAgb25FcnJvcihfY29udGV4dDMudDApO1xuXG4gICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUzLCBudWxsLCBbWzAsIDE4XV0pO1xuICB9KSk7XG4gIHJldHVybiBfcmVhZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmV0Y2gtcHJvZ3Jlc3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnBhcnNlTUlNRVR5cGUgPSBwYXJzZU1JTUVUeXBlO1xuZXhwb3J0cy5wYXJzZU1JTUVUeXBlRnJvbVVSTCA9IHBhcnNlTUlNRVR5cGVGcm9tVVJMO1xudmFyIERBVEFfVVJMX1BBVFRFUk4gPSAvXmRhdGE6KFstXFx3Ll0rXFwvWy1cXHcuK10rKSg7fCwpLztcbnZhciBNSU1FX1RZUEVfUEFUVEVSTiA9IC9eKFstXFx3Ll0rXFwvWy1cXHcuK10rKS87XG5cbmZ1bmN0aW9uIHBhcnNlTUlNRVR5cGUobWltZVN0cmluZykge1xuICB2YXIgbWF0Y2hlcyA9IE1JTUVfVFlQRV9QQVRURVJOLmV4ZWMobWltZVN0cmluZyk7XG5cbiAgaWYgKG1hdGNoZXMpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBtaW1lU3RyaW5nO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1JTUVUeXBlRnJvbVVSTCh1cmwpIHtcbiAgdmFyIG1hdGNoZXMgPSBEQVRBX1VSTF9QQVRURVJOLmV4ZWModXJsKTtcblxuICBpZiAobWF0Y2hlcykge1xuICAgIHJldHVybiBtYXRjaGVzWzFdO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWltZS10eXBlLXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXRSZXNvdXJjZVVybEFuZFR5cGUgPSBnZXRSZXNvdXJjZVVybEFuZFR5cGU7XG5leHBvcnRzLmdldFJlc291cmNlQ29udGVudExlbmd0aCA9IGdldFJlc291cmNlQ29udGVudExlbmd0aDtcblxudmFyIF9pc1R5cGUgPSByZXF1aXJlKFwiLi4vLi4vamF2YXNjcmlwdC11dGlscy9pcy10eXBlXCIpO1xuXG52YXIgX21pbWVUeXBlVXRpbHMgPSByZXF1aXJlKFwiLi9taW1lLXR5cGUtdXRpbHNcIik7XG5cbnZhciBRVUVSWV9TVFJJTkdfUEFUVEVSTiA9IC9cXD8uKi87XG5cbmZ1bmN0aW9uIGdldFJlc291cmNlVXJsQW5kVHlwZShyZXNvdXJjZSkge1xuICBpZiAoKDAsIF9pc1R5cGUuaXNSZXNwb25zZSkocmVzb3VyY2UpKSB7XG4gICAgdmFyIHVybCA9IHN0cmlwUXVlcnlTdHJpbmcocmVzb3VyY2UudXJsIHx8ICcnKTtcbiAgICB2YXIgY29udGVudFR5cGVIZWFkZXIgPSByZXNvdXJjZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykgfHwgJyc7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVybDogdXJsLFxuICAgICAgdHlwZTogKDAsIF9taW1lVHlwZVV0aWxzLnBhcnNlTUlNRVR5cGUpKGNvbnRlbnRUeXBlSGVhZGVyKSB8fCAoMCwgX21pbWVUeXBlVXRpbHMucGFyc2VNSU1FVHlwZUZyb21VUkwpKHVybClcbiAgICB9O1xuICB9XG5cbiAgaWYgKCgwLCBfaXNUeXBlLmlzQmxvYikocmVzb3VyY2UpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVybDogc3RyaXBRdWVyeVN0cmluZyhyZXNvdXJjZS5uYW1lIHx8ICcnKSxcbiAgICAgIHR5cGU6IHJlc291cmNlLnR5cGUgfHwgJydcbiAgICB9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiByZXNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdXJsOiBzdHJpcFF1ZXJ5U3RyaW5nKHJlc291cmNlKSxcbiAgICAgIHR5cGU6ICgwLCBfbWltZVR5cGVVdGlscy5wYXJzZU1JTUVUeXBlRnJvbVVSTCkocmVzb3VyY2UpXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdXJsOiAnJyxcbiAgICB0eXBlOiAnJ1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRSZXNvdXJjZUNvbnRlbnRMZW5ndGgocmVzb3VyY2UpIHtcbiAgaWYgKCgwLCBfaXNUeXBlLmlzUmVzcG9uc2UpKHJlc291cmNlKSkge1xuICAgIHJldHVybiByZXNvdXJjZS5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddIHx8IC0xO1xuICB9XG5cbiAgaWYgKCgwLCBfaXNUeXBlLmlzQmxvYikocmVzb3VyY2UpKSB7XG4gICAgcmV0dXJuIHJlc291cmNlLnNpemU7XG4gIH1cblxuICBpZiAodHlwZW9mIHJlc291cmNlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiByZXNvdXJjZS5sZW5ndGg7XG4gIH1cblxuICBpZiAocmVzb3VyY2UgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiByZXNvdXJjZS5ieXRlTGVuZ3RoO1xuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhyZXNvdXJjZSkpIHtcbiAgICByZXR1cm4gcmVzb3VyY2UuYnl0ZUxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gc3RyaXBRdWVyeVN0cmluZyh1cmwpIHtcbiAgcmV0dXJuIHVybC5yZXBsYWNlKFFVRVJZX1NUUklOR19QQVRURVJOLCAnJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvdXJjZS11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm1ha2VSZXNwb25zZSA9IG1ha2VSZXNwb25zZTtcbmV4cG9ydHMuY2hlY2tSZXNwb25zZSA9IGNoZWNrUmVzcG9uc2U7XG5leHBvcnRzLmNoZWNrUmVzcG9uc2VTeW5jID0gY2hlY2tSZXNwb25zZVN5bmM7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2lzVHlwZSA9IHJlcXVpcmUoXCIuLi8uLi9qYXZhc2NyaXB0LXV0aWxzL2lzLXR5cGVcIik7XG5cbnZhciBfcmVzb3VyY2VVdGlscyA9IHJlcXVpcmUoXCIuL3Jlc291cmNlLXV0aWxzXCIpO1xuXG5mdW5jdGlvbiBtYWtlUmVzcG9uc2UoX3gpIHtcbiAgcmV0dXJuIF9tYWtlUmVzcG9uc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX21ha2VSZXNwb25zZSgpIHtcbiAgX21ha2VSZXNwb25zZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKHJlc291cmNlKSB7XG4gICAgdmFyIGhlYWRlcnMsIGNvbnRlbnRMZW5ndGgsIF9nZXRSZXNvdXJjZVVybEFuZFR5cCwgdXJsLCB0eXBlLCBpbml0aWFsRGF0YVVybCwgcmVzcG9uc2U7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghKDAsIF9pc1R5cGUuaXNSZXNwb25zZSkocmVzb3VyY2UpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCByZXNvdXJjZSk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBoZWFkZXJzID0ge307XG4gICAgICAgICAgICBjb250ZW50TGVuZ3RoID0gKDAsIF9yZXNvdXJjZVV0aWxzLmdldFJlc291cmNlQ29udGVudExlbmd0aCkocmVzb3VyY2UpO1xuXG4gICAgICAgICAgICBpZiAoY29udGVudExlbmd0aCA+PSAwKSB7XG4gICAgICAgICAgICAgIGhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10gPSBTdHJpbmcoY29udGVudExlbmd0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9nZXRSZXNvdXJjZVVybEFuZFR5cCA9ICgwLCBfcmVzb3VyY2VVdGlscy5nZXRSZXNvdXJjZVVybEFuZFR5cGUpKHJlc291cmNlKSwgdXJsID0gX2dldFJlc291cmNlVXJsQW5kVHlwLnVybCwgdHlwZSA9IF9nZXRSZXNvdXJjZVVybEFuZFR5cC50eXBlO1xuXG4gICAgICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgICBoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9IHR5cGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA5O1xuICAgICAgICAgICAgcmV0dXJuIGdldEluaXRpYWxEYXRhVXJsKHJlc291cmNlKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGluaXRpYWxEYXRhVXJsID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgaWYgKGluaXRpYWxEYXRhVXJsKSB7XG4gICAgICAgICAgICAgIGhlYWRlcnNbJ3gtZmlyc3QtYnl0ZXMnXSA9IGluaXRpYWxEYXRhVXJsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc291cmNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICByZXNvdXJjZSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShyZXNvdXJjZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKHJlc291cmNlLCB7XG4gICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3BvbnNlLCAndXJsJywge1xuICAgICAgICAgICAgICB2YWx1ZTogdXJsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzcG9uc2UpO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9tYWtlUmVzcG9uc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tSZXNwb25zZShfeDIpIHtcbiAgcmV0dXJuIF9jaGVja1Jlc3BvbnNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9jaGVja1Jlc3BvbnNlKCkge1xuICBfY2hlY2tSZXNwb25zZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMihyZXNwb25zZSkge1xuICAgIHZhciBtZXNzYWdlO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gZ2V0UmVzcG9uc2VFcnJvcihyZXNwb25zZSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBtZXNzYWdlID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMik7XG4gIH0pKTtcbiAgcmV0dXJuIF9jaGVja1Jlc3BvbnNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrUmVzcG9uc2VTeW5jKHJlc3BvbnNlKSB7XG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICB2YXIgbWVzc2FnZSA9IFwiXCIuY29uY2F0KHJlc3BvbnNlLnN0YXR1cywgXCIgXCIpLmNvbmNhdChyZXNwb25zZS5zdGF0dXNUZXh0KTtcbiAgICBtZXNzYWdlID0gbWVzc2FnZS5sZW5ndGggPiA2MCA/IFwiXCIuY29uY2F0KG1lc3NhZ2Uuc2xpY2UoNjApLCBcIi4uLlwiKSA6IG1lc3NhZ2U7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJlc3BvbnNlRXJyb3IoX3gzKSB7XG4gIHJldHVybiBfZ2V0UmVzcG9uc2VFcnJvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0UmVzcG9uc2VFcnJvcigpIHtcbiAgX2dldFJlc3BvbnNlRXJyb3IgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMocmVzcG9uc2UpIHtcbiAgICB2YXIgbWVzc2FnZSwgY29udGVudFR5cGUsIHRleHQ7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgbWVzc2FnZSA9IFwiRmFpbGVkIHRvIGZldGNoIHJlc291cmNlIFwiLmNvbmNhdChyZXNwb25zZS51cmwsIFwiIChcIikuY29uY2F0KHJlc3BvbnNlLnN0YXR1cywgXCIpOiBcIik7XG4gICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDE7XG4gICAgICAgICAgICBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKTtcbiAgICAgICAgICAgIHRleHQgPSByZXNwb25zZS5zdGF0dXNUZXh0O1xuXG4gICAgICAgICAgICBpZiAoIWNvbnRlbnRUeXBlLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi9qc29uJykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0My50MCA9IHRleHQ7XG4gICAgICAgICAgICBfY29udGV4dDMudDEgPSBcIiBcIjtcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gOTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBfY29udGV4dDMudDIgPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgIHRleHQgPSBfY29udGV4dDMudDAgKz0gX2NvbnRleHQzLnQxLmNvbmNhdC5jYWxsKF9jb250ZXh0My50MSwgX2NvbnRleHQzLnQyKTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBtZXNzYWdlICs9IHRleHQ7XG4gICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZS5sZW5ndGggPiA2MCA/IFwiXCIuY29uY2F0KG1lc3NhZ2Uuc2xpY2UoNjApLCBcIi4uLlwiKSA6IG1lc3NhZ2U7XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDE3O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAxNTtcbiAgICAgICAgICAgIF9jb250ZXh0My50MyA9IF9jb250ZXh0M1tcImNhdGNoXCJdKDEpO1xuXG4gICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIG1lc3NhZ2UpO1xuXG4gICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUzLCBudWxsLCBbWzEsIDE1XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0UmVzcG9uc2VFcnJvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRJbml0aWFsRGF0YVVybChfeDQpIHtcbiAgcmV0dXJuIF9nZXRJbml0aWFsRGF0YVVybC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0SW5pdGlhbERhdGFVcmwoKSB7XG4gIF9nZXRJbml0aWFsRGF0YVVybCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlNChyZXNvdXJjZSkge1xuICAgIHZhciBJTklUSUFMX0RBVEFfTEVOR1RILCBibG9iU2xpY2UsIHNsaWNlLCBiYXNlNjQ7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgSU5JVElBTF9EQVRBX0xFTkdUSCA9IDU7XG5cbiAgICAgICAgICAgIGlmICghKHR5cGVvZiByZXNvdXJjZSA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIFwiZGF0YTosXCIuY29uY2F0KHJlc291cmNlLnNsaWNlKDAsIElOSVRJQUxfREFUQV9MRU5HVEgpKSk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBpZiAoIShyZXNvdXJjZSBpbnN0YW5jZW9mIEJsb2IpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJsb2JTbGljZSA9IHJlc291cmNlLnNsaWNlKDAsIDUpO1xuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA3O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG4gICAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2V2ZW50JHRhcmdldDtcblxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGV2ZW50ID09PSBudWxsIHx8IGV2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2V2ZW50JHRhcmdldCA9IGV2ZW50LnRhcmdldCkgPT09IG51bGwgfHwgX2V2ZW50JHRhcmdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2V2ZW50JHRhcmdldC5yZXN1bHQpO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2JTbGljZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0NC5zZW50KTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIGlmICghKHJlc291cmNlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzbGljZSA9IHJlc291cmNlLnNsaWNlKDAsIElOSVRJQUxfREFUQV9MRU5HVEgpO1xuICAgICAgICAgICAgYmFzZTY0ID0gYXJyYXlCdWZmZXJUb0Jhc2U2NChzbGljZSk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCBcImRhdGE6YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCBudWxsKTtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNCk7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRJbml0aWFsRGF0YVVybC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBhcnJheUJ1ZmZlclRvQmFzZTY0KGJ1ZmZlcikge1xuICB2YXIgYmluYXJ5ID0gJyc7XG4gIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICBiaW5hcnkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gIH1cblxuICByZXR1cm4gYnRvYShiaW5hcnkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzcG9uc2UtdXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5OdWxsTG9hZGVyID0gZXhwb3J0cy5OdWxsV29ya2VyTG9hZGVyID0gdm9pZCAwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9hd2FpdEFzeW5jR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXdhaXRBc3luY0dlbmVyYXRvclwiKSk7XG5cbnZhciBfd3JhcEFzeW5jR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvd3JhcEFzeW5jR2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY0l0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNJdGVyYXRvclwiKSk7XG5cbnZhciBWRVJTSU9OID0gdHlwZW9mIFwiMy4wLjlcIiAhPT0gJ3VuZGVmaW5lZCcgPyBcIjMuMC45XCIgOiAnbGF0ZXN0JztcbnZhciBOdWxsV29ya2VyTG9hZGVyID0ge1xuICBuYW1lOiAnTnVsbCBsb2FkZXInLFxuICBpZDogJ251bGwnLFxuICBtb2R1bGU6ICdjb3JlJyxcbiAgdmVyc2lvbjogVkVSU0lPTixcbiAgd29ya2VyOiB0cnVlLFxuICBtaW1lVHlwZXM6IFsnYXBwbGljYXRpb24veC5lbXB0eSddLFxuICBleHRlbnNpb25zOiBbJ251bGwnXSxcbiAgdGVzdHM6IFtmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XSxcbiAgb3B0aW9uczoge1xuICAgIG51bGw6IHt9XG4gIH1cbn07XG5leHBvcnRzLk51bGxXb3JrZXJMb2FkZXIgPSBOdWxsV29ya2VyTG9hZGVyO1xudmFyIE51bGxMb2FkZXIgPSB7XG4gIG5hbWU6ICdOdWxsIGxvYWRlcicsXG4gIGlkOiAnbnVsbCcsXG4gIG1vZHVsZTogJ2NvcmUnLFxuICB2ZXJzaW9uOiBWRVJTSU9OLFxuICBtaW1lVHlwZXM6IFsnYXBwbGljYXRpb24veC5lbXB0eSddLFxuICBleHRlbnNpb25zOiBbJ251bGwnXSxcbiAgcGFyc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3BhcnNlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoYXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGFycmF5QnVmZmVyKTtcblxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZSk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gcGFyc2UoX3gyKSB7XG4gICAgICByZXR1cm4gX3BhcnNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlO1xuICB9KCksXG4gIHBhcnNlU3luYzogZnVuY3Rpb24gcGFyc2VTeW5jKGFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGFycmF5QnVmZmVyO1xuICB9LFxuICBwYXJzZUluQmF0Y2hlczogZnVuY3Rpb24gKCkge1xuICAgIHZhciBfZ2VuZXJhdG9yID0gKDAsIF93cmFwQXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoYXN5bmNJdGVyYXRvcikge1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24sIF9kaWRJdGVyYXRvckVycm9yLCBfaXRlcmF0b3JFcnJvciwgX2l0ZXJhdG9yLCBfc3RlcCwgX3ZhbHVlLCBiYXRjaDtcblxuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAyO1xuICAgICAgICAgICAgICBfaXRlcmF0b3IgPSAoMCwgX2FzeW5jSXRlcmF0b3IyLmRlZmF1bHQpKGFzeW5jSXRlcmF0b3IpO1xuXG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgcmV0dXJuICgwLCBfYXdhaXRBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoX2l0ZXJhdG9yLm5leHQoKSk7XG5cbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgX3N0ZXAgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IF9zdGVwLmRvbmU7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgIHJldHVybiAoMCwgX2F3YWl0QXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKF9zdGVwLnZhbHVlKTtcblxuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgX3ZhbHVlID0gX2NvbnRleHQyLnNlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24pIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYmF0Y2ggPSBfdmFsdWU7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgIHJldHVybiBiYXRjaDtcblxuICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDIwO1xuICAgICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDJbXCJjYXRjaFwiXSgyKTtcbiAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IF9jb250ZXh0Mi50MDtcblxuICAgICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAyNDtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAyNTtcblxuICAgICAgICAgICAgICBpZiAoISghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyOTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjk7XG4gICAgICAgICAgICAgIHJldHVybiAoMCwgX2F3YWl0QXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKF9pdGVyYXRvci5yZXR1cm4oKSk7XG5cbiAgICAgICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMjk7XG5cbiAgICAgICAgICAgICAgaWYgKCFfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMzI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcblxuICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5maW5pc2goMjkpO1xuXG4gICAgICAgICAgICBjYXNlIDMzOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmZpbmlzaCgyNCk7XG5cbiAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTIsIG51bGwsIFtbMiwgMjAsIDI0LCAzNF0sIFsyNSwsIDI5LCAzM11dKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0b3IoX3gpIHtcbiAgICAgIHJldHVybiBfZ2VuZXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfSgpLFxuICB0ZXN0czogW2Z1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1dLFxuICBvcHRpb25zOiB7XG4gICAgbnVsbDoge31cbiAgfVxufTtcbmV4cG9ydHMuTnVsbExvYWRlciA9IE51bGxMb2FkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udWxsLWxvYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLl90eXBlY2hlY2tDU1ZMb2FkZXIgPSBleHBvcnRzLkNTVkxvYWRlciA9IHZvaWQgMDtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9zY2hlbWEgPSByZXF1aXJlKFwiQGxvYWRlcnMuZ2wvc2NoZW1hXCIpO1xuXG52YXIgX3BhcGFwYXJzZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGlicy9wYXBhcGFyc2VcIikpO1xuXG52YXIgX2FzeW5jSXRlcmF0b3JTdHJlYW1lciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2FzeW5jLWl0ZXJhdG9yLXN0cmVhbWVyXCIpKTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBWRVJTSU9OID0gdHlwZW9mIFwiMy4wLjlcIiAhPT0gJ3VuZGVmaW5lZCcgPyBcIjMuMC45XCIgOiAnbGF0ZXN0JztcbnZhciBERUZBVUxUX0NTVl9MT0FERVJfT1BUSU9OUyA9IHtcbiAgY3N2OiB7XG4gICAgc2hhcGU6ICdvYmplY3Qtcm93LXRhYmxlJyxcbiAgICBvcHRpbWl6ZU1lbW9yeVVzYWdlOiBmYWxzZSxcbiAgICBoZWFkZXI6ICdhdXRvJyxcbiAgICBjb2x1bW5QcmVmaXg6ICdjb2x1bW4nLFxuICAgIHF1b3RlQ2hhcjogJ1wiJyxcbiAgICBlc2NhcGVDaGFyOiAnXCInLFxuICAgIGR5bmFtaWNUeXBpbmc6IHRydWUsXG4gICAgY29tbWVudHM6IGZhbHNlLFxuICAgIHNraXBFbXB0eUxpbmVzOiB0cnVlLFxuICAgIGRlbGltaXRlcnNUb0d1ZXNzOiBbJywnLCAnXFx0JywgJ3wnLCAnOyddXG4gIH1cbn07XG52YXIgQ1NWTG9hZGVyID0ge1xuICBpZDogJ2NzdicsXG4gIG1vZHVsZTogJ2NzdicsXG4gIG5hbWU6ICdDU1YnLFxuICB2ZXJzaW9uOiBWRVJTSU9OLFxuICBleHRlbnNpb25zOiBbJ2NzdiddLFxuICBtaW1lVHlwZXM6IFsndGV4dC9jc3YnXSxcbiAgY2F0ZWdvcnk6ICd0YWJsZScsXG4gIHBhcnNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9wYXJzZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKGFycmF5QnVmZmVyLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBwYXJzZUNTVihuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYXJyYXlCdWZmZXIpLCBvcHRpb25zKSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlKF94LCBfeDIpIHtcbiAgICAgIHJldHVybiBfcGFyc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2U7XG4gIH0oKSxcbiAgcGFyc2VUZXh0OiBmdW5jdGlvbiBwYXJzZVRleHQodGV4dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBwYXJzZUNTVih0ZXh0LCBvcHRpb25zKTtcbiAgfSxcbiAgcGFyc2VJbkJhdGNoZXM6IHBhcnNlQ1NWSW5CYXRjaGVzLFxuICBvcHRpb25zOiBERUZBVUxUX0NTVl9MT0FERVJfT1BUSU9OU1xufTtcbmV4cG9ydHMuQ1NWTG9hZGVyID0gQ1NWTG9hZGVyO1xuXG5mdW5jdGlvbiBwYXJzZUNTVihfeDMsIF94NCkge1xuICByZXR1cm4gX3BhcnNlQ1NWLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9wYXJzZUNTVigpIHtcbiAgX3BhcnNlQ1NWID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGNzdlRleHQsIG9wdGlvbnMpIHtcbiAgICB2YXIgY3N2T3B0aW9ucywgZmlyc3RSb3csIGhlYWRlciwgcGFyc2VXaXRoSGVhZGVyLCBwYXBhcGFyc2VDb25maWcsIHJlc3VsdCwgcm93cywgaGVhZGVyUm93O1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNzdk9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIERFRkFVTFRfQ1NWX0xPQURFUl9PUFRJT05TLmNzdiksIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jc3YpO1xuICAgICAgICAgICAgZmlyc3RSb3cgPSByZWFkRmlyc3RSb3coY3N2VGV4dCk7XG4gICAgICAgICAgICBoZWFkZXIgPSBjc3ZPcHRpb25zLmhlYWRlciA9PT0gJ2F1dG8nID8gaXNIZWFkZXJSb3coZmlyc3RSb3cpIDogQm9vbGVhbihjc3ZPcHRpb25zLmhlYWRlcik7XG4gICAgICAgICAgICBwYXJzZVdpdGhIZWFkZXIgPSBoZWFkZXI7XG4gICAgICAgICAgICBwYXBhcGFyc2VDb25maWcgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGNzdk9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgICAgICBoZWFkZXI6IHBhcnNlV2l0aEhlYWRlcixcbiAgICAgICAgICAgICAgZG93bmxvYWQ6IGZhbHNlLFxuICAgICAgICAgICAgICB0cmFuc2Zvcm1IZWFkZXI6IHBhcnNlV2l0aEhlYWRlciA/IGR1cGxpY2F0ZUNvbHVtblRyYW5zZm9ybWVyKCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiBlcnJvcihlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3VsdCA9IF9wYXBhcGFyc2UuZGVmYXVsdC5wYXJzZShjc3ZUZXh0LCBwYXBhcGFyc2VDb25maWcpO1xuICAgICAgICAgICAgcm93cyA9IHJlc3VsdC5kYXRhO1xuICAgICAgICAgICAgaGVhZGVyUm93ID0gcmVzdWx0Lm1ldGEuZmllbGRzIHx8IGdlbmVyYXRlSGVhZGVyKGNzdk9wdGlvbnMuY29sdW1uUHJlZml4LCBmaXJzdFJvdy5sZW5ndGgpO1xuICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gY3N2T3B0aW9ucy5zaGFwZTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gX2NvbnRleHQyLnQwID09PSAnb2JqZWN0LXJvdy10YWJsZScgPyAxMSA6IF9jb250ZXh0Mi50MCA9PT0gJ2FycmF5LXJvdy10YWJsZScgPyAxMyA6IDE1O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgcm93cyA9IHJvd3MubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocm93KSA/ICgwLCBfc2NoZW1hLmNvbnZlcnRUb09iamVjdFJvdykocm93LCBoZWFkZXJSb3cpIDogcm93O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcImJyZWFrXCIsIDE1KTtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICByb3dzID0gcm93cy5tYXAoZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShyb3cpID8gcm93IDogKDAsIF9zY2hlbWEuY29udmVydFRvQXJyYXlSb3cpKHJvdywgaGVhZGVyUm93KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJicmVha1wiLCAxNSk7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgcm93cyk7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIpO1xuICB9KSk7XG4gIHJldHVybiBfcGFyc2VDU1YuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VDU1ZJbkJhdGNoZXMoYXN5bmNJdGVyYXRvciwgb3B0aW9ucykge1xuICB2YXIgX29wdGlvbnM7XG5cbiAgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zLmJhdGNoU2l6ZSA9PT0gJ2F1dG8nKSB7XG4gICAgb3B0aW9ucy5iYXRjaFNpemUgPSA0MDAwO1xuICB9XG5cbiAgdmFyIGNzdk9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIERFRkFVTFRfQ1NWX0xPQURFUl9PUFRJT05TLmNzdiksIChfb3B0aW9ucyA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9vcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0aW9ucy5jc3YpO1xuXG4gIHZhciBhc3luY1F1ZXVlID0gbmV3IF9zY2hlbWEuQXN5bmNRdWV1ZSgpO1xuICB2YXIgaXNGaXJzdFJvdyA9IHRydWU7XG4gIHZhciBoZWFkZXJSb3cgPSBudWxsO1xuICB2YXIgdGFibGVCYXRjaEJ1aWxkZXIgPSBudWxsO1xuICB2YXIgc2NoZW1hID0gbnVsbDtcblxuICB2YXIgY29uZmlnID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjc3ZPcHRpb25zKSwge30sIHtcbiAgICBoZWFkZXI6IGZhbHNlLFxuICAgIGRvd25sb2FkOiBmYWxzZSxcbiAgICBjaHVua1NpemU6IDEwMjQgKiAxMDI0ICogNSxcbiAgICBza2lwRW1wdHlMaW5lczogZmFsc2UsXG4gICAgc3RlcDogZnVuY3Rpb24gc3RlcChyZXN1bHRzKSB7XG4gICAgICB2YXIgcm93ID0gcmVzdWx0cy5kYXRhO1xuXG4gICAgICBpZiAoY3N2T3B0aW9ucy5za2lwRW1wdHlMaW5lcykge1xuICAgICAgICB2YXIgY29sbGFwc2VkUm93ID0gcm93LmZsYXQoKS5qb2luKCcnKS50cmltKCk7XG5cbiAgICAgICAgaWYgKGNvbGxhcHNlZFJvdyA9PT0gJycpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGJ5dGVzVXNlZCA9IHJlc3VsdHMubWV0YS5jdXJzb3I7XG5cbiAgICAgIGlmIChpc0ZpcnN0Um93ICYmICFoZWFkZXJSb3cpIHtcbiAgICAgICAgdmFyIGhlYWRlciA9IGNzdk9wdGlvbnMuaGVhZGVyID09PSAnYXV0bycgPyBpc0hlYWRlclJvdyhyb3cpIDogQm9vbGVhbihjc3ZPcHRpb25zLmhlYWRlcik7XG5cbiAgICAgICAgaWYgKGhlYWRlcikge1xuICAgICAgICAgIGhlYWRlclJvdyA9IHJvdy5tYXAoZHVwbGljYXRlQ29sdW1uVHJhbnNmb3JtZXIoKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0ZpcnN0Um93KSB7XG4gICAgICAgIGlzRmlyc3RSb3cgPSBmYWxzZTtcblxuICAgICAgICBpZiAoIWhlYWRlclJvdykge1xuICAgICAgICAgIGhlYWRlclJvdyA9IGdlbmVyYXRlSGVhZGVyKGNzdk9wdGlvbnMuY29sdW1uUHJlZml4LCByb3cubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjaGVtYSA9IGRlZHVjZVNjaGVtYShyb3csIGhlYWRlclJvdyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjc3ZPcHRpb25zLm9wdGltaXplTWVtb3J5VXNhZ2UpIHtcbiAgICAgICAgcm93ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyb3cpKTtcbiAgICAgIH1cblxuICAgICAgdGFibGVCYXRjaEJ1aWxkZXIgPSB0YWJsZUJhdGNoQnVpbGRlciB8fCBuZXcgX3NjaGVtYS5UYWJsZUJhdGNoQnVpbGRlcihzY2hlbWEsIF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBzaGFwZTogY3N2T3B0aW9ucy5zaGFwZSB8fCAnYXJyYXktcm93LXRhYmxlJ1xuICAgICAgfSwgb3B0aW9ucykpO1xuXG4gICAgICB0cnkge1xuICAgICAgICB0YWJsZUJhdGNoQnVpbGRlci5hZGRSb3cocm93KTtcbiAgICAgICAgdmFyIGJhdGNoID0gdGFibGVCYXRjaEJ1aWxkZXIgJiYgdGFibGVCYXRjaEJ1aWxkZXIuZ2V0RnVsbEJhdGNoKHtcbiAgICAgICAgICBieXRlc1VzZWQ6IGJ5dGVzVXNlZFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoYmF0Y2gpIHtcbiAgICAgICAgICBhc3luY1F1ZXVlLmVucXVldWUoYmF0Y2gpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBhc3luY1F1ZXVlLmVucXVldWUoZXJyb3IpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHJlc3VsdHMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBieXRlc1VzZWQgPSByZXN1bHRzLm1ldGEuY3Vyc29yO1xuICAgICAgICB2YXIgYmF0Y2ggPSB0YWJsZUJhdGNoQnVpbGRlciAmJiB0YWJsZUJhdGNoQnVpbGRlci5nZXRGaW5hbEJhdGNoKHtcbiAgICAgICAgICBieXRlc1VzZWQ6IGJ5dGVzVXNlZFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoYmF0Y2gpIHtcbiAgICAgICAgICBhc3luY1F1ZXVlLmVucXVldWUoYmF0Y2gpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBhc3luY1F1ZXVlLmVucXVldWUoZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICBhc3luY1F1ZXVlLmNsb3NlKCk7XG4gICAgfVxuICB9KTtcblxuICBfcGFwYXBhcnNlLmRlZmF1bHQucGFyc2UoYXN5bmNJdGVyYXRvciwgY29uZmlnLCBfYXN5bmNJdGVyYXRvclN0cmVhbWVyLmRlZmF1bHQpO1xuXG4gIHJldHVybiBhc3luY1F1ZXVlO1xufVxuXG5mdW5jdGlvbiBpc0hlYWRlclJvdyhyb3cpIHtcbiAgcmV0dXJuIHJvdyAmJiByb3cuZXZlcnkoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZWFkRmlyc3RSb3coY3N2VGV4dCkge1xuICB2YXIgcmVzdWx0ID0gX3BhcGFwYXJzZS5kZWZhdWx0LnBhcnNlKGNzdlRleHQsIHtcbiAgICBkb3dubG9hZDogZmFsc2UsXG4gICAgZHluYW1pY1R5cGluZzogdHJ1ZSxcbiAgICBwcmV2aWV3OiAxXG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQuZGF0YVswXTtcbn1cblxuZnVuY3Rpb24gZHVwbGljYXRlQ29sdW1uVHJhbnNmb3JtZXIoKSB7XG4gIHZhciBvYnNlcnZlZENvbHVtbnMgPSBuZXcgU2V0KCk7XG4gIHJldHVybiBmdW5jdGlvbiAoY29sKSB7XG4gICAgdmFyIGNvbE5hbWUgPSBjb2w7XG4gICAgdmFyIGNvdW50ZXIgPSAxO1xuXG4gICAgd2hpbGUgKG9ic2VydmVkQ29sdW1ucy5oYXMoY29sTmFtZSkpIHtcbiAgICAgIGNvbE5hbWUgPSBcIlwiLmNvbmNhdChjb2wsIFwiLlwiKS5jb25jYXQoY291bnRlcik7XG4gICAgICBjb3VudGVyKys7XG4gICAgfVxuXG4gICAgb2JzZXJ2ZWRDb2x1bW5zLmFkZChjb2xOYW1lKTtcbiAgICByZXR1cm4gY29sTmFtZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVIZWFkZXIoY29sdW1uUHJlZml4KSB7XG4gIHZhciBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgdmFyIGhlYWRlcnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICBoZWFkZXJzLnB1c2goXCJcIi5jb25jYXQoY29sdW1uUHJlZml4KS5jb25jYXQoaSArIDEpKTtcbiAgfVxuXG4gIHJldHVybiBoZWFkZXJzO1xufVxuXG5mdW5jdGlvbiBkZWR1Y2VTY2hlbWEocm93LCBoZWFkZXJSb3cpIHtcbiAgdmFyIHNjaGVtYSA9IGhlYWRlclJvdyA/IHt9IDogW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3cubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29sdW1uTmFtZSA9IGhlYWRlclJvdyAmJiBoZWFkZXJSb3dbaV0gfHwgaTtcbiAgICB2YXIgdmFsdWUgPSByb3dbaV07XG5cbiAgICBzd2l0Y2ggKCgwLCBfdHlwZW9mMi5kZWZhdWx0KSh2YWx1ZSkpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgc2NoZW1hW2NvbHVtbk5hbWVdID0ge1xuICAgICAgICAgIG5hbWU6IFN0cmluZyhjb2x1bW5OYW1lKSxcbiAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICB0eXBlOiBGbG9hdDMyQXJyYXlcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzY2hlbWFbY29sdW1uTmFtZV0gPSB7XG4gICAgICAgICAgbmFtZTogU3RyaW5nKGNvbHVtbk5hbWUpLFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIHR5cGU6IEFycmF5XG4gICAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNjaGVtYTtcbn1cblxudmFyIF90eXBlY2hlY2tDU1ZMb2FkZXIgPSBDU1ZMb2FkZXI7XG5leHBvcnRzLl90eXBlY2hlY2tDU1ZMb2FkZXIgPSBfdHlwZWNoZWNrQ1NWTG9hZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3N2LWxvYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNTVkxvYWRlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfY3N2TG9hZGVyLkNTVkxvYWRlcjtcbiAgfVxufSk7XG5cbnZhciBfY3N2TG9hZGVyID0gcmVxdWlyZShcIi4vY3N2LWxvYWRlclwiKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEFzeW5jSXRlcmF0b3JTdHJlYW1lcjtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNJdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jSXRlcmF0b3JcIikpO1xuXG52YXIgX3BhcGFwYXJzZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2xpYnMvcGFwYXBhcnNlXCIpKTtcblxudmFyIENodW5rU3RyZWFtZXIgPSBfcGFwYXBhcnNlLmRlZmF1bHQuQ2h1bmtTdHJlYW1lcjtcblxuZnVuY3Rpb24gQXN5bmNJdGVyYXRvclN0cmVhbWVyKGNvbmZpZykge1xuICBjb25maWcgPSBjb25maWcgfHwge307XG4gIENodW5rU3RyZWFtZXIuY2FsbCh0aGlzLCBjb25maWcpO1xuICB0aGlzLnRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKHRoaXMuX2NvbmZpZy5lbmNvZGluZyk7XG5cbiAgdGhpcy5zdHJlYW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZShhc3luY0l0ZXJhdG9yKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiwgX2RpZEl0ZXJhdG9yRXJyb3IsIF9pdGVyYXRvckVycm9yLCBfaXRlcmF0b3IsIF9zdGVwLCBfdmFsdWUsIGNodW5rO1xuXG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgdGhpcy5faW5wdXQgPSBhc3luY0l0ZXJhdG9yO1xuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA0O1xuICAgICAgICAgICAgICBfaXRlcmF0b3IgPSAoMCwgX2FzeW5jSXRlcmF0b3IyLmRlZmF1bHQpKGFzeW5jSXRlcmF0b3IpO1xuXG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA4O1xuICAgICAgICAgICAgICByZXR1cm4gX2l0ZXJhdG9yLm5leHQoKTtcblxuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICBfc3RlcCA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSBfc3RlcC5kb25lO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgIHJldHVybiBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgX3ZhbHVlID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgICBpZiAoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbikge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNodW5rID0gX3ZhbHVlO1xuICAgICAgICAgICAgICB0aGlzLnBhcnNlQ2h1bmsodGhpcy5nZXRTdHJpbmdDaHVuayhjaHVuaykpO1xuXG4gICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjE7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSg0KTtcbiAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IF9jb250ZXh0LnQwO1xuXG4gICAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjU7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyNjtcblxuICAgICAgICAgICAgICBpZiAoISghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDMwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDMwO1xuICAgICAgICAgICAgICByZXR1cm4gX2l0ZXJhdG9yLnJldHVybigpO1xuXG4gICAgICAgICAgICBjYXNlIDMwOlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMzA7XG5cbiAgICAgICAgICAgICAgaWYgKCFfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuXG4gICAgICAgICAgICBjYXNlIDMzOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDMwKTtcblxuICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmZpbmlzaCgyNSk7XG5cbiAgICAgICAgICAgIGNhc2UgMzU6XG4gICAgICAgICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdGhpcy5wYXJzZUNodW5rKCcnKTtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQyO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDM5O1xuICAgICAgICAgICAgICBfY29udGV4dC50MSA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMSk7XG5cbiAgICAgICAgICAgICAgdGhpcy5fc2VuZEVycm9yKF9jb250ZXh0LnQxKTtcblxuICAgICAgICAgICAgY2FzZSA0MjpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUsIHRoaXMsIFtbMSwgMzldLCBbNCwgMjEsIDI1LCAzNV0sIFsyNiwsIDMwLCAzNF1dKTtcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKF94KSB7XG4gICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0oKTtcblxuICB0aGlzLl9uZXh0Q2h1bmsgPSBmdW5jdGlvbiBuZXh0Q2h1bmsoKSB7fTtcblxuICB0aGlzLmdldFN0cmluZ0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycgPyBjaHVuayA6IHRoaXMudGV4dERlY29kZXIuZGVjb2RlKGNodW5rLCB7XG4gICAgICBzdHJlYW06IHRydWVcbiAgICB9KTtcbiAgfTtcbn1cblxuQXN5bmNJdGVyYXRvclN0cmVhbWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2h1bmtTdHJlYW1lci5wcm90b3R5cGUpO1xuQXN5bmNJdGVyYXRvclN0cmVhbWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFzeW5jSXRlcmF0b3JTdHJlYW1lcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzeW5jLWl0ZXJhdG9yLXN0cmVhbWVyLmpzLm1hcCIsIi8vIFRoaXMgaXMgYSBmb3JrIG9mIHBhcGFwYXJzZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21ob2x0L1BhcGFQYXJzZVxuLyogQGxpY2Vuc2VcblBhcGEgUGFyc2VcbnY1LjAuMC1iZXRhLjBcbmh0dHBzOi8vZ2l0aHViLmNvbS9taG9sdC9QYXBhUGFyc2VcbkxpY2Vuc2U6IE1JVFxuKi9cbi8vIEZPUksgU1VNTUFSWTpcbi8vIC0gQWRvcHQgRVM2IGV4cG9ydHNcbi8vIC0gSW1wbGVtZW50IG5ldyBBc3luY0l0ZXJhdG9yU3RyZWFtZXJcbi8vIC0gUmVtb3ZlIG5vbiBBc3luYyBJdGVyYXRvciBzdHJlYW1lcnMgKGNhbiBhbGwgYmUgaGFuZGxlZCBieSBuZXcgc3RyZWFtZXIpXG4vLyAtIFJlbW92ZSB1bnVzZWQgV29ya2VyIHN1cHBvcnQgKGxvYWRlcnMuZ2wgd29ya2VyIHN5c3RlbSB1c2VkIGluc3RlYWQpXG4vLyAtIFJlbW92ZSB1bnVzZWQgalF1ZXJ5IHBsdWdpbiBzdXBwb3J0XG5cbi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBAdHMtbm9jaGVja1xudmFyIGdsb2JhbCA9IChmdW5jdGlvbigpIHtcbiAgLy8gYWx0ZXJuYXRpdmUgbWV0aG9kLCBzaW1pbGFyIHRvIGBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpYFxuICAvLyBidXQgd2l0aG91dCB1c2luZyBgZXZhbGAgKHdoaWNoIGlzIGRpc2FibGVkIHdoZW5cbiAgLy8gdXNpbmcgQ29udGVudCBTZWN1cml0eSBQb2xpY3kpLlxuXG4gIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBnbG9iYWw7XG4gIH1cblxuICAvLyBXaGVuIHJ1bm5pbmcgdGVzdHMgbm9uZSBvZiB0aGUgYWJvdmUgaGF2ZSBiZWVuIGRlZmluZWRcbiAgcmV0dXJuIHt9O1xufSkoKTtcblxudmFyIElTX1BBUEFfV09SS0VSID0gZmFsc2U7XG5cbnZhciBQYXBhID0ge307XG5tb2R1bGUuZXhwb3J0cyA9IFBhcGE7XG5QYXBhLnBhcnNlID0gQ3N2VG9Kc29uO1xuUGFwYS51bnBhcnNlID0gSnNvblRvQ3N2O1xuXG5QYXBhLlJFQ09SRF9TRVAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDMwKTtcblBhcGEuVU5JVF9TRVAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDMxKTtcblBhcGEuQllURV9PUkRFUl9NQVJLID0gJ1xcdWZlZmYnO1xuUGFwYS5CQURfREVMSU1JVEVSUyA9IFsnXFxyJywgJ1xcbicsICdcIicsIFBhcGEuQllURV9PUkRFUl9NQVJLXTtcblBhcGEuV09SS0VSU19TVVBQT1JURUQgPSBmYWxzZTsgLy8gIUlTX1dPUktFUiAmJiAhIWdsb2JhbC5Xb3JrZXI7XG5QYXBhLk5PREVfU1RSRUFNX0lOUFVUID0gMTtcblxuLy8gQ29uZmlndXJhYmxlIGNodW5rIHNpemVzIGZvciBsb2NhbCBhbmQgcmVtb3RlIGZpbGVzLCByZXNwZWN0aXZlbHlcblBhcGEuTG9jYWxDaHVua1NpemUgPSAxMDI0ICogMTAyNCAqIDEwOyAvLyAxMCBNQlxuUGFwYS5SZW1vdGVDaHVua1NpemUgPSAxMDI0ICogMTAyNCAqIDU7IC8vIDUgTUJcblBhcGEuRGVmYXVsdERlbGltaXRlciA9ICcsJzsgLy8gVXNlZCBpZiBub3Qgc3BlY2lmaWVkIGFuZCBkZXRlY3Rpb24gZmFpbHNcblxuLy8gRXhwb3NlZCBmb3IgdGVzdGluZyBhbmQgZGV2ZWxvcG1lbnQgb25seVxuUGFwYS5QYXJzZXIgPSBQYXJzZXI7XG5QYXBhLlBhcnNlckhhbmRsZSA9IFBhcnNlckhhbmRsZTtcblxuLy8gQkVHSU4gRk9SS1xuUGFwYS5DaHVua1N0cmVhbWVyID0gQ2h1bmtTdHJlYW1lcjtcblBhcGEuU3RyaW5nU3RyZWFtZXIgPSBTdHJpbmdTdHJlYW1lcjtcbi8qXG5QYXBhLk5ldHdvcmtTdHJlYW1lciA9IE5ldHdvcmtTdHJlYW1lcjtcblBhcGEuRmlsZVN0cmVhbWVyID0gRmlsZVN0cmVhbWVyO1xuUGFwYS5SZWFkYWJsZVN0cmVhbVN0cmVhbWVyID0gUmVhZGFibGVTdHJlYW1TdHJlYW1lcjtcbmlmICh0eXBlb2YgUEFQQV9CUk9XU0VSX0NPTlRFWFQgPT09ICd1bmRlZmluZWQnKSB7XG4gIFBhcGEuRHVwbGV4U3RyZWFtU3RyZWFtZXIgPSBEdXBsZXhTdHJlYW1TdHJlYW1lcjtcbn1cbiovXG4vLyBFTkQgRk9SS1xuXG4vLyBCRUdJTiBGT1JLXG4vLyBBZGRzIGFuIGFyZ3VtZW50IHRvIHBhcGEucGFyc2Vcbi8vIGZ1bmN0aW9uIENzdlRvSnNvbihfaW5wdXQsIF9jb25maWcpXG5mdW5jdGlvbiBDc3ZUb0pzb24oXG4gIF9pbnB1dCxcbiAgX2NvbmZpZyxcbiAgVXNlckRlZmluZWRTdHJlYW1lciAvLyBCRUdJTiBGT1JLXG4pIHtcbiAgX2NvbmZpZyA9IF9jb25maWcgfHwge307XG4gIHZhciBkeW5hbWljVHlwaW5nID0gX2NvbmZpZy5keW5hbWljVHlwaW5nIHx8IGZhbHNlO1xuICBpZiAoaXNGdW5jdGlvbihkeW5hbWljVHlwaW5nKSkge1xuICAgIF9jb25maWcuZHluYW1pY1R5cGluZ0Z1bmN0aW9uID0gZHluYW1pY1R5cGluZztcbiAgICAvLyBXaWxsIGJlIGZpbGxlZCBvbiBmaXJzdCByb3cgY2FsbFxuICAgIGR5bmFtaWNUeXBpbmcgPSB7fTtcbiAgfVxuICBfY29uZmlnLmR5bmFtaWNUeXBpbmcgPSBkeW5hbWljVHlwaW5nO1xuXG4gIF9jb25maWcudHJhbnNmb3JtID0gaXNGdW5jdGlvbihfY29uZmlnLnRyYW5zZm9ybSkgPyBfY29uZmlnLnRyYW5zZm9ybSA6IGZhbHNlO1xuXG4gIGlmIChfY29uZmlnLndvcmtlciAmJiBQYXBhLldPUktFUlNfU1VQUE9SVEVEKSB7XG4gICAgdmFyIHcgPSBuZXdXb3JrZXIoKTtcblxuICAgIHcudXNlclN0ZXAgPSBfY29uZmlnLnN0ZXA7XG4gICAgdy51c2VyQ2h1bmsgPSBfY29uZmlnLmNodW5rO1xuICAgIHcudXNlckNvbXBsZXRlID0gX2NvbmZpZy5jb21wbGV0ZTtcbiAgICB3LnVzZXJFcnJvciA9IF9jb25maWcuZXJyb3I7XG5cbiAgICBfY29uZmlnLnN0ZXAgPSBpc0Z1bmN0aW9uKF9jb25maWcuc3RlcCk7XG4gICAgX2NvbmZpZy5jaHVuayA9IGlzRnVuY3Rpb24oX2NvbmZpZy5jaHVuayk7XG4gICAgX2NvbmZpZy5jb21wbGV0ZSA9IGlzRnVuY3Rpb24oX2NvbmZpZy5jb21wbGV0ZSk7XG4gICAgX2NvbmZpZy5lcnJvciA9IGlzRnVuY3Rpb24oX2NvbmZpZy5lcnJvcik7XG4gICAgZGVsZXRlIF9jb25maWcud29ya2VyOyAvLyBwcmV2ZW50IGluZmluaXRlIGxvb3BcblxuICAgIHcucG9zdE1lc3NhZ2Uoe1xuICAgICAgaW5wdXQ6IF9pbnB1dCxcbiAgICAgIGNvbmZpZzogX2NvbmZpZyxcbiAgICAgIHdvcmtlcklkOiB3LmlkXG4gICAgfSk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc3RyZWFtZXIgPSBudWxsO1xuICAvKlxuICBpZiAoX2lucHV0ID09PSBQYXBhLk5PREVfU1RSRUFNX0lOUFVUICYmIHR5cGVvZiBQQVBBX0JST1dTRVJfQ09OVEVYVCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBjcmVhdGUgYSBub2RlIER1cGxleCBzdHJlYW0gZm9yIHVzZVxuICAgIC8vIHdpdGggLnBpcGVcbiAgICBzdHJlYW1lciA9IG5ldyBEdXBsZXhTdHJlYW1TdHJlYW1lcihfY29uZmlnKTtcbiAgICByZXR1cm4gc3RyZWFtZXIuZ2V0U3RyZWFtKCk7XG4gIH0gZWxzZVxuICAqL1xuICBpZiAodHlwZW9mIF9pbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBpZiAoX2NvbmZpZy5kb3dubG9hZCkgc3RyZWFtZXIgPSBuZXcgTmV0d29ya1N0cmVhbWVyKF9jb25maWcpO1xuICAgIC8vIGVsc2VcbiAgICBzdHJlYW1lciA9IG5ldyBTdHJpbmdTdHJlYW1lcihfY29uZmlnKTtcbiAgfVxuICAvKlxuICBlbHNlIGlmIChfaW5wdXQucmVhZGFibGUgPT09IHRydWUgJiYgaXNGdW5jdGlvbihfaW5wdXQucmVhZCkgJiYgaXNGdW5jdGlvbihfaW5wdXQub24pKSB7XG4gICAgc3RyZWFtZXIgPSBuZXcgUmVhZGFibGVTdHJlYW1TdHJlYW1lcihfY29uZmlnKTtcbiAgfSBlbHNlIGlmICgoZ2xvYmFsLkZpbGUgJiYgX2lucHV0IGluc3RhbmNlb2YgRmlsZSkgfHwgX2lucHV0IGluc3RhbmNlb2YgT2JqZWN0KVxuICAgIC8vIC4uLlNhZmFyaS4gKHNlZSBpc3N1ZSAjMTA2KVxuICAgIHN0cmVhbWVyID0gbmV3IEZpbGVTdHJlYW1lcihfY29uZmlnKTtcbiAgKi9cblxuICAvLyBCRUdJTiBGT1JLXG4gIGlmICghc3RyZWFtZXIpIHtcbiAgICBzdHJlYW1lciA9IG5ldyBVc2VyRGVmaW5lZFN0cmVhbWVyKF9jb25maWcpO1xuICB9XG4gIC8vIEVORCBGT1JLXG5cbiAgcmV0dXJuIHN0cmVhbWVyLnN0cmVhbShfaW5wdXQpO1xufVxuXG5mdW5jdGlvbiBKc29uVG9Dc3YoX2lucHV0LCBfY29uZmlnKSB7XG4gIC8vIERlZmF1bHQgY29uZmlndXJhdGlvblxuXG4gIC8qKiB3aGV0aGVyIHRvIHN1cnJvdW5kIGV2ZXJ5IGRhdHVtIHdpdGggcXVvdGVzICovXG4gIHZhciBfcXVvdGVzID0gZmFsc2U7XG5cbiAgLyoqIHdoZXRoZXIgdG8gd3JpdGUgaGVhZGVycyAqL1xuICB2YXIgX3dyaXRlSGVhZGVyID0gdHJ1ZTtcblxuICAvKiogZGVsaW1pdGluZyBjaGFyYWN0ZXIocykgKi9cbiAgdmFyIF9kZWxpbWl0ZXIgPSAnLCc7XG5cbiAgLyoqIG5ld2xpbmUgY2hhcmFjdGVyKHMpICovXG4gIHZhciBfbmV3bGluZSA9ICdcXHJcXG4nO1xuXG4gIC8qKiBxdW90ZSBjaGFyYWN0ZXIgKi9cbiAgdmFyIF9xdW90ZUNoYXIgPSAnXCInO1xuXG4gIC8qKiBlc2NhcGVkIHF1b3RlIGNoYXJhY3RlciwgZWl0aGVyIFwiXCIgb3IgPGNvbmZpZy5lc2NhcGVDaGFyPlwiICovXG4gIHZhciBfZXNjYXBlZFF1b3RlID0gX3F1b3RlQ2hhciArIF9xdW90ZUNoYXI7XG5cbiAgLyoqIHdoZXRoZXIgdG8gc2tpcCBlbXB0eSBsaW5lcyAqL1xuICB2YXIgX3NraXBFbXB0eUxpbmVzID0gZmFsc2U7XG5cbiAgLyoqIHRoZSBjb2x1bW5zIChrZXlzKSB3ZSBleHBlY3Qgd2hlbiB3ZSB1bnBhcnNlIG9iamVjdHMgKi9cbiAgdmFyIF9jb2x1bW5zID0gbnVsbDtcblxuICB1bnBhY2tDb25maWcoKTtcblxuICB2YXIgcXVvdGVDaGFyUmVnZXggPSBuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4cChfcXVvdGVDaGFyKSwgJ2cnKTtcblxuICBpZiAodHlwZW9mIF9pbnB1dCA9PT0gJ3N0cmluZycpIF9pbnB1dCA9IEpTT04ucGFyc2UoX2lucHV0KTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShfaW5wdXQpKSB7XG4gICAgaWYgKCFfaW5wdXQubGVuZ3RoIHx8IEFycmF5LmlzQXJyYXkoX2lucHV0WzBdKSkgcmV0dXJuIHNlcmlhbGl6ZShudWxsLCBfaW5wdXQsIF9za2lwRW1wdHlMaW5lcyk7XG4gICAgZWxzZSBpZiAodHlwZW9mIF9pbnB1dFswXSA9PT0gJ29iamVjdCcpXG4gICAgICByZXR1cm4gc2VyaWFsaXplKF9jb2x1bW5zIHx8IG9iamVjdEtleXMoX2lucHV0WzBdKSwgX2lucHV0LCBfc2tpcEVtcHR5TGluZXMpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBfaW5wdXQgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHR5cGVvZiBfaW5wdXQuZGF0YSA9PT0gJ3N0cmluZycpIF9pbnB1dC5kYXRhID0gSlNPTi5wYXJzZShfaW5wdXQuZGF0YSk7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShfaW5wdXQuZGF0YSkpIHtcbiAgICAgIGlmICghX2lucHV0LmZpZWxkcykgX2lucHV0LmZpZWxkcyA9IF9pbnB1dC5tZXRhICYmIF9pbnB1dC5tZXRhLmZpZWxkcztcblxuICAgICAgaWYgKCFfaW5wdXQuZmllbGRzKVxuICAgICAgICBfaW5wdXQuZmllbGRzID0gQXJyYXkuaXNBcnJheShfaW5wdXQuZGF0YVswXSkgPyBfaW5wdXQuZmllbGRzIDogb2JqZWN0S2V5cyhfaW5wdXQuZGF0YVswXSk7XG5cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShfaW5wdXQuZGF0YVswXSkgJiYgdHlwZW9mIF9pbnB1dC5kYXRhWzBdICE9PSAnb2JqZWN0JylcbiAgICAgICAgX2lucHV0LmRhdGEgPSBbX2lucHV0LmRhdGFdOyAvLyBoYW5kbGVzIGlucHV0IGxpa2UgWzEsMiwzXSBvciBbJ2FzZGYnXVxuICAgIH1cblxuICAgIHJldHVybiBzZXJpYWxpemUoX2lucHV0LmZpZWxkcyB8fCBbXSwgX2lucHV0LmRhdGEgfHwgW10sIF9za2lwRW1wdHlMaW5lcyk7XG4gIH1cblxuICAvLyBEZWZhdWx0IChhbnkgdmFsaWQgcGF0aHMgc2hvdWxkIHJldHVybiBiZWZvcmUgdGhpcylcbiAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gc2VyaWFsaXplIHVucmVjb2duaXplZCBpbnB1dCcpO1xuXG4gIGZ1bmN0aW9uIHVucGFja0NvbmZpZygpIHtcbiAgICBpZiAodHlwZW9mIF9jb25maWcgIT09ICdvYmplY3QnKSByZXR1cm47XG5cbiAgICBpZiAoXG4gICAgICB0eXBlb2YgX2NvbmZpZy5kZWxpbWl0ZXIgPT09ICdzdHJpbmcnICYmXG4gICAgICAhUGFwYS5CQURfREVMSU1JVEVSUy5maWx0ZXIoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIF9jb25maWcuZGVsaW1pdGVyLmluZGV4T2YodmFsdWUpICE9PSAtMTtcbiAgICAgIH0pLmxlbmd0aFxuICAgICkge1xuICAgICAgX2RlbGltaXRlciA9IF9jb25maWcuZGVsaW1pdGVyO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgX2NvbmZpZy5xdW90ZXMgPT09ICdib29sZWFuJyB8fCBBcnJheS5pc0FycmF5KF9jb25maWcucXVvdGVzKSlcbiAgICAgIF9xdW90ZXMgPSBfY29uZmlnLnF1b3RlcztcblxuICAgIGlmICh0eXBlb2YgX2NvbmZpZy5za2lwRW1wdHlMaW5lcyA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiBfY29uZmlnLnNraXBFbXB0eUxpbmVzID09PSAnc3RyaW5nJylcbiAgICAgIF9za2lwRW1wdHlMaW5lcyA9IF9jb25maWcuc2tpcEVtcHR5TGluZXM7XG5cbiAgICBpZiAodHlwZW9mIF9jb25maWcubmV3bGluZSA9PT0gJ3N0cmluZycpIF9uZXdsaW5lID0gX2NvbmZpZy5uZXdsaW5lO1xuXG4gICAgaWYgKHR5cGVvZiBfY29uZmlnLnF1b3RlQ2hhciA9PT0gJ3N0cmluZycpIF9xdW90ZUNoYXIgPSBfY29uZmlnLnF1b3RlQ2hhcjtcblxuICAgIGlmICh0eXBlb2YgX2NvbmZpZy5oZWFkZXIgPT09ICdib29sZWFuJykgX3dyaXRlSGVhZGVyID0gX2NvbmZpZy5oZWFkZXI7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShfY29uZmlnLmNvbHVtbnMpKSB7XG4gICAgICBpZiAoX2NvbmZpZy5jb2x1bW5zLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdPcHRpb24gY29sdW1ucyBpcyBlbXB0eScpO1xuXG4gICAgICBfY29sdW1ucyA9IF9jb25maWcuY29sdW1ucztcbiAgICB9XG5cbiAgICBpZiAoX2NvbmZpZy5lc2NhcGVDaGFyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIF9lc2NhcGVkUXVvdGUgPSBfY29uZmlnLmVzY2FwZUNoYXIgKyBfcXVvdGVDaGFyO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBUdXJucyBhbiBvYmplY3QncyBrZXlzIGludG8gYW4gYXJyYXkgKi9cbiAgZnVuY3Rpb24gb2JqZWN0S2V5cyhvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHJldHVybiBbXTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICAgIHJldHVybiBrZXlzO1xuICB9XG5cbiAgLyoqIFRoZSBkb3VibGUgZm9yIGxvb3AgdGhhdCBpdGVyYXRlcyB0aGUgZGF0YSBhbmQgd3JpdGVzIG91dCBhIENTViBzdHJpbmcgaW5jbHVkaW5nIGhlYWRlciByb3cgKi9cbiAgZnVuY3Rpb24gc2VyaWFsaXplKGZpZWxkcywgZGF0YSwgc2tpcEVtcHR5TGluZXMpIHtcbiAgICB2YXIgY3N2ID0gJyc7XG5cbiAgICBpZiAodHlwZW9mIGZpZWxkcyA9PT0gJ3N0cmluZycpIGZpZWxkcyA9IEpTT04ucGFyc2UoZmllbGRzKTtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcblxuICAgIHZhciBoYXNIZWFkZXIgPSBBcnJheS5pc0FycmF5KGZpZWxkcykgJiYgZmllbGRzLmxlbmd0aCA+IDA7XG4gICAgdmFyIGRhdGFLZXllZEJ5RmllbGQgPSAhQXJyYXkuaXNBcnJheShkYXRhWzBdKTtcblxuICAgIC8vIElmIHRoZXJlIGEgaGVhZGVyIHJvdywgd3JpdGUgaXQgZmlyc3RcbiAgICBpZiAoaGFzSGVhZGVyICYmIF93cml0ZUhlYWRlcikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgPiAwKSBjc3YgKz0gX2RlbGltaXRlcjtcbiAgICAgICAgY3N2ICs9IHNhZmUoZmllbGRzW2ldLCBpKTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLmxlbmd0aCA+IDApIGNzdiArPSBfbmV3bGluZTtcbiAgICB9XG5cbiAgICAvLyBUaGVuIHdyaXRlIG91dCB0aGUgZGF0YVxuICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IGRhdGEubGVuZ3RoOyByb3crKykge1xuICAgICAgdmFyIG1heENvbCA9IGhhc0hlYWRlciA/IGZpZWxkcy5sZW5ndGggOiBkYXRhW3Jvd10ubGVuZ3RoO1xuXG4gICAgICB2YXIgZW1wdHlMaW5lID0gZmFsc2U7XG4gICAgICB2YXIgbnVsbExpbmUgPSBoYXNIZWFkZXIgPyBPYmplY3Qua2V5cyhkYXRhW3Jvd10pLmxlbmd0aCA9PT0gMCA6IGRhdGFbcm93XS5sZW5ndGggPT09IDA7XG4gICAgICBpZiAoc2tpcEVtcHR5TGluZXMgJiYgIWhhc0hlYWRlcikge1xuICAgICAgICBlbXB0eUxpbmUgPVxuICAgICAgICAgIHNraXBFbXB0eUxpbmVzID09PSAnZ3JlZWR5J1xuICAgICAgICAgICAgPyBkYXRhW3Jvd10uam9pbignJykudHJpbSgpID09PSAnJ1xuICAgICAgICAgICAgOiBkYXRhW3Jvd10ubGVuZ3RoID09PSAxICYmIGRhdGFbcm93XVswXS5sZW5ndGggPT09IDA7XG4gICAgICB9XG4gICAgICBpZiAoc2tpcEVtcHR5TGluZXMgPT09ICdncmVlZHknICYmIGhhc0hlYWRlcikge1xuICAgICAgICB2YXIgbGluZSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IG1heENvbDsgYysrKSB7XG4gICAgICAgICAgdmFyIGN4ID0gZGF0YUtleWVkQnlGaWVsZCA/IGZpZWxkc1tjXSA6IGM7XG4gICAgICAgICAgbGluZS5wdXNoKGRhdGFbcm93XVtjeF0pO1xuICAgICAgICB9XG4gICAgICAgIGVtcHR5TGluZSA9IGxpbmUuam9pbignJykudHJpbSgpID09PSAnJztcbiAgICAgIH1cbiAgICAgIGlmICghZW1wdHlMaW5lKSB7XG4gICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IG1heENvbDsgY29sKyspIHtcbiAgICAgICAgICBpZiAoY29sID4gMCAmJiAhbnVsbExpbmUpIGNzdiArPSBfZGVsaW1pdGVyO1xuICAgICAgICAgIHZhciBjb2xJZHggPSBoYXNIZWFkZXIgJiYgZGF0YUtleWVkQnlGaWVsZCA/IGZpZWxkc1tjb2xdIDogY29sO1xuICAgICAgICAgIGNzdiArPSBzYWZlKGRhdGFbcm93XVtjb2xJZHhdLCBjb2wpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3cgPCBkYXRhLmxlbmd0aCAtIDEgJiYgKCFza2lwRW1wdHlMaW5lcyB8fCAobWF4Q29sID4gMCAmJiAhbnVsbExpbmUpKSkge1xuICAgICAgICAgIGNzdiArPSBfbmV3bGluZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3N2O1xuICB9XG5cbiAgLyoqIEVuY2xvc2VzIGEgdmFsdWUgYXJvdW5kIHF1b3RlcyBpZiBuZWVkZWQgKG1ha2VzIGEgdmFsdWUgc2FmZSBmb3IgQ1NWIGluc2VydGlvbikgKi9cbiAgZnVuY3Rpb24gc2FmZShzdHIsIGNvbCkge1xuICAgIGlmICh0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJyB8fCBzdHIgPT09IG51bGwpIHJldHVybiAnJztcblxuICAgIGlmIChzdHIuY29uc3RydWN0b3IgPT09IERhdGUpIHJldHVybiBKU09OLnN0cmluZ2lmeShzdHIpLnNsaWNlKDEsIDI1KTtcblxuICAgIHN0ciA9IHN0ci50b1N0cmluZygpLnJlcGxhY2UocXVvdGVDaGFyUmVnZXgsIF9lc2NhcGVkUXVvdGUpO1xuXG4gICAgdmFyIG5lZWRzUXVvdGVzID1cbiAgICAgICh0eXBlb2YgX3F1b3RlcyA9PT0gJ2Jvb2xlYW4nICYmIF9xdW90ZXMpIHx8XG4gICAgICAoQXJyYXkuaXNBcnJheShfcXVvdGVzKSAmJiBfcXVvdGVzW2NvbF0pIHx8XG4gICAgICBoYXNBbnkoc3RyLCBQYXBhLkJBRF9ERUxJTUlURVJTKSB8fFxuICAgICAgc3RyLmluZGV4T2YoX2RlbGltaXRlcikgPiAtMSB8fFxuICAgICAgc3RyLmNoYXJBdCgwKSA9PT0gJyAnIHx8XG4gICAgICBzdHIuY2hhckF0KHN0ci5sZW5ndGggLSAxKSA9PT0gJyAnO1xuXG4gICAgcmV0dXJuIG5lZWRzUXVvdGVzID8gX3F1b3RlQ2hhciArIHN0ciArIF9xdW90ZUNoYXIgOiBzdHI7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNBbnkoc3RyLCBzdWJzdHJpbmdzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzdHJpbmdzLmxlbmd0aDsgaSsrKSBpZiAoc3RyLmluZGV4T2Yoc3Vic3RyaW5nc1tpXSkgPiAtMSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKiBDaHVua1N0cmVhbWVyIGlzIHRoZSBiYXNlIHByb3RvdHlwZSBmb3IgdmFyaW91cyBzdHJlYW1lciBpbXBsZW1lbnRhdGlvbnMuICovXG5mdW5jdGlvbiBDaHVua1N0cmVhbWVyKGNvbmZpZykge1xuICB0aGlzLl9oYW5kbGUgPSBudWxsO1xuICB0aGlzLl9maW5pc2hlZCA9IGZhbHNlO1xuICB0aGlzLl9jb21wbGV0ZWQgPSBmYWxzZTtcbiAgdGhpcy5faW5wdXQgPSBudWxsO1xuICB0aGlzLl9iYXNlSW5kZXggPSAwO1xuICB0aGlzLl9wYXJ0aWFsTGluZSA9ICcnO1xuICB0aGlzLl9yb3dDb3VudCA9IDA7XG4gIHRoaXMuX3N0YXJ0ID0gMDtcbiAgdGhpcy5fbmV4dENodW5rID0gbnVsbDtcbiAgdGhpcy5pc0ZpcnN0Q2h1bmsgPSB0cnVlO1xuICB0aGlzLl9jb21wbGV0ZVJlc3VsdHMgPSB7XG4gICAgZGF0YTogW10sXG4gICAgZXJyb3JzOiBbXSxcbiAgICBtZXRhOiB7fVxuICB9O1xuICByZXBsYWNlQ29uZmlnLmNhbGwodGhpcywgY29uZmlnKTtcblxuICB0aGlzLnBhcnNlQ2h1bmsgPSBmdW5jdGlvbihjaHVuaywgaXNGYWtlQ2h1bmspIHtcbiAgICAvLyBGaXJzdCBjaHVuayBwcmUtcHJvY2Vzc2luZ1xuICAgIGlmICh0aGlzLmlzRmlyc3RDaHVuayAmJiBpc0Z1bmN0aW9uKHRoaXMuX2NvbmZpZy5iZWZvcmVGaXJzdENodW5rKSkge1xuICAgICAgdmFyIG1vZGlmaWVkQ2h1bmsgPSB0aGlzLl9jb25maWcuYmVmb3JlRmlyc3RDaHVuayhjaHVuayk7XG4gICAgICBpZiAobW9kaWZpZWRDaHVuayAhPT0gdW5kZWZpbmVkKSBjaHVuayA9IG1vZGlmaWVkQ2h1bms7XG4gICAgfVxuICAgIHRoaXMuaXNGaXJzdENodW5rID0gZmFsc2U7XG5cbiAgICAvLyBSZWpvaW4gdGhlIGxpbmUgd2UgbGlrZWx5IGp1c3Qgc3BsaXQgaW4gdHdvIGJ5IGNodW5raW5nIHRoZSBmaWxlXG4gICAgdmFyIGFnZ3JlZ2F0ZSA9IHRoaXMuX3BhcnRpYWxMaW5lICsgY2h1bms7XG4gICAgdGhpcy5fcGFydGlhbExpbmUgPSAnJztcblxuICAgIHZhciByZXN1bHRzID0gdGhpcy5faGFuZGxlLnBhcnNlKGFnZ3JlZ2F0ZSwgdGhpcy5fYmFzZUluZGV4LCAhdGhpcy5fZmluaXNoZWQpO1xuXG4gICAgaWYgKHRoaXMuX2hhbmRsZS5wYXVzZWQoKSB8fCB0aGlzLl9oYW5kbGUuYWJvcnRlZCgpKSByZXR1cm47XG5cbiAgICB2YXIgbGFzdEluZGV4ID0gcmVzdWx0cy5tZXRhLmN1cnNvcjtcblxuICAgIGlmICghdGhpcy5fZmluaXNoZWQpIHtcbiAgICAgIHRoaXMuX3BhcnRpYWxMaW5lID0gYWdncmVnYXRlLnN1YnN0cmluZyhsYXN0SW5kZXggLSB0aGlzLl9iYXNlSW5kZXgpO1xuICAgICAgdGhpcy5fYmFzZUluZGV4ID0gbGFzdEluZGV4O1xuICAgIH1cblxuICAgIGlmIChyZXN1bHRzICYmIHJlc3VsdHMuZGF0YSkgdGhpcy5fcm93Q291bnQgKz0gcmVzdWx0cy5kYXRhLmxlbmd0aDtcblxuICAgIHZhciBmaW5pc2hlZEluY2x1ZGluZ1ByZXZpZXcgPVxuICAgICAgdGhpcy5fZmluaXNoZWQgfHwgKHRoaXMuX2NvbmZpZy5wcmV2aWV3ICYmIHRoaXMuX3Jvd0NvdW50ID49IHRoaXMuX2NvbmZpZy5wcmV2aWV3KTtcblxuICAgIGlmIChJU19QQVBBX1dPUktFUikge1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgcmVzdWx0czogcmVzdWx0cyxcbiAgICAgICAgd29ya2VySWQ6IFBhcGEuV09SS0VSX0lELFxuICAgICAgICBmaW5pc2hlZDogZmluaXNoZWRJbmNsdWRpbmdQcmV2aWV3XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fY29uZmlnLmNodW5rKSAmJiAhaXNGYWtlQ2h1bmspIHtcbiAgICAgIHRoaXMuX2NvbmZpZy5jaHVuayhyZXN1bHRzLCB0aGlzLl9oYW5kbGUpO1xuICAgICAgaWYgKHRoaXMuX2hhbmRsZS5wYXVzZWQoKSB8fCB0aGlzLl9oYW5kbGUuYWJvcnRlZCgpKSByZXR1cm47XG4gICAgICByZXN1bHRzID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fY29tcGxldGVSZXN1bHRzID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fY29uZmlnLnN0ZXAgJiYgIXRoaXMuX2NvbmZpZy5jaHVuaykge1xuICAgICAgdGhpcy5fY29tcGxldGVSZXN1bHRzLmRhdGEgPSB0aGlzLl9jb21wbGV0ZVJlc3VsdHMuZGF0YS5jb25jYXQocmVzdWx0cy5kYXRhKTtcbiAgICAgIHRoaXMuX2NvbXBsZXRlUmVzdWx0cy5lcnJvcnMgPSB0aGlzLl9jb21wbGV0ZVJlc3VsdHMuZXJyb3JzLmNvbmNhdChyZXN1bHRzLmVycm9ycyk7XG4gICAgICB0aGlzLl9jb21wbGV0ZVJlc3VsdHMubWV0YSA9IHJlc3VsdHMubWV0YTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAhdGhpcy5fY29tcGxldGVkICYmXG4gICAgICBmaW5pc2hlZEluY2x1ZGluZ1ByZXZpZXcgJiZcbiAgICAgIGlzRnVuY3Rpb24odGhpcy5fY29uZmlnLmNvbXBsZXRlKSAmJlxuICAgICAgKCFyZXN1bHRzIHx8ICFyZXN1bHRzLm1ldGEuYWJvcnRlZClcbiAgICApIHtcbiAgICAgIHRoaXMuX2NvbmZpZy5jb21wbGV0ZSh0aGlzLl9jb21wbGV0ZVJlc3VsdHMsIHRoaXMuX2lucHV0KTtcbiAgICAgIHRoaXMuX2NvbXBsZXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFmaW5pc2hlZEluY2x1ZGluZ1ByZXZpZXcgJiYgKCFyZXN1bHRzIHx8ICFyZXN1bHRzLm1ldGEucGF1c2VkKSkgdGhpcy5fbmV4dENodW5rKCk7XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICB0aGlzLl9zZW5kRXJyb3IgPSBmdW5jdGlvbihlcnJvcikge1xuICAgIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2NvbmZpZy5lcnJvcikpIHRoaXMuX2NvbmZpZy5lcnJvcihlcnJvcik7XG4gICAgZWxzZSBpZiAoSVNfUEFQQV9XT1JLRVIgJiYgdGhpcy5fY29uZmlnLmVycm9yKSB7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2Uoe1xuICAgICAgICB3b3JrZXJJZDogUGFwYS5XT1JLRVJfSUQsXG4gICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgZmluaXNoZWQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVwbGFjZUNvbmZpZyhjb25maWcpIHtcbiAgICAvLyBEZWVwLWNvcHkgdGhlIGNvbmZpZyBzbyB3ZSBjYW4gZWRpdCBpdFxuICAgIHZhciBjb25maWdDb3B5ID0gY29weShjb25maWcpO1xuICAgIGNvbmZpZ0NvcHkuY2h1bmtTaXplID0gcGFyc2VJbnQoY29uZmlnQ29weS5jaHVua1NpemUpOyAvLyBwYXJzZUludCBWRVJZIGltcG9ydGFudCBzbyB3ZSBkb24ndCBjb25jYXRlbmF0ZSBzdHJpbmdzIVxuICAgIGlmICghY29uZmlnLnN0ZXAgJiYgIWNvbmZpZy5jaHVuaykgY29uZmlnQ29weS5jaHVua1NpemUgPSBudWxsOyAvLyBkaXNhYmxlIFJhbmdlIGhlYWRlciBpZiBub3Qgc3RyZWFtaW5nOyBiYWQgdmFsdWVzIGJyZWFrIElJUyAtIHNlZSBpc3N1ZSAjMTk2XG4gICAgdGhpcy5faGFuZGxlID0gbmV3IFBhcnNlckhhbmRsZShjb25maWdDb3B5KTtcbiAgICB0aGlzLl9oYW5kbGUuc3RyZWFtZXIgPSB0aGlzO1xuICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZ0NvcHk7IC8vIHBlcnNpc3QgdGhlIGNvcHkgdG8gdGhlIGNhbGxlclxuICB9XG59XG5mdW5jdGlvbiBTdHJpbmdTdHJlYW1lcihjb25maWcpIHtcbiAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICBDaHVua1N0cmVhbWVyLmNhbGwodGhpcywgY29uZmlnKTtcblxuICB2YXIgcmVtYWluaW5nO1xuICB0aGlzLnN0cmVhbSA9IGZ1bmN0aW9uKHMpIHtcbiAgICByZW1haW5pbmcgPSBzO1xuICAgIHJldHVybiB0aGlzLl9uZXh0Q2h1bmsoKTtcbiAgfTtcbiAgdGhpcy5fbmV4dENodW5rID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2ZpbmlzaGVkKSByZXR1cm47XG4gICAgdmFyIHNpemUgPSB0aGlzLl9jb25maWcuY2h1bmtTaXplO1xuICAgIHZhciBjaHVuayA9IHNpemUgPyByZW1haW5pbmcuc3Vic3RyKDAsIHNpemUpIDogcmVtYWluaW5nO1xuICAgIHJlbWFpbmluZyA9IHNpemUgPyByZW1haW5pbmcuc3Vic3RyKHNpemUpIDogJyc7XG4gICAgdGhpcy5fZmluaXNoZWQgPSAhcmVtYWluaW5nO1xuICAgIHJldHVybiB0aGlzLnBhcnNlQ2h1bmsoY2h1bmspO1xuICB9O1xufVxuU3RyaW5nU3RyZWFtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdHJpbmdTdHJlYW1lci5wcm90b3R5cGUpO1xuU3RyaW5nU3RyZWFtZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3RyaW5nU3RyZWFtZXI7XG5cbi8vIFVzZSBvbmUgUGFyc2VySGFuZGxlIHBlciBlbnRpcmUgQ1NWIGZpbGUgb3Igc3RyaW5nXG5mdW5jdGlvbiBQYXJzZXJIYW5kbGUoX2NvbmZpZykge1xuICAvLyBPbmUgZ29hbCBpcyB0byBtaW5pbWl6ZSB0aGUgdXNlIG9mIHJlZ3VsYXIgZXhwcmVzc2lvbnMuLi5cbiAgdmFyIEZMT0FUID0gL15cXHMqLT8oXFxkKlxcLj9cXGQrfFxcZCtcXC4/XFxkKikoZVstK10/XFxkKyk/XFxzKiQvaTtcbiAgdmFyIElTT19EQVRFID0gLyhcXGR7NH0tWzAxXVxcZC1bMC0zXVxcZFRbMC0yXVxcZDpbMC01XVxcZDpbMC01XVxcZFxcLlxcZCsoWystXVswLTJdXFxkOlswLTVdXFxkfFopKXwoXFxkezR9LVswMV1cXGQtWzAtM11cXGRUWzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGQoWystXVswLTJdXFxkOlswLTVdXFxkfFopKXwoXFxkezR9LVswMV1cXGQtWzAtM11cXGRUWzAtMl1cXGQ6WzAtNV1cXGQoWystXVswLTJdXFxkOlswLTVdXFxkfFopKS87XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgX3N0ZXBDb3VudGVyID0gMDsgLy8gTnVtYmVyIG9mIHRpbWVzIHN0ZXAgd2FzIGNhbGxlZCAobnVtYmVyIG9mIHJvd3MgcGFyc2VkKVxuICB2YXIgX3Jvd0NvdW50ZXIgPSAwOyAvLyBOdW1iZXIgb2Ygcm93cyB0aGF0IGhhdmUgYmVlbiBwYXJzZWQgc28gZmFyXG4gIHZhciBfaW5wdXQ7IC8vIFRoZSBpbnB1dCBiZWluZyBwYXJzZWRcbiAgdmFyIF9wYXJzZXI7IC8vIFRoZSBjb3JlIHBhcnNlciBiZWluZyB1c2VkXG4gIHZhciBfcGF1c2VkID0gZmFsc2U7IC8vIFdoZXRoZXIgd2UgYXJlIHBhdXNlZCBvciBub3RcbiAgdmFyIF9hYm9ydGVkID0gZmFsc2U7IC8vIFdoZXRoZXIgdGhlIHBhcnNlciBoYXMgYWJvcnRlZCBvciBub3RcbiAgdmFyIF9kZWxpbWl0ZXJFcnJvcjsgLy8gVGVtcG9yYXJ5IHN0YXRlIGJldHdlZW4gZGVsaW1pdGVyIGRldGVjdGlvbiBhbmQgcHJvY2Vzc2luZyByZXN1bHRzXG4gIHZhciBfZmllbGRzID0gW107IC8vIEZpZWxkcyBhcmUgZnJvbSB0aGUgaGVhZGVyIHJvdyBvZiB0aGUgaW5wdXQsIGlmIHRoZXJlIGlzIG9uZVxuICB2YXIgX3Jlc3VsdHMgPSB7XG4gICAgLy8gVGhlIGxhc3QgcmVzdWx0cyByZXR1cm5lZCBmcm9tIHRoZSBwYXJzZXJcbiAgICBkYXRhOiBbXSxcbiAgICBlcnJvcnM6IFtdLFxuICAgIG1ldGE6IHt9XG4gIH07XG5cbiAgaWYgKGlzRnVuY3Rpb24oX2NvbmZpZy5zdGVwKSkge1xuICAgIHZhciB1c2VyU3RlcCA9IF9jb25maWcuc3RlcDtcbiAgICBfY29uZmlnLnN0ZXAgPSBmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgICBfcmVzdWx0cyA9IHJlc3VsdHM7XG5cbiAgICAgIGlmIChuZWVkc0hlYWRlclJvdygpKSBwcm9jZXNzUmVzdWx0cygpO1xuICAgICAgLy8gb25seSBjYWxsIHVzZXIncyBzdGVwIGZ1bmN0aW9uIGFmdGVyIGhlYWRlciByb3dcbiAgICAgIGVsc2Uge1xuICAgICAgICBwcm9jZXNzUmVzdWx0cygpO1xuXG4gICAgICAgIC8vIEl0J3MgcG9zc2JpbGUgdGhhdCB0aGlzIGxpbmUgd2FzIGVtcHR5IGFuZCB0aGVyZSdzIG5vIHJvdyBoZXJlIGFmdGVyIGFsbFxuICAgICAgICBpZiAoIV9yZXN1bHRzLmRhdGEgfHwgX3Jlc3VsdHMuZGF0YS5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgICAgICBfc3RlcENvdW50ZXIgKz0gcmVzdWx0cy5kYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKF9jb25maWcucHJldmlldyAmJiBfc3RlcENvdW50ZXIgPiBfY29uZmlnLnByZXZpZXcpIF9wYXJzZXIuYWJvcnQoKTtcbiAgICAgICAgZWxzZSB1c2VyU3RlcChfcmVzdWx0cywgc2VsZik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgaW5wdXQuIE1vc3QgdXNlcnMgd29uJ3QgbmVlZCwgYW5kIHNob3VsZG4ndCBtZXNzIHdpdGgsIHRoZSBiYXNlSW5kZXhcbiAgICogYW5kIGlnbm9yZUxhc3RSb3cgcGFyYW1ldGVycy4gVGhleSBhcmUgdXNlZCBieSBzdHJlYW1lcnMgKHdyYXBwZXIgZnVuY3Rpb25zKVxuICAgKiB3aGVuIGFuIGlucHV0IGNvbWVzIGluIG11bHRpcGxlIGNodW5rcywgbGlrZSBmcm9tIGEgZmlsZS5cbiAgICovXG4gIHRoaXMucGFyc2UgPSBmdW5jdGlvbihpbnB1dCwgYmFzZUluZGV4LCBpZ25vcmVMYXN0Um93KSB7XG4gICAgdmFyIHF1b3RlQ2hhciA9IF9jb25maWcucXVvdGVDaGFyIHx8ICdcIic7XG4gICAgaWYgKCFfY29uZmlnLm5ld2xpbmUpIF9jb25maWcubmV3bGluZSA9IGd1ZXNzTGluZUVuZGluZ3MoaW5wdXQsIHF1b3RlQ2hhcik7XG5cbiAgICBfZGVsaW1pdGVyRXJyb3IgPSBmYWxzZTtcbiAgICBpZiAoIV9jb25maWcuZGVsaW1pdGVyKSB7XG4gICAgICB2YXIgZGVsaW1HdWVzcyA9IGd1ZXNzRGVsaW1pdGVyKFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgX2NvbmZpZy5uZXdsaW5lLFxuICAgICAgICBfY29uZmlnLnNraXBFbXB0eUxpbmVzLFxuICAgICAgICBfY29uZmlnLmNvbW1lbnRzLFxuICAgICAgICBfY29uZmlnLmRlbGltaXRlcnNUb0d1ZXNzXG4gICAgICApO1xuICAgICAgaWYgKGRlbGltR3Vlc3Muc3VjY2Vzc2Z1bCkgX2NvbmZpZy5kZWxpbWl0ZXIgPSBkZWxpbUd1ZXNzLmJlc3REZWxpbWl0ZXI7XG4gICAgICBlbHNlIHtcbiAgICAgICAgX2RlbGltaXRlckVycm9yID0gdHJ1ZTsgLy8gYWRkIGVycm9yIGFmdGVyIHBhcnNpbmcgKG90aGVyd2lzZSBpdCB3b3VsZCBiZSBvdmVyd3JpdHRlbilcbiAgICAgICAgX2NvbmZpZy5kZWxpbWl0ZXIgPSBQYXBhLkRlZmF1bHREZWxpbWl0ZXI7XG4gICAgICB9XG4gICAgICBfcmVzdWx0cy5tZXRhLmRlbGltaXRlciA9IF9jb25maWcuZGVsaW1pdGVyO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihfY29uZmlnLmRlbGltaXRlcikpIHtcbiAgICAgIF9jb25maWcuZGVsaW1pdGVyID0gX2NvbmZpZy5kZWxpbWl0ZXIoaW5wdXQpO1xuICAgICAgX3Jlc3VsdHMubWV0YS5kZWxpbWl0ZXIgPSBfY29uZmlnLmRlbGltaXRlcjtcbiAgICB9XG5cbiAgICB2YXIgcGFyc2VyQ29uZmlnID0gY29weShfY29uZmlnKTtcbiAgICBpZiAoX2NvbmZpZy5wcmV2aWV3ICYmIF9jb25maWcuaGVhZGVyKSBwYXJzZXJDb25maWcucHJldmlldysrOyAvLyB0byBjb21wZW5zYXRlIGZvciBoZWFkZXIgcm93XG5cbiAgICBfaW5wdXQgPSBpbnB1dDtcbiAgICBfcGFyc2VyID0gbmV3IFBhcnNlcihwYXJzZXJDb25maWcpO1xuICAgIF9yZXN1bHRzID0gX3BhcnNlci5wYXJzZShfaW5wdXQsIGJhc2VJbmRleCwgaWdub3JlTGFzdFJvdyk7XG4gICAgcHJvY2Vzc1Jlc3VsdHMoKTtcbiAgICByZXR1cm4gX3BhdXNlZCA/IHttZXRhOiB7cGF1c2VkOiB0cnVlfX0gOiBfcmVzdWx0cyB8fCB7bWV0YToge3BhdXNlZDogZmFsc2V9fTtcbiAgfTtcblxuICB0aGlzLnBhdXNlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfcGF1c2VkO1xuICB9O1xuXG4gIHRoaXMucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICBfcGF1c2VkID0gdHJ1ZTtcbiAgICBfcGFyc2VyLmFib3J0KCk7XG4gICAgX2lucHV0ID0gX2lucHV0LnN1YnN0cihfcGFyc2VyLmdldENoYXJJbmRleCgpKTtcbiAgfTtcblxuICB0aGlzLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICAgIF9wYXVzZWQgPSBmYWxzZTtcbiAgICBzZWxmLnN0cmVhbWVyLnBhcnNlQ2h1bmsoX2lucHV0LCB0cnVlKTtcbiAgfTtcblxuICB0aGlzLmFib3J0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gX2Fib3J0ZWQ7XG4gIH07XG5cbiAgdGhpcy5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgIF9hYm9ydGVkID0gdHJ1ZTtcbiAgICBfcGFyc2VyLmFib3J0KCk7XG4gICAgX3Jlc3VsdHMubWV0YS5hYm9ydGVkID0gdHJ1ZTtcbiAgICBpZiAoaXNGdW5jdGlvbihfY29uZmlnLmNvbXBsZXRlKSkgX2NvbmZpZy5jb21wbGV0ZShfcmVzdWx0cyk7XG4gICAgX2lucHV0ID0gJyc7XG4gIH07XG5cbiAgZnVuY3Rpb24gdGVzdEVtcHR5TGluZShzKSB7XG4gICAgcmV0dXJuIF9jb25maWcuc2tpcEVtcHR5TGluZXMgPT09ICdncmVlZHknXG4gICAgICA/IHMuam9pbignJykudHJpbSgpID09PSAnJ1xuICAgICAgOiBzLmxlbmd0aCA9PT0gMSAmJiBzWzBdLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NSZXN1bHRzKCkge1xuICAgIGlmIChfcmVzdWx0cyAmJiBfZGVsaW1pdGVyRXJyb3IpIHtcbiAgICAgIGFkZEVycm9yKFxuICAgICAgICAnRGVsaW1pdGVyJyxcbiAgICAgICAgJ1VuZGV0ZWN0YWJsZURlbGltaXRlcicsXG4gICAgICAgIFwiVW5hYmxlIHRvIGF1dG8tZGV0ZWN0IGRlbGltaXRpbmcgY2hhcmFjdGVyOyBkZWZhdWx0ZWQgdG8gJ1wiICsgUGFwYS5EZWZhdWx0RGVsaW1pdGVyICsgXCInXCJcbiAgICAgICk7XG4gICAgICBfZGVsaW1pdGVyRXJyb3IgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoX2NvbmZpZy5za2lwRW1wdHlMaW5lcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfcmVzdWx0cy5kYXRhLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAodGVzdEVtcHR5TGluZShfcmVzdWx0cy5kYXRhW2ldKSkgX3Jlc3VsdHMuZGF0YS5zcGxpY2UoaS0tLCAxKTtcbiAgICB9XG5cbiAgICBpZiAobmVlZHNIZWFkZXJSb3coKSkgZmlsbEhlYWRlckZpZWxkcygpO1xuXG4gICAgcmV0dXJuIGFwcGx5SGVhZGVyQW5kRHluYW1pY1R5cGluZ0FuZFRyYW5zZm9ybWF0aW9uKCk7XG4gIH1cblxuICBmdW5jdGlvbiBuZWVkc0hlYWRlclJvdygpIHtcbiAgICByZXR1cm4gX2NvbmZpZy5oZWFkZXIgJiYgX2ZpZWxkcy5sZW5ndGggPT09IDA7XG4gIH1cblxuICBmdW5jdGlvbiBmaWxsSGVhZGVyRmllbGRzKCkge1xuICAgIGlmICghX3Jlc3VsdHMpIHJldHVybjtcblxuICAgIGZ1bmN0aW9uIGFkZEhlZGVyKGhlYWRlcikge1xuICAgICAgaWYgKGlzRnVuY3Rpb24oX2NvbmZpZy50cmFuc2Zvcm1IZWFkZXIpKSBoZWFkZXIgPSBfY29uZmlnLnRyYW5zZm9ybUhlYWRlcihoZWFkZXIpO1xuXG4gICAgICBfZmllbGRzLnB1c2goaGVhZGVyKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShfcmVzdWx0cy5kYXRhWzBdKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IG5lZWRzSGVhZGVyUm93KCkgJiYgaSA8IF9yZXN1bHRzLmRhdGEubGVuZ3RoOyBpKyspXG4gICAgICAgIF9yZXN1bHRzLmRhdGFbaV0uZm9yRWFjaChhZGRIZWRlcik7XG5cbiAgICAgIF9yZXN1bHRzLmRhdGEuc3BsaWNlKDAsIDEpO1xuICAgIH1cbiAgICAvLyBpZiBfcmVzdWx0cy5kYXRhWzBdIGlzIG5vdCBhbiBhcnJheSwgd2UgYXJlIGluIGEgc3RlcCB3aGVyZSBfcmVzdWx0cy5kYXRhIGlzIHRoZSByb3cuXG4gICAgZWxzZSBfcmVzdWx0cy5kYXRhLmZvckVhY2goYWRkSGVkZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkQXBwbHlEeW5hbWljVHlwaW5nKGZpZWxkKSB7XG4gICAgLy8gQ2FjaGUgZnVuY3Rpb24gdmFsdWVzIHRvIGF2b2lkIGNhbGxpbmcgaXQgZm9yIGVhY2ggcm93XG4gICAgaWYgKF9jb25maWcuZHluYW1pY1R5cGluZ0Z1bmN0aW9uICYmIF9jb25maWcuZHluYW1pY1R5cGluZ1tmaWVsZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgX2NvbmZpZy5keW5hbWljVHlwaW5nW2ZpZWxkXSA9IF9jb25maWcuZHluYW1pY1R5cGluZ0Z1bmN0aW9uKGZpZWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIChfY29uZmlnLmR5bmFtaWNUeXBpbmdbZmllbGRdIHx8IF9jb25maWcuZHluYW1pY1R5cGluZykgPT09IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUR5bmFtaWMoZmllbGQsIHZhbHVlKSB7XG4gICAgaWYgKHNob3VsZEFwcGx5RHluYW1pY1R5cGluZyhmaWVsZCkpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gJ3RydWUnIHx8IHZhbHVlID09PSAnVFJVRScpIHJldHVybiB0cnVlO1xuICAgICAgZWxzZSBpZiAodmFsdWUgPT09ICdmYWxzZScgfHwgdmFsdWUgPT09ICdGQUxTRScpIHJldHVybiBmYWxzZTtcbiAgICAgIGVsc2UgaWYgKEZMT0FULnRlc3QodmFsdWUpKSByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICBlbHNlIGlmIChJU09fREFURS50ZXN0KHZhbHVlKSkgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgIGVsc2UgcmV0dXJuIHZhbHVlID09PSAnJyA/IG51bGwgOiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlIZWFkZXJBbmREeW5hbWljVHlwaW5nQW5kVHJhbnNmb3JtYXRpb24oKSB7XG4gICAgaWYgKCFfcmVzdWx0cyB8fCAhX3Jlc3VsdHMuZGF0YSB8fCAoIV9jb25maWcuaGVhZGVyICYmICFfY29uZmlnLmR5bmFtaWNUeXBpbmcgJiYgIV9jb25maWcudHJhbnNmb3JtKSlcbiAgICAgIHJldHVybiBfcmVzdWx0cztcblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NSb3cocm93U291cmNlLCBpKSB7XG4gICAgICB2YXIgcm93ID0gX2NvbmZpZy5oZWFkZXIgPyB7fSA6IFtdO1xuXG4gICAgICB2YXIgajtcbiAgICAgIGZvciAoaiA9IDA7IGogPCByb3dTb3VyY2UubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGZpZWxkID0gajtcbiAgICAgICAgdmFyIHZhbHVlID0gcm93U291cmNlW2pdO1xuXG4gICAgICAgIGlmIChfY29uZmlnLmhlYWRlcikgZmllbGQgPSBqID49IF9maWVsZHMubGVuZ3RoID8gJ19fcGFyc2VkX2V4dHJhJyA6IF9maWVsZHNbal07XG5cbiAgICAgICAgaWYgKF9jb25maWcudHJhbnNmb3JtKSB2YWx1ZSA9IF9jb25maWcudHJhbnNmb3JtKHZhbHVlLCBmaWVsZCk7XG5cbiAgICAgICAgdmFsdWUgPSBwYXJzZUR5bmFtaWMoZmllbGQsIHZhbHVlKTtcblxuICAgICAgICBpZiAoZmllbGQgPT09ICdfX3BhcnNlZF9leHRyYScpIHtcbiAgICAgICAgICByb3dbZmllbGRdID0gcm93W2ZpZWxkXSB8fCBbXTtcbiAgICAgICAgICByb3dbZmllbGRdLnB1c2godmFsdWUpO1xuICAgICAgICB9IGVsc2Ugcm93W2ZpZWxkXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoX2NvbmZpZy5oZWFkZXIpIHtcbiAgICAgICAgaWYgKGogPiBfZmllbGRzLmxlbmd0aClcbiAgICAgICAgICBhZGRFcnJvcihcbiAgICAgICAgICAgICdGaWVsZE1pc21hdGNoJyxcbiAgICAgICAgICAgICdUb29NYW55RmllbGRzJyxcbiAgICAgICAgICAgICdUb28gbWFueSBmaWVsZHM6IGV4cGVjdGVkICcgKyBfZmllbGRzLmxlbmd0aCArICcgZmllbGRzIGJ1dCBwYXJzZWQgJyArIGosXG4gICAgICAgICAgICBfcm93Q291bnRlciArIGlcbiAgICAgICAgICApO1xuICAgICAgICBlbHNlIGlmIChqIDwgX2ZpZWxkcy5sZW5ndGgpXG4gICAgICAgICAgYWRkRXJyb3IoXG4gICAgICAgICAgICAnRmllbGRNaXNtYXRjaCcsXG4gICAgICAgICAgICAnVG9vRmV3RmllbGRzJyxcbiAgICAgICAgICAgICdUb28gZmV3IGZpZWxkczogZXhwZWN0ZWQgJyArIF9maWVsZHMubGVuZ3RoICsgJyBmaWVsZHMgYnV0IHBhcnNlZCAnICsgaixcbiAgICAgICAgICAgIF9yb3dDb3VudGVyICsgaVxuICAgICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByb3c7XG4gICAgfVxuXG4gICAgdmFyIGluY3JlbWVudEJ5ID0gMTtcbiAgICBpZiAoIV9yZXN1bHRzLmRhdGFbMF0gfHwgQXJyYXkuaXNBcnJheShfcmVzdWx0cy5kYXRhWzBdKSkge1xuICAgICAgX3Jlc3VsdHMuZGF0YSA9IF9yZXN1bHRzLmRhdGEubWFwKHByb2Nlc3NSb3cpO1xuICAgICAgaW5jcmVtZW50QnkgPSBfcmVzdWx0cy5kYXRhLmxlbmd0aDtcbiAgICB9IGVsc2UgX3Jlc3VsdHMuZGF0YSA9IHByb2Nlc3NSb3coX3Jlc3VsdHMuZGF0YSwgMCk7XG5cbiAgICBpZiAoX2NvbmZpZy5oZWFkZXIgJiYgX3Jlc3VsdHMubWV0YSkgX3Jlc3VsdHMubWV0YS5maWVsZHMgPSBfZmllbGRzO1xuXG4gICAgX3Jvd0NvdW50ZXIgKz0gaW5jcmVtZW50Qnk7XG4gICAgcmV0dXJuIF9yZXN1bHRzO1xuICB9XG5cbiAgZnVuY3Rpb24gZ3Vlc3NEZWxpbWl0ZXIoaW5wdXQsIG5ld2xpbmUsIHNraXBFbXB0eUxpbmVzLCBjb21tZW50cywgZGVsaW1pdGVyc1RvR3Vlc3MpIHtcbiAgICB2YXIgYmVzdERlbGltLCBiZXN0RGVsdGEsIGZpZWxkQ291bnRQcmV2Um93O1xuXG4gICAgZGVsaW1pdGVyc1RvR3Vlc3MgPSBkZWxpbWl0ZXJzVG9HdWVzcyB8fCBbJywnLCAnXFx0JywgJ3wnLCAnOycsIFBhcGEuUkVDT1JEX1NFUCwgUGFwYS5VTklUX1NFUF07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbGltaXRlcnNUb0d1ZXNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVsaW0gPSBkZWxpbWl0ZXJzVG9HdWVzc1tpXTtcbiAgICAgIHZhciBkZWx0YSA9IDAsXG4gICAgICAgIGF2Z0ZpZWxkQ291bnQgPSAwLFxuICAgICAgICBlbXB0eUxpbmVzQ291bnQgPSAwO1xuICAgICAgZmllbGRDb3VudFByZXZSb3cgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHZhciBwcmV2aWV3ID0gbmV3IFBhcnNlcih7XG4gICAgICAgIGNvbW1lbnRzOiBjb21tZW50cyxcbiAgICAgICAgZGVsaW1pdGVyOiBkZWxpbSxcbiAgICAgICAgbmV3bGluZTogbmV3bGluZSxcbiAgICAgICAgcHJldmlldzogMTBcbiAgICAgIH0pLnBhcnNlKGlucHV0KTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcmV2aWV3LmRhdGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHNraXBFbXB0eUxpbmVzICYmIHRlc3RFbXB0eUxpbmUocHJldmlldy5kYXRhW2pdKSkge1xuICAgICAgICAgIGVtcHR5TGluZXNDb3VudCsrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaWVsZENvdW50ID0gcHJldmlldy5kYXRhW2pdLmxlbmd0aDtcbiAgICAgICAgYXZnRmllbGRDb3VudCArPSBmaWVsZENvdW50O1xuXG4gICAgICAgIGlmICh0eXBlb2YgZmllbGRDb3VudFByZXZSb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgZmllbGRDb3VudFByZXZSb3cgPSAwO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGZpZWxkQ291bnQgPiAxKSB7XG4gICAgICAgICAgZGVsdGEgKz0gTWF0aC5hYnMoZmllbGRDb3VudCAtIGZpZWxkQ291bnRQcmV2Um93KTtcbiAgICAgICAgICBmaWVsZENvdW50UHJldlJvdyA9IGZpZWxkQ291bnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHByZXZpZXcuZGF0YS5sZW5ndGggPiAwKSBhdmdGaWVsZENvdW50IC89IHByZXZpZXcuZGF0YS5sZW5ndGggLSBlbXB0eUxpbmVzQ291bnQ7XG5cbiAgICAgIGlmICgodHlwZW9mIGJlc3REZWx0YSA9PT0gJ3VuZGVmaW5lZCcgfHwgZGVsdGEgPiBiZXN0RGVsdGEpICYmIGF2Z0ZpZWxkQ291bnQgPiAxLjk5KSB7XG4gICAgICAgIGJlc3REZWx0YSA9IGRlbHRhO1xuICAgICAgICBiZXN0RGVsaW0gPSBkZWxpbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfY29uZmlnLmRlbGltaXRlciA9IGJlc3REZWxpbTtcblxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzZnVsOiAhIWJlc3REZWxpbSxcbiAgICAgIGJlc3REZWxpbWl0ZXI6IGJlc3REZWxpbVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBndWVzc0xpbmVFbmRpbmdzKGlucHV0LCBxdW90ZUNoYXIpIHtcbiAgICBpbnB1dCA9IGlucHV0LnN1YnN0cigwLCAxMDI0ICogMTAyNCk7IC8vIG1heCBsZW5ndGggMSBNQlxuICAgIC8vIFJlcGxhY2UgYWxsIHRoZSB0ZXh0IGluc2lkZSBxdW90ZXNcbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4cChxdW90ZUNoYXIpICsgJyhbXl0qPyknICsgZXNjYXBlUmVnRXhwKHF1b3RlQ2hhciksICdnbScpO1xuICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShyZSwgJycpO1xuXG4gICAgdmFyIHIgPSBpbnB1dC5zcGxpdCgnXFxyJyk7XG5cbiAgICB2YXIgbiA9IGlucHV0LnNwbGl0KCdcXG4nKTtcblxuICAgIHZhciBuQXBwZWFyc0ZpcnN0ID0gbi5sZW5ndGggPiAxICYmIG5bMF0ubGVuZ3RoIDwgclswXS5sZW5ndGg7XG5cbiAgICBpZiAoci5sZW5ndGggPT09IDEgfHwgbkFwcGVhcnNGaXJzdCkgcmV0dXJuICdcXG4nO1xuXG4gICAgdmFyIG51bVdpdGhOID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyW2ldWzBdID09PSAnXFxuJykgbnVtV2l0aE4rKztcbiAgICB9XG5cbiAgICByZXR1cm4gbnVtV2l0aE4gPj0gci5sZW5ndGggLyAyID8gJ1xcclxcbicgOiAnXFxyJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEVycm9yKHR5cGUsIGNvZGUsIG1zZywgcm93KSB7XG4gICAgX3Jlc3VsdHMuZXJyb3JzLnB1c2goe1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGNvZGU6IGNvZGUsXG4gICAgICBtZXNzYWdlOiBtc2csXG4gICAgICByb3c6IHJvd1xuICAgIH0pO1xuICB9XG59XG5cbi8qKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L0d1aWRlL1JlZ3VsYXJfRXhwcmVzc2lvbnMgKi9cbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpOyAvLyAkJiBtZWFucyB0aGUgd2hvbGUgbWF0Y2hlZCBzdHJpbmdcbn1cblxuLyoqIFRoZSBjb3JlIHBhcnNlciBpbXBsZW1lbnRzIHNwZWVkeSBhbmQgY29ycmVjdCBDU1YgcGFyc2luZyAqL1xuZnVuY3Rpb24gUGFyc2VyKGNvbmZpZykge1xuICAvLyBVbnBhY2sgdGhlIGNvbmZpZyBvYmplY3RcbiAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICB2YXIgZGVsaW0gPSBjb25maWcuZGVsaW1pdGVyO1xuICB2YXIgbmV3bGluZSA9IGNvbmZpZy5uZXdsaW5lO1xuICB2YXIgY29tbWVudHMgPSBjb25maWcuY29tbWVudHM7XG4gIHZhciBzdGVwID0gY29uZmlnLnN0ZXA7XG4gIHZhciBwcmV2aWV3ID0gY29uZmlnLnByZXZpZXc7XG4gIHZhciBmYXN0TW9kZSA9IGNvbmZpZy5mYXN0TW9kZTtcbiAgdmFyIHF1b3RlQ2hhcjtcbiAgLyoqIEFsbG93cyBmb3Igbm8gcXVvdGVDaGFyIGJ5IHNldHRpbmcgcXVvdGVDaGFyIHRvIHVuZGVmaW5lZCBpbiBjb25maWcgKi9cbiAgaWYgKGNvbmZpZy5xdW90ZUNoYXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHF1b3RlQ2hhciA9ICdcIic7XG4gIH0gZWxzZSB7XG4gICAgcXVvdGVDaGFyID0gY29uZmlnLnF1b3RlQ2hhcjtcbiAgfVxuICB2YXIgZXNjYXBlQ2hhciA9IHF1b3RlQ2hhcjtcbiAgaWYgKGNvbmZpZy5lc2NhcGVDaGFyICE9PSB1bmRlZmluZWQpIHtcbiAgICBlc2NhcGVDaGFyID0gY29uZmlnLmVzY2FwZUNoYXI7XG4gIH1cblxuICAvLyBEZWxpbWl0ZXIgbXVzdCBiZSB2YWxpZFxuICBpZiAodHlwZW9mIGRlbGltICE9PSAnc3RyaW5nJyB8fCBQYXBhLkJBRF9ERUxJTUlURVJTLmluZGV4T2YoZGVsaW0pID4gLTEpIGRlbGltID0gJywnO1xuXG4gIC8vIENvbW1lbnQgY2hhcmFjdGVyIG11c3QgYmUgdmFsaWRcbiAgaWYgKGNvbW1lbnRzID09PSBkZWxpbSkgdGhyb3cgbmV3IEVycm9yKCdDb21tZW50IGNoYXJhY3RlciBzYW1lIGFzIGRlbGltaXRlcicpO1xuICBlbHNlIGlmIChjb21tZW50cyA9PT0gdHJ1ZSkgY29tbWVudHMgPSAnIyc7XG4gIGVsc2UgaWYgKHR5cGVvZiBjb21tZW50cyAhPT0gJ3N0cmluZycgfHwgUGFwYS5CQURfREVMSU1JVEVSUy5pbmRleE9mKGNvbW1lbnRzKSA+IC0xKVxuICAgIGNvbW1lbnRzID0gZmFsc2U7XG5cbiAgLy8gTmV3bGluZSBtdXN0IGJlIHZhbGlkOiBcXHIsIFxcbiwgb3IgXFxyXFxuXG4gIGlmIChuZXdsaW5lICE9PSAnXFxuJyAmJiBuZXdsaW5lICE9PSAnXFxyJyAmJiBuZXdsaW5lICE9PSAnXFxyXFxuJykgbmV3bGluZSA9ICdcXG4nO1xuXG4gIC8vIFdlJ3JlIGdvbm5hIG5lZWQgdGhlc2UgYXQgdGhlIFBhcnNlciBzY29wZVxuICB2YXIgY3Vyc29yID0gMDtcbiAgdmFyIGFib3J0ZWQgPSBmYWxzZTtcblxuICB0aGlzLnBhcnNlID0gZnVuY3Rpb24oaW5wdXQsIGJhc2VJbmRleCwgaWdub3JlTGFzdFJvdykge1xuICAgIC8vIEZvciBzb21lIHJlYXNvbiwgaW4gQ2hyb21lLCB0aGlzIHNwZWVkcyB0aGluZ3MgdXAgKCE/KVxuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IG11c3QgYmUgYSBzdHJpbmcnKTtcblxuICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gY29tcHV0ZSBzb21lIG9mIHRoZXNlIGV2ZXJ5IHRpbWUgcGFyc2UoKSBpcyBjYWxsZWQsXG4gICAgLy8gYnV0IGhhdmluZyB0aGVtIGluIGEgbW9yZSBsb2NhbCBzY29wZSBzZWVtcyB0byBwZXJmb3JtIGJldHRlclxuICAgIHZhciBpbnB1dExlbiA9IGlucHV0Lmxlbmd0aCxcbiAgICAgIGRlbGltTGVuID0gZGVsaW0ubGVuZ3RoLFxuICAgICAgbmV3bGluZUxlbiA9IG5ld2xpbmUubGVuZ3RoLFxuICAgICAgY29tbWVudHNMZW4gPSBjb21tZW50cy5sZW5ndGg7XG4gICAgdmFyIHN0ZXBJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbihzdGVwKTtcblxuICAgIC8vIEVzdGFibGlzaCBzdGFydGluZyBzdGF0ZVxuICAgIGN1cnNvciA9IDA7XG4gICAgdmFyIGRhdGEgPSBbXSxcbiAgICAgIGVycm9ycyA9IFtdLFxuICAgICAgcm93ID0gW10sXG4gICAgICBsYXN0Q3Vyc29yID0gMDtcblxuICAgIGlmICghaW5wdXQpIHJldHVybiByZXR1cm5hYmxlKCk7XG5cbiAgICBpZiAoZmFzdE1vZGUgfHwgKGZhc3RNb2RlICE9PSBmYWxzZSAmJiBpbnB1dC5pbmRleE9mKHF1b3RlQ2hhcikgPT09IC0xKSkge1xuICAgICAgdmFyIHJvd3MgPSBpbnB1dC5zcGxpdChuZXdsaW5lKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICByb3cgPSByb3dzW2ldO1xuICAgICAgICBjdXJzb3IgKz0gcm93Lmxlbmd0aDtcbiAgICAgICAgaWYgKGkgIT09IHJvd3MubGVuZ3RoIC0gMSkgY3Vyc29yICs9IG5ld2xpbmUubGVuZ3RoO1xuICAgICAgICBlbHNlIGlmIChpZ25vcmVMYXN0Um93KSByZXR1cm4gcmV0dXJuYWJsZSgpO1xuICAgICAgICBpZiAoY29tbWVudHMgJiYgcm93LnN1YnN0cigwLCBjb21tZW50c0xlbikgPT09IGNvbW1lbnRzKSBjb250aW51ZTtcbiAgICAgICAgaWYgKHN0ZXBJc0Z1bmN0aW9uKSB7XG4gICAgICAgICAgZGF0YSA9IFtdO1xuICAgICAgICAgIHB1c2hSb3cocm93LnNwbGl0KGRlbGltKSk7XG4gICAgICAgICAgZG9TdGVwKCk7XG4gICAgICAgICAgaWYgKGFib3J0ZWQpIHJldHVybiByZXR1cm5hYmxlKCk7XG4gICAgICAgIH0gZWxzZSBwdXNoUm93KHJvdy5zcGxpdChkZWxpbSkpO1xuICAgICAgICBpZiAocHJldmlldyAmJiBpID49IHByZXZpZXcpIHtcbiAgICAgICAgICBkYXRhID0gZGF0YS5zbGljZSgwLCBwcmV2aWV3KTtcbiAgICAgICAgICByZXR1cm4gcmV0dXJuYWJsZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldHVybmFibGUoKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dERlbGltID0gaW5wdXQuaW5kZXhPZihkZWxpbSwgY3Vyc29yKTtcbiAgICB2YXIgbmV4dE5ld2xpbmUgPSBpbnB1dC5pbmRleE9mKG5ld2xpbmUsIGN1cnNvcik7XG4gICAgdmFyIHF1b3RlQ2hhclJlZ2V4ID0gbmV3IFJlZ0V4cChlc2NhcGVSZWdFeHAoZXNjYXBlQ2hhcikgKyBlc2NhcGVSZWdFeHAocXVvdGVDaGFyKSwgJ2cnKTtcbiAgICB2YXIgcXVvdGVTZWFyY2g7XG5cbiAgICAvLyBQYXJzZXIgbG9vcFxuICAgIGZvciAoOzspIHtcbiAgICAgIC8vIEZpZWxkIGhhcyBvcGVuaW5nIHF1b3RlXG4gICAgICBpZiAoaW5wdXRbY3Vyc29yXSA9PT0gcXVvdGVDaGFyKSB7XG4gICAgICAgIC8vIFN0YXJ0IG91ciBzZWFyY2ggZm9yIHRoZSBjbG9zaW5nIHF1b3RlIHdoZXJlIHRoZSBjdXJzb3IgaXNcbiAgICAgICAgcXVvdGVTZWFyY2ggPSBjdXJzb3I7XG5cbiAgICAgICAgLy8gU2tpcCB0aGUgb3BlbmluZyBxdW90ZVxuICAgICAgICBjdXJzb3IrKztcblxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgLy8gRmluZCBjbG9zaW5nIHF1b3RlXG4gICAgICAgICAgcXVvdGVTZWFyY2ggPSBpbnB1dC5pbmRleE9mKHF1b3RlQ2hhciwgcXVvdGVTZWFyY2ggKyAxKTtcblxuICAgICAgICAgIC8vTm8gb3RoZXIgcXVvdGVzIGFyZSBmb3VuZCAtIG5vIG90aGVyIGRlbGltaXRlcnNcbiAgICAgICAgICBpZiAocXVvdGVTZWFyY2ggPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoIWlnbm9yZUxhc3RSb3cpIHtcbiAgICAgICAgICAgICAgLy8gTm8gY2xvc2luZyBxdW90ZS4uLiB3aGF0IGEgcGl0eVxuICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1F1b3RlcycsXG4gICAgICAgICAgICAgICAgY29kZTogJ01pc3NpbmdRdW90ZXMnLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdRdW90ZWQgZmllbGQgdW50ZXJtaW5hdGVkJyxcbiAgICAgICAgICAgICAgICByb3c6IGRhdGEubGVuZ3RoLCAvLyByb3cgaGFzIHlldCB0byBiZSBpbnNlcnRlZFxuICAgICAgICAgICAgICAgIGluZGV4OiBjdXJzb3JcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmluaXNoKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ2xvc2luZyBxdW90ZSBhdCBFT0ZcbiAgICAgICAgICBpZiAocXVvdGVTZWFyY2ggPT09IGlucHV0TGVuIC0gMSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gaW5wdXQuc3Vic3RyaW5nKGN1cnNvciwgcXVvdGVTZWFyY2gpLnJlcGxhY2UocXVvdGVDaGFyUmVnZXgsIHF1b3RlQ2hhcik7XG4gICAgICAgICAgICByZXR1cm4gZmluaXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGlzIHF1b3RlIGlzIGVzY2FwZWQsIGl0J3MgcGFydCBvZiB0aGUgZGF0YTsgc2tpcCBpdFxuICAgICAgICAgIC8vIElmIHRoZSBxdW90ZSBjaGFyYWN0ZXIgaXMgdGhlIGVzY2FwZSBjaGFyYWN0ZXIsIHRoZW4gY2hlY2sgaWYgdGhlIG5leHQgY2hhcmFjdGVyIGlzIHRoZSBlc2NhcGUgY2hhcmFjdGVyXG4gICAgICAgICAgaWYgKHF1b3RlQ2hhciA9PT0gZXNjYXBlQ2hhciAmJiBpbnB1dFtxdW90ZVNlYXJjaCArIDFdID09PSBlc2NhcGVDaGFyKSB7XG4gICAgICAgICAgICBxdW90ZVNlYXJjaCsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhlIHF1b3RlIGNoYXJhY3RlciBpcyBub3QgdGhlIGVzY2FwZSBjaGFyYWN0ZXIsIHRoZW4gY2hlY2sgaWYgdGhlIHByZXZpb3VzIGNoYXJhY3RlciB3YXMgdGhlIGVzY2FwZSBjaGFyYWN0ZXJcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBxdW90ZUNoYXIgIT09IGVzY2FwZUNoYXIgJiZcbiAgICAgICAgICAgIHF1b3RlU2VhcmNoICE9PSAwICYmXG4gICAgICAgICAgICBpbnB1dFtxdW90ZVNlYXJjaCAtIDFdID09PSBlc2NhcGVDaGFyXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDaGVjayB1cCB0byBuZXh0RGVsaW0gb3IgbmV4dE5ld2xpbmUsIHdoaWNoZXZlciBpcyBjbG9zZXN0XG4gICAgICAgICAgdmFyIGNoZWNrVXBUbyA9IG5leHROZXdsaW5lID09PSAtMSA/IG5leHREZWxpbSA6IE1hdGgubWluKG5leHREZWxpbSwgbmV4dE5ld2xpbmUpO1xuICAgICAgICAgIHZhciBzcGFjZXNCZXR3ZWVuUXVvdGVBbmREZWxpbWl0ZXIgPSBleHRyYVNwYWNlcyhjaGVja1VwVG8pO1xuXG4gICAgICAgICAgLy8gQ2xvc2luZyBxdW90ZSBmb2xsb3dlZCBieSBkZWxpbWl0ZXIgb3IgJ3VubmVjZXNzYXJ5IHNwYWNlcyArIGRlbGltaXRlcidcbiAgICAgICAgICBpZiAoaW5wdXRbcXVvdGVTZWFyY2ggKyAxICsgc3BhY2VzQmV0d2VlblF1b3RlQW5kRGVsaW1pdGVyXSA9PT0gZGVsaW0pIHtcbiAgICAgICAgICAgIHJvdy5wdXNoKGlucHV0LnN1YnN0cmluZyhjdXJzb3IsIHF1b3RlU2VhcmNoKS5yZXBsYWNlKHF1b3RlQ2hhclJlZ2V4LCBxdW90ZUNoYXIpKTtcbiAgICAgICAgICAgIGN1cnNvciA9IHF1b3RlU2VhcmNoICsgMSArIHNwYWNlc0JldHdlZW5RdW90ZUFuZERlbGltaXRlciArIGRlbGltTGVuO1xuICAgICAgICAgICAgbmV4dERlbGltID0gaW5wdXQuaW5kZXhPZihkZWxpbSwgY3Vyc29yKTtcbiAgICAgICAgICAgIG5leHROZXdsaW5lID0gaW5wdXQuaW5kZXhPZihuZXdsaW5lLCBjdXJzb3IpO1xuXG4gICAgICAgICAgICBpZiAoc3RlcElzRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgZG9TdGVwKCk7XG4gICAgICAgICAgICAgIGlmIChhYm9ydGVkKSByZXR1cm4gcmV0dXJuYWJsZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJldmlldyAmJiBkYXRhLmxlbmd0aCA+PSBwcmV2aWV3KSByZXR1cm4gcmV0dXJuYWJsZSh0cnVlKTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHNwYWNlc0JldHdlZW5RdW90ZUFuZE5ld0xpbmUgPSBleHRyYVNwYWNlcyhuZXh0TmV3bGluZSk7XG5cbiAgICAgICAgICAvLyBDbG9zaW5nIHF1b3RlIGZvbGxvd2VkIGJ5IG5ld2xpbmUgb3IgJ3VubmVjZXNzYXJ5IHNwYWNlcyArIG5ld0xpbmUnXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgaW5wdXQuc3Vic3RyKHF1b3RlU2VhcmNoICsgMSArIHNwYWNlc0JldHdlZW5RdW90ZUFuZE5ld0xpbmUsIG5ld2xpbmVMZW4pID09PSBuZXdsaW5lXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByb3cucHVzaChpbnB1dC5zdWJzdHJpbmcoY3Vyc29yLCBxdW90ZVNlYXJjaCkucmVwbGFjZShxdW90ZUNoYXJSZWdleCwgcXVvdGVDaGFyKSk7XG4gICAgICAgICAgICBzYXZlUm93KHF1b3RlU2VhcmNoICsgMSArIHNwYWNlc0JldHdlZW5RdW90ZUFuZE5ld0xpbmUgKyBuZXdsaW5lTGVuKTtcbiAgICAgICAgICAgIG5leHREZWxpbSA9IGlucHV0LmluZGV4T2YoZGVsaW0sIGN1cnNvcik7IC8vIGJlY2F1c2Ugd2UgbWF5IGhhdmUgc2tpcHBlZCB0aGUgbmV4dERlbGltIGluIHRoZSBxdW90ZWQgZmllbGRcblxuICAgICAgICAgICAgaWYgKHN0ZXBJc0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICAgIGRvU3RlcCgpO1xuICAgICAgICAgICAgICBpZiAoYWJvcnRlZCkgcmV0dXJuIHJldHVybmFibGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByZXZpZXcgJiYgZGF0YS5sZW5ndGggPj0gcHJldmlldykgcmV0dXJuIHJldHVybmFibGUodHJ1ZSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENoZWNrcyBmb3IgdmFsaWQgY2xvc2luZyBxdW90ZXMgYXJlIGNvbXBsZXRlIChlc2NhcGVkIHF1b3RlcyBvciBxdW90ZSBmb2xsb3dlZCBieSBFT0YvZGVsaW1pdGVyL25ld2xpbmUpIC0tIGFzc3VtZSB0aGVzZSBxdW90ZXMgYXJlIHBhcnQgb2YgYW4gaW52YWxpZCB0ZXh0IHN0cmluZ1xuICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdRdW90ZXMnLFxuICAgICAgICAgICAgY29kZTogJ0ludmFsaWRRdW90ZXMnLFxuICAgICAgICAgICAgbWVzc2FnZTogJ1RyYWlsaW5nIHF1b3RlIG9uIHF1b3RlZCBmaWVsZCBpcyBtYWxmb3JtZWQnLFxuICAgICAgICAgICAgcm93OiBkYXRhLmxlbmd0aCwgLy8gcm93IGhhcyB5ZXQgdG8gYmUgaW5zZXJ0ZWRcbiAgICAgICAgICAgIGluZGV4OiBjdXJzb3JcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHF1b3RlU2VhcmNoKys7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RlcElzRnVuY3Rpb24pIHtcbiAgICAgICAgICBkb1N0ZXAoKTtcbiAgICAgICAgICBpZiAoYWJvcnRlZCkgcmV0dXJuIHJldHVybmFibGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmV2aWV3ICYmIGRhdGEubGVuZ3RoID49IHByZXZpZXcpIHJldHVybiByZXR1cm5hYmxlKHRydWUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ29tbWVudCBmb3VuZCBhdCBzdGFydCBvZiBuZXcgbGluZVxuICAgICAgaWYgKGNvbW1lbnRzICYmIHJvdy5sZW5ndGggPT09IDAgJiYgaW5wdXQuc3Vic3RyKGN1cnNvciwgY29tbWVudHNMZW4pID09PSBjb21tZW50cykge1xuICAgICAgICBpZiAobmV4dE5ld2xpbmUgPT09IC0xKVxuICAgICAgICAgIC8vIENvbW1lbnQgZW5kcyBhdCBFT0ZcbiAgICAgICAgICByZXR1cm4gcmV0dXJuYWJsZSgpO1xuICAgICAgICBjdXJzb3IgPSBuZXh0TmV3bGluZSArIG5ld2xpbmVMZW47XG4gICAgICAgIG5leHROZXdsaW5lID0gaW5wdXQuaW5kZXhPZihuZXdsaW5lLCBjdXJzb3IpO1xuICAgICAgICBuZXh0RGVsaW0gPSBpbnB1dC5pbmRleE9mKGRlbGltLCBjdXJzb3IpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gTmV4dCBkZWxpbWl0ZXIgY29tZXMgYmVmb3JlIG5leHQgbmV3bGluZSwgc28gd2UndmUgcmVhY2hlZCBlbmQgb2YgZmllbGRcbiAgICAgIGlmIChuZXh0RGVsaW0gIT09IC0xICYmIChuZXh0RGVsaW0gPCBuZXh0TmV3bGluZSB8fCBuZXh0TmV3bGluZSA9PT0gLTEpKSB7XG4gICAgICAgIHJvdy5wdXNoKGlucHV0LnN1YnN0cmluZyhjdXJzb3IsIG5leHREZWxpbSkpO1xuICAgICAgICBjdXJzb3IgPSBuZXh0RGVsaW0gKyBkZWxpbUxlbjtcbiAgICAgICAgbmV4dERlbGltID0gaW5wdXQuaW5kZXhPZihkZWxpbSwgY3Vyc29yKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIEVuZCBvZiByb3dcbiAgICAgIGlmIChuZXh0TmV3bGluZSAhPT0gLTEpIHtcbiAgICAgICAgcm93LnB1c2goaW5wdXQuc3Vic3RyaW5nKGN1cnNvciwgbmV4dE5ld2xpbmUpKTtcbiAgICAgICAgc2F2ZVJvdyhuZXh0TmV3bGluZSArIG5ld2xpbmVMZW4pO1xuXG4gICAgICAgIGlmIChzdGVwSXNGdW5jdGlvbikge1xuICAgICAgICAgIGRvU3RlcCgpO1xuICAgICAgICAgIGlmIChhYm9ydGVkKSByZXR1cm4gcmV0dXJuYWJsZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXZpZXcgJiYgZGF0YS5sZW5ndGggPj0gcHJldmlldykgcmV0dXJuIHJldHVybmFibGUodHJ1ZSk7XG5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBmaW5pc2goKTtcblxuICAgIGZ1bmN0aW9uIHB1c2hSb3cocm93KSB7XG4gICAgICBkYXRhLnB1c2gocm93KTtcbiAgICAgIGxhc3RDdXJzb3IgPSBjdXJzb3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2hlY2tzIGlmIHRoZXJlIGFyZSBleHRyYSBzcGFjZXMgYWZ0ZXIgY2xvc2luZyBxdW90ZSBhbmQgZ2l2ZW4gaW5kZXggd2l0aG91dCBhbnkgdGV4dFxuICAgICAqIGlmIFllcywgcmV0dXJucyB0aGUgbnVtYmVyIG9mIHNwYWNlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV4dHJhU3BhY2VzKGluZGV4KSB7XG4gICAgICB2YXIgc3BhY2VMZW5ndGggPSAwO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICB2YXIgdGV4dEJldHdlZW5DbG9zaW5nUXVvdGVBbmRJbmRleCA9IGlucHV0LnN1YnN0cmluZyhxdW90ZVNlYXJjaCArIDEsIGluZGV4KTtcbiAgICAgICAgaWYgKHRleHRCZXR3ZWVuQ2xvc2luZ1F1b3RlQW5kSW5kZXggJiYgdGV4dEJldHdlZW5DbG9zaW5nUXVvdGVBbmRJbmRleC50cmltKCkgPT09ICcnKSB7XG4gICAgICAgICAgc3BhY2VMZW5ndGggPSB0ZXh0QmV0d2VlbkNsb3NpbmdRdW90ZUFuZEluZGV4Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNwYWNlTGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgdGhlIHJlbWFpbmluZyBpbnB1dCBmcm9tIGN1cnNvciB0byB0aGUgZW5kIGludG9cbiAgICAgKiByb3csIHNhdmVzIHRoZSByb3csIGNhbGxzIHN0ZXAsIGFuZCByZXR1cm5zIHRoZSByZXN1bHRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmlzaCh2YWx1ZSkge1xuICAgICAgaWYgKGlnbm9yZUxhc3RSb3cpIHJldHVybiByZXR1cm5hYmxlKCk7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykgdmFsdWUgPSBpbnB1dC5zdWJzdHIoY3Vyc29yKTtcbiAgICAgIHJvdy5wdXNoKHZhbHVlKTtcbiAgICAgIGN1cnNvciA9IGlucHV0TGVuOyAvLyBpbXBvcnRhbnQgaW4gY2FzZSBwYXJzaW5nIGlzIHBhdXNlZFxuICAgICAgcHVzaFJvdyhyb3cpO1xuICAgICAgaWYgKHN0ZXBJc0Z1bmN0aW9uKSBkb1N0ZXAoKTtcbiAgICAgIHJldHVybiByZXR1cm5hYmxlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwZW5kcyB0aGUgY3VycmVudCByb3cgdG8gdGhlIHJlc3VsdHMuIEl0IHNldHMgdGhlIGN1cnNvclxuICAgICAqIHRvIG5ld0N1cnNvciBhbmQgZmluZHMgdGhlIG5leHROZXdsaW5lLiBUaGUgY2FsbGVyIHNob3VsZFxuICAgICAqIHRha2UgY2FyZSB0byBleGVjdXRlIHVzZXIncyBzdGVwIGZ1bmN0aW9uIGFuZCBjaGVjayBmb3JcbiAgICAgKiBwcmV2aWV3IGFuZCBlbmQgcGFyc2luZyBpZiBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2F2ZVJvdyhuZXdDdXJzb3IpIHtcbiAgICAgIGN1cnNvciA9IG5ld0N1cnNvcjtcbiAgICAgIHB1c2hSb3cocm93KTtcbiAgICAgIHJvdyA9IFtdO1xuICAgICAgbmV4dE5ld2xpbmUgPSBpbnB1dC5pbmRleE9mKG5ld2xpbmUsIGN1cnNvcik7XG4gICAgfVxuXG4gICAgLyoqIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIHJlc3VsdHMsIGVycm9ycywgYW5kIG1ldGEuICovXG4gICAgZnVuY3Rpb24gcmV0dXJuYWJsZShzdG9wcGVkLCBzdGVwKSB7XG4gICAgICB2YXIgaXNTdGVwID0gc3RlcCB8fCBmYWxzZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IGlzU3RlcCA/IGRhdGFbMF0gOiBkYXRhLFxuICAgICAgICBlcnJvcnM6IGVycm9ycyxcbiAgICAgICAgbWV0YToge1xuICAgICAgICAgIGRlbGltaXRlcjogZGVsaW0sXG4gICAgICAgICAgbGluZWJyZWFrOiBuZXdsaW5lLFxuICAgICAgICAgIGFib3J0ZWQ6IGFib3J0ZWQsXG4gICAgICAgICAgdHJ1bmNhdGVkOiAhIXN0b3BwZWQsXG4gICAgICAgICAgY3Vyc29yOiBsYXN0Q3Vyc29yICsgKGJhc2VJbmRleCB8fCAwKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKiBFeGVjdXRlcyB0aGUgdXNlcidzIHN0ZXAgZnVuY3Rpb24gYW5kIHJlc2V0cyBkYXRhICYgZXJyb3JzLiAqL1xuICAgIGZ1bmN0aW9uIGRvU3RlcCgpIHtcbiAgICAgIHN0ZXAocmV0dXJuYWJsZSh1bmRlZmluZWQsIHRydWUpKTtcbiAgICAgIGRhdGEgPSBbXTtcbiAgICAgIGVycm9ycyA9IFtdO1xuICAgIH1cbiAgfTtcblxuICAvKiogU2V0cyB0aGUgYWJvcnQgZmxhZyAqL1xuICB0aGlzLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgYWJvcnRlZCA9IHRydWU7XG4gIH07XG5cbiAgLyoqIEdldHMgdGhlIGN1cnNvciBwb3NpdGlvbiAqL1xuICB0aGlzLmdldENoYXJJbmRleCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjdXJzb3I7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vdEltcGxlbWVudGVkKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZC4nKTtcbn1cblxuLyoqIE1ha2VzIGEgZGVlcCBjb3B5IG9mIGFuIGFycmF5IG9yIG9iamVjdCAobW9zdGx5KSAqL1xuZnVuY3Rpb24gY29weShvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkgcmV0dXJuIG9iajtcbiAgdmFyIGNweSA9IEFycmF5LmlzQXJyYXkob2JqKSA/IFtdIDoge307XG4gIGZvciAodmFyIGtleSBpbiBvYmopIGNweVtrZXldID0gY29weShvYmpba2V5XSk7XG4gIHJldHVybiBjcHk7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oZnVuYykge1xuICByZXR1cm4gdHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbic7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbnZhciBfdHlwZW9mID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXNzZXJ0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hc3NlcnQuYXNzZXJ0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzQnJvd3NlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2xvYmFscy5pc0Jyb3dzZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNXb3JrZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dsb2JhbHMuaXNXb3JrZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibm9kZVZlcnNpb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dsb2JhbHMubm9kZVZlcnNpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2VsZlwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2xvYmFscy5zZWxmO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIndpbmRvd1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2xvYmFscy53aW5kb3c7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2xvYmFsXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxzLmdsb2JhbDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkb2N1bWVudFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2xvYmFscy5kb2N1bWVudDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVMb2FkZXJXb3JrZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2NyZWF0ZUxvYWRlcldvcmtlci5jcmVhdGVMb2FkZXJXb3JrZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VXaXRoV29ya2VyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9wYXJzZVdpdGhXb3JrZXIucGFyc2VXaXRoV29ya2VyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNhblBhcnNlV2l0aFdvcmtlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfcGFyc2VXaXRoV29ya2VyLmNhblBhcnNlV2l0aFdvcmtlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZUpTT05cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3BhcnNlSnNvbi5wYXJzZUpTT047XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9BcnJheUJ1ZmZlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYXJyYXlCdWZmZXJVdGlscy50b0FycmF5QnVmZmVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNsaWNlQXJyYXlCdWZmZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2FycmF5QnVmZmVyVXRpbHMuc2xpY2VBcnJheUJ1ZmZlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb25jYXRlbmF0ZUFycmF5QnVmZmVyc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYXJyYXlCdWZmZXJVdGlscy5jb25jYXRlbmF0ZUFycmF5QnVmZmVycztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb25jYXRlbmF0ZVR5cGVkQXJyYXlzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hcnJheUJ1ZmZlclV0aWxzLmNvbmNhdGVuYXRlVHlwZWRBcnJheXM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29tcGFyZUFycmF5QnVmZmVyc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYXJyYXlCdWZmZXJVdGlscy5jb21wYXJlQXJyYXlCdWZmZXJzO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhZFRvTkJ5dGVzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9tZW1vcnlDb3B5VXRpbHMucGFkVG9OQnl0ZXM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29weVRvQXJyYXlcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX21lbW9yeUNvcHlVdGlscy5jb3B5VG9BcnJheTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb3B5QXJyYXlCdWZmZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX21lbW9yeUNvcHlVdGlscy5jb3B5QXJyYXlCdWZmZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29weVBhZGRlZEFycmF5QnVmZmVyVG9EYXRhVmlld1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYmluYXJ5Q29weVV0aWxzLmNvcHlQYWRkZWRBcnJheUJ1ZmZlclRvRGF0YVZpZXc7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29weVBhZGRlZFN0cmluZ1RvRGF0YVZpZXdcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2JpbmFyeUNvcHlVdGlscy5jb3B5UGFkZGVkU3RyaW5nVG9EYXRhVmlldztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYWRTdHJpbmdUb0J5dGVBbGlnbm1lbnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2VuY29kZVV0aWxzLnBhZFN0cmluZ1RvQnl0ZUFsaWdubWVudDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb3B5U3RyaW5nVG9EYXRhVmlld1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZW5jb2RlVXRpbHMuY29weVN0cmluZ1RvRGF0YVZpZXc7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29weUJpbmFyeVRvRGF0YVZpZXdcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2VuY29kZVV0aWxzLmNvcHlCaW5hcnlUb0RhdGFWaWV3O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEZpcnN0Q2hhcmFjdGVyc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2V0Rmlyc3RDaGFyYWN0ZXJzLmdldEZpcnN0Q2hhcmFjdGVycztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRNYWdpY1N0cmluZ1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2V0Rmlyc3RDaGFyYWN0ZXJzLmdldE1hZ2ljU3RyaW5nO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1ha2VUZXh0RW5jb2Rlckl0ZXJhdG9yXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90ZXh0SXRlcmF0b3JzLm1ha2VUZXh0RW5jb2Rlckl0ZXJhdG9yO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1ha2VUZXh0RGVjb2Rlckl0ZXJhdG9yXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90ZXh0SXRlcmF0b3JzLm1ha2VUZXh0RGVjb2Rlckl0ZXJhdG9yO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1ha2VMaW5lSXRlcmF0b3JcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3RleHRJdGVyYXRvcnMubWFrZUxpbmVJdGVyYXRvcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYWtlTnVtYmVyZWRMaW5lSXRlcmF0b3JcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3RleHRJdGVyYXRvcnMubWFrZU51bWJlcmVkTGluZUl0ZXJhdG9yO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZvckVhY2hcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2FzeW5jSXRlcmF0aW9uLmZvckVhY2g7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnNBc3luY1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYXN5bmNJdGVyYXRpb24uY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnNBc3luYztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXF1ZXN0U2NoZWR1bGVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9yZXF1ZXN0U2NoZWR1bGVyLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2V0UGF0aFByZWZpeFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZmlsZUFsaWFzZXMuc2V0UGF0aFByZWZpeDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRQYXRoUHJlZml4XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9maWxlQWxpYXNlcy5nZXRQYXRoUHJlZml4O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlc29sdmVQYXRoXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9maWxlQWxpYXNlcy5yZXNvbHZlUGF0aDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfYWRkQWxpYXNlc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZmlsZUFsaWFzZXMuYWRkQWxpYXNlcztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0J1ZmZlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYnVmZmVyVXRpbHMuaXNCdWZmZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9CdWZmZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2J1ZmZlclV0aWxzLnRvQnVmZmVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImJ1ZmZlclRvQXJyYXlCdWZmZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2J1ZmZlclV0aWxzLmJ1ZmZlclRvQXJyYXlCdWZmZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSlNPTkxvYWRlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfanNvbkxvYWRlci5KU09OTG9hZGVyO1xuICB9XG59KTtcbmV4cG9ydHMuZnMgPSBleHBvcnRzLnBhdGggPSB2b2lkIDA7XG5cbnZhciBfYXNzZXJ0ID0gcmVxdWlyZShcIi4vbGliL2Vudi11dGlscy9hc3NlcnRcIik7XG5cbnZhciBfZ2xvYmFscyA9IHJlcXVpcmUoXCIuL2xpYi9lbnYtdXRpbHMvZ2xvYmFsc1wiKTtcblxudmFyIF9jcmVhdGVMb2FkZXJXb3JrZXIgPSByZXF1aXJlKFwiLi9saWIvd29ya2VyLWxvYWRlci11dGlscy9jcmVhdGUtbG9hZGVyLXdvcmtlclwiKTtcblxudmFyIF9wYXJzZVdpdGhXb3JrZXIgPSByZXF1aXJlKFwiLi9saWIvd29ya2VyLWxvYWRlci11dGlscy9wYXJzZS13aXRoLXdvcmtlclwiKTtcblxudmFyIF9wYXJzZUpzb24gPSByZXF1aXJlKFwiLi9saWIvcGFyc2VyLXV0aWxzL3BhcnNlLWpzb25cIik7XG5cbnZhciBfYXJyYXlCdWZmZXJVdGlscyA9IHJlcXVpcmUoXCIuL2xpYi9iaW5hcnktdXRpbHMvYXJyYXktYnVmZmVyLXV0aWxzXCIpO1xuXG52YXIgX21lbW9yeUNvcHlVdGlscyA9IHJlcXVpcmUoXCIuL2xpYi9iaW5hcnktdXRpbHMvbWVtb3J5LWNvcHktdXRpbHNcIik7XG5cbnZhciBfYmluYXJ5Q29weVV0aWxzID0gcmVxdWlyZShcIi4vbGliL2JpbmFyeS11dGlscy9iaW5hcnktY29weS11dGlsc1wiKTtcblxudmFyIF9lbmNvZGVVdGlscyA9IHJlcXVpcmUoXCIuL2xpYi9iaW5hcnktdXRpbHMvZW5jb2RlLXV0aWxzXCIpO1xuXG52YXIgX2dldEZpcnN0Q2hhcmFjdGVycyA9IHJlcXVpcmUoXCIuL2xpYi9iaW5hcnktdXRpbHMvZ2V0LWZpcnN0LWNoYXJhY3RlcnNcIik7XG5cbnZhciBfdGV4dEl0ZXJhdG9ycyA9IHJlcXVpcmUoXCIuL2xpYi9pdGVyYXRvcnMvdGV4dC1pdGVyYXRvcnNcIik7XG5cbnZhciBfYXN5bmNJdGVyYXRpb24gPSByZXF1aXJlKFwiLi9saWIvaXRlcmF0b3JzL2FzeW5jLWl0ZXJhdGlvblwiKTtcblxudmFyIF9yZXF1ZXN0U2NoZWR1bGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvcmVxdWVzdC11dGlscy9yZXF1ZXN0LXNjaGVkdWxlclwiKSk7XG5cbnZhciBwYXRoID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbGliL3BhdGgtdXRpbHMvcGF0aFwiKSk7XG5cbmV4cG9ydHMucGF0aCA9IHBhdGg7XG5cbnZhciBfZmlsZUFsaWFzZXMgPSByZXF1aXJlKFwiLi9saWIvcGF0aC11dGlscy9maWxlLWFsaWFzZXNcIik7XG5cbnZhciBmcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2xpYi9ub2RlL2ZzXCIpKTtcblxuZXhwb3J0cy5mcyA9IGZzO1xuXG52YXIgX2J1ZmZlclV0aWxzID0gcmVxdWlyZShcIi4vbGliL2JpbmFyeS11dGlscy9idWZmZXItdXRpbHNcIik7XG5cbnZhciBfanNvbkxvYWRlciA9IHJlcXVpcmUoXCIuL2pzb24tbG9hZGVyXCIpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpOyB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDsgfSkobm9kZUludGVyb3ApOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHsgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoa2V5ICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLl90eXBlY2hlY2tKU09OTG9hZGVyID0gZXhwb3J0cy5KU09OTG9hZGVyID0gdm9pZCAwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIFZFUlNJT04gPSB0eXBlb2YgXCIzLjAuOVwiICE9PSAndW5kZWZpbmVkJyA/IFwiMy4wLjlcIiA6ICdsYXRlc3QnO1xudmFyIEpTT05Mb2FkZXIgPSB7XG4gIG5hbWU6ICdKU09OJyxcbiAgaWQ6ICdqc29uJyxcbiAgbW9kdWxlOiAnanNvbicsXG4gIHZlcnNpb246IFZFUlNJT04sXG4gIGV4dGVuc2lvbnM6IFsnanNvbicsICdnZW9qc29uJ10sXG4gIG1pbWVUeXBlczogWydhcHBsaWNhdGlvbi9qc29uJ10sXG4gIGNhdGVnb3J5OiAnanNvbicsXG4gIHRleHQ6IHRydWUsXG4gIHBhcnNlVGV4dFN5bmM6IHBhcnNlVGV4dFN5bmMsXG4gIHBhcnNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9wYXJzZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKGFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBwYXJzZVRleHRTeW5jKG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShhcnJheUJ1ZmZlcikpKTtcblxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZSk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gcGFyc2UoX3gpIHtcbiAgICAgIHJldHVybiBfcGFyc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2U7XG4gIH0oKSxcbiAgb3B0aW9uczoge31cbn07XG5leHBvcnRzLkpTT05Mb2FkZXIgPSBKU09OTG9hZGVyO1xuXG5mdW5jdGlvbiBwYXJzZVRleHRTeW5jKHRleHQpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UodGV4dCk7XG59XG5cbnZhciBfdHlwZWNoZWNrSlNPTkxvYWRlciA9IEpTT05Mb2FkZXI7XG5leHBvcnRzLl90eXBlY2hlY2tKU09OTG9hZGVyID0gX3R5cGVjaGVja0pTT05Mb2FkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc29uLWxvYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbnZhciBfdHlwZW9mMyA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMudG9BcnJheUJ1ZmZlciA9IHRvQXJyYXlCdWZmZXI7XG5leHBvcnRzLmNvbXBhcmVBcnJheUJ1ZmZlcnMgPSBjb21wYXJlQXJyYXlCdWZmZXJzO1xuZXhwb3J0cy5jb25jYXRlbmF0ZUFycmF5QnVmZmVycyA9IGNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzO1xuZXhwb3J0cy5jb25jYXRlbmF0ZVR5cGVkQXJyYXlzID0gY29uY2F0ZW5hdGVUeXBlZEFycmF5cztcbmV4cG9ydHMuc2xpY2VBcnJheUJ1ZmZlciA9IHNsaWNlQXJyYXlCdWZmZXI7XG5cbnZhciBfdHlwZW9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpKTtcblxudmFyIG5vZGUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi4vbm9kZS9idWZmZXItdXRpbHMubm9kZVwiKSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOyB9KShub2RlSW50ZXJvcCk7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqLCBub2RlSW50ZXJvcCkgeyBpZiAoIW5vZGVJbnRlcm9wICYmIG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZjMob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoa2V5ICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gdG9BcnJheUJ1ZmZlcihkYXRhKSB7XG4gIGlmIChub2RlLnRvQXJyYXlCdWZmZXIpIHtcbiAgICBkYXRhID0gbm9kZS50b0FycmF5QnVmZmVyKGRhdGEpO1xuICB9XG5cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgdGV4dCA9IGRhdGE7XG4gICAgdmFyIHVpbnQ4QXJyYXkgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodGV4dCk7XG4gICAgcmV0dXJuIHVpbnQ4QXJyYXkuYnVmZmVyO1xuICB9XG5cbiAgaWYgKGRhdGEgJiYgKDAsIF90eXBlb2YyLmRlZmF1bHQpKGRhdGEpID09PSAnb2JqZWN0JyAmJiBkYXRhLl90b0FycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGRhdGEuX3RvQXJyYXlCdWZmZXIoKTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcigndG9BcnJheUJ1ZmZlcicpO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlQXJyYXlCdWZmZXJzKGFycmF5QnVmZmVyMSwgYXJyYXlCdWZmZXIyLCBieXRlTGVuZ3RoKSB7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHx8IGFycmF5QnVmZmVyMS5ieXRlTGVuZ3RoO1xuXG4gIGlmIChhcnJheUJ1ZmZlcjEuYnl0ZUxlbmd0aCA8IGJ5dGVMZW5ndGggfHwgYXJyYXlCdWZmZXIyLmJ5dGVMZW5ndGggPCBieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGFycmF5MSA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyMSk7XG4gIHZhciBhcnJheTIgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcjIpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkxLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc291cmNlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzb3VyY2VzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgdmFyIHNvdXJjZUFycmF5cyA9IHNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UyKSB7XG4gICAgcmV0dXJuIHNvdXJjZTIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IG5ldyBVaW50OEFycmF5KHNvdXJjZTIpIDogc291cmNlMjtcbiAgfSk7XG4gIHZhciBieXRlTGVuZ3RoID0gc291cmNlQXJyYXlzLnJlZHVjZShmdW5jdGlvbiAobGVuZ3RoLCB0eXBlZEFycmF5KSB7XG4gICAgcmV0dXJuIGxlbmd0aCArIHR5cGVkQXJyYXkuYnl0ZUxlbmd0aDtcbiAgfSwgMCk7XG4gIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShieXRlTGVuZ3RoKTtcbiAgdmFyIG9mZnNldCA9IDA7XG5cbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHNvdXJjZUFycmF5cyksXG4gICAgICBfc3RlcDtcblxuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgc291cmNlQXJyYXkgPSBfc3RlcC52YWx1ZTtcbiAgICAgIHJlc3VsdC5zZXQoc291cmNlQXJyYXksIG9mZnNldCk7XG4gICAgICBvZmZzZXQgKz0gc291cmNlQXJyYXkuYnl0ZUxlbmd0aDtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQuYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBjb25jYXRlbmF0ZVR5cGVkQXJyYXlzKCkge1xuICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHR5cGVkQXJyYXlzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgdHlwZWRBcnJheXNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuXG4gIHZhciBhcnJheXMgPSB0eXBlZEFycmF5cztcbiAgdmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGFycmF5cyAmJiBhcnJheXMubGVuZ3RoID4gMSAmJiBhcnJheXNbMF0uY29uc3RydWN0b3IgfHwgbnVsbDtcblxuICBpZiAoIVR5cGVkQXJyYXlDb25zdHJ1Y3Rvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignXCJjb25jYXRlbmF0ZVR5cGVkQXJyYXlzXCIgLSBpbmNvcnJlY3QgcXVhbnRpdHkgb2YgYXJndW1lbnRzIG9yIGFyZ3VtZW50cyBoYXZlIGluY29tcGF0aWJsZSBkYXRhIHR5cGVzJyk7XG4gIH1cblxuICB2YXIgc3VtTGVuZ3RoID0gYXJyYXlzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCB2YWx1ZSkge1xuICAgIHJldHVybiBhY2MgKyB2YWx1ZS5sZW5ndGg7XG4gIH0sIDApO1xuICB2YXIgcmVzdWx0ID0gbmV3IFR5cGVkQXJyYXlDb25zdHJ1Y3RvcihzdW1MZW5ndGgpO1xuICB2YXIgb2Zmc2V0ID0gMDtcblxuICBmb3IgKHZhciBfaSA9IDAsIF9hcnJheXMgPSBhcnJheXM7IF9pIDwgX2FycmF5cy5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgYXJyYXkgPSBfYXJyYXlzW19pXTtcbiAgICByZXN1bHQuc2V0KGFycmF5LCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBhcnJheS5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBzbGljZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIHZhciBzdWJBcnJheSA9IGJ5dGVMZW5ndGggIT09IHVuZGVmaW5lZCA/IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKS5zdWJhcnJheShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCkgOiBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikuc3ViYXJyYXkoYnl0ZU9mZnNldCk7XG4gIHZhciBhcnJheUNvcHkgPSBuZXcgVWludDhBcnJheShzdWJBcnJheSk7XG4gIHJldHVybiBhcnJheUNvcHkuYnVmZmVyO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJyYXktYnVmZmVyLXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jb3B5UGFkZGVkQXJyYXlCdWZmZXJUb0RhdGFWaWV3ID0gY29weVBhZGRlZEFycmF5QnVmZmVyVG9EYXRhVmlldztcbmV4cG9ydHMuY29weVBhZGRlZFN0cmluZ1RvRGF0YVZpZXcgPSBjb3B5UGFkZGVkU3RyaW5nVG9EYXRhVmlldztcblxudmFyIF9tZW1vcnlDb3B5VXRpbHMgPSByZXF1aXJlKFwiLi9tZW1vcnktY29weS11dGlsc1wiKTtcblxuZnVuY3Rpb24gY29weVBhZGRlZEFycmF5QnVmZmVyVG9EYXRhVmlldyhkYXRhVmlldywgYnl0ZU9mZnNldCwgc291cmNlQnVmZmVyLCBwYWRkaW5nKSB7XG4gIHZhciBwYWRkZWRMZW5ndGggPSAoMCwgX21lbW9yeUNvcHlVdGlscy5wYWRUb05CeXRlcykoc291cmNlQnVmZmVyLmJ5dGVMZW5ndGgsIHBhZGRpbmcpO1xuICB2YXIgcGFkTGVuZ3RoID0gcGFkZGVkTGVuZ3RoIC0gc291cmNlQnVmZmVyLmJ5dGVMZW5ndGg7XG5cbiAgaWYgKGRhdGFWaWV3KSB7XG4gICAgdmFyIHRhcmdldEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YVZpZXcuYnVmZmVyLCBkYXRhVmlldy5ieXRlT2Zmc2V0ICsgYnl0ZU9mZnNldCwgc291cmNlQnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgIHZhciBzb3VyY2VBcnJheSA9IG5ldyBVaW50OEFycmF5KHNvdXJjZUJ1ZmZlcik7XG4gICAgdGFyZ2V0QXJyYXkuc2V0KHNvdXJjZUFycmF5KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFkTGVuZ3RoOyArK2kpIHtcbiAgICAgIGRhdGFWaWV3LnNldFVpbnQ4KGJ5dGVPZmZzZXQgKyBzb3VyY2VCdWZmZXIuYnl0ZUxlbmd0aCArIGksIDB4MjApO1xuICAgIH1cbiAgfVxuXG4gIGJ5dGVPZmZzZXQgKz0gcGFkZGVkTGVuZ3RoO1xuICByZXR1cm4gYnl0ZU9mZnNldDtcbn1cblxuZnVuY3Rpb24gY29weVBhZGRlZFN0cmluZ1RvRGF0YVZpZXcoZGF0YVZpZXcsIGJ5dGVPZmZzZXQsIHN0cmluZywgcGFkZGluZykge1xuICB2YXIgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgdmFyIHN0cmluZ0J1ZmZlciA9IHRleHRFbmNvZGVyLmVuY29kZShzdHJpbmcpO1xuICBieXRlT2Zmc2V0ID0gY29weVBhZGRlZEFycmF5QnVmZmVyVG9EYXRhVmlldyhkYXRhVmlldywgYnl0ZU9mZnNldCwgc3RyaW5nQnVmZmVyLCBwYWRkaW5nKTtcbiAgcmV0dXJuIGJ5dGVPZmZzZXQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaW5hcnktY29weS11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbnZhciBfdHlwZW9mMyA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuaXNCdWZmZXIgPSBpc0J1ZmZlcjtcbmV4cG9ydHMudG9CdWZmZXIgPSB0b0J1ZmZlcjtcbmV4cG9ydHMuYnVmZmVyVG9BcnJheUJ1ZmZlciA9IGJ1ZmZlclRvQXJyYXlCdWZmZXI7XG5cbnZhciBfdHlwZW9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpKTtcblxudmFyIG5vZGUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi4vbm9kZS9idWZmZXItdXRpbHMubm9kZVwiKSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOyB9KShub2RlSW50ZXJvcCk7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqLCBub2RlSW50ZXJvcCkgeyBpZiAoIW5vZGVJbnRlcm9wICYmIG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZjMob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoa2V5ICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAmJiAoMCwgX3R5cGVvZjIuZGVmYXVsdCkodmFsdWUpID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5pc0J1ZmZlcjtcbn1cblxuZnVuY3Rpb24gdG9CdWZmZXIoZGF0YSkge1xuICByZXR1cm4gbm9kZS50b0J1ZmZlciA/IG5vZGUudG9CdWZmZXIoZGF0YSkgOiBkYXRhO1xufVxuXG5mdW5jdGlvbiBidWZmZXJUb0FycmF5QnVmZmVyKGRhdGEpIHtcbiAgaWYgKG5vZGUudG9BcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBub2RlLnRvQXJyYXlCdWZmZXIoZGF0YSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1ZmZlci11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucGFkU3RyaW5nVG9CeXRlQWxpZ25tZW50ID0gcGFkU3RyaW5nVG9CeXRlQWxpZ25tZW50O1xuZXhwb3J0cy5jb3B5U3RyaW5nVG9EYXRhVmlldyA9IGNvcHlTdHJpbmdUb0RhdGFWaWV3O1xuZXhwb3J0cy5jb3B5QmluYXJ5VG9EYXRhVmlldyA9IGNvcHlCaW5hcnlUb0RhdGFWaWV3O1xuXG5mdW5jdGlvbiBwYWRTdHJpbmdUb0J5dGVBbGlnbm1lbnQoc3RyaW5nLCBieXRlQWxpZ25tZW50KSB7XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICB2YXIgcGFkZGVkTGVuZ3RoID0gTWF0aC5jZWlsKGxlbmd0aCAvIGJ5dGVBbGlnbm1lbnQpICogYnl0ZUFsaWdubWVudDtcbiAgdmFyIHBhZGRpbmcgPSBwYWRkZWRMZW5ndGggLSBsZW5ndGg7XG4gIHZhciB3aGl0ZXNwYWNlID0gJyc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWRkaW5nOyArK2kpIHtcbiAgICB3aGl0ZXNwYWNlICs9ICcgJztcbiAgfVxuXG4gIHJldHVybiBzdHJpbmcgKyB3aGl0ZXNwYWNlO1xufVxuXG5mdW5jdGlvbiBjb3B5U3RyaW5nVG9EYXRhVmlldyhkYXRhVmlldywgYnl0ZU9mZnNldCwgc3RyaW5nLCBieXRlTGVuZ3RoKSB7XG4gIGlmIChkYXRhVmlldykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhVmlldy5zZXRVaW50OChieXRlT2Zmc2V0ICsgaSwgc3RyaW5nLmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aDtcbn1cblxuZnVuY3Rpb24gY29weUJpbmFyeVRvRGF0YVZpZXcoZGF0YVZpZXcsIGJ5dGVPZmZzZXQsIGJpbmFyeSwgYnl0ZUxlbmd0aCkge1xuICBpZiAoZGF0YVZpZXcpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVMZW5ndGg7IGkrKykge1xuICAgICAgZGF0YVZpZXcuc2V0VWludDgoYnl0ZU9mZnNldCArIGksIGJpbmFyeVtpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVPZmZzZXQgKyBieXRlTGVuZ3RoO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5jb2RlLXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXRGaXJzdENoYXJhY3RlcnMgPSBnZXRGaXJzdENoYXJhY3RlcnM7XG5leHBvcnRzLmdldE1hZ2ljU3RyaW5nID0gZ2V0TWFnaWNTdHJpbmc7XG5cbmZ1bmN0aW9uIGdldEZpcnN0Q2hhcmFjdGVycyhkYXRhKSB7XG4gIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDU7XG5cbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkYXRhLnNsaWNlKDAsIGxlbmd0aCk7XG4gIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgcmV0dXJuIGdldE1hZ2ljU3RyaW5nKGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgdmFyIGJ5dGVPZmZzZXQgPSAwO1xuICAgIHJldHVybiBnZXRNYWdpY1N0cmluZyhkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRNYWdpY1N0cmluZyhhcnJheUJ1ZmZlciwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoIDw9IGJ5dGVPZmZzZXQgKyBsZW5ndGgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpO1xuICB2YXIgbWFnaWMgPSAnJztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgbWFnaWMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhVmlldy5nZXRVaW50OChieXRlT2Zmc2V0ICsgaSkpO1xuICB9XG5cbiAgcmV0dXJuIG1hZ2ljO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LWZpcnN0LWNoYXJhY3RlcnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnBhZFRvTkJ5dGVzID0gcGFkVG9OQnl0ZXM7XG5leHBvcnRzLmNvcHlBcnJheUJ1ZmZlciA9IGNvcHlBcnJheUJ1ZmZlcjtcbmV4cG9ydHMuY29weVRvQXJyYXkgPSBjb3B5VG9BcnJheTtcblxudmFyIF9hc3NlcnQgPSByZXF1aXJlKFwiLi4vZW52LXV0aWxzL2Fzc2VydFwiKTtcblxuZnVuY3Rpb24gcGFkVG9OQnl0ZXMoYnl0ZUxlbmd0aCwgcGFkZGluZykge1xuICAoMCwgX2Fzc2VydC5hc3NlcnQpKGJ5dGVMZW5ndGggPj0gMCk7XG4gICgwLCBfYXNzZXJ0LmFzc2VydCkocGFkZGluZyA+IDApO1xuICByZXR1cm4gYnl0ZUxlbmd0aCArIChwYWRkaW5nIC0gMSkgJiB+KHBhZGRpbmcgLSAxKTtcbn1cblxuZnVuY3Rpb24gY29weUFycmF5QnVmZmVyKHRhcmdldEJ1ZmZlciwgc291cmNlQnVmZmVyLCBieXRlT2Zmc2V0KSB7XG4gIHZhciBieXRlTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBzb3VyY2VCdWZmZXIuYnl0ZUxlbmd0aDtcbiAgdmFyIHRhcmdldEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodGFyZ2V0QnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgdmFyIHNvdXJjZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoc291cmNlQnVmZmVyKTtcbiAgdGFyZ2V0QXJyYXkuc2V0KHNvdXJjZUFycmF5KTtcbiAgcmV0dXJuIHRhcmdldEJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gY29weVRvQXJyYXkoc291cmNlLCB0YXJnZXQsIHRhcmdldE9mZnNldCkge1xuICB2YXIgc291cmNlQXJyYXk7XG5cbiAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgc291cmNlQXJyYXkgPSBuZXcgVWludDhBcnJheShzb3VyY2UpO1xuICB9IGVsc2Uge1xuICAgIHZhciBzcmNCeXRlT2Zmc2V0ID0gc291cmNlLmJ5dGVPZmZzZXQ7XG4gICAgdmFyIHNyY0J5dGVMZW5ndGggPSBzb3VyY2UuYnl0ZUxlbmd0aDtcbiAgICBzb3VyY2VBcnJheSA9IG5ldyBVaW50OEFycmF5KHNvdXJjZS5idWZmZXIgfHwgc291cmNlLmFycmF5QnVmZmVyLCBzcmNCeXRlT2Zmc2V0LCBzcmNCeXRlTGVuZ3RoKTtcbiAgfVxuXG4gIHRhcmdldC5zZXQoc291cmNlQXJyYXksIHRhcmdldE9mZnNldCk7XG4gIHJldHVybiB0YXJnZXRPZmZzZXQgKyBwYWRUb05CeXRlcyhzb3VyY2VBcnJheS5ieXRlTGVuZ3RoLCA0KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lbW9yeS1jb3B5LXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG5cbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCAnbG9hZGVyIGFzc2VydGlvbiBmYWlsZWQuJyk7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc2VydC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm5vZGVWZXJzaW9uID0gZXhwb3J0cy5pc1dvcmtlciA9IGV4cG9ydHMuaXNCcm93c2VyID0gZXhwb3J0cy5kb2N1bWVudCA9IGV4cG9ydHMuZ2xvYmFsID0gZXhwb3J0cy53aW5kb3cgPSBleHBvcnRzLnNlbGYgPSB2b2lkIDA7XG5cbnZhciBfdHlwZW9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpKTtcblxudmFyIGdsb2JhbHMgPSB7XG4gIHNlbGY6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLFxuICB3aW5kb3c6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdyxcbiAgZ2xvYmFsOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwsXG4gIGRvY3VtZW50OiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50XG59O1xudmFyIHNlbGZfID0gZ2xvYmFscy5zZWxmIHx8IGdsb2JhbHMud2luZG93IHx8IGdsb2JhbHMuZ2xvYmFsIHx8IHt9O1xuZXhwb3J0cy5zZWxmID0gc2VsZl87XG52YXIgd2luZG93XyA9IGdsb2JhbHMud2luZG93IHx8IGdsb2JhbHMuc2VsZiB8fCBnbG9iYWxzLmdsb2JhbCB8fCB7fTtcbmV4cG9ydHMud2luZG93ID0gd2luZG93XztcbnZhciBnbG9iYWxfID0gZ2xvYmFscy5nbG9iYWwgfHwgZ2xvYmFscy5zZWxmIHx8IGdsb2JhbHMud2luZG93IHx8IHt9O1xuZXhwb3J0cy5nbG9iYWwgPSBnbG9iYWxfO1xudmFyIGRvY3VtZW50XyA9IGdsb2JhbHMuZG9jdW1lbnQgfHwge307XG5leHBvcnRzLmRvY3VtZW50ID0gZG9jdW1lbnRfO1xudmFyIGlzQnJvd3NlciA9ICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjIuZGVmYXVsdCkocHJvY2VzcykpICE9PSAnb2JqZWN0JyB8fCBTdHJpbmcocHJvY2VzcykgIT09ICdbb2JqZWN0IHByb2Nlc3NdJyB8fCBwcm9jZXNzLmJyb3dzZXI7XG5leHBvcnRzLmlzQnJvd3NlciA9IGlzQnJvd3NlcjtcbnZhciBpc1dvcmtlciA9IHR5cGVvZiBpbXBvcnRTY3JpcHRzID09PSAnZnVuY3Rpb24nO1xuZXhwb3J0cy5pc1dvcmtlciA9IGlzV29ya2VyO1xudmFyIG1hdGNoZXMgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy52ZXJzaW9uICYmIC92KFswLTldKikvLmV4ZWMocHJvY2Vzcy52ZXJzaW9uKTtcbnZhciBub2RlVmVyc2lvbiA9IG1hdGNoZXMgJiYgcGFyc2VGbG9hdChtYXRjaGVzWzFdKSB8fCAwO1xuZXhwb3J0cy5ub2RlVmVyc2lvbiA9IG5vZGVWZXJzaW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2xvYmFscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmZvckVhY2ggPSBmb3JFYWNoO1xuZXhwb3J0cy5jb25jYXRlbmF0ZUFycmF5QnVmZmVyc0FzeW5jID0gY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnNBc3luYztcbmV4cG9ydHMuY29uY2F0ZW5hdGVTdHJpbmdzQXN5bmMgPSBjb25jYXRlbmF0ZVN0cmluZ3NBc3luYztcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNJdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jSXRlcmF0b3JcIikpO1xuXG52YXIgX2FycmF5QnVmZmVyVXRpbHMgPSByZXF1aXJlKFwiLi4vYmluYXJ5LXV0aWxzL2FycmF5LWJ1ZmZlci11dGlsc1wiKTtcblxuZnVuY3Rpb24gZm9yRWFjaChfeCwgX3gyKSB7XG4gIHJldHVybiBfZm9yRWFjaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZm9yRWFjaCgpIHtcbiAgX2ZvckVhY2ggPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZShpdGVyYXRvciwgdmlzaXRvcikge1xuICAgIHZhciBfeWllbGQkaXRlcmF0b3IkbmV4dCwgZG9uZSwgdmFsdWUsIGNhbmNlbDtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCF0cnVlKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yLm5leHQoKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIF95aWVsZCRpdGVyYXRvciRuZXh0ID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIGRvbmUgPSBfeWllbGQkaXRlcmF0b3IkbmV4dC5kb25lO1xuICAgICAgICAgICAgdmFsdWUgPSBfeWllbGQkaXRlcmF0b3IkbmV4dC52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgY2FuY2VsID0gdmlzaXRvcih2YWx1ZSk7XG5cbiAgICAgICAgICAgIGlmICghY2FuY2VsKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIik7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDA7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUpO1xuICB9KSk7XG4gIHJldHVybiBfZm9yRWFjaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBjb25jYXRlbmF0ZUFycmF5QnVmZmVyc0FzeW5jKF94Mykge1xuICByZXR1cm4gX2NvbmNhdGVuYXRlQXJyYXlCdWZmZXJzQXN5bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2NvbmNhdGVuYXRlQXJyYXlCdWZmZXJzQXN5bmMoKSB7XG4gIF9jb25jYXRlbmF0ZUFycmF5QnVmZmVyc0FzeW5jID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGFzeW5jSXRlcmF0b3IpIHtcbiAgICB2YXIgYXJyYXlCdWZmZXJzLCBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uLCBfZGlkSXRlcmF0b3JFcnJvciwgX2l0ZXJhdG9yRXJyb3IsIF9pdGVyYXRvciwgX3N0ZXAsIF92YWx1ZSwgY2h1bms7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBhcnJheUJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMztcbiAgICAgICAgICAgIF9pdGVyYXRvciA9ICgwLCBfYXN5bmNJdGVyYXRvcjIuZGVmYXVsdCkoYXN5bmNJdGVyYXRvcik7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDc7XG4gICAgICAgICAgICByZXR1cm4gX2l0ZXJhdG9yLm5leHQoKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIF9zdGVwID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gX3N0ZXAuZG9uZTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTE7XG4gICAgICAgICAgICByZXR1cm4gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgX3ZhbHVlID0gX2NvbnRleHQyLnNlbnQ7XG5cbiAgICAgICAgICAgIGlmIChfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaHVuayA9IF92YWx1ZTtcbiAgICAgICAgICAgIGFycmF5QnVmZmVycy5wdXNoKGNodW5rKTtcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDIwO1xuICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gX2NvbnRleHQyW1wiY2F0Y2hcIl0oMyk7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IF9jb250ZXh0Mi50MDtcblxuICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDI0O1xuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAyNTtcblxuICAgICAgICAgICAgaWYgKCEoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyOTtcbiAgICAgICAgICAgIHJldHVybiBfaXRlcmF0b3IucmV0dXJuKCk7XG5cbiAgICAgICAgICBjYXNlIDI5OlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAyOTtcblxuICAgICAgICAgICAgaWYgKCFfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDMyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG5cbiAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5maW5pc2goMjkpO1xuXG4gICAgICAgICAgY2FzZSAzMzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuZmluaXNoKDI0KTtcblxuICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBfYXJyYXlCdWZmZXJVdGlscy5jb25jYXRlbmF0ZUFycmF5QnVmZmVycy5hcHBseSh2b2lkIDAsIGFycmF5QnVmZmVycykpO1xuXG4gICAgICAgICAgY2FzZSAzNTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyLCBudWxsLCBbWzMsIDIwLCAyNCwgMzRdLCBbMjUsLCAyOSwgMzNdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9jb25jYXRlbmF0ZUFycmF5QnVmZmVyc0FzeW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGNvbmNhdGVuYXRlU3RyaW5nc0FzeW5jKF94NCkge1xuICByZXR1cm4gX2NvbmNhdGVuYXRlU3RyaW5nc0FzeW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9jb25jYXRlbmF0ZVN0cmluZ3NBc3luYygpIHtcbiAgX2NvbmNhdGVuYXRlU3RyaW5nc0FzeW5jID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKGFzeW5jSXRlcmF0b3IpIHtcbiAgICB2YXIgc3RyaW5ncywgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIsIF9kaWRJdGVyYXRvckVycm9yMiwgX2l0ZXJhdG9yRXJyb3IyLCBfaXRlcmF0b3IyLCBfc3RlcDIsIF92YWx1ZTIsIGNodW5rO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgc3RyaW5ncyA9IFtdO1xuICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDM7XG4gICAgICAgICAgICBfaXRlcmF0b3IyID0gKDAsIF9hc3luY0l0ZXJhdG9yMi5kZWZhdWx0KShhc3luY0l0ZXJhdG9yKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNztcbiAgICAgICAgICAgIHJldHVybiBfaXRlcmF0b3IyLm5leHQoKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIF9zdGVwMiA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSBfc3RlcDIuZG9uZTtcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTE7XG4gICAgICAgICAgICByZXR1cm4gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIF92YWx1ZTIgPSBfY29udGV4dDMuc2VudDtcblxuICAgICAgICAgICAgaWYgKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaHVuayA9IF92YWx1ZTI7XG4gICAgICAgICAgICBzdHJpbmdzLnB1c2goY2h1bmspO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDIwO1xuICAgICAgICAgICAgX2NvbnRleHQzLnQwID0gX2NvbnRleHQzW1wiY2F0Y2hcIl0oMyk7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gX2NvbnRleHQzLnQwO1xuXG4gICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMjQ7XG4gICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDI1O1xuXG4gICAgICAgICAgICBpZiAoISghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4gIT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAyOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjk7XG4gICAgICAgICAgICByZXR1cm4gX2l0ZXJhdG9yMi5yZXR1cm4oKTtcblxuICAgICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDI5O1xuXG4gICAgICAgICAgICBpZiAoIV9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDMyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuXG4gICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuZmluaXNoKDI5KTtcblxuICAgICAgICAgIGNhc2UgMzM6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmZpbmlzaCgyNCk7XG5cbiAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgc3RyaW5ncy5qb2luKCcnKSk7XG5cbiAgICAgICAgICBjYXNlIDM1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTMsIG51bGwsIFtbMywgMjAsIDI0LCAzNF0sIFsyNSwsIDI5LCAzM11dKTtcbiAgfSkpO1xuICByZXR1cm4gX2NvbmNhdGVuYXRlU3RyaW5nc0FzeW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3luYy1pdGVyYXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5tYWtlVGV4dERlY29kZXJJdGVyYXRvciA9IG1ha2VUZXh0RGVjb2Rlckl0ZXJhdG9yO1xuZXhwb3J0cy5tYWtlVGV4dEVuY29kZXJJdGVyYXRvciA9IG1ha2VUZXh0RW5jb2Rlckl0ZXJhdG9yO1xuZXhwb3J0cy5tYWtlTGluZUl0ZXJhdG9yID0gbWFrZUxpbmVJdGVyYXRvcjtcbmV4cG9ydHMubWFrZU51bWJlcmVkTGluZUl0ZXJhdG9yID0gbWFrZU51bWJlcmVkTGluZUl0ZXJhdG9yO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2F3YWl0QXN5bmNHZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hd2FpdEFzeW5jR2VuZXJhdG9yXCIpKTtcblxudmFyIF93cmFwQXN5bmNHZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy93cmFwQXN5bmNHZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jSXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY0l0ZXJhdG9yXCIpKTtcblxuZnVuY3Rpb24gbWFrZVRleHREZWNvZGVySXRlcmF0b3IoX3gpIHtcbiAgcmV0dXJuIF9tYWtlVGV4dERlY29kZXJJdGVyYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfbWFrZVRleHREZWNvZGVySXRlcmF0b3IoKSB7XG4gIF9tYWtlVGV4dERlY29kZXJJdGVyYXRvciA9ICgwLCBfd3JhcEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoYXJyYXlCdWZmZXJJdGVyYXRvcikge1xuICAgIHZhciBvcHRpb25zLFxuICAgICAgICB0ZXh0RGVjb2RlcixcbiAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbixcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IsXG4gICAgICAgIF9pdGVyYXRvckVycm9yLFxuICAgICAgICBfaXRlcmF0b3IsXG4gICAgICAgIF9zdGVwLFxuICAgICAgICBfdmFsdWUsXG4gICAgICAgIGFycmF5QnVmZmVyLFxuICAgICAgICBfYXJncyA9IGFyZ3VtZW50cztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgb3B0aW9ucyA9IF9hcmdzLmxlbmd0aCA+IDEgJiYgX2FyZ3NbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzWzFdIDoge307XG4gICAgICAgICAgICB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2Rlcih1bmRlZmluZWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDQ7XG4gICAgICAgICAgICBfaXRlcmF0b3IgPSAoMCwgX2FzeW5jSXRlcmF0b3IyLmRlZmF1bHQpKGFycmF5QnVmZmVySXRlcmF0b3IpO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDg7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9hd2FpdEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShfaXRlcmF0b3IubmV4dCgpKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIF9zdGVwID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSBfc3RlcC5kb25lO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEyO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfYXdhaXRBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoX3N0ZXAudmFsdWUpO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIF92YWx1ZSA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgIGlmIChfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFycmF5QnVmZmVyID0gX3ZhbHVlO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE3O1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhcnJheUJ1ZmZlciA9PT0gJ3N0cmluZycgPyBhcnJheUJ1ZmZlciA6IHRleHREZWNvZGVyLmRlY29kZShhcnJheUJ1ZmZlciwge1xuICAgICAgICAgICAgICBzdHJlYW06IHRydWVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjY7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjI7XG4gICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oNCk7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IF9jb250ZXh0LnQwO1xuXG4gICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyNjtcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyNztcblxuICAgICAgICAgICAgaWYgKCEoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMzE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMzE7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9hd2FpdEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShfaXRlcmF0b3IucmV0dXJuKCkpO1xuXG4gICAgICAgICAgY2FzZSAzMTpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAzMTtcblxuICAgICAgICAgICAgaWYgKCFfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMzQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcblxuICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDMxKTtcblxuICAgICAgICAgIGNhc2UgMzU6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDI2KTtcblxuICAgICAgICAgIGNhc2UgMzY6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbNCwgMjIsIDI2LCAzNl0sIFsyNywsIDMxLCAzNV1dKTtcbiAgfSkpO1xuICByZXR1cm4gX21ha2VUZXh0RGVjb2Rlckl0ZXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIG1ha2VUZXh0RW5jb2Rlckl0ZXJhdG9yKF94Mikge1xuICByZXR1cm4gX21ha2VUZXh0RW5jb2Rlckl0ZXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9tYWtlVGV4dEVuY29kZXJJdGVyYXRvcigpIHtcbiAgX21ha2VUZXh0RW5jb2Rlckl0ZXJhdG9yID0gKDAsIF93cmFwQXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIodGV4dEl0ZXJhdG9yKSB7XG4gICAgdmFyIHRleHRFbmNvZGVyLCBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiwgX2RpZEl0ZXJhdG9yRXJyb3IyLCBfaXRlcmF0b3JFcnJvcjIsIF9pdGVyYXRvcjIsIF9zdGVwMiwgX3ZhbHVlMiwgdGV4dDtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMztcbiAgICAgICAgICAgIF9pdGVyYXRvcjIgPSAoMCwgX2FzeW5jSXRlcmF0b3IyLmRlZmF1bHQpKHRleHRJdGVyYXRvcik7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDc7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9hd2FpdEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShfaXRlcmF0b3IyLm5leHQoKSk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBfc3RlcDIgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gX3N0ZXAyLmRvbmU7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDExO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfYXdhaXRBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoX3N0ZXAyLnZhbHVlKTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBfdmFsdWUyID0gX2NvbnRleHQyLnNlbnQ7XG5cbiAgICAgICAgICAgIGlmIChfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMikge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGV4dCA9IF92YWx1ZTI7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE2O1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0ZXh0ID09PSAnc3RyaW5nJyA/IHRleHRFbmNvZGVyLmVuY29kZSh0ZXh0KSA6IHRleHQ7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA1O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyNTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMjE7XG4gICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDJbXCJjYXRjaFwiXSgzKTtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjIgPSBfY29udGV4dDIudDA7XG5cbiAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAyNTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMjY7XG5cbiAgICAgICAgICAgIGlmICghKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybiAhPSBudWxsKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDMwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAzMDtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2F3YWl0QXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKF9pdGVyYXRvcjIucmV0dXJuKCkpO1xuXG4gICAgICAgICAgY2FzZSAzMDpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMzA7XG5cbiAgICAgICAgICAgIGlmICghX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMzM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG5cbiAgICAgICAgICBjYXNlIDMzOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5maW5pc2goMzApO1xuXG4gICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuZmluaXNoKDI1KTtcblxuICAgICAgICAgIGNhc2UgMzU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMiwgbnVsbCwgW1szLCAyMSwgMjUsIDM1XSwgWzI2LCwgMzAsIDM0XV0pO1xuICB9KSk7XG4gIHJldHVybiBfbWFrZVRleHRFbmNvZGVySXRlcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gbWFrZUxpbmVJdGVyYXRvcihfeDMpIHtcbiAgcmV0dXJuIF9tYWtlTGluZUl0ZXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9tYWtlTGluZUl0ZXJhdG9yKCkge1xuICBfbWFrZUxpbmVJdGVyYXRvciA9ICgwLCBfd3JhcEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKHRleHRJdGVyYXRvcikge1xuICAgIHZhciBwcmV2aW91cywgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMsIF9kaWRJdGVyYXRvckVycm9yMywgX2l0ZXJhdG9yRXJyb3IzLCBfaXRlcmF0b3IzLCBfc3RlcDMsIF92YWx1ZTMsIHRleHRDaHVuaywgZW9sSW5kZXgsIGxpbmU7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBwcmV2aW91cyA9ICcnO1xuICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlO1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IzID0gZmFsc2U7XG4gICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDM7XG4gICAgICAgICAgICBfaXRlcmF0b3IzID0gKDAsIF9hc3luY0l0ZXJhdG9yMi5kZWZhdWx0KSh0ZXh0SXRlcmF0b3IpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA3O1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfYXdhaXRBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoX2l0ZXJhdG9yMy5uZXh0KCkpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgX3N0ZXAzID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IF9zdGVwMy5kb25lO1xuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxMTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2F3YWl0QXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKF9zdGVwMy52YWx1ZSk7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgX3ZhbHVlMyA9IF9jb250ZXh0My5zZW50O1xuXG4gICAgICAgICAgICBpZiAoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAyNjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRleHRDaHVuayA9IF92YWx1ZTM7XG4gICAgICAgICAgICBwcmV2aW91cyArPSB0ZXh0Q2h1bms7XG4gICAgICAgICAgICBlb2xJbmRleCA9IHZvaWQgMDtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBpZiAoISgoZW9sSW5kZXggPSBwcmV2aW91cy5pbmRleE9mKCdcXG4nKSkgPj0gMCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAyMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpbmUgPSBwcmV2aW91cy5zbGljZSgwLCBlb2xJbmRleCArIDEpO1xuICAgICAgICAgICAgcHJldmlvdXMgPSBwcmV2aW91cy5zbGljZShlb2xJbmRleCArIDEpO1xuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAyMTtcbiAgICAgICAgICAgIHJldHVybiBsaW5lO1xuXG4gICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTY7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWU7XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDMyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDI4OlxuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAyODtcbiAgICAgICAgICAgIF9jb250ZXh0My50MCA9IF9jb250ZXh0M1tcImNhdGNoXCJdKDMpO1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IzID0gdHJ1ZTtcbiAgICAgICAgICAgIF9pdGVyYXRvckVycm9yMyA9IF9jb250ZXh0My50MDtcblxuICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDMyO1xuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAzMztcblxuICAgICAgICAgICAgaWYgKCEoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuICE9IG51bGwpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMzc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDM3O1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfYXdhaXRBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoX2l0ZXJhdG9yMy5yZXR1cm4oKSk7XG5cbiAgICAgICAgICBjYXNlIDM3OlxuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAzNztcblxuICAgICAgICAgICAgaWYgKCFfZGlkSXRlcmF0b3JFcnJvcjMpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA0MDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMztcblxuICAgICAgICAgIGNhc2UgNDA6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmZpbmlzaCgzNyk7XG5cbiAgICAgICAgICBjYXNlIDQxOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5maW5pc2goMzIpO1xuXG4gICAgICAgICAgY2FzZSA0MjpcbiAgICAgICAgICAgIGlmICghKHByZXZpb3VzLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNDU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDQ1O1xuICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzO1xuXG4gICAgICAgICAgY2FzZSA0NTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUzLCBudWxsLCBbWzMsIDI4LCAzMiwgNDJdLCBbMzMsLCAzNywgNDFdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9tYWtlTGluZUl0ZXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIG1ha2VOdW1iZXJlZExpbmVJdGVyYXRvcihfeDQpIHtcbiAgcmV0dXJuIF9tYWtlTnVtYmVyZWRMaW5lSXRlcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX21ha2VOdW1iZXJlZExpbmVJdGVyYXRvcigpIHtcbiAgX21ha2VOdW1iZXJlZExpbmVJdGVyYXRvciA9ICgwLCBfd3JhcEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KGxpbmVJdGVyYXRvcikge1xuICAgIHZhciBjb3VudGVyLCBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCwgX2RpZEl0ZXJhdG9yRXJyb3I0LCBfaXRlcmF0b3JFcnJvcjQsIF9pdGVyYXRvcjQsIF9zdGVwNCwgX3ZhbHVlNCwgbGluZTtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNvdW50ZXIgPSAxO1xuICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSB0cnVlO1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I0ID0gZmFsc2U7XG4gICAgICAgICAgICBfY29udGV4dDQucHJldiA9IDM7XG4gICAgICAgICAgICBfaXRlcmF0b3I0ID0gKDAsIF9hc3luY0l0ZXJhdG9yMi5kZWZhdWx0KShsaW5lSXRlcmF0b3IpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA3O1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfYXdhaXRBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoX2l0ZXJhdG9yNC5uZXh0KCkpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgX3N0ZXA0ID0gX2NvbnRleHQ0LnNlbnQ7XG4gICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IF9zdGVwNC5kb25lO1xuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2F3YWl0QXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKF9zdGVwNC52YWx1ZSk7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgX3ZhbHVlNCA9IF9jb250ZXh0NC5zZW50O1xuXG4gICAgICAgICAgICBpZiAoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAyMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpbmUgPSBfdmFsdWU0O1xuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAxNjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGNvdW50ZXI6IGNvdW50ZXIsXG4gICAgICAgICAgICAgIGxpbmU6IGxpbmVcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgY291bnRlcisrO1xuXG4gICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZTtcbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gNTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMjY7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICBfY29udGV4dDQucHJldiA9IDIyO1xuICAgICAgICAgICAgX2NvbnRleHQ0LnQwID0gX2NvbnRleHQ0W1wiY2F0Y2hcIl0oMyk7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjQgPSB0cnVlO1xuICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3I0ID0gX2NvbnRleHQ0LnQwO1xuXG4gICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gMjY7XG4gICAgICAgICAgICBfY29udGV4dDQucHJldiA9IDI3O1xuXG4gICAgICAgICAgICBpZiAoISghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgJiYgX2l0ZXJhdG9yNC5yZXR1cm4gIT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAzMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMzE7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9hd2FpdEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShfaXRlcmF0b3I0LnJldHVybigpKTtcblxuICAgICAgICAgIGNhc2UgMzE6XG4gICAgICAgICAgICBfY29udGV4dDQucHJldiA9IDMxO1xuXG4gICAgICAgICAgICBpZiAoIV9kaWRJdGVyYXRvckVycm9yNCkge1xuICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDM0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I0O1xuXG4gICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuZmluaXNoKDMxKTtcblxuICAgICAgICAgIGNhc2UgMzU6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmZpbmlzaCgyNik7XG5cbiAgICAgICAgICBjYXNlIDM2OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTQsIG51bGwsIFtbMywgMjIsIDI2LCAzNl0sIFsyNywsIDMxLCAzNV1dKTtcbiAgfSkpO1xuICByZXR1cm4gX21ha2VOdW1iZXJlZExpbmVJdGVyYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGV4dC1pdGVyYXRvcnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnBhcnNlSlNPTiA9IHBhcnNlSlNPTjtcblxudmFyIF9nZXRGaXJzdENoYXJhY3RlcnMgPSByZXF1aXJlKFwiLi4vYmluYXJ5LXV0aWxzL2dldC1maXJzdC1jaGFyYWN0ZXJzXCIpO1xuXG5mdW5jdGlvbiBwYXJzZUpTT04oc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyaW5nKTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBwYXJzZSBKU09OIGZyb20gZGF0YSBzdGFydGluZyB3aXRoIFxcXCJcIi5jb25jYXQoKDAsIF9nZXRGaXJzdENoYXJhY3RlcnMuZ2V0Rmlyc3RDaGFyYWN0ZXJzKShzdHJpbmcpLCBcIlxcXCJcIikpO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZS1qc29uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5zZXRQYXRoUHJlZml4ID0gc2V0UGF0aFByZWZpeDtcbmV4cG9ydHMuZ2V0UGF0aFByZWZpeCA9IGdldFBhdGhQcmVmaXg7XG5leHBvcnRzLmFkZEFsaWFzZXMgPSBhZGRBbGlhc2VzO1xuZXhwb3J0cy5yZXNvbHZlUGF0aCA9IHJlc29sdmVQYXRoO1xudmFyIHBhdGhQcmVmaXggPSAnJztcbnZhciBmaWxlQWxpYXNlcyA9IHt9O1xuXG5mdW5jdGlvbiBzZXRQYXRoUHJlZml4KHByZWZpeCkge1xuICBwYXRoUHJlZml4ID0gcHJlZml4O1xufVxuXG5mdW5jdGlvbiBnZXRQYXRoUHJlZml4KCkge1xuICByZXR1cm4gcGF0aFByZWZpeDtcbn1cblxuZnVuY3Rpb24gYWRkQWxpYXNlcyhhbGlhc2VzKSB7XG4gIE9iamVjdC5hc3NpZ24oZmlsZUFsaWFzZXMsIGFsaWFzZXMpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlUGF0aChmaWxlbmFtZSkge1xuICBmb3IgKHZhciBhbGlhcyBpbiBmaWxlQWxpYXNlcykge1xuICAgIGlmIChmaWxlbmFtZS5zdGFydHNXaXRoKGFsaWFzKSkge1xuICAgICAgdmFyIHJlcGxhY2VtZW50ID0gZmlsZUFsaWFzZXNbYWxpYXNdO1xuICAgICAgZmlsZW5hbWUgPSBmaWxlbmFtZS5yZXBsYWNlKGFsaWFzLCByZXBsYWNlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFmaWxlbmFtZS5zdGFydHNXaXRoKCdodHRwOi8vJykgJiYgIWZpbGVuYW1lLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJykpIHtcbiAgICBmaWxlbmFtZSA9IFwiXCIuY29uY2F0KHBhdGhQcmVmaXgpLmNvbmNhdChmaWxlbmFtZSk7XG4gIH1cblxuICByZXR1cm4gZmlsZW5hbWU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWxlLWFsaWFzZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRpcm5hbWUgPSBkaXJuYW1lO1xuZXhwb3J0cy5qb2luID0gam9pbjtcblxuZnVuY3Rpb24gZGlybmFtZSh1cmwpIHtcbiAgdmFyIHNsYXNoSW5kZXggPSB1cmwgJiYgdXJsLmxhc3RJbmRleE9mKCcvJyk7XG4gIHJldHVybiBzbGFzaEluZGV4ID49IDAgPyB1cmwuc3Vic3RyKDAsIHNsYXNoSW5kZXgpIDogJyc7XG59XG5cbmZ1bmN0aW9uIGpvaW4oKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwYXJ0cyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBwYXJ0c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHZhciBzZXBhcmF0b3IgPSAnLyc7XG4gIHBhcnRzID0gcGFydHMubWFwKGZ1bmN0aW9uIChwYXJ0LCBpbmRleCkge1xuICAgIGlmIChpbmRleCkge1xuICAgICAgcGFydCA9IHBhcnQucmVwbGFjZShuZXcgUmVnRXhwKFwiXlwiLmNvbmNhdChzZXBhcmF0b3IpKSwgJycpO1xuICAgIH1cblxuICAgIGlmIChpbmRleCAhPT0gcGFydHMubGVuZ3RoIC0gMSkge1xuICAgICAgcGFydCA9IHBhcnQucmVwbGFjZShuZXcgUmVnRXhwKFwiXCIuY29uY2F0KHNlcGFyYXRvciwgXCIkXCIpKSwgJycpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJ0O1xuICB9KTtcbiAgcmV0dXJuIHBhcnRzLmpvaW4oc2VwYXJhdG9yKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX3N0YXRzID0gcmVxdWlyZShcIkBwcm9iZS5nbC9zdGF0c1wiKTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBTVEFUX1FVRVVFRF9SRVFVRVNUUyA9ICdRdWV1ZWQgUmVxdWVzdHMnO1xudmFyIFNUQVRfQUNUSVZFX1JFUVVFU1RTID0gJ0FjdGl2ZSBSZXF1ZXN0cyc7XG52YXIgU1RBVF9DQU5DRUxMRURfUkVRVUVTVFMgPSAnQ2FuY2VsbGVkIFJlcXVlc3RzJztcbnZhciBTVEFUX1FVRVVFRF9SRVFVRVNUU19FVkVSID0gJ1F1ZXVlZCBSZXF1ZXN0cyBFdmVyJztcbnZhciBTVEFUX0FDVElWRV9SRVFVRVNUU19FVkVSID0gJ0FjdGl2ZSBSZXF1ZXN0cyBFdmVyJztcbnZhciBERUZBVUxUX1BST1BTID0ge1xuICBpZDogJ3JlcXVlc3Qtc2NoZWR1bGVyJyxcbiAgdGhyb3R0bGVSZXF1ZXN0czogdHJ1ZSxcbiAgbWF4UmVxdWVzdHM6IDZcbn07XG5cbnZhciBSZXF1ZXN0U2NoZWR1bGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZXF1ZXN0U2NoZWR1bGVyKCkge1xuICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgUmVxdWVzdFNjaGVkdWxlcik7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJwcm9wc1wiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwic3RhdHNcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcImFjdGl2ZVJlcXVlc3RDb3VudFwiLCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcInJlcXVlc3RRdWV1ZVwiLCBbXSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJyZXF1ZXN0TWFwXCIsIG5ldyBNYXAoKSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJkZWZlcnJlZFVwZGF0ZVwiLCBudWxsKTtcbiAgICB0aGlzLnByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBERUZBVUxUX1BST1BTKSwgcHJvcHMpO1xuICAgIHRoaXMuc3RhdHMgPSBuZXcgX3N0YXRzLlN0YXRzKHtcbiAgICAgIGlkOiB0aGlzLnByb3BzLmlkXG4gICAgfSk7XG4gICAgdGhpcy5zdGF0cy5nZXQoU1RBVF9RVUVVRURfUkVRVUVTVFMpO1xuICAgIHRoaXMuc3RhdHMuZ2V0KFNUQVRfQUNUSVZFX1JFUVVFU1RTKTtcbiAgICB0aGlzLnN0YXRzLmdldChTVEFUX0NBTkNFTExFRF9SRVFVRVNUUyk7XG4gICAgdGhpcy5zdGF0cy5nZXQoU1RBVF9RVUVVRURfUkVRVUVTVFNfRVZFUik7XG4gICAgdGhpcy5zdGF0cy5nZXQoU1RBVF9BQ1RJVkVfUkVRVUVTVFNfRVZFUik7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShSZXF1ZXN0U2NoZWR1bGVyLCBbe1xuICAgIGtleTogXCJzY2hlZHVsZVJlcXVlc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2NoZWR1bGVSZXF1ZXN0KGhhbmRsZSkge1xuICAgICAgdmFyIGdldFByaW9yaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfTtcblxuICAgICAgaWYgKCF0aGlzLnByb3BzLnRocm90dGxlUmVxdWVzdHMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgZG9uZTogZnVuY3Rpb24gZG9uZSgpIHt9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5yZXF1ZXN0TWFwLmhhcyhoYW5kbGUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RNYXAuZ2V0KGhhbmRsZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXF1ZXN0ID0ge1xuICAgICAgICBoYW5kbGU6IGhhbmRsZSxcbiAgICAgICAgcHJpb3JpdHk6IDAsXG4gICAgICAgIGdldFByaW9yaXR5OiBnZXRQcmlvcml0eVxuICAgICAgfTtcbiAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgcmVxdWVzdC5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucmVxdWVzdFF1ZXVlLnB1c2gocmVxdWVzdCk7XG4gICAgICB0aGlzLnJlcXVlc3RNYXAuc2V0KGhhbmRsZSwgcHJvbWlzZSk7XG5cbiAgICAgIHRoaXMuX2lzc3VlTmV3UmVxdWVzdHMoKTtcblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9pc3N1ZVJlcXVlc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzc3VlUmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgaGFuZGxlID0gcmVxdWVzdC5oYW5kbGUsXG4gICAgICAgICAgcmVzb2x2ZSA9IHJlcXVlc3QucmVzb2x2ZTtcbiAgICAgIHZhciBpc0RvbmUgPSBmYWxzZTtcblxuICAgICAgdmFyIGRvbmUgPSBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgICBpZiAoIWlzRG9uZSkge1xuICAgICAgICAgIGlzRG9uZSA9IHRydWU7XG5cbiAgICAgICAgICBfdGhpcy5yZXF1ZXN0TWFwLmRlbGV0ZShoYW5kbGUpO1xuXG4gICAgICAgICAgX3RoaXMuYWN0aXZlUmVxdWVzdENvdW50LS07XG5cbiAgICAgICAgICBfdGhpcy5faXNzdWVOZXdSZXF1ZXN0cygpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmFjdGl2ZVJlcXVlc3RDb3VudCsrO1xuICAgICAgcmV0dXJuIHJlc29sdmUgPyByZXNvbHZlKHtcbiAgICAgICAgZG9uZTogZG9uZVxuICAgICAgfSkgOiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICBkb25lOiBkb25lXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2lzc3VlTmV3UmVxdWVzdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzc3VlTmV3UmVxdWVzdHMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLmRlZmVycmVkVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuZGVmZXJyZWRVcGRhdGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLl9pc3N1ZU5ld1JlcXVlc3RzQXN5bmMoKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9pc3N1ZU5ld1JlcXVlc3RzQXN5bmNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzc3VlTmV3UmVxdWVzdHNBc3luYygpIHtcbiAgICAgIHRoaXMuZGVmZXJyZWRVcGRhdGUgPSBudWxsO1xuICAgICAgdmFyIGZyZWVTbG90cyA9IE1hdGgubWF4KHRoaXMucHJvcHMubWF4UmVxdWVzdHMgLSB0aGlzLmFjdGl2ZVJlcXVlc3RDb3VudCwgMCk7XG5cbiAgICAgIGlmIChmcmVlU2xvdHMgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl91cGRhdGVBbGxSZXF1ZXN0cygpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyZWVTbG90czsgKytpKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0UXVldWUuc2hpZnQoKTtcblxuICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgIHRoaXMuX2lzc3VlUmVxdWVzdChyZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlQWxsUmVxdWVzdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUFsbFJlcXVlc3RzKCkge1xuICAgICAgdmFyIHJlcXVlc3RRdWV1ZSA9IHRoaXMucmVxdWVzdFF1ZXVlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcXVlc3RRdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHJlcXVlc3RRdWV1ZVtpXTtcblxuICAgICAgICBpZiAoIXRoaXMuX3VwZGF0ZVJlcXVlc3QocmVxdWVzdCkpIHtcbiAgICAgICAgICByZXF1ZXN0UXVldWUuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIHRoaXMucmVxdWVzdE1hcC5kZWxldGUocmVxdWVzdC5oYW5kbGUpO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXF1ZXN0UXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZVJlcXVlc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVJlcXVlc3QocmVxdWVzdCkge1xuICAgICAgcmVxdWVzdC5wcmlvcml0eSA9IHJlcXVlc3QuZ2V0UHJpb3JpdHkocmVxdWVzdC5oYW5kbGUpO1xuXG4gICAgICBpZiAocmVxdWVzdC5wcmlvcml0eSA8IDApIHtcbiAgICAgICAgcmVxdWVzdC5yZXNvbHZlKG51bGwpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUmVxdWVzdFNjaGVkdWxlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUmVxdWVzdFNjaGVkdWxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcXVlc3Qtc2NoZWR1bGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY3JlYXRlTG9hZGVyV29ya2VyID0gY3JlYXRlTG9hZGVyV29ya2VyO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF93b3JrZXJVdGlscyA9IHJlcXVpcmUoXCJAbG9hZGVycy5nbC93b3JrZXItdXRpbHNcIik7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgcmVxdWVzdElkID0gMDtcblxuZnVuY3Rpb24gY3JlYXRlTG9hZGVyV29ya2VyKGxvYWRlcikge1xuICBpZiAodHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgX3dvcmtlclV0aWxzLldvcmtlckJvZHkub25tZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUodHlwZSwgcGF5bG9hZCkge1xuICAgICAgdmFyIGlucHV0LCBfcGF5bG9hZCRvcHRpb25zLCBvcHRpb25zLCByZXN1bHQsIG1lc3NhZ2U7XG5cbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dC50MCA9IHR5cGU7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSBfY29udGV4dC50MCA9PT0gJ3Byb2Nlc3MnID8gMyA6IDE2O1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMztcbiAgICAgICAgICAgICAgaW5wdXQgPSBwYXlsb2FkLmlucHV0LCBfcGF5bG9hZCRvcHRpb25zID0gcGF5bG9hZC5vcHRpb25zLCBvcHRpb25zID0gX3BheWxvYWQkb3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfcGF5bG9hZCRvcHRpb25zO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRGF0YSh7XG4gICAgICAgICAgICAgICAgbG9hZGVyOiBsb2FkZXIsXG4gICAgICAgICAgICAgICAgYXJyYXlCdWZmZXI6IGlucHV0LFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAgICAgcGFyc2U6IHBhcnNlT25NYWluVGhyZWFkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgICAgIF93b3JrZXJVdGlscy5Xb3JrZXJCb2R5LnBvc3RNZXNzYWdlKCdkb25lJywge1xuICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxMTtcbiAgICAgICAgICAgICAgX2NvbnRleHQudDEgPSBfY29udGV4dFtcImNhdGNoXCJdKDMpO1xuICAgICAgICAgICAgICBtZXNzYWdlID0gX2NvbnRleHQudDEgaW5zdGFuY2VvZiBFcnJvciA/IF9jb250ZXh0LnQxLm1lc3NhZ2UgOiAnJztcblxuICAgICAgICAgICAgICBfd29ya2VyVXRpbHMuV29ya2VyQm9keS5wb3N0TWVzc2FnZSgnZXJyb3InLCB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IG1lc3NhZ2VcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJicmVha1wiLCAxNik7XG5cbiAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlLCBudWxsLCBbWzMsIDExXV0pO1xuICAgIH0pKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoX3gsIF94Mikge1xuICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9KCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlT25NYWluVGhyZWFkKGFycmF5QnVmZmVyLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIGlkID0gcmVxdWVzdElkKys7XG5cbiAgICB2YXIgb25NZXNzYWdlID0gZnVuY3Rpb24gb25NZXNzYWdlKHR5cGUsIHBheWxvYWQpIHtcbiAgICAgIGlmIChwYXlsb2FkLmlkICE9PSBpZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdkb25lJzpcbiAgICAgICAgICBfd29ya2VyVXRpbHMuV29ya2VyQm9keS5yZW1vdmVFdmVudExpc3RlbmVyKG9uTWVzc2FnZSk7XG5cbiAgICAgICAgICByZXNvbHZlKHBheWxvYWQucmVzdWx0KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgX3dvcmtlclV0aWxzLldvcmtlckJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihvbk1lc3NhZ2UpO1xuXG4gICAgICAgICAgcmVqZWN0KHBheWxvYWQuZXJyb3IpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICB9XG4gICAgfTtcblxuICAgIF93b3JrZXJVdGlscy5Xb3JrZXJCb2R5LmFkZEV2ZW50TGlzdGVuZXIob25NZXNzYWdlKTtcblxuICAgIHZhciBwYXlsb2FkID0ge1xuICAgICAgaWQ6IGlkLFxuICAgICAgaW5wdXQ6IGFycmF5QnVmZmVyLFxuICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgIH07XG5cbiAgICBfd29ya2VyVXRpbHMuV29ya2VyQm9keS5wb3N0TWVzc2FnZSgncHJvY2VzcycsIHBheWxvYWQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VEYXRhKF94Mykge1xuICByZXR1cm4gX3BhcnNlRGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfcGFyc2VEYXRhKCkge1xuICBfcGFyc2VEYXRhID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKF9yZWYyKSB7XG4gICAgdmFyIGxvYWRlciwgYXJyYXlCdWZmZXIsIG9wdGlvbnMsIGNvbnRleHQsIGRhdGEsIHBhcnNlciwgdGV4dERlY29kZXI7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgbG9hZGVyID0gX3JlZjIubG9hZGVyLCBhcnJheUJ1ZmZlciA9IF9yZWYyLmFycmF5QnVmZmVyLCBvcHRpb25zID0gX3JlZjIub3B0aW9ucywgY29udGV4dCA9IF9yZWYyLmNvbnRleHQ7XG5cbiAgICAgICAgICAgIGlmICghKGxvYWRlci5wYXJzZVN5bmMgfHwgbG9hZGVyLnBhcnNlKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRhID0gYXJyYXlCdWZmZXI7XG4gICAgICAgICAgICBwYXJzZXIgPSBsb2FkZXIucGFyc2VTeW5jIHx8IGxvYWRlci5wYXJzZTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTM7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIGlmICghbG9hZGVyLnBhcnNlVGV4dFN5bmMpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICAgICAgICBkYXRhID0gdGV4dERlY29kZXIuZGVjb2RlKGFycmF5QnVmZmVyKTtcbiAgICAgICAgICAgIHBhcnNlciA9IGxvYWRlci5wYXJzZVRleHRTeW5jO1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBsb2FkIGRhdGEgd2l0aCBcIi5jb25jYXQobG9hZGVyLm5hbWUsIFwiIGxvYWRlclwiKSk7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgICAgIG1vZHVsZXM6IGxvYWRlciAmJiBsb2FkZXIub3B0aW9ucyAmJiBsb2FkZXIub3B0aW9ucy5tb2R1bGVzIHx8IHt9LFxuICAgICAgICAgICAgICB3b3JrZXI6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTY7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VyKGRhdGEsIF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpLCBjb250ZXh0LCBsb2FkZXIpO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0Mi5zZW50KTtcblxuICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMik7XG4gIH0pKTtcbiAgcmV0dXJuIF9wYXJzZURhdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZS1sb2FkZXItd29ya2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY2FuUGFyc2VXaXRoV29ya2VyID0gY2FuUGFyc2VXaXRoV29ya2VyO1xuZXhwb3J0cy5wYXJzZVdpdGhXb3JrZXIgPSBwYXJzZVdpdGhXb3JrZXI7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX3dvcmtlclV0aWxzID0gcmVxdWlyZShcIkBsb2FkZXJzLmdsL3dvcmtlci11dGlsc1wiKTtcblxuZnVuY3Rpb24gY2FuUGFyc2VXaXRoV29ya2VyKGxvYWRlciwgb3B0aW9ucykge1xuICBpZiAoIV93b3JrZXJVdGlscy5Xb3JrZXJGYXJtLmlzU3VwcG9ydGVkKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gbG9hZGVyLndvcmtlciAmJiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLndvcmtlcik7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2l0aFdvcmtlcihfeCwgX3gyLCBfeDMsIF94NCwgX3g1KSB7XG4gIHJldHVybiBfcGFyc2VXaXRoV29ya2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9wYXJzZVdpdGhXb3JrZXIoKSB7XG4gIF9wYXJzZVdpdGhXb3JrZXIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZShsb2FkZXIsIGRhdGEsIG9wdGlvbnMsIGNvbnRleHQsIHBhcnNlT25NYWluVGhyZWFkKSB7XG4gICAgdmFyIG5hbWUsIHVybCwgd29ya2VyRmFybSwgd29ya2VyUG9vbCwgam9iLCByZXN1bHQ7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBuYW1lID0gbG9hZGVyLmlkO1xuICAgICAgICAgICAgdXJsID0gKDAsIF93b3JrZXJVdGlscy5nZXRXb3JrZXJVUkwpKGxvYWRlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICB3b3JrZXJGYXJtID0gX3dvcmtlclV0aWxzLldvcmtlckZhcm0uZ2V0V29ya2VyRmFybShvcHRpb25zKTtcbiAgICAgICAgICAgIHdvcmtlclBvb2wgPSB3b3JrZXJGYXJtLmdldFdvcmtlclBvb2woe1xuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvcHRpb25zID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvcHRpb25zKSk7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgIHJldHVybiB3b3JrZXJQb29sLnN0YXJ0Sm9iKCdwcm9jZXNzLW9uLXdvcmtlcicsIG9uTWVzc2FnZS5iaW5kKG51bGwsIHBhcnNlT25NYWluVGhyZWFkKSk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBqb2IgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgam9iLnBvc3RNZXNzYWdlKCdwcm9jZXNzJywge1xuICAgICAgICAgICAgICBpbnB1dDogZGF0YSxcbiAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7XG4gICAgICAgICAgICByZXR1cm4gam9iLnJlc3VsdDtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE0O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG5cbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dC5zZW50KTtcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUpO1xuICB9KSk7XG4gIHJldHVybiBfcGFyc2VXaXRoV29ya2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIG9uTWVzc2FnZShfeDYsIF94NywgX3g4LCBfeDkpIHtcbiAgcmV0dXJuIF9vbk1lc3NhZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX29uTWVzc2FnZSgpIHtcbiAgX29uTWVzc2FnZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMihwYXJzZU9uTWFpblRocmVhZCwgam9iLCB0eXBlLCBwYXlsb2FkKSB7XG4gICAgdmFyIGlkLCBpbnB1dCwgb3B0aW9ucywgcmVzdWx0LCBtZXNzYWdlO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IHR5cGU7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IF9jb250ZXh0Mi50MCA9PT0gJ2RvbmUnID8gMyA6IF9jb250ZXh0Mi50MCA9PT0gJ2Vycm9yJyA/IDUgOiBfY29udGV4dDIudDAgPT09ICdwcm9jZXNzJyA/IDcgOiAyMDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgam9iLmRvbmUocGF5bG9hZCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcImJyZWFrXCIsIDIxKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGpvYi5lcnJvcihwYXlsb2FkLmVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwiYnJlYWtcIiwgMjEpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgaWQgPSBwYXlsb2FkLmlkLCBpbnB1dCA9IHBheWxvYWQuaW5wdXQsIG9wdGlvbnMgPSBwYXlsb2FkLm9wdGlvbnM7XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDg7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDExO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlT25NYWluVGhyZWFkKGlucHV0LCBvcHRpb25zKTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgIGpvYi5wb3N0TWVzc2FnZSgnZG9uZScsIHtcbiAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE5O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAxNTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi50MSA9IF9jb250ZXh0MltcImNhdGNoXCJdKDgpO1xuICAgICAgICAgICAgbWVzc2FnZSA9IF9jb250ZXh0Mi50MSBpbnN0YW5jZW9mIEVycm9yID8gX2NvbnRleHQyLnQxLm1lc3NhZ2UgOiAndW5rbm93biBlcnJvcic7XG4gICAgICAgICAgICBqb2IucG9zdE1lc3NhZ2UoJ2Vycm9yJywge1xuICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgIGVycm9yOiBtZXNzYWdlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcImJyZWFrXCIsIDIxKTtcblxuICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJwYXJzZS13aXRoLXdvcmtlciB1bmtub3duIG1lc3NhZ2UgXCIuY29uY2F0KHR5cGUpKTtcblxuICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMiwgbnVsbCwgW1s4LCAxNV1dKTtcbiAgfSkpO1xuICByZXR1cm4gX29uTWVzc2FnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2Utd2l0aC13b3JrZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldE1lc2hTaXplID0gZ2V0TWVzaFNpemU7XG5leHBvcnRzLmdldE1lc2hCb3VuZGluZ0JveCA9IGdldE1lc2hCb3VuZGluZ0JveDtcblxuZnVuY3Rpb24gZ2V0TWVzaFNpemUoYXR0cmlidXRlcykge1xuICB2YXIgc2l6ZSA9IDA7XG5cbiAgZm9yICh2YXIgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgdmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG5cbiAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGF0dHJpYnV0ZSkpIHtcbiAgICAgIHNpemUgKz0gYXR0cmlidXRlLmJ5dGVMZW5ndGggKiBhdHRyaWJ1dGUuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNpemU7XG59XG5cbmZ1bmN0aW9uIGdldE1lc2hCb3VuZGluZ0JveChhdHRyaWJ1dGVzKSB7XG4gIHZhciBtaW5YID0gSW5maW5pdHk7XG4gIHZhciBtaW5ZID0gSW5maW5pdHk7XG4gIHZhciBtaW5aID0gSW5maW5pdHk7XG4gIHZhciBtYXhYID0gLUluZmluaXR5O1xuICB2YXIgbWF4WSA9IC1JbmZpbml0eTtcbiAgdmFyIG1heFogPSAtSW5maW5pdHk7XG4gIHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLlBPU0lUSU9OID8gYXR0cmlidXRlcy5QT1NJVElPTi52YWx1ZSA6IFtdO1xuICB2YXIgbGVuID0gcG9zaXRpb25zICYmIHBvc2l0aW9ucy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMykge1xuICAgIHZhciB4ID0gcG9zaXRpb25zW2ldO1xuICAgIHZhciB5ID0gcG9zaXRpb25zW2kgKyAxXTtcbiAgICB2YXIgeiA9IHBvc2l0aW9uc1tpICsgMl07XG4gICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XG4gICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgbWluWiA9IHogPCBtaW5aID8geiA6IG1pblo7XG4gICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XG4gICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XG4gICAgbWF4WiA9IHogPiBtYXhaID8geiA6IG1heFo7XG4gIH1cblxuICByZXR1cm4gW1ttaW5YLCBtaW5ZLCBtaW5aXSwgW21heFgsIG1heFksIG1heFpdXTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lc2gtdXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGFibGVCYXRjaEJ1aWxkZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3RhYmxlQmF0Y2hCdWlsZGVyLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUm93VGFibGVCYXRjaEFnZ3JlZ2F0b3JcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3Jvd1RhYmxlQmF0Y2hBZ2dyZWdhdG9yLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29sdW1uYXJUYWJsZUJhdGNoQWdncmVnYXRvclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfY29sdW1uYXJUYWJsZUJhdGNoQWdncmVnYXRvci5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbnZlcnRUb09iamVjdFJvd1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfcm93VXRpbHMuY29udmVydFRvT2JqZWN0Um93O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbnZlcnRUb0FycmF5Um93XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9yb3dVdGlscy5jb252ZXJ0VG9BcnJheVJvdztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRNZXNoU2l6ZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbWVzaFV0aWxzLmdldE1lc2hTaXplO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldE1lc2hCb3VuZGluZ0JveFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbWVzaFV0aWxzLmdldE1lc2hCb3VuZGluZ0JveDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTY2hlbWFcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5TY2hlbWE7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmllbGRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5GaWVsZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEYXRhVHlwZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLkRhdGFUeXBlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk51bGxcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5OdWxsO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJpbmFyeVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLkJpbmFyeTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCb29sXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuQm9vbDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5JbnQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW50OFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLkludDg7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW50MTZcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5JbnQxNjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnQzMlwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLkludDMyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludDY0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuSW50NjQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVWludDhcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5VaW50ODtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVaW50MTZcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5VaW50MTY7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVWludDMyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuVWludDMyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVpbnQ2NFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLlVpbnQ2NDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGbG9hdFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLkZsb2F0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZsb2F0MTZcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5GbG9hdDE2O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZsb2F0MzJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5GbG9hdDMyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZsb2F0NjRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5GbG9hdDY0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlV0ZjhcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5VdGY4O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRhdGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5EYXRlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRhdGVEYXlcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5EYXRlRGF5O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRhdGVNaWxsaXNlY29uZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLkRhdGVNaWxsaXNlY29uZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUaW1lXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuVGltZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUaW1lTWlsbGlzZWNvbmRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5UaW1lTWlsbGlzZWNvbmQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGltZVNlY29uZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLlRpbWVTZWNvbmQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGltZXN0YW1wXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuVGltZXN0YW1wO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRpbWVzdGFtcFNlY29uZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLlRpbWVzdGFtcFNlY29uZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUaW1lc3RhbXBNaWxsaXNlY29uZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLlRpbWVzdGFtcE1pbGxpc2Vjb25kO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRpbWVzdGFtcE1pY3Jvc2Vjb25kXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuVGltZXN0YW1wTWljcm9zZWNvbmQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGltZXN0YW1wTmFub3NlY29uZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLlRpbWVzdGFtcE5hbm9zZWNvbmQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW50ZXJ2YWxcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5JbnRlcnZhbDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnRlcnZhbERheVRpbWVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5JbnRlcnZhbERheVRpbWU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW50ZXJ2YWxZZWFyTW9udGhcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5JbnRlcnZhbFllYXJNb250aDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGaXhlZFNpemVMaXN0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuRml4ZWRTaXplTGlzdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWR1Y2VUYWJsZVNjaGVtYVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZGVkdWNlVGFibGVTY2hlbWEuZGVkdWNlVGFibGVTY2hlbWE7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0VHlwZUluZm9cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dldFR5cGVJbmZvLmdldFR5cGVJbmZvO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEFycm93VHlwZUZyb21UeXBlZEFycmF5XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlVXRpbHMuZ2V0QXJyb3dUeXBlRnJvbVR5cGVkQXJyYXk7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXN5bmNRdWV1ZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYXN5bmNRdWV1ZS5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF90YWJsZUJhdGNoQnVpbGRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL3RhYmxlL3RhYmxlLWJhdGNoLWJ1aWxkZXJcIikpO1xuXG52YXIgX3Jvd1RhYmxlQmF0Y2hBZ2dyZWdhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvdGFibGUvcm93LXRhYmxlLWJhdGNoLWFnZ3JlZ2F0b3JcIikpO1xuXG52YXIgX2NvbHVtbmFyVGFibGVCYXRjaEFnZ3JlZ2F0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi90YWJsZS9jb2x1bW5hci10YWJsZS1iYXRjaC1hZ2dyZWdhdG9yXCIpKTtcblxudmFyIF9yb3dVdGlscyA9IHJlcXVpcmUoXCIuL2xpYi91dGlscy9yb3ctdXRpbHNcIik7XG5cbnZhciBfbWVzaFV0aWxzID0gcmVxdWlyZShcIi4vY2F0ZWdvcnkvbWVzaC9tZXNoLXV0aWxzXCIpO1xuXG52YXIgX3NjaGVtYSA9IHJlcXVpcmUoXCIuL2xpYi9zY2hlbWFcIik7XG5cbnZhciBfZGVkdWNlVGFibGVTY2hlbWEgPSByZXF1aXJlKFwiLi9saWIvc2NoZW1hLXV0aWxzL2RlZHVjZS10YWJsZS1zY2hlbWFcIik7XG5cbnZhciBfZ2V0VHlwZUluZm8gPSByZXF1aXJlKFwiLi9saWIvc2NoZW1hLXV0aWxzL2dldC10eXBlLWluZm9cIik7XG5cbnZhciBfdHlwZVV0aWxzID0gcmVxdWlyZShcIi4vbGliL3NjaGVtYS11dGlscy90eXBlLXV0aWxzXCIpO1xuXG52YXIgX2FzeW5jUXVldWUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi91dGlscy9hc3luYy1xdWV1ZVwiKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVkdWNlVGFibGVTY2hlbWEgPSBkZWR1Y2VUYWJsZVNjaGVtYTtcblxuZnVuY3Rpb24gZGVkdWNlVGFibGVTY2hlbWEodGFibGUsIHNjaGVtYSkge1xuICB2YXIgZGVkdWNlZFNjaGVtYSA9IEFycmF5LmlzQXJyYXkodGFibGUpID8gZGVkdWNlU2NoZW1hRm9yUm93VGFibGUodGFibGUpIDogZGVkdWNlU2NoZW1hRm9yQ29sdW1uYXJUYWJsZSh0YWJsZSk7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKGRlZHVjZWRTY2hlbWEsIHNjaGVtYSk7XG59XG5cbmZ1bmN0aW9uIGRlZHVjZVNjaGVtYUZvckNvbHVtbmFyVGFibGUoY29sdW1uYXJUYWJsZSkge1xuICB2YXIgc2NoZW1hID0ge307XG5cbiAgZm9yICh2YXIgZmllbGQgaW4gY29sdW1uYXJUYWJsZSkge1xuICAgIHZhciBjb2x1bW4gPSBjb2x1bW5hclRhYmxlW2ZpZWxkXTtcblxuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoY29sdW1uKSkge1xuICAgICAgc2NoZW1hW2ZpZWxkXSA9IGNvbHVtbi5jb25zdHJ1Y3RvcjtcbiAgICB9IGVsc2UgaWYgKGNvbHVtbi5sZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGNvbHVtblswXTtcbiAgICAgIHNjaGVtYVtmaWVsZF0gPSBkZWR1Y2VUeXBlRnJvbVZhbHVlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBzY2hlbWFbZmllbGRdID0gc2NoZW1hW2ZpZWxkXSB8fCBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHNjaGVtYTtcbn1cblxuZnVuY3Rpb24gZGVkdWNlU2NoZW1hRm9yUm93VGFibGUocm93VGFibGUpIHtcbiAgdmFyIHNjaGVtYSA9IHt9O1xuXG4gIGlmIChyb3dUYWJsZS5sZW5ndGgpIHtcbiAgICB2YXIgcm93ID0gcm93VGFibGVbMF07XG5cbiAgICBmb3IgKHZhciBmaWVsZCBpbiByb3cpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHJvd1tmaWVsZF07XG4gICAgICBzY2hlbWFbZmllbGRdID0gZGVkdWNlVHlwZUZyb21WYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNjaGVtYTtcbn1cblxuZnVuY3Rpb24gZGVkdWNlVHlwZUZyb21WYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIERhdGU7XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICByZXR1cm4gRmxvYXQzMkFycmF5O1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gU3RyaW5nO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWR1Y2UtdGFibGUtc2NoZW1hLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXRUeXBlSW5mbyA9IGdldFR5cGVJbmZvO1xuXG52YXIgX3NjaGVtYSA9IHJlcXVpcmUoXCIuLi9zY2hlbWFcIik7XG5cbmZ1bmN0aW9uIGdldFR5cGVJbmZvKGFycm93VHlwZUxpa2UpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlSWQ6IGFycm93VHlwZUxpa2UudHlwZUlkLFxuICAgIEFycmF5VHlwZTogYXJyb3dUeXBlTGlrZS5BcnJheVR5cGUsXG4gICAgdHlwZU5hbWU6IGFycm93VHlwZUxpa2UudG9TdHJpbmcoKSxcbiAgICB0eXBlRW51bU5hbWU6IGdldFR5cGVLZXkoYXJyb3dUeXBlTGlrZS50eXBlSWQpLFxuICAgIHByZWNpc2lvbjogYXJyb3dUeXBlTGlrZS5wcmVjaXNpb25cbiAgfTtcbn1cblxudmFyIFJldmVyc2VUeXBlID0gbnVsbDtcblxuZnVuY3Rpb24gZ2V0VHlwZUtleSh0eXBlS2V5KSB7XG4gIGlmICghUmV2ZXJzZVR5cGUpIHtcbiAgICBSZXZlcnNlVHlwZSA9IHt9O1xuXG4gICAgZm9yICh2YXIgX2tleSBpbiBfc2NoZW1hLlR5cGUpIHtcbiAgICAgIFJldmVyc2VUeXBlW19zY2hlbWEuVHlwZVtfa2V5XV0gPSBfa2V5O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBSZXZlcnNlVHlwZVt0eXBlS2V5XTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC10eXBlLWluZm8uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldEFycm93VHlwZUZyb21UeXBlZEFycmF5ID0gZ2V0QXJyb3dUeXBlRnJvbVR5cGVkQXJyYXk7XG5cbnZhciBfc2NoZW1hID0gcmVxdWlyZShcIi4uL3NjaGVtYVwiKTtcblxuZnVuY3Rpb24gZ2V0QXJyb3dUeXBlRnJvbVR5cGVkQXJyYXkoYXJyYXkpIHtcbiAgc3dpdGNoIChhcnJheS5jb25zdHJ1Y3Rvcikge1xuICAgIGNhc2UgSW50OEFycmF5OlxuICAgICAgcmV0dXJuIG5ldyBfc2NoZW1hLkludDgoKTtcblxuICAgIGNhc2UgVWludDhBcnJheTpcbiAgICAgIHJldHVybiBuZXcgX3NjaGVtYS5VaW50OCgpO1xuXG4gICAgY2FzZSBJbnQxNkFycmF5OlxuICAgICAgcmV0dXJuIG5ldyBfc2NoZW1hLkludDE2KCk7XG5cbiAgICBjYXNlIFVpbnQxNkFycmF5OlxuICAgICAgcmV0dXJuIG5ldyBfc2NoZW1hLlVpbnQxNigpO1xuXG4gICAgY2FzZSBJbnQzMkFycmF5OlxuICAgICAgcmV0dXJuIG5ldyBfc2NoZW1hLkludDMyKCk7XG5cbiAgICBjYXNlIFVpbnQzMkFycmF5OlxuICAgICAgcmV0dXJuIG5ldyBfc2NoZW1hLlVpbnQzMigpO1xuXG4gICAgY2FzZSBGbG9hdDMyQXJyYXk6XG4gICAgICByZXR1cm4gbmV3IF9zY2hlbWEuRmxvYXQzMigpO1xuXG4gICAgY2FzZSBGbG9hdDY0QXJyYXk6XG4gICAgICByZXR1cm4gbmV3IF9zY2hlbWEuRmxvYXQ2NCgpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignYXJyYXkgdHlwZSBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGUtdXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlR5cGUgPSB2b2lkIDA7XG52YXIgVHlwZTtcbmV4cG9ydHMuVHlwZSA9IFR5cGU7XG5cbihmdW5jdGlvbiAoVHlwZSkge1xuICBUeXBlW1R5cGVbXCJOT05FXCJdID0gMF0gPSBcIk5PTkVcIjtcbiAgVHlwZVtUeXBlW1wiTnVsbFwiXSA9IDFdID0gXCJOdWxsXCI7XG4gIFR5cGVbVHlwZVtcIkludFwiXSA9IDJdID0gXCJJbnRcIjtcbiAgVHlwZVtUeXBlW1wiRmxvYXRcIl0gPSAzXSA9IFwiRmxvYXRcIjtcbiAgVHlwZVtUeXBlW1wiQmluYXJ5XCJdID0gNF0gPSBcIkJpbmFyeVwiO1xuICBUeXBlW1R5cGVbXCJVdGY4XCJdID0gNV0gPSBcIlV0ZjhcIjtcbiAgVHlwZVtUeXBlW1wiQm9vbFwiXSA9IDZdID0gXCJCb29sXCI7XG4gIFR5cGVbVHlwZVtcIkRlY2ltYWxcIl0gPSA3XSA9IFwiRGVjaW1hbFwiO1xuICBUeXBlW1R5cGVbXCJEYXRlXCJdID0gOF0gPSBcIkRhdGVcIjtcbiAgVHlwZVtUeXBlW1wiVGltZVwiXSA9IDldID0gXCJUaW1lXCI7XG4gIFR5cGVbVHlwZVtcIlRpbWVzdGFtcFwiXSA9IDEwXSA9IFwiVGltZXN0YW1wXCI7XG4gIFR5cGVbVHlwZVtcIkludGVydmFsXCJdID0gMTFdID0gXCJJbnRlcnZhbFwiO1xuICBUeXBlW1R5cGVbXCJMaXN0XCJdID0gMTJdID0gXCJMaXN0XCI7XG4gIFR5cGVbVHlwZVtcIlN0cnVjdFwiXSA9IDEzXSA9IFwiU3RydWN0XCI7XG4gIFR5cGVbVHlwZVtcIlVuaW9uXCJdID0gMTRdID0gXCJVbmlvblwiO1xuICBUeXBlW1R5cGVbXCJGaXhlZFNpemVCaW5hcnlcIl0gPSAxNV0gPSBcIkZpeGVkU2l6ZUJpbmFyeVwiO1xuICBUeXBlW1R5cGVbXCJGaXhlZFNpemVMaXN0XCJdID0gMTZdID0gXCJGaXhlZFNpemVMaXN0XCI7XG4gIFR5cGVbVHlwZVtcIk1hcFwiXSA9IDE3XSA9IFwiTWFwXCI7XG4gIFR5cGVbVHlwZVtcIkRpY3Rpb25hcnlcIl0gPSAtMV0gPSBcIkRpY3Rpb25hcnlcIjtcbiAgVHlwZVtUeXBlW1wiSW50OFwiXSA9IC0yXSA9IFwiSW50OFwiO1xuICBUeXBlW1R5cGVbXCJJbnQxNlwiXSA9IC0zXSA9IFwiSW50MTZcIjtcbiAgVHlwZVtUeXBlW1wiSW50MzJcIl0gPSAtNF0gPSBcIkludDMyXCI7XG4gIFR5cGVbVHlwZVtcIkludDY0XCJdID0gLTVdID0gXCJJbnQ2NFwiO1xuICBUeXBlW1R5cGVbXCJVaW50OFwiXSA9IC02XSA9IFwiVWludDhcIjtcbiAgVHlwZVtUeXBlW1wiVWludDE2XCJdID0gLTddID0gXCJVaW50MTZcIjtcbiAgVHlwZVtUeXBlW1wiVWludDMyXCJdID0gLThdID0gXCJVaW50MzJcIjtcbiAgVHlwZVtUeXBlW1wiVWludDY0XCJdID0gLTldID0gXCJVaW50NjRcIjtcbiAgVHlwZVtUeXBlW1wiRmxvYXQxNlwiXSA9IC0xMF0gPSBcIkZsb2F0MTZcIjtcbiAgVHlwZVtUeXBlW1wiRmxvYXQzMlwiXSA9IC0xMV0gPSBcIkZsb2F0MzJcIjtcbiAgVHlwZVtUeXBlW1wiRmxvYXQ2NFwiXSA9IC0xMl0gPSBcIkZsb2F0NjRcIjtcbiAgVHlwZVtUeXBlW1wiRGF0ZURheVwiXSA9IC0xM10gPSBcIkRhdGVEYXlcIjtcbiAgVHlwZVtUeXBlW1wiRGF0ZU1pbGxpc2Vjb25kXCJdID0gLTE0XSA9IFwiRGF0ZU1pbGxpc2Vjb25kXCI7XG4gIFR5cGVbVHlwZVtcIlRpbWVzdGFtcFNlY29uZFwiXSA9IC0xNV0gPSBcIlRpbWVzdGFtcFNlY29uZFwiO1xuICBUeXBlW1R5cGVbXCJUaW1lc3RhbXBNaWxsaXNlY29uZFwiXSA9IC0xNl0gPSBcIlRpbWVzdGFtcE1pbGxpc2Vjb25kXCI7XG4gIFR5cGVbVHlwZVtcIlRpbWVzdGFtcE1pY3Jvc2Vjb25kXCJdID0gLTE3XSA9IFwiVGltZXN0YW1wTWljcm9zZWNvbmRcIjtcbiAgVHlwZVtUeXBlW1wiVGltZXN0YW1wTmFub3NlY29uZFwiXSA9IC0xOF0gPSBcIlRpbWVzdGFtcE5hbm9zZWNvbmRcIjtcbiAgVHlwZVtUeXBlW1wiVGltZVNlY29uZFwiXSA9IC0xOV0gPSBcIlRpbWVTZWNvbmRcIjtcbiAgVHlwZVtUeXBlW1wiVGltZU1pbGxpc2Vjb25kXCJdID0gLTIwXSA9IFwiVGltZU1pbGxpc2Vjb25kXCI7XG4gIFR5cGVbVHlwZVtcIlRpbWVNaWNyb3NlY29uZFwiXSA9IC0yMV0gPSBcIlRpbWVNaWNyb3NlY29uZFwiO1xuICBUeXBlW1R5cGVbXCJUaW1lTmFub3NlY29uZFwiXSA9IC0yMl0gPSBcIlRpbWVOYW5vc2Vjb25kXCI7XG4gIFR5cGVbVHlwZVtcIkRlbnNlVW5pb25cIl0gPSAtMjNdID0gXCJEZW5zZVVuaW9uXCI7XG4gIFR5cGVbVHlwZVtcIlNwYXJzZVVuaW9uXCJdID0gLTI0XSA9IFwiU3BhcnNlVW5pb25cIjtcbiAgVHlwZVtUeXBlW1wiSW50ZXJ2YWxEYXlUaW1lXCJdID0gLTI1XSA9IFwiSW50ZXJ2YWxEYXlUaW1lXCI7XG4gIFR5cGVbVHlwZVtcIkludGVydmFsWWVhck1vbnRoXCJdID0gLTI2XSA9IFwiSW50ZXJ2YWxZZWFyTW9udGhcIjtcbn0pKFR5cGUgfHwgKGV4cG9ydHMuVHlwZSA9IFR5cGUgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW51bS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBGaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRmllbGQobmFtZSwgdHlwZSkge1xuICAgIHZhciBudWxsYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgdmFyIG1ldGFkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBuZXcgTWFwKCk7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgRmllbGQpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwibmFtZVwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwidHlwZVwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwibnVsbGFibGVcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcIm1ldGFkYXRhXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMubnVsbGFibGUgPSBudWxsYWJsZTtcbiAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShGaWVsZCwgW3tcbiAgICBrZXk6IFwidHlwZUlkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlICYmIHRoaXMudHlwZS50eXBlSWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIG5ldyBGaWVsZCh0aGlzLm5hbWUsIHRoaXMudHlwZSwgdGhpcy5udWxsYWJsZSwgdGhpcy5tZXRhZGF0YSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBhcmVUb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLm5hbWUgPT09IG90aGVyLm5hbWUgJiYgdGhpcy50eXBlID09PSBvdGhlci50eXBlICYmIHRoaXMubnVsbGFibGUgPT09IG90aGVyLm51bGxhYmxlICYmIHRoaXMubWV0YWRhdGEgPT09IG90aGVyLm1ldGFkYXRhO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aGlzLnR5cGUpLmNvbmNhdCh0aGlzLm51bGxhYmxlID8gJywgbnVsbGFibGUnIDogJycpLmNvbmNhdCh0aGlzLm1ldGFkYXRhID8gXCIsIG1ldGFkYXRhOiBcIi5jb25jYXQodGhpcy5tZXRhZGF0YSkgOiAnJyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBGaWVsZDtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRmllbGQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWVsZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfdG9Db25zdW1hYmxlQXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheVwiKSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfYXNzZXJ0ID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2Fzc2VydFwiKTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG52YXIgU2NoZW1hID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTY2hlbWEoZmllbGRzLCBtZXRhZGF0YSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFNjaGVtYSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJmaWVsZHNcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcIm1ldGFkYXRhXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9hc3NlcnQuYXNzZXJ0KShBcnJheS5pc0FycmF5KGZpZWxkcykpO1xuICAgIGNoZWNrTmFtZXMoZmllbGRzKTtcbiAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGEgfHwgbmV3IE1hcCgpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoU2NoZW1hLCBbe1xuICAgIGtleTogXCJjb21wYXJlVG9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVRvKG90aGVyKSB7XG4gICAgICBpZiAodGhpcy5tZXRhZGF0YSAhPT0gb3RoZXIubWV0YWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5maWVsZHMubGVuZ3RoICE9PSBvdGhlci5maWVsZHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpZWxkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoIXRoaXMuZmllbGRzW2ldLmNvbXBhcmVUbyhvdGhlci5maWVsZHNbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0KCkge1xuICAgICAgdmFyIG5hbWVNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgY29sdW1uTmFtZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGNvbHVtbk5hbWVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfaSA9IDAsIF9jb2x1bW5OYW1lcyA9IGNvbHVtbk5hbWVzOyBfaSA8IF9jb2x1bW5OYW1lcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIG5hbWUgPSBfY29sdW1uTmFtZXNbX2ldO1xuICAgICAgICBuYW1lTWFwW25hbWVdID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlbGVjdGVkRmllbGRzID0gdGhpcy5maWVsZHMuZmlsdGVyKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICByZXR1cm4gbmFtZU1hcFtmaWVsZC5uYW1lXTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBTY2hlbWEoc2VsZWN0ZWRGaWVsZHMsIHRoaXMubWV0YWRhdGEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3RBdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RBdCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgY29sdW1uSW5kaWNlcyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBjb2x1bW5JbmRpY2VzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxlY3RlZEZpZWxkcyA9IGNvbHVtbkluZGljZXMubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuZmllbGRzW2luZGV4XTtcbiAgICAgIH0pLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIHJldHVybiBuZXcgU2NoZW1hKHNlbGVjdGVkRmllbGRzLCB0aGlzLm1ldGFkYXRhKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXNzaWduXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFzc2lnbihzY2hlbWFPckZpZWxkcykge1xuICAgICAgdmFyIGZpZWxkcztcbiAgICAgIHZhciBtZXRhZGF0YSA9IHRoaXMubWV0YWRhdGE7XG5cbiAgICAgIGlmIChzY2hlbWFPckZpZWxkcyBpbnN0YW5jZW9mIFNjaGVtYSkge1xuICAgICAgICB2YXIgb3RoZXJTY2hlbWEgPSBzY2hlbWFPckZpZWxkcztcbiAgICAgICAgZmllbGRzID0gb3RoZXJTY2hlbWEuZmllbGRzO1xuICAgICAgICBtZXRhZGF0YSA9IG1lcmdlTWFwcyhtZXJnZU1hcHMobmV3IE1hcCgpLCB0aGlzLm1ldGFkYXRhKSwgb3RoZXJTY2hlbWEubWV0YWRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmllbGRzID0gc2NoZW1hT3JGaWVsZHM7XG4gICAgICB9XG5cbiAgICAgIHZhciBmaWVsZE1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmZpZWxkcyksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGZpZWxkID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgZmllbGRNYXBbZmllbGQubmFtZV0gPSBmaWVsZDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGZpZWxkcyksXG4gICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfZmllbGQgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgZmllbGRNYXBbX2ZpZWxkLm5hbWVdID0gX2ZpZWxkO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1lcmdlZEZpZWxkcyA9IE9iamVjdC52YWx1ZXMoZmllbGRNYXApO1xuICAgICAgcmV0dXJuIG5ldyBTY2hlbWEobWVyZ2VkRmllbGRzLCBtZXRhZGF0YSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTY2hlbWE7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFNjaGVtYTtcblxuZnVuY3Rpb24gY2hlY2tOYW1lcyhmaWVsZHMpIHtcbiAgdmFyIHVzZWROYW1lcyA9IHt9O1xuXG4gIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZmllbGRzKSxcbiAgICAgIF9zdGVwMztcblxuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgZmllbGQgPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgIGlmICh1c2VkTmFtZXNbZmllbGQubmFtZV0pIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdTY2hlbWE6IGR1cGxpY2F0ZWQgZmllbGQgbmFtZScsIGZpZWxkLm5hbWUsIGZpZWxkKTtcbiAgICAgIH1cblxuICAgICAgdXNlZE5hbWVzW2ZpZWxkLm5hbWVdID0gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjMuZigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlTWFwcyhtMSwgbTIpIHtcbiAgcmV0dXJuIG5ldyBNYXAoW10uY29uY2F0KCgwLCBfdG9Db25zdW1hYmxlQXJyYXkyLmRlZmF1bHQpKG0xIHx8IG5ldyBNYXAoKSksICgwLCBfdG9Db25zdW1hYmxlQXJyYXkyLmRlZmF1bHQpKG0yIHx8IG5ldyBNYXAoKSkpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjaGVtYS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUeXBlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9lbnVtLlR5cGU7XG4gIH1cbn0pO1xuZXhwb3J0cy5GaXhlZFNpemVMaXN0ID0gZXhwb3J0cy5JbnRlcnZhbFllYXJNb250aCA9IGV4cG9ydHMuSW50ZXJ2YWxEYXlUaW1lID0gZXhwb3J0cy5JbnRlcnZhbCA9IGV4cG9ydHMuVGltZXN0YW1wTmFub3NlY29uZCA9IGV4cG9ydHMuVGltZXN0YW1wTWljcm9zZWNvbmQgPSBleHBvcnRzLlRpbWVzdGFtcE1pbGxpc2Vjb25kID0gZXhwb3J0cy5UaW1lc3RhbXBTZWNvbmQgPSBleHBvcnRzLlRpbWVzdGFtcCA9IGV4cG9ydHMuVGltZU1pbGxpc2Vjb25kID0gZXhwb3J0cy5UaW1lU2Vjb25kID0gZXhwb3J0cy5UaW1lID0gZXhwb3J0cy5EYXRlTWlsbGlzZWNvbmQgPSBleHBvcnRzLkRhdGVEYXkgPSBleHBvcnRzLkRhdGUgPSBleHBvcnRzLlV0ZjggPSBleHBvcnRzLkJpbmFyeSA9IGV4cG9ydHMuRmxvYXQ2NCA9IGV4cG9ydHMuRmxvYXQzMiA9IGV4cG9ydHMuRmxvYXQxNiA9IGV4cG9ydHMuRmxvYXQgPSBleHBvcnRzLlVpbnQ2NCA9IGV4cG9ydHMuVWludDMyID0gZXhwb3J0cy5VaW50MTYgPSBleHBvcnRzLlVpbnQ4ID0gZXhwb3J0cy5JbnQ2NCA9IGV4cG9ydHMuSW50MzIgPSBleHBvcnRzLkludDE2ID0gZXhwb3J0cy5JbnQ4ID0gZXhwb3J0cy5JbnQgPSBleHBvcnRzLkJvb2wgPSBleHBvcnRzLk51bGwgPSBleHBvcnRzLkRhdGFUeXBlID0gdm9pZCAwO1xuXG52YXIgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2VudW0gPSByZXF1aXJlKFwiLi9lbnVtXCIpO1xuXG52YXIgX1N5bWJvbCR0b1N0cmluZ1RhZywgX1N5bWJvbCR0b1N0cmluZ1RhZzIsIF9TeW1ib2wkdG9TdHJpbmdUYWczLCBfU3ltYm9sJHRvU3RyaW5nVGFnNCwgX1N5bWJvbCR0b1N0cmluZ1RhZzUsIF9TeW1ib2wkdG9TdHJpbmdUYWc2LCBfU3ltYm9sJHRvU3RyaW5nVGFnNztcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBEYXRhVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRGF0YVR5cGUoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgRGF0YVR5cGUpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoRGF0YVR5cGUsIFt7XG4gICAga2V5OiBcInR5cGVJZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9lbnVtLlR5cGUuTk9ORTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcGFyZVRvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVUbyhvdGhlcikge1xuICAgICAgcmV0dXJuIHRoaXMgPT09IG90aGVyO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImlzTnVsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc051bGwoeCkge1xuICAgICAgcmV0dXJuIHggJiYgeC50eXBlSWQgPT09IF9lbnVtLlR5cGUuTnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNJbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNJbnQoeCkge1xuICAgICAgcmV0dXJuIHggJiYgeC50eXBlSWQgPT09IF9lbnVtLlR5cGUuSW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0Zsb2F0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRmxvYXQoeCkge1xuICAgICAgcmV0dXJuIHggJiYgeC50eXBlSWQgPT09IF9lbnVtLlR5cGUuRmxvYXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzQmluYXJ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzQmluYXJ5KHgpIHtcbiAgICAgIHJldHVybiB4ICYmIHgudHlwZUlkID09PSBfZW51bS5UeXBlLkJpbmFyeTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNVdGY4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzVXRmOCh4KSB7XG4gICAgICByZXR1cm4geCAmJiB4LnR5cGVJZCA9PT0gX2VudW0uVHlwZS5VdGY4O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0Jvb2xcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNCb29sKHgpIHtcbiAgICAgIHJldHVybiB4ICYmIHgudHlwZUlkID09PSBfZW51bS5UeXBlLkJvb2w7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzRGVjaW1hbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0RlY2ltYWwoeCkge1xuICAgICAgcmV0dXJuIHggJiYgeC50eXBlSWQgPT09IF9lbnVtLlR5cGUuRGVjaW1hbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNEYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRGF0ZSh4KSB7XG4gICAgICByZXR1cm4geCAmJiB4LnR5cGVJZCA9PT0gX2VudW0uVHlwZS5EYXRlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1RpbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNUaW1lKHgpIHtcbiAgICAgIHJldHVybiB4ICYmIHgudHlwZUlkID09PSBfZW51bS5UeXBlLlRpbWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzVGltZXN0YW1wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzVGltZXN0YW1wKHgpIHtcbiAgICAgIHJldHVybiB4ICYmIHgudHlwZUlkID09PSBfZW51bS5UeXBlLlRpbWVzdGFtcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNJbnRlcnZhbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0ludGVydmFsKHgpIHtcbiAgICAgIHJldHVybiB4ICYmIHgudHlwZUlkID09PSBfZW51bS5UeXBlLkludGVydmFsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0xpc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNMaXN0KHgpIHtcbiAgICAgIHJldHVybiB4ICYmIHgudHlwZUlkID09PSBfZW51bS5UeXBlLkxpc3Q7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzU3RydWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzU3RydWN0KHgpIHtcbiAgICAgIHJldHVybiB4ICYmIHgudHlwZUlkID09PSBfZW51bS5UeXBlLlN0cnVjdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNVbmlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1VuaW9uKHgpIHtcbiAgICAgIHJldHVybiB4ICYmIHgudHlwZUlkID09PSBfZW51bS5UeXBlLlVuaW9uO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0ZpeGVkU2l6ZUJpbmFyeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0ZpeGVkU2l6ZUJpbmFyeSh4KSB7XG4gICAgICByZXR1cm4geCAmJiB4LnR5cGVJZCA9PT0gX2VudW0uVHlwZS5GaXhlZFNpemVCaW5hcnk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzRml4ZWRTaXplTGlzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0ZpeGVkU2l6ZUxpc3QoeCkge1xuICAgICAgcmV0dXJuIHggJiYgeC50eXBlSWQgPT09IF9lbnVtLlR5cGUuRml4ZWRTaXplTGlzdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNNYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNNYXAoeCkge1xuICAgICAgcmV0dXJuIHggJiYgeC50eXBlSWQgPT09IF9lbnVtLlR5cGUuTWFwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0RpY3Rpb25hcnlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNEaWN0aW9uYXJ5KHgpIHtcbiAgICAgIHJldHVybiB4ICYmIHgudHlwZUlkID09PSBfZW51bS5UeXBlLkRpY3Rpb25hcnk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBEYXRhVHlwZTtcbn0oKTtcblxuZXhwb3J0cy5EYXRhVHlwZSA9IERhdGFUeXBlO1xuXG52YXIgTnVsbCA9IGZ1bmN0aW9uIChfRGF0YVR5cGUpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoTnVsbCwgX0RhdGFUeXBlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKE51bGwpO1xuXG4gIGZ1bmN0aW9uIE51bGwoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgTnVsbCk7XG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoTnVsbCwgW3tcbiAgICBrZXk6IFwidHlwZUlkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2VudW0uVHlwZS5OdWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogU3ltYm9sLnRvU3RyaW5nVGFnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICdOdWxsJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ051bGwnO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTnVsbDtcbn0oRGF0YVR5cGUpO1xuXG5leHBvcnRzLk51bGwgPSBOdWxsO1xuXG52YXIgQm9vbCA9IGZ1bmN0aW9uIChfRGF0YVR5cGUyKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEJvb2wsIF9EYXRhVHlwZTIpO1xuXG4gIHZhciBfc3VwZXIyID0gX2NyZWF0ZVN1cGVyKEJvb2wpO1xuXG4gIGZ1bmN0aW9uIEJvb2woKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgQm9vbCk7XG4gICAgcmV0dXJuIF9zdXBlcjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEJvb2wsIFt7XG4gICAga2V5OiBcInR5cGVJZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9lbnVtLlR5cGUuQm9vbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFN5bWJvbC50b1N0cmluZ1RhZyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnQm9vbCc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICdCb29sJztcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEJvb2w7XG59KERhdGFUeXBlKTtcblxuZXhwb3J0cy5Cb29sID0gQm9vbDtcbl9TeW1ib2wkdG9TdHJpbmdUYWcgPSBTeW1ib2wudG9TdHJpbmdUYWc7XG5cbnZhciBJbnQgPSBmdW5jdGlvbiAoX0RhdGFUeXBlMykge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShJbnQsIF9EYXRhVHlwZTMpO1xuXG4gIHZhciBfc3VwZXIzID0gX2NyZWF0ZVN1cGVyKEludCk7XG5cbiAgZnVuY3Rpb24gSW50KGlzU2lnbmVkLCBiaXRXaWR0aCkge1xuICAgIHZhciBfdGhpcztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEludCk7XG4gICAgX3RoaXMgPSBfc3VwZXIzLmNhbGwodGhpcyk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzKSwgXCJpc1NpZ25lZFwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpcyksIFwiYml0V2lkdGhcIiwgdm9pZCAwKTtcbiAgICBfdGhpcy5pc1NpZ25lZCA9IGlzU2lnbmVkO1xuICAgIF90aGlzLmJpdFdpZHRoID0gYml0V2lkdGg7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoSW50LCBbe1xuICAgIGtleTogXCJ0eXBlSWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfZW51bS5UeXBlLkludDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IF9TeW1ib2wkdG9TdHJpbmdUYWcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ0ludCc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMuaXNTaWduZWQgPyAnSScgOiAnVWknLCBcIm50XCIpLmNvbmNhdCh0aGlzLmJpdFdpZHRoKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEludDtcbn0oRGF0YVR5cGUpO1xuXG5leHBvcnRzLkludCA9IEludDtcblxudmFyIEludDggPSBmdW5jdGlvbiAoX0ludCkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShJbnQ4LCBfSW50KTtcblxuICB2YXIgX3N1cGVyNCA9IF9jcmVhdGVTdXBlcihJbnQ4KTtcblxuICBmdW5jdGlvbiBJbnQ4KCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEludDgpO1xuICAgIHJldHVybiBfc3VwZXI0LmNhbGwodGhpcywgdHJ1ZSwgOCk7XG4gIH1cblxuICByZXR1cm4gSW50ODtcbn0oSW50KTtcblxuZXhwb3J0cy5JbnQ4ID0gSW50ODtcblxudmFyIEludDE2ID0gZnVuY3Rpb24gKF9JbnQyKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEludDE2LCBfSW50Mik7XG5cbiAgdmFyIF9zdXBlcjUgPSBfY3JlYXRlU3VwZXIoSW50MTYpO1xuXG4gIGZ1bmN0aW9uIEludDE2KCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEludDE2KTtcbiAgICByZXR1cm4gX3N1cGVyNS5jYWxsKHRoaXMsIHRydWUsIDE2KTtcbiAgfVxuXG4gIHJldHVybiBJbnQxNjtcbn0oSW50KTtcblxuZXhwb3J0cy5JbnQxNiA9IEludDE2O1xuXG52YXIgSW50MzIgPSBmdW5jdGlvbiAoX0ludDMpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoSW50MzIsIF9JbnQzKTtcblxuICB2YXIgX3N1cGVyNiA9IF9jcmVhdGVTdXBlcihJbnQzMik7XG5cbiAgZnVuY3Rpb24gSW50MzIoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgSW50MzIpO1xuICAgIHJldHVybiBfc3VwZXI2LmNhbGwodGhpcywgdHJ1ZSwgMzIpO1xuICB9XG5cbiAgcmV0dXJuIEludDMyO1xufShJbnQpO1xuXG5leHBvcnRzLkludDMyID0gSW50MzI7XG5cbnZhciBJbnQ2NCA9IGZ1bmN0aW9uIChfSW50NCkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShJbnQ2NCwgX0ludDQpO1xuXG4gIHZhciBfc3VwZXI3ID0gX2NyZWF0ZVN1cGVyKEludDY0KTtcblxuICBmdW5jdGlvbiBJbnQ2NCgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBJbnQ2NCk7XG4gICAgcmV0dXJuIF9zdXBlcjcuY2FsbCh0aGlzLCB0cnVlLCA2NCk7XG4gIH1cblxuICByZXR1cm4gSW50NjQ7XG59KEludCk7XG5cbmV4cG9ydHMuSW50NjQgPSBJbnQ2NDtcblxudmFyIFVpbnQ4ID0gZnVuY3Rpb24gKF9JbnQ1KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKFVpbnQ4LCBfSW50NSk7XG5cbiAgdmFyIF9zdXBlcjggPSBfY3JlYXRlU3VwZXIoVWludDgpO1xuXG4gIGZ1bmN0aW9uIFVpbnQ4KCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFVpbnQ4KTtcbiAgICByZXR1cm4gX3N1cGVyOC5jYWxsKHRoaXMsIGZhbHNlLCA4KTtcbiAgfVxuXG4gIHJldHVybiBVaW50ODtcbn0oSW50KTtcblxuZXhwb3J0cy5VaW50OCA9IFVpbnQ4O1xuXG52YXIgVWludDE2ID0gZnVuY3Rpb24gKF9JbnQ2KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKFVpbnQxNiwgX0ludDYpO1xuXG4gIHZhciBfc3VwZXI5ID0gX2NyZWF0ZVN1cGVyKFVpbnQxNik7XG5cbiAgZnVuY3Rpb24gVWludDE2KCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFVpbnQxNik7XG4gICAgcmV0dXJuIF9zdXBlcjkuY2FsbCh0aGlzLCBmYWxzZSwgMTYpO1xuICB9XG5cbiAgcmV0dXJuIFVpbnQxNjtcbn0oSW50KTtcblxuZXhwb3J0cy5VaW50MTYgPSBVaW50MTY7XG5cbnZhciBVaW50MzIgPSBmdW5jdGlvbiAoX0ludDcpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoVWludDMyLCBfSW50Nyk7XG5cbiAgdmFyIF9zdXBlcjEwID0gX2NyZWF0ZVN1cGVyKFVpbnQzMik7XG5cbiAgZnVuY3Rpb24gVWludDMyKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFVpbnQzMik7XG4gICAgcmV0dXJuIF9zdXBlcjEwLmNhbGwodGhpcywgZmFsc2UsIDMyKTtcbiAgfVxuXG4gIHJldHVybiBVaW50MzI7XG59KEludCk7XG5cbmV4cG9ydHMuVWludDMyID0gVWludDMyO1xuXG52YXIgVWludDY0ID0gZnVuY3Rpb24gKF9JbnQ4KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKFVpbnQ2NCwgX0ludDgpO1xuXG4gIHZhciBfc3VwZXIxMSA9IF9jcmVhdGVTdXBlcihVaW50NjQpO1xuXG4gIGZ1bmN0aW9uIFVpbnQ2NCgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBVaW50NjQpO1xuICAgIHJldHVybiBfc3VwZXIxMS5jYWxsKHRoaXMsIGZhbHNlLCA2NCk7XG4gIH1cblxuICByZXR1cm4gVWludDY0O1xufShJbnQpO1xuXG5leHBvcnRzLlVpbnQ2NCA9IFVpbnQ2NDtcbnZhciBQcmVjaXNpb24gPSB7XG4gIEhBTEY6IDE2LFxuICBTSU5HTEU6IDMyLFxuICBET1VCTEU6IDY0XG59O1xuX1N5bWJvbCR0b1N0cmluZ1RhZzIgPSBTeW1ib2wudG9TdHJpbmdUYWc7XG5cbnZhciBGbG9hdCA9IGZ1bmN0aW9uIChfRGF0YVR5cGU0KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEZsb2F0LCBfRGF0YVR5cGU0KTtcblxuICB2YXIgX3N1cGVyMTIgPSBfY3JlYXRlU3VwZXIoRmxvYXQpO1xuXG4gIGZ1bmN0aW9uIEZsb2F0KHByZWNpc2lvbikge1xuICAgIHZhciBfdGhpczI7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBGbG9hdCk7XG4gICAgX3RoaXMyID0gX3N1cGVyMTIuY2FsbCh0aGlzKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXMyKSwgXCJwcmVjaXNpb25cIiwgdm9pZCAwKTtcbiAgICBfdGhpczIucHJlY2lzaW9uID0gcHJlY2lzaW9uO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShGbG9hdCwgW3tcbiAgICBrZXk6IFwidHlwZUlkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2VudW0uVHlwZS5GbG9hdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IF9TeW1ib2wkdG9TdHJpbmdUYWcyLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICdGbG9hdCc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIFwiRmxvYXRcIi5jb25jYXQodGhpcy5wcmVjaXNpb24pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRmxvYXQ7XG59KERhdGFUeXBlKTtcblxuZXhwb3J0cy5GbG9hdCA9IEZsb2F0O1xuXG52YXIgRmxvYXQxNiA9IGZ1bmN0aW9uIChfRmxvYXQpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoRmxvYXQxNiwgX0Zsb2F0KTtcblxuICB2YXIgX3N1cGVyMTMgPSBfY3JlYXRlU3VwZXIoRmxvYXQxNik7XG5cbiAgZnVuY3Rpb24gRmxvYXQxNigpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBGbG9hdDE2KTtcbiAgICByZXR1cm4gX3N1cGVyMTMuY2FsbCh0aGlzLCBQcmVjaXNpb24uSEFMRik7XG4gIH1cblxuICByZXR1cm4gRmxvYXQxNjtcbn0oRmxvYXQpO1xuXG5leHBvcnRzLkZsb2F0MTYgPSBGbG9hdDE2O1xuXG52YXIgRmxvYXQzMiA9IGZ1bmN0aW9uIChfRmxvYXQyKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEZsb2F0MzIsIF9GbG9hdDIpO1xuXG4gIHZhciBfc3VwZXIxNCA9IF9jcmVhdGVTdXBlcihGbG9hdDMyKTtcblxuICBmdW5jdGlvbiBGbG9hdDMyKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEZsb2F0MzIpO1xuICAgIHJldHVybiBfc3VwZXIxNC5jYWxsKHRoaXMsIFByZWNpc2lvbi5TSU5HTEUpO1xuICB9XG5cbiAgcmV0dXJuIEZsb2F0MzI7XG59KEZsb2F0KTtcblxuZXhwb3J0cy5GbG9hdDMyID0gRmxvYXQzMjtcblxudmFyIEZsb2F0NjQgPSBmdW5jdGlvbiAoX0Zsb2F0Mykge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShGbG9hdDY0LCBfRmxvYXQzKTtcblxuICB2YXIgX3N1cGVyMTUgPSBfY3JlYXRlU3VwZXIoRmxvYXQ2NCk7XG5cbiAgZnVuY3Rpb24gRmxvYXQ2NCgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBGbG9hdDY0KTtcbiAgICByZXR1cm4gX3N1cGVyMTUuY2FsbCh0aGlzLCBQcmVjaXNpb24uRE9VQkxFKTtcbiAgfVxuXG4gIHJldHVybiBGbG9hdDY0O1xufShGbG9hdCk7XG5cbmV4cG9ydHMuRmxvYXQ2NCA9IEZsb2F0NjQ7XG5cbnZhciBCaW5hcnkgPSBmdW5jdGlvbiAoX0RhdGFUeXBlNSkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShCaW5hcnksIF9EYXRhVHlwZTUpO1xuXG4gIHZhciBfc3VwZXIxNiA9IF9jcmVhdGVTdXBlcihCaW5hcnkpO1xuXG4gIGZ1bmN0aW9uIEJpbmFyeSgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBCaW5hcnkpO1xuICAgIHJldHVybiBfc3VwZXIxNi5jYWxsKHRoaXMpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoQmluYXJ5LCBbe1xuICAgIGtleTogXCJ0eXBlSWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfZW51bS5UeXBlLkJpbmFyeTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ0JpbmFyeSc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBTeW1ib2wudG9TdHJpbmdUYWcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ0JpbmFyeSc7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCaW5hcnk7XG59KERhdGFUeXBlKTtcblxuZXhwb3J0cy5CaW5hcnkgPSBCaW5hcnk7XG5cbnZhciBVdGY4ID0gZnVuY3Rpb24gKF9EYXRhVHlwZTYpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoVXRmOCwgX0RhdGFUeXBlNik7XG5cbiAgdmFyIF9zdXBlcjE3ID0gX2NyZWF0ZVN1cGVyKFV0ZjgpO1xuXG4gIGZ1bmN0aW9uIFV0ZjgoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgVXRmOCk7XG4gICAgcmV0dXJuIF9zdXBlcjE3LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShVdGY4LCBbe1xuICAgIGtleTogXCJ0eXBlSWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfZW51bS5UeXBlLlV0Zjg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBTeW1ib2wudG9TdHJpbmdUYWcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ1V0ZjgnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAnVXRmOCc7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBVdGY4O1xufShEYXRhVHlwZSk7XG5cbmV4cG9ydHMuVXRmOCA9IFV0Zjg7XG52YXIgRGF0ZVVuaXQgPSB7XG4gIERBWTogMCxcbiAgTUlMTElTRUNPTkQ6IDFcbn07XG5fU3ltYm9sJHRvU3RyaW5nVGFnMyA9IFN5bWJvbC50b1N0cmluZ1RhZztcblxudmFyIERhdGUgPSBmdW5jdGlvbiAoX0RhdGFUeXBlNykge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShEYXRlLCBfRGF0YVR5cGU3KTtcblxuICB2YXIgX3N1cGVyMTggPSBfY3JlYXRlU3VwZXIoRGF0ZSk7XG5cbiAgZnVuY3Rpb24gRGF0ZSh1bml0KSB7XG4gICAgdmFyIF90aGlzMztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIERhdGUpO1xuICAgIF90aGlzMyA9IF9zdXBlcjE4LmNhbGwodGhpcyk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzMyksIFwidW5pdFwiLCB2b2lkIDApO1xuICAgIF90aGlzMy51bml0ID0gdW5pdDtcbiAgICByZXR1cm4gX3RoaXMzO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoRGF0ZSwgW3tcbiAgICBrZXk6IFwidHlwZUlkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2VudW0uVHlwZS5EYXRlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogX1N5bWJvbCR0b1N0cmluZ1RhZzMsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ0RhdGUnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcIkRhdGVcIi5jb25jYXQoKHRoaXMudW5pdCArIDEpICogMzIsIFwiPFwiKS5jb25jYXQoRGF0ZVVuaXRbdGhpcy51bml0XSwgXCI+XCIpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRGF0ZTtcbn0oRGF0YVR5cGUpO1xuXG5leHBvcnRzLkRhdGUgPSBEYXRlO1xuXG52YXIgRGF0ZURheSA9IGZ1bmN0aW9uIChfRGF0ZSkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShEYXRlRGF5LCBfRGF0ZSk7XG5cbiAgdmFyIF9zdXBlcjE5ID0gX2NyZWF0ZVN1cGVyKERhdGVEYXkpO1xuXG4gIGZ1bmN0aW9uIERhdGVEYXkoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgRGF0ZURheSk7XG4gICAgcmV0dXJuIF9zdXBlcjE5LmNhbGwodGhpcywgRGF0ZVVuaXQuREFZKTtcbiAgfVxuXG4gIHJldHVybiBEYXRlRGF5O1xufShEYXRlKTtcblxuZXhwb3J0cy5EYXRlRGF5ID0gRGF0ZURheTtcblxudmFyIERhdGVNaWxsaXNlY29uZCA9IGZ1bmN0aW9uIChfRGF0ZTIpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoRGF0ZU1pbGxpc2Vjb25kLCBfRGF0ZTIpO1xuXG4gIHZhciBfc3VwZXIyMCA9IF9jcmVhdGVTdXBlcihEYXRlTWlsbGlzZWNvbmQpO1xuXG4gIGZ1bmN0aW9uIERhdGVNaWxsaXNlY29uZCgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBEYXRlTWlsbGlzZWNvbmQpO1xuICAgIHJldHVybiBfc3VwZXIyMC5jYWxsKHRoaXMsIERhdGVVbml0Lk1JTExJU0VDT05EKTtcbiAgfVxuXG4gIHJldHVybiBEYXRlTWlsbGlzZWNvbmQ7XG59KERhdGUpO1xuXG5leHBvcnRzLkRhdGVNaWxsaXNlY29uZCA9IERhdGVNaWxsaXNlY29uZDtcbnZhciBUaW1lVW5pdCA9IHtcbiAgU0VDT05EOiAxLFxuICBNSUxMSVNFQ09ORDogMWUzLFxuICBNSUNST1NFQ09ORDogMWU2LFxuICBOQU5PU0VDT05EOiAxZTlcbn07XG5fU3ltYm9sJHRvU3RyaW5nVGFnNCA9IFN5bWJvbC50b1N0cmluZ1RhZztcblxudmFyIFRpbWUgPSBmdW5jdGlvbiAoX0RhdGFUeXBlOCkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShUaW1lLCBfRGF0YVR5cGU4KTtcblxuICB2YXIgX3N1cGVyMjEgPSBfY3JlYXRlU3VwZXIoVGltZSk7XG5cbiAgZnVuY3Rpb24gVGltZSh1bml0LCBiaXRXaWR0aCkge1xuICAgIHZhciBfdGhpczQ7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBUaW1lKTtcbiAgICBfdGhpczQgPSBfc3VwZXIyMS5jYWxsKHRoaXMpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczQpLCBcInVuaXRcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXM0KSwgXCJiaXRXaWR0aFwiLCB2b2lkIDApO1xuICAgIF90aGlzNC51bml0ID0gdW5pdDtcbiAgICBfdGhpczQuYml0V2lkdGggPSBiaXRXaWR0aDtcbiAgICByZXR1cm4gX3RoaXM0O1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoVGltZSwgW3tcbiAgICBrZXk6IFwidHlwZUlkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2VudW0uVHlwZS5UaW1lO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcIlRpbWVcIi5jb25jYXQodGhpcy5iaXRXaWR0aCwgXCI8XCIpLmNvbmNhdChUaW1lVW5pdFt0aGlzLnVuaXRdLCBcIj5cIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBfU3ltYm9sJHRvU3RyaW5nVGFnNCxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnVGltZSc7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUaW1lO1xufShEYXRhVHlwZSk7XG5cbmV4cG9ydHMuVGltZSA9IFRpbWU7XG5cbnZhciBUaW1lU2Vjb25kID0gZnVuY3Rpb24gKF9UaW1lKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKFRpbWVTZWNvbmQsIF9UaW1lKTtcblxuICB2YXIgX3N1cGVyMjIgPSBfY3JlYXRlU3VwZXIoVGltZVNlY29uZCk7XG5cbiAgZnVuY3Rpb24gVGltZVNlY29uZCgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBUaW1lU2Vjb25kKTtcbiAgICByZXR1cm4gX3N1cGVyMjIuY2FsbCh0aGlzLCBUaW1lVW5pdC5TRUNPTkQsIDMyKTtcbiAgfVxuXG4gIHJldHVybiBUaW1lU2Vjb25kO1xufShUaW1lKTtcblxuZXhwb3J0cy5UaW1lU2Vjb25kID0gVGltZVNlY29uZDtcblxudmFyIFRpbWVNaWxsaXNlY29uZCA9IGZ1bmN0aW9uIChfVGltZTIpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoVGltZU1pbGxpc2Vjb25kLCBfVGltZTIpO1xuXG4gIHZhciBfc3VwZXIyMyA9IF9jcmVhdGVTdXBlcihUaW1lTWlsbGlzZWNvbmQpO1xuXG4gIGZ1bmN0aW9uIFRpbWVNaWxsaXNlY29uZCgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBUaW1lTWlsbGlzZWNvbmQpO1xuICAgIHJldHVybiBfc3VwZXIyMy5jYWxsKHRoaXMsIFRpbWVVbml0Lk1JTExJU0VDT05ELCAzMik7XG4gIH1cblxuICByZXR1cm4gVGltZU1pbGxpc2Vjb25kO1xufShUaW1lKTtcblxuZXhwb3J0cy5UaW1lTWlsbGlzZWNvbmQgPSBUaW1lTWlsbGlzZWNvbmQ7XG5fU3ltYm9sJHRvU3RyaW5nVGFnNSA9IFN5bWJvbC50b1N0cmluZ1RhZztcblxudmFyIFRpbWVzdGFtcCA9IGZ1bmN0aW9uIChfRGF0YVR5cGU5KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKFRpbWVzdGFtcCwgX0RhdGFUeXBlOSk7XG5cbiAgdmFyIF9zdXBlcjI0ID0gX2NyZWF0ZVN1cGVyKFRpbWVzdGFtcCk7XG5cbiAgZnVuY3Rpb24gVGltZXN0YW1wKHVuaXQpIHtcbiAgICB2YXIgX3RoaXM1O1xuXG4gICAgdmFyIHRpbWV6b25lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFRpbWVzdGFtcCk7XG4gICAgX3RoaXM1ID0gX3N1cGVyMjQuY2FsbCh0aGlzKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXM1KSwgXCJ1bml0XCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzNSksIFwidGltZXpvbmVcIiwgdm9pZCAwKTtcbiAgICBfdGhpczUudW5pdCA9IHVuaXQ7XG4gICAgX3RoaXM1LnRpbWV6b25lID0gdGltZXpvbmU7XG4gICAgcmV0dXJuIF90aGlzNTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKFRpbWVzdGFtcCwgW3tcbiAgICBrZXk6IFwidHlwZUlkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2VudW0uVHlwZS5UaW1lc3RhbXA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBfU3ltYm9sJHRvU3RyaW5nVGFnNSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnVGltZXN0YW1wJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCJUaW1lc3RhbXA8XCIuY29uY2F0KFRpbWVVbml0W3RoaXMudW5pdF0pLmNvbmNhdCh0aGlzLnRpbWV6b25lID8gXCIsIFwiLmNvbmNhdCh0aGlzLnRpbWV6b25lKSA6ICcnLCBcIj5cIik7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUaW1lc3RhbXA7XG59KERhdGFUeXBlKTtcblxuZXhwb3J0cy5UaW1lc3RhbXAgPSBUaW1lc3RhbXA7XG5cbnZhciBUaW1lc3RhbXBTZWNvbmQgPSBmdW5jdGlvbiAoX1RpbWVzdGFtcCkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShUaW1lc3RhbXBTZWNvbmQsIF9UaW1lc3RhbXApO1xuXG4gIHZhciBfc3VwZXIyNSA9IF9jcmVhdGVTdXBlcihUaW1lc3RhbXBTZWNvbmQpO1xuXG4gIGZ1bmN0aW9uIFRpbWVzdGFtcFNlY29uZCgpIHtcbiAgICB2YXIgdGltZXpvbmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgVGltZXN0YW1wU2Vjb25kKTtcbiAgICByZXR1cm4gX3N1cGVyMjUuY2FsbCh0aGlzLCBUaW1lVW5pdC5TRUNPTkQsIHRpbWV6b25lKTtcbiAgfVxuXG4gIHJldHVybiBUaW1lc3RhbXBTZWNvbmQ7XG59KFRpbWVzdGFtcCk7XG5cbmV4cG9ydHMuVGltZXN0YW1wU2Vjb25kID0gVGltZXN0YW1wU2Vjb25kO1xuXG52YXIgVGltZXN0YW1wTWlsbGlzZWNvbmQgPSBmdW5jdGlvbiAoX1RpbWVzdGFtcDIpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoVGltZXN0YW1wTWlsbGlzZWNvbmQsIF9UaW1lc3RhbXAyKTtcblxuICB2YXIgX3N1cGVyMjYgPSBfY3JlYXRlU3VwZXIoVGltZXN0YW1wTWlsbGlzZWNvbmQpO1xuXG4gIGZ1bmN0aW9uIFRpbWVzdGFtcE1pbGxpc2Vjb25kKCkge1xuICAgIHZhciB0aW1lem9uZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBUaW1lc3RhbXBNaWxsaXNlY29uZCk7XG4gICAgcmV0dXJuIF9zdXBlcjI2LmNhbGwodGhpcywgVGltZVVuaXQuTUlMTElTRUNPTkQsIHRpbWV6b25lKTtcbiAgfVxuXG4gIHJldHVybiBUaW1lc3RhbXBNaWxsaXNlY29uZDtcbn0oVGltZXN0YW1wKTtcblxuZXhwb3J0cy5UaW1lc3RhbXBNaWxsaXNlY29uZCA9IFRpbWVzdGFtcE1pbGxpc2Vjb25kO1xuXG52YXIgVGltZXN0YW1wTWljcm9zZWNvbmQgPSBmdW5jdGlvbiAoX1RpbWVzdGFtcDMpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoVGltZXN0YW1wTWljcm9zZWNvbmQsIF9UaW1lc3RhbXAzKTtcblxuICB2YXIgX3N1cGVyMjcgPSBfY3JlYXRlU3VwZXIoVGltZXN0YW1wTWljcm9zZWNvbmQpO1xuXG4gIGZ1bmN0aW9uIFRpbWVzdGFtcE1pY3Jvc2Vjb25kKCkge1xuICAgIHZhciB0aW1lem9uZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBUaW1lc3RhbXBNaWNyb3NlY29uZCk7XG4gICAgcmV0dXJuIF9zdXBlcjI3LmNhbGwodGhpcywgVGltZVVuaXQuTUlDUk9TRUNPTkQsIHRpbWV6b25lKTtcbiAgfVxuXG4gIHJldHVybiBUaW1lc3RhbXBNaWNyb3NlY29uZDtcbn0oVGltZXN0YW1wKTtcblxuZXhwb3J0cy5UaW1lc3RhbXBNaWNyb3NlY29uZCA9IFRpbWVzdGFtcE1pY3Jvc2Vjb25kO1xuXG52YXIgVGltZXN0YW1wTmFub3NlY29uZCA9IGZ1bmN0aW9uIChfVGltZXN0YW1wNCkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShUaW1lc3RhbXBOYW5vc2Vjb25kLCBfVGltZXN0YW1wNCk7XG5cbiAgdmFyIF9zdXBlcjI4ID0gX2NyZWF0ZVN1cGVyKFRpbWVzdGFtcE5hbm9zZWNvbmQpO1xuXG4gIGZ1bmN0aW9uIFRpbWVzdGFtcE5hbm9zZWNvbmQoKSB7XG4gICAgdmFyIHRpbWV6b25lID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFRpbWVzdGFtcE5hbm9zZWNvbmQpO1xuICAgIHJldHVybiBfc3VwZXIyOC5jYWxsKHRoaXMsIFRpbWVVbml0Lk5BTk9TRUNPTkQsIHRpbWV6b25lKTtcbiAgfVxuXG4gIHJldHVybiBUaW1lc3RhbXBOYW5vc2Vjb25kO1xufShUaW1lc3RhbXApO1xuXG5leHBvcnRzLlRpbWVzdGFtcE5hbm9zZWNvbmQgPSBUaW1lc3RhbXBOYW5vc2Vjb25kO1xudmFyIEludGVydmFsVW5pdCA9IHtcbiAgREFZX1RJTUU6IDAsXG4gIFlFQVJfTU9OVEg6IDFcbn07XG5fU3ltYm9sJHRvU3RyaW5nVGFnNiA9IFN5bWJvbC50b1N0cmluZ1RhZztcblxudmFyIEludGVydmFsID0gZnVuY3Rpb24gKF9EYXRhVHlwZTEwKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEludGVydmFsLCBfRGF0YVR5cGUxMCk7XG5cbiAgdmFyIF9zdXBlcjI5ID0gX2NyZWF0ZVN1cGVyKEludGVydmFsKTtcblxuICBmdW5jdGlvbiBJbnRlcnZhbCh1bml0KSB7XG4gICAgdmFyIF90aGlzNjtcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEludGVydmFsKTtcbiAgICBfdGhpczYgPSBfc3VwZXIyOS5jYWxsKHRoaXMpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczYpLCBcInVuaXRcIiwgdm9pZCAwKTtcbiAgICBfdGhpczYudW5pdCA9IHVuaXQ7XG4gICAgcmV0dXJuIF90aGlzNjtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEludGVydmFsLCBbe1xuICAgIGtleTogXCJ0eXBlSWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfZW51bS5UeXBlLkludGVydmFsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogX1N5bWJvbCR0b1N0cmluZ1RhZzYsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ0ludGVydmFsJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCJJbnRlcnZhbDxcIi5jb25jYXQoSW50ZXJ2YWxVbml0W3RoaXMudW5pdF0sIFwiPlwiKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEludGVydmFsO1xufShEYXRhVHlwZSk7XG5cbmV4cG9ydHMuSW50ZXJ2YWwgPSBJbnRlcnZhbDtcblxudmFyIEludGVydmFsRGF5VGltZSA9IGZ1bmN0aW9uIChfSW50ZXJ2YWwpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoSW50ZXJ2YWxEYXlUaW1lLCBfSW50ZXJ2YWwpO1xuXG4gIHZhciBfc3VwZXIzMCA9IF9jcmVhdGVTdXBlcihJbnRlcnZhbERheVRpbWUpO1xuXG4gIGZ1bmN0aW9uIEludGVydmFsRGF5VGltZSgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBJbnRlcnZhbERheVRpbWUpO1xuICAgIHJldHVybiBfc3VwZXIzMC5jYWxsKHRoaXMsIEludGVydmFsVW5pdC5EQVlfVElNRSk7XG4gIH1cblxuICByZXR1cm4gSW50ZXJ2YWxEYXlUaW1lO1xufShJbnRlcnZhbCk7XG5cbmV4cG9ydHMuSW50ZXJ2YWxEYXlUaW1lID0gSW50ZXJ2YWxEYXlUaW1lO1xuXG52YXIgSW50ZXJ2YWxZZWFyTW9udGggPSBmdW5jdGlvbiAoX0ludGVydmFsMikge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShJbnRlcnZhbFllYXJNb250aCwgX0ludGVydmFsMik7XG5cbiAgdmFyIF9zdXBlcjMxID0gX2NyZWF0ZVN1cGVyKEludGVydmFsWWVhck1vbnRoKTtcblxuICBmdW5jdGlvbiBJbnRlcnZhbFllYXJNb250aCgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBJbnRlcnZhbFllYXJNb250aCk7XG4gICAgcmV0dXJuIF9zdXBlcjMxLmNhbGwodGhpcywgSW50ZXJ2YWxVbml0LllFQVJfTU9OVEgpO1xuICB9XG5cbiAgcmV0dXJuIEludGVydmFsWWVhck1vbnRoO1xufShJbnRlcnZhbCk7XG5cbmV4cG9ydHMuSW50ZXJ2YWxZZWFyTW9udGggPSBJbnRlcnZhbFllYXJNb250aDtcbl9TeW1ib2wkdG9TdHJpbmdUYWc3ID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xuXG52YXIgRml4ZWRTaXplTGlzdCA9IGZ1bmN0aW9uIChfRGF0YVR5cGUxMSkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShGaXhlZFNpemVMaXN0LCBfRGF0YVR5cGUxMSk7XG5cbiAgdmFyIF9zdXBlcjMyID0gX2NyZWF0ZVN1cGVyKEZpeGVkU2l6ZUxpc3QpO1xuXG4gIGZ1bmN0aW9uIEZpeGVkU2l6ZUxpc3QobGlzdFNpemUsIGNoaWxkKSB7XG4gICAgdmFyIF90aGlzNztcblxuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEZpeGVkU2l6ZUxpc3QpO1xuICAgIF90aGlzNyA9IF9zdXBlcjMyLmNhbGwodGhpcyk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzNyksIFwibGlzdFNpemVcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXM3KSwgXCJjaGlsZHJlblwiLCB2b2lkIDApO1xuICAgIF90aGlzNy5saXN0U2l6ZSA9IGxpc3RTaXplO1xuICAgIF90aGlzNy5jaGlsZHJlbiA9IFtjaGlsZF07XG4gICAgcmV0dXJuIF90aGlzNztcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEZpeGVkU2l6ZUxpc3QsIFt7XG4gICAga2V5OiBcInR5cGVJZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9lbnVtLlR5cGUuRml4ZWRTaXplTGlzdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFsdWVUeXBlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlblswXS50eXBlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWx1ZUZpZWxkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlblswXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IF9TeW1ib2wkdG9TdHJpbmdUYWc3LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICdGaXhlZFNpemVMaXN0JztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCJGaXhlZFNpemVMaXN0W1wiLmNvbmNhdCh0aGlzLmxpc3RTaXplLCBcIl08XCIpLmNvbmNhdCh0aGlzLnZhbHVlVHlwZSwgXCI+XCIpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRml4ZWRTaXplTGlzdDtcbn0oRGF0YVR5cGUpO1xuXG5leHBvcnRzLkZpeGVkU2l6ZUxpc3QgPSBGaXhlZFNpemVMaXN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTY2hlbWFcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZpZWxkXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9maWVsZC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuVHlwZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEYXRhVHlwZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5EYXRhVHlwZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOdWxsXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLk51bGw7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQm9vbFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5Cb29sO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5JbnQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW50OFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5JbnQ4O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludDE2XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLkludDE2O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludDMyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLkludDMyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludDY0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLkludDY0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVpbnQ4XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLlVpbnQ4O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVpbnQxNlwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5VaW50MTY7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVWludDMyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLlVpbnQzMjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVaW50NjRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuVWludDY0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZsb2F0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLkZsb2F0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZsb2F0MTZcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuRmxvYXQxNjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGbG9hdDMyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLkZsb2F0MzI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmxvYXQ2NFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5GbG9hdDY0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJpbmFyeVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5CaW5hcnk7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVXRmOFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5VdGY4O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRhdGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuRGF0ZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEYXRlRGF5XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLkRhdGVEYXk7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGF0ZU1pbGxpc2Vjb25kXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLkRhdGVNaWxsaXNlY29uZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUaW1lXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLlRpbWU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGltZVNlY29uZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5UaW1lU2Vjb25kO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRpbWVNaWxsaXNlY29uZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5UaW1lTWlsbGlzZWNvbmQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGltZXN0YW1wXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLlRpbWVzdGFtcDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUaW1lc3RhbXBTZWNvbmRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuVGltZXN0YW1wU2Vjb25kO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRpbWVzdGFtcE1pbGxpc2Vjb25kXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLlRpbWVzdGFtcE1pbGxpc2Vjb25kO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRpbWVzdGFtcE1pY3Jvc2Vjb25kXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLlRpbWVzdGFtcE1pY3Jvc2Vjb25kO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRpbWVzdGFtcE5hbm9zZWNvbmRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuVGltZXN0YW1wTmFub3NlY29uZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnRlcnZhbFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5JbnRlcnZhbDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnRlcnZhbERheVRpbWVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuSW50ZXJ2YWxEYXlUaW1lO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludGVydmFsWWVhck1vbnRoXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLkludGVydmFsWWVhck1vbnRoO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZpeGVkU2l6ZUxpc3RcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuRml4ZWRTaXplTGlzdDtcbiAgfVxufSk7XG5cbnZhciBfc2NoZW1hID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pbXBsL3NjaGVtYVwiKSk7XG5cbnZhciBfZmllbGQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2ltcGwvZmllbGRcIikpO1xuXG52YXIgX3R5cGUgPSByZXF1aXJlKFwiLi9pbXBsL3R5cGVcIik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBERUZBVUxUX1JPV19DT1VOVCA9IDEwMDtcblxudmFyIFJvd1RhYmxlQmF0Y2hBZ2dyZWdhdG9yID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSb3dUYWJsZUJhdGNoQWdncmVnYXRvcihzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBSb3dUYWJsZUJhdGNoQWdncmVnYXRvcik7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJzY2hlbWFcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcImxlbmd0aFwiLCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcInJvd3NcIiwgbnVsbCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJjdXJzb3JcIiwgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJfaGVhZGVyc1wiLCBbXSk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgICB0aGlzLl9oZWFkZXJzID0gW107XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgdGhpcy5faGVhZGVyc1tzY2hlbWFba2V5XS5pbmRleF0gPSBzY2hlbWFba2V5XS5uYW1lO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKFJvd1RhYmxlQmF0Y2hBZ2dyZWdhdG9yLCBbe1xuICAgIGtleTogXCJyb3dDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByb3dDb3VudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkQXJyYXlSb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQXJyYXlSb3cocm93LCBjdXJzb3IpIHtcbiAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoY3Vyc29yKSkge1xuICAgICAgICB0aGlzLmN1cnNvciA9IGN1cnNvcjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yb3dzID0gdGhpcy5yb3dzIHx8IG5ldyBBcnJheShERUZBVUxUX1JPV19DT1VOVCk7XG4gICAgICB0aGlzLnJvd3NbdGhpcy5sZW5ndGhdID0gcm93O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkT2JqZWN0Um93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE9iamVjdFJvdyhyb3csIGN1cnNvcikge1xuICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShjdXJzb3IpKSB7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gY3Vyc29yO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJvd3MgPSB0aGlzLnJvd3MgfHwgbmV3IEFycmF5KERFRkFVTFRfUk9XX0NPVU5UKTtcbiAgICAgIHRoaXMucm93c1t0aGlzLmxlbmd0aF0gPSByb3c7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRCYXRjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCYXRjaCgpIHtcbiAgICAgIHZhciByb3dzID0gdGhpcy5yb3dzO1xuXG4gICAgICBpZiAoIXJvd3MpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJvd3MgPSByb3dzLnNsaWNlKDAsIHRoaXMubGVuZ3RoKTtcbiAgICAgIHRoaXMucm93cyA9IG51bGw7XG4gICAgICB2YXIgYmF0Y2ggPSB7XG4gICAgICAgIHNoYXBlOiB0aGlzLm9wdGlvbnMuc2hhcGUsXG4gICAgICAgIGJhdGNoVHlwZTogJ2RhdGEnLFxuICAgICAgICBkYXRhOiByb3dzLFxuICAgICAgICBsZW5ndGg6IHRoaXMubGVuZ3RoLFxuICAgICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgICBjdXJzb3I6IHRoaXMuY3Vyc29yXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGJhdGNoO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUm93VGFibGVCYXRjaEFnZ3JlZ2F0b3I7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJvd1RhYmxlQmF0Y2hBZ2dyZWdhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZS10YWJsZS1iYXRjaC1hZ2dyZWdhdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9zbGljZWRUb0FycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheVwiKSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBERUZBVUxUX1JPV19DT1VOVCA9IDEwMDtcblxudmFyIENvbHVtbmFyVGFibGVCYXRjaEFnZ3JlZ2F0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbHVtbmFyVGFibGVCYXRjaEFnZ3JlZ2F0b3Ioc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgQ29sdW1uYXJUYWJsZUJhdGNoQWdncmVnYXRvcik7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJzY2hlbWFcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcImxlbmd0aFwiLCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcImFsbG9jYXRlZFwiLCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcImNvbHVtbnNcIiwge30pO1xuICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuXG4gICAgdGhpcy5fcmVhbGxvY2F0ZUNvbHVtbnMoKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKENvbHVtbmFyVGFibGVCYXRjaEFnZ3JlZ2F0b3IsIFt7XG4gICAga2V5OiBcInJvd0NvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvd0NvdW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRBcnJheVJvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRBcnJheVJvdyhyb3cpIHtcbiAgICAgIHRoaXMuX3JlYWxsb2NhdGVDb2x1bW5zKCk7XG5cbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgZm9yICh2YXIgZmllbGROYW1lIGluIHRoaXMuY29sdW1ucykge1xuICAgICAgICB0aGlzLmNvbHVtbnNbZmllbGROYW1lXVt0aGlzLmxlbmd0aF0gPSByb3dbaSsrXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkT2JqZWN0Um93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE9iamVjdFJvdyhyb3cpIHtcbiAgICAgIHRoaXMuX3JlYWxsb2NhdGVDb2x1bW5zKCk7XG5cbiAgICAgIGZvciAodmFyIGZpZWxkTmFtZSBpbiByb3cpIHtcbiAgICAgICAgdGhpcy5jb2x1bW5zW2ZpZWxkTmFtZV1bdGhpcy5sZW5ndGhdID0gcm93W2ZpZWxkTmFtZV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEJhdGNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJhdGNoKCkge1xuICAgICAgdGhpcy5fcHJ1bmVDb2x1bW5zKCk7XG5cbiAgICAgIHZhciBjb2x1bW5zID0gQXJyYXkuaXNBcnJheSh0aGlzLnNjaGVtYSkgPyB0aGlzLmNvbHVtbnMgOiB7fTtcblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMuc2NoZW1hKSkge1xuICAgICAgICBmb3IgKHZhciBmaWVsZE5hbWUgaW4gdGhpcy5zY2hlbWEpIHtcbiAgICAgICAgICB2YXIgZmllbGQgPSB0aGlzLnNjaGVtYVtmaWVsZE5hbWVdO1xuICAgICAgICAgIGNvbHVtbnNbZmllbGQubmFtZV0gPSB0aGlzLmNvbHVtbnNbZmllbGQuaW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29sdW1ucyA9IHt9O1xuICAgICAgdmFyIGJhdGNoID0ge1xuICAgICAgICBzaGFwZTogJ2NvbHVtbmFyLXRhYmxlJyxcbiAgICAgICAgYmF0Y2hUeXBlOiAnZGF0YScsXG4gICAgICAgIGRhdGE6IGNvbHVtbnMsXG4gICAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWEsXG4gICAgICAgIGxlbmd0aDogdGhpcy5sZW5ndGhcbiAgICAgIH07XG4gICAgICByZXR1cm4gYmF0Y2g7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZWFsbG9jYXRlQ29sdW1uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVhbGxvY2F0ZUNvbHVtbnMoKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPCB0aGlzLmFsbG9jYXRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWxsb2NhdGVkID0gdGhpcy5hbGxvY2F0ZWQgPiAwID8gdGhpcy5hbGxvY2F0ZWQgKj0gMiA6IERFRkFVTFRfUk9XX0NPVU5UO1xuICAgICAgdGhpcy5jb2x1bW5zID0ge307XG5cbiAgICAgIGZvciAodmFyIGZpZWxkTmFtZSBpbiB0aGlzLnNjaGVtYSkge1xuICAgICAgICB2YXIgZmllbGQgPSB0aGlzLnNjaGVtYVtmaWVsZE5hbWVdO1xuICAgICAgICB2YXIgQXJyYXlUeXBlID0gZmllbGQudHlwZSB8fCBGbG9hdDMyQXJyYXk7XG4gICAgICAgIHZhciBvbGRDb2x1bW4gPSB0aGlzLmNvbHVtbnNbZmllbGQuaW5kZXhdO1xuXG4gICAgICAgIGlmIChvbGRDb2x1bW4gJiYgQXJyYXlCdWZmZXIuaXNWaWV3KG9sZENvbHVtbikpIHtcbiAgICAgICAgICB2YXIgdHlwZWRBcnJheSA9IG5ldyBBcnJheVR5cGUodGhpcy5hbGxvY2F0ZWQpO1xuICAgICAgICAgIHR5cGVkQXJyYXkuc2V0KG9sZENvbHVtbik7XG4gICAgICAgICAgdGhpcy5jb2x1bW5zW2ZpZWxkLmluZGV4XSA9IHR5cGVkQXJyYXk7XG4gICAgICAgIH0gZWxzZSBpZiAob2xkQ29sdW1uKSB7XG4gICAgICAgICAgb2xkQ29sdW1uLmxlbmd0aCA9IHRoaXMuYWxsb2NhdGVkO1xuICAgICAgICAgIHRoaXMuY29sdW1uc1tmaWVsZC5pbmRleF0gPSBvbGRDb2x1bW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jb2x1bW5zW2ZpZWxkLmluZGV4XSA9IG5ldyBBcnJheVR5cGUodGhpcy5hbGxvY2F0ZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9wcnVuZUNvbHVtbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BydW5lQ29sdW1ucygpIHtcbiAgICAgIGZvciAodmFyIF9pID0gMCwgX09iamVjdCRlbnRyaWVzID0gT2JqZWN0LmVudHJpZXModGhpcy5jb2x1bW5zKTsgX2kgPCBfT2JqZWN0JGVudHJpZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBfT2JqZWN0JGVudHJpZXMkX2kgPSAoMCwgX3NsaWNlZFRvQXJyYXkyLmRlZmF1bHQpKF9PYmplY3QkZW50cmllc1tfaV0sIDIpLFxuICAgICAgICAgICAgX2NvbHVtbk5hbWUgPSBfT2JqZWN0JGVudHJpZXMkX2lbMF0sXG4gICAgICAgICAgICBjb2x1bW4gPSBfT2JqZWN0JGVudHJpZXMkX2lbMV07XG5cbiAgICAgICAgdGhpcy5jb2x1bW5zW19jb2x1bW5OYW1lXSA9IGNvbHVtbi5zbGljZSgwLCB0aGlzLmxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDb2x1bW5hclRhYmxlQmF0Y2hBZ2dyZWdhdG9yO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDb2x1bW5hclRhYmxlQmF0Y2hBZ2dyZWdhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29sdW1uYXItdGFibGUtYmF0Y2gtYWdncmVnYXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfcm93VXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMvcm93LXV0aWxzXCIpO1xuXG52YXIgREVGQVVMVF9ST1dfQ09VTlQgPSAxMDA7XG5cbnZhciBSb3dUYWJsZUJhdGNoQWdncmVnYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUm93VGFibGVCYXRjaEFnZ3JlZ2F0b3Ioc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgUm93VGFibGVCYXRjaEFnZ3JlZ2F0b3IpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwic2NoZW1hXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJvcHRpb25zXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJsZW5ndGhcIiwgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJvYmplY3RSb3dzXCIsIG51bGwpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiYXJyYXlSb3dzXCIsIG51bGwpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiY3Vyc29yXCIsIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiX2hlYWRlcnNcIiwgW10pO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgICAgdGhpcy5faGVhZGVycyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgIHRoaXMuX2hlYWRlcnNbc2NoZW1hW2tleV0uaW5kZXhdID0gc2NoZW1hW2tleV0ubmFtZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShSb3dUYWJsZUJhdGNoQWdncmVnYXRvciwgW3tcbiAgICBrZXk6IFwicm93Q291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcm93Q291bnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZEFycmF5Um93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEFycmF5Um93KHJvdywgY3Vyc29yKSB7XG4gICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGN1cnNvcikpIHtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBjdXJzb3I7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAodGhpcy5vcHRpb25zLnNoYXBlKSB7XG4gICAgICAgIGNhc2UgJ29iamVjdC1yb3ctdGFibGUnOlxuICAgICAgICAgIHZhciByb3dPYmplY3QgPSAoMCwgX3Jvd1V0aWxzLmNvbnZlcnRUb09iamVjdFJvdykocm93LCB0aGlzLl9oZWFkZXJzKTtcbiAgICAgICAgICB0aGlzLmFkZE9iamVjdFJvdyhyb3dPYmplY3QsIGN1cnNvcik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnYXJyYXktcm93LXRhYmxlJzpcbiAgICAgICAgICB0aGlzLmFycmF5Um93cyA9IHRoaXMuYXJyYXlSb3dzIHx8IG5ldyBBcnJheShERUZBVUxUX1JPV19DT1VOVCk7XG4gICAgICAgICAgdGhpcy5hcnJheVJvd3NbdGhpcy5sZW5ndGhdID0gcm93O1xuICAgICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZE9iamVjdFJvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRPYmplY3RSb3cocm93LCBjdXJzb3IpIHtcbiAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoY3Vyc29yKSkge1xuICAgICAgICB0aGlzLmN1cnNvciA9IGN1cnNvcjtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh0aGlzLm9wdGlvbnMuc2hhcGUpIHtcbiAgICAgICAgY2FzZSAnYXJyYXktcm93LXRhYmxlJzpcbiAgICAgICAgICB2YXIgcm93QXJyYXkgPSAoMCwgX3Jvd1V0aWxzLmNvbnZlcnRUb0FycmF5Um93KShyb3csIHRoaXMuX2hlYWRlcnMpO1xuICAgICAgICAgIHRoaXMuYWRkQXJyYXlSb3cocm93QXJyYXksIGN1cnNvcik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnb2JqZWN0LXJvdy10YWJsZSc6XG4gICAgICAgICAgdGhpcy5vYmplY3RSb3dzID0gdGhpcy5vYmplY3RSb3dzIHx8IG5ldyBBcnJheShERUZBVUxUX1JPV19DT1VOVCk7XG4gICAgICAgICAgdGhpcy5vYmplY3RSb3dzW3RoaXMubGVuZ3RoXSA9IHJvdztcbiAgICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRCYXRjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCYXRjaCgpIHtcbiAgICAgIHZhciByb3dzID0gdGhpcy5hcnJheVJvd3MgfHwgdGhpcy5vYmplY3RSb3dzO1xuXG4gICAgICBpZiAoIXJvd3MpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJvd3MgPSByb3dzLnNsaWNlKDAsIHRoaXMubGVuZ3RoKTtcbiAgICAgIHRoaXMuYXJyYXlSb3dzID0gbnVsbDtcbiAgICAgIHRoaXMub2JqZWN0Um93cyA9IG51bGw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzaGFwZTogdGhpcy5vcHRpb25zLnNoYXBlLFxuICAgICAgICBiYXRjaFR5cGU6ICdkYXRhJyxcbiAgICAgICAgZGF0YTogcm93cyxcbiAgICAgICAgbGVuZ3RoOiB0aGlzLmxlbmd0aCxcbiAgICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgICAgY3Vyc29yOiB0aGlzLmN1cnNvclxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFJvd1RhYmxlQmF0Y2hBZ2dyZWdhdG9yO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSb3dUYWJsZUJhdGNoQWdncmVnYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdy10YWJsZS1iYXRjaC1hZ2dyZWdhdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9iYXNlVGFibGVCYXRjaEFnZ3JlZ2F0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Jhc2UtdGFibGUtYmF0Y2gtYWdncmVnYXRvclwiKSk7XG5cbnZhciBfcm93VGFibGVCYXRjaEFnZ3JlZ2F0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3Jvdy10YWJsZS1iYXRjaC1hZ2dyZWdhdG9yXCIpKTtcblxudmFyIF9jb2x1bW5hclRhYmxlQmF0Y2hBZ2dyZWdhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb2x1bW5hci10YWJsZS1iYXRjaC1hZ2dyZWdhdG9yXCIpKTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gIHNoYXBlOiAnYXJyYXktcm93LXRhYmxlJyxcbiAgYmF0Y2hTaXplOiAnYXV0bycsXG4gIGJhdGNoRGVib3VuY2VNczogMCxcbiAgbGltaXQ6IDAsXG4gIF9saW1pdE1COiAwXG59O1xudmFyIEVSUl9NRVNTQUdFID0gJ1RhYmxlQmF0Y2hCdWlsZGVyJztcblxudmFyIFRhYmxlQmF0Y2hCdWlsZGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUYWJsZUJhdGNoQnVpbGRlcihzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBUYWJsZUJhdGNoQnVpbGRlcik7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJzY2hlbWFcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcImFnZ3JlZ2F0b3JcIiwgbnVsbCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJiYXRjaENvdW50XCIsIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiYnl0ZXNVc2VkXCIsIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiaXNDaHVua0NvbXBsZXRlXCIsIGZhbHNlKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcImxhc3RCYXRjaEVtaXR0ZWRNc1wiLCBEYXRlLm5vdygpKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcInRvdGFsTGVuZ3RoXCIsIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwidG90YWxCeXRlc1wiLCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcInJvd0J5dGVzXCIsIDApO1xuICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgIHRoaXMub3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgREVGQVVMVF9PUFRJT05TKSwgb3B0aW9ucyk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShUYWJsZUJhdGNoQnVpbGRlciwgW3tcbiAgICBrZXk6IFwibGltaXRSZWFjaGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpbWl0UmVhY2hlZCgpIHtcbiAgICAgIHZhciBfdGhpcyRvcHRpb25zLCBfdGhpcyRvcHRpb25zMjtcblxuICAgICAgaWYgKEJvb2xlYW4oKF90aGlzJG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMpID09PSBudWxsIHx8IF90aGlzJG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJG9wdGlvbnMubGltaXQpICYmIHRoaXMudG90YWxMZW5ndGggPj0gdGhpcy5vcHRpb25zLmxpbWl0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoQm9vbGVhbigoX3RoaXMkb3B0aW9uczIgPSB0aGlzLm9wdGlvbnMpID09PSBudWxsIHx8IF90aGlzJG9wdGlvbnMyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zMi5fbGltaXRNQikgJiYgdGhpcy50b3RhbEJ5dGVzIC8gMWU2ID49IHRoaXMub3B0aW9ucy5fbGltaXRNQikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRSb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUm93KHJvdykge1xuICAgICAgaWYgKHRoaXMubGltaXRSZWFjaGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRvdGFsTGVuZ3RoKys7XG4gICAgICB0aGlzLnJvd0J5dGVzID0gdGhpcy5yb3dCeXRlcyB8fCB0aGlzLl9lc3RpbWF0ZVJvd01CKHJvdyk7XG4gICAgICB0aGlzLnRvdGFsQnl0ZXMgKz0gdGhpcy5yb3dCeXRlcztcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocm93KSkge1xuICAgICAgICB0aGlzLmFkZEFycmF5Um93KHJvdyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkZE9iamVjdFJvdyhyb3cpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRBcnJheVJvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRBcnJheVJvdyhyb3cpIHtcbiAgICAgIGlmICghdGhpcy5hZ2dyZWdhdG9yKSB7XG4gICAgICAgIHZhciBUYWJsZUJhdGNoVHlwZSA9IHRoaXMuX2dldFRhYmxlQmF0Y2hUeXBlKCk7XG5cbiAgICAgICAgdGhpcy5hZ2dyZWdhdG9yID0gbmV3IFRhYmxlQmF0Y2hUeXBlKHRoaXMuc2NoZW1hLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFnZ3JlZ2F0b3IuYWRkQXJyYXlSb3cocm93KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkT2JqZWN0Um93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE9iamVjdFJvdyhyb3cpIHtcbiAgICAgIGlmICghdGhpcy5hZ2dyZWdhdG9yKSB7XG4gICAgICAgIHZhciBUYWJsZUJhdGNoVHlwZSA9IHRoaXMuX2dldFRhYmxlQmF0Y2hUeXBlKCk7XG5cbiAgICAgICAgdGhpcy5hZ2dyZWdhdG9yID0gbmV3IFRhYmxlQmF0Y2hUeXBlKHRoaXMuc2NoZW1hLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFnZ3JlZ2F0b3IuYWRkT2JqZWN0Um93KHJvdyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNodW5rQ29tcGxldGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2h1bmtDb21wbGV0ZShjaHVuaykge1xuICAgICAgaWYgKGNodW5rIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgdGhpcy5ieXRlc1VzZWQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5ieXRlc1VzZWQgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlzQ2h1bmtDb21wbGV0ZSA9IHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZ1bGxCYXRjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGdWxsQmF0Y2gob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzRnVsbCgpID8gdGhpcy5fZ2V0QmF0Y2gob3B0aW9ucykgOiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRGaW5hbEJhdGNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZpbmFsQmF0Y2gob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldEJhdGNoKG9wdGlvbnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZXN0aW1hdGVSb3dNQlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXN0aW1hdGVSb3dNQihyb3cpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHJvdykgPyByb3cubGVuZ3RoICogOCA6IE9iamVjdC5rZXlzKHJvdykubGVuZ3RoICogODtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2lzRnVsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNGdWxsKCkge1xuICAgICAgaWYgKCF0aGlzLmFnZ3JlZ2F0b3IgfHwgdGhpcy5hZ2dyZWdhdG9yLnJvd0NvdW50KCkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmJhdGNoU2l6ZSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0NodW5rQ29tcGxldGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmJhdGNoU2l6ZSA+IHRoaXMuYWdncmVnYXRvci5yb3dDb3VudCgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYXRjaERlYm91bmNlTXMgPiBEYXRlLm5vdygpIC0gdGhpcy5sYXN0QmF0Y2hFbWl0dGVkTXMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlzQ2h1bmtDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5sYXN0QmF0Y2hFbWl0dGVkTXMgPSBEYXRlLm5vdygpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRCYXRjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QmF0Y2gob3B0aW9ucykge1xuICAgICAgaWYgKCF0aGlzLmFnZ3JlZ2F0b3IpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCAmJiBvcHRpb25zLmJ5dGVzVXNlZCkge1xuICAgICAgICB0aGlzLmJ5dGVzVXNlZCA9IG9wdGlvbnMuYnl0ZXNVc2VkO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9ybWFsaXplZEJhdGNoID0gdGhpcy5hZ2dyZWdhdG9yLmdldEJhdGNoKCk7XG4gICAgICBub3JtYWxpemVkQmF0Y2guY291bnQgPSB0aGlzLmJhdGNoQ291bnQ7XG4gICAgICBub3JtYWxpemVkQmF0Y2guYnl0ZXNVc2VkID0gdGhpcy5ieXRlc1VzZWQ7XG4gICAgICBPYmplY3QuYXNzaWduKG5vcm1hbGl6ZWRCYXRjaCwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmJhdGNoQ291bnQrKztcbiAgICAgIHRoaXMuYWdncmVnYXRvciA9IG51bGw7XG4gICAgICByZXR1cm4gbm9ybWFsaXplZEJhdGNoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0VGFibGVCYXRjaFR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFRhYmxlQmF0Y2hUeXBlKCkge1xuICAgICAgc3dpdGNoICh0aGlzLm9wdGlvbnMuc2hhcGUpIHtcbiAgICAgICAgY2FzZSAncm93LXRhYmxlJzpcbiAgICAgICAgICByZXR1cm4gX2Jhc2VUYWJsZUJhdGNoQWdncmVnYXRvci5kZWZhdWx0O1xuXG4gICAgICAgIGNhc2UgJ2FycmF5LXJvdy10YWJsZSc6XG4gICAgICAgIGNhc2UgJ29iamVjdC1yb3ctdGFibGUnOlxuICAgICAgICAgIHJldHVybiBfcm93VGFibGVCYXRjaEFnZ3JlZ2F0b3IuZGVmYXVsdDtcblxuICAgICAgICBjYXNlICdjb2x1bW5hci10YWJsZSc6XG4gICAgICAgICAgcmV0dXJuIF9jb2x1bW5hclRhYmxlQmF0Y2hBZ2dyZWdhdG9yLmRlZmF1bHQ7XG5cbiAgICAgICAgY2FzZSAnYXJyb3ctdGFibGUnOlxuICAgICAgICAgIGlmICghVGFibGVCYXRjaEJ1aWxkZXIuQXJyb3dCYXRjaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUl9NRVNTQUdFKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gVGFibGVCYXRjaEJ1aWxkZXIuQXJyb3dCYXRjaDtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJfTUVTU0FHRSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUYWJsZUJhdGNoQnVpbGRlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gVGFibGVCYXRjaEJ1aWxkZXI7XG4oMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShUYWJsZUJhdGNoQnVpbGRlciwgXCJBcnJvd0JhdGNoXCIsIHZvaWQgMCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWJsZS1iYXRjaC1idWlsZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMudGFrZUFzeW5jID0gdGFrZUFzeW5jO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfd3JhcE5hdGl2ZVN1cGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvd3JhcE5hdGl2ZVN1cGVyXCIpKTtcblxudmFyIF9TeW1ib2wkYXN5bmNJdGVyYXRvcjtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yLmRlZmF1bHQpKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBBcnJheVF1ZXVlID0gZnVuY3Rpb24gKF9BcnJheSkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShBcnJheVF1ZXVlLCBfQXJyYXkpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoQXJyYXlRdWV1ZSk7XG5cbiAgZnVuY3Rpb24gQXJyYXlRdWV1ZSgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBBcnJheVF1ZXVlKTtcbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShBcnJheVF1ZXVlLCBbe1xuICAgIGtleTogXCJlbnF1ZXVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVucXVldWUodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXF1ZXVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlcXVldWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaGlmdCgpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQXJyYXlRdWV1ZTtcbn0oKDAsIF93cmFwTmF0aXZlU3VwZXIyLmRlZmF1bHQpKEFycmF5KSk7XG5cbl9TeW1ib2wkYXN5bmNJdGVyYXRvciA9IFN5bWJvbC5hc3luY0l0ZXJhdG9yO1xuXG52YXIgQXN5bmNRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQXN5bmNRdWV1ZSgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBBc3luY1F1ZXVlKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcIl92YWx1ZXNcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcIl9zZXR0bGVyc1wiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiX2Nsb3NlZFwiLCB2b2lkIDApO1xuICAgIHRoaXMuX3ZhbHVlcyA9IG5ldyBBcnJheVF1ZXVlKCk7XG4gICAgdGhpcy5fc2V0dGxlcnMgPSBuZXcgQXJyYXlRdWV1ZSgpO1xuICAgIHRoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoQXN5bmNRdWV1ZSwgW3tcbiAgICBrZXk6IFwiY2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICB3aGlsZSAodGhpcy5fc2V0dGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLl9zZXR0bGVycy5kZXF1ZXVlKCkucmVzb2x2ZSh7XG4gICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IF9TeW1ib2wkYXN5bmNJdGVyYXRvcixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5xdWV1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbnF1ZXVlKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2xvc2VkJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9zZXR0bGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICh0aGlzLl92YWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBpbnRlcm5hbCBzdGF0ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNldHRsZXIgPSB0aGlzLl9zZXR0bGVycy5kZXF1ZXVlKCk7XG5cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBzZXR0bGVyLnJlamVjdCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0dGxlci5yZXNvbHZlKHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl92YWx1ZXMuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5leHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl92YWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl92YWx1ZXMuZGVxdWV1ZSgpO1xuXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICBpZiAodGhpcy5fc2V0dGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBpbnRlcm5hbCBzdGF0ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgX3RoaXMuX3NldHRsZXJzLmVucXVldWUoe1xuICAgICAgICAgIHJlc29sdmU6IHJlc29sdmUsXG4gICAgICAgICAgcmVqZWN0OiByZWplY3RcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEFzeW5jUXVldWU7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEFzeW5jUXVldWU7XG5cbmZ1bmN0aW9uIHRha2VBc3luYyhfeCkge1xuICByZXR1cm4gX3Rha2VBc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfdGFrZUFzeW5jKCkge1xuICBfdGFrZUFzeW5jID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoYXN5bmNJdGVyYWJsZSkge1xuICAgIHZhciBjb3VudCxcbiAgICAgICAgcmVzdWx0LFxuICAgICAgICBpdGVyYXRvcixcbiAgICAgICAgX3lpZWxkJGl0ZXJhdG9yJG5leHQsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkb25lLFxuICAgICAgICBfYXJncyA9IGFyZ3VtZW50cztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY291bnQgPSBfYXJncy5sZW5ndGggPiAxICYmIF9hcmdzWzFdICE9PSB1bmRlZmluZWQgPyBfYXJnc1sxXSA6IEluZmluaXR5O1xuICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBpdGVyYXRvciA9IGFzeW5jSXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBpZiAoIShyZXN1bHQubGVuZ3RoIDwgY291bnQpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2O1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yLm5leHQoKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIF95aWVsZCRpdGVyYXRvciRuZXh0ID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIHZhbHVlID0gX3lpZWxkJGl0ZXJhdG9yJG5leHQudmFsdWU7XG4gICAgICAgICAgICBkb25lID0gX3lpZWxkJGl0ZXJhdG9yJG5leHQuZG9uZTtcblxuICAgICAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJicmVha1wiLCAxNCk7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHJlc3VsdCk7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlKTtcbiAgfSkpO1xuICByZXR1cm4gX3Rha2VBc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXN5bmMtcXVldWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNvbnZlcnRUb09iamVjdFJvdyA9IGNvbnZlcnRUb09iamVjdFJvdztcbmV4cG9ydHMuY29udmVydFRvQXJyYXlSb3cgPSBjb252ZXJ0VG9BcnJheVJvdztcblxuZnVuY3Rpb24gY29udmVydFRvT2JqZWN0Um93KGFycmF5Um93LCBoZWFkZXJzKSB7XG4gIGlmICghYXJyYXlSb3cpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ251bGwgcm93Jyk7XG4gIH1cblxuICBpZiAoIWhlYWRlcnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGhlYWRlcnMnKTtcbiAgfVxuXG4gIHZhciBvYmplY3RSb3cgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICBvYmplY3RSb3dbaGVhZGVyc1tpXV0gPSBhcnJheVJvd1tpXTtcbiAgfVxuXG4gIHJldHVybiBvYmplY3RSb3c7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRUb0FycmF5Um93KG9iamVjdFJvdywgaGVhZGVycykge1xuICBpZiAoIW9iamVjdFJvdykge1xuICAgIHRocm93IG5ldyBFcnJvcignbnVsbCByb3cnKTtcbiAgfVxuXG4gIGlmICghaGVhZGVycykge1xuICAgIHRocm93IG5ldyBFcnJvcignbm8gaGVhZGVycycpO1xuICB9XG5cbiAgdmFyIGFycmF5Um93ID0gbmV3IEFycmF5KGhlYWRlcnMubGVuZ3RoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICBhcnJheVJvd1tpXSA9IG9iamVjdFJvd1toZWFkZXJzW2ldXTtcbiAgfVxuXG4gIHJldHVybiBhcnJheVJvdztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdy11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhc3NlcnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2Fzc2VydC5hc3NlcnQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNCcm93c2VyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxzLmlzQnJvd3NlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1dvcmtlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2xvYmFscy5pc1dvcmtlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXb3JrZXJKb2JcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3dvcmtlckpvYi5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldvcmtlclRocmVhZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfd29ya2VyVGhyZWFkLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29ya2VyRmFybVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfd29ya2VyRmFybS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldvcmtlclBvb2xcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3dvcmtlclBvb2wuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXb3JrZXJCb2R5XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF93b3JrZXJCb2R5LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicHJvY2Vzc09uV29ya2VyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9wcm9jZXNzT25Xb3JrZXIucHJvY2Vzc09uV29ya2VyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNhblByb2Nlc3NPbldvcmtlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfcHJvY2Vzc09uV29ya2VyLmNhblByb2Nlc3NPbldvcmtlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVXb3JrZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2NyZWF0ZVdvcmtlci5jcmVhdGVXb3JrZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0V29ya2VyVVJMXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nZXRXb3JrZXJVcmwuZ2V0V29ya2VyVVJMO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZhbGlkYXRlV29ya2VyVmVyc2lvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdmFsaWRhdGVXb3JrZXJWZXJzaW9uLnZhbGlkYXRlV29ya2VyVmVyc2lvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRUcmFuc2Zlckxpc3RcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dldFRyYW5zZmVyTGlzdC5nZXRUcmFuc2Zlckxpc3Q7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0TGlicmFyeVVybFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbGlicmFyeVV0aWxzLmdldExpYnJhcnlVcmw7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibG9hZExpYnJhcnlcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2xpYnJhcnlVdGlscy5sb2FkTGlicmFyeTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBc3luY1F1ZXVlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hc3luY1F1ZXVlLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2hpbGRQcm9jZXNzUHJveHlcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2NoaWxkUHJvY2Vzc1Byb3h5LmRlZmF1bHQ7XG4gIH1cbn0pO1xuZXhwb3J0cy5OdWxsV29ya2VyID0gdm9pZCAwO1xuXG52YXIgX3ZlcnNpb24gPSByZXF1aXJlKFwiLi9saWIvZW52LXV0aWxzL3ZlcnNpb25cIik7XG5cbnZhciBfYXNzZXJ0ID0gcmVxdWlyZShcIi4vbGliL2Vudi11dGlscy9hc3NlcnRcIik7XG5cbnZhciBfZ2xvYmFscyA9IHJlcXVpcmUoXCIuL2xpYi9lbnYtdXRpbHMvZ2xvYmFsc1wiKTtcblxudmFyIF93b3JrZXJKb2IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi93b3JrZXItZmFybS93b3JrZXItam9iXCIpKTtcblxudmFyIF93b3JrZXJUaHJlYWQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi93b3JrZXItZmFybS93b3JrZXItdGhyZWFkXCIpKTtcblxudmFyIF93b3JrZXJGYXJtID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvd29ya2VyLWZhcm0vd29ya2VyLWZhcm1cIikpO1xuXG52YXIgX3dvcmtlclBvb2wgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi93b3JrZXItZmFybS93b3JrZXItcG9vbFwiKSk7XG5cbnZhciBfd29ya2VyQm9keSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL3dvcmtlci1mYXJtL3dvcmtlci1ib2R5XCIpKTtcblxudmFyIF9wcm9jZXNzT25Xb3JrZXIgPSByZXF1aXJlKFwiLi9saWIvd29ya2VyLWFwaS9wcm9jZXNzLW9uLXdvcmtlclwiKTtcblxudmFyIF9jcmVhdGVXb3JrZXIgPSByZXF1aXJlKFwiLi9saWIvd29ya2VyLWFwaS9jcmVhdGUtd29ya2VyXCIpO1xuXG52YXIgX2dldFdvcmtlclVybCA9IHJlcXVpcmUoXCIuL2xpYi93b3JrZXItYXBpL2dldC13b3JrZXItdXJsXCIpO1xuXG52YXIgX3ZhbGlkYXRlV29ya2VyVmVyc2lvbiA9IHJlcXVpcmUoXCIuL2xpYi93b3JrZXItYXBpL3ZhbGlkYXRlLXdvcmtlci12ZXJzaW9uXCIpO1xuXG52YXIgX2dldFRyYW5zZmVyTGlzdCA9IHJlcXVpcmUoXCIuL2xpYi93b3JrZXItdXRpbHMvZ2V0LXRyYW5zZmVyLWxpc3RcIik7XG5cbnZhciBfbGlicmFyeVV0aWxzID0gcmVxdWlyZShcIi4vbGliL2xpYnJhcnktdXRpbHMvbGlicmFyeS11dGlsc1wiKTtcblxudmFyIF9hc3luY1F1ZXVlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvYXN5bmMtcXVldWUvYXN5bmMtcXVldWVcIikpO1xuXG52YXIgX2NoaWxkUHJvY2Vzc1Byb3h5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvcHJvY2Vzcy11dGlscy9jaGlsZC1wcm9jZXNzLXByb3h5XCIpKTtcblxudmFyIE51bGxXb3JrZXIgPSB7XG4gIGlkOiAnbnVsbCcsXG4gIG5hbWU6ICdudWxsJyxcbiAgbW9kdWxlOiAnd29ya2VyLXV0aWxzJyxcbiAgdmVyc2lvbjogX3ZlcnNpb24uVkVSU0lPTixcbiAgb3B0aW9uczoge1xuICAgIG51bGw6IHt9XG4gIH1cbn07XG5leHBvcnRzLk51bGxXb3JrZXIgPSBOdWxsV29ya2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX1N5bWJvbCRhc3luY0l0ZXJhdG9yO1xuXG5fU3ltYm9sJGFzeW5jSXRlcmF0b3IgPSBTeW1ib2wuYXN5bmNJdGVyYXRvcjtcblxudmFyIEFzeW5jUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFzeW5jUXVldWUoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgQXN5bmNRdWV1ZSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJfdmFsdWVzXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJfc2V0dGxlcnNcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcIl9jbG9zZWRcIiwgdm9pZCAwKTtcbiAgICB0aGlzLl92YWx1ZXMgPSBbXTtcbiAgICB0aGlzLl9zZXR0bGVycyA9IFtdO1xuICAgIHRoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoQXN5bmNRdWV1ZSwgW3tcbiAgICBrZXk6IF9TeW1ib2wkYXN5bmNJdGVyYXRvcixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbnF1ZXVlKHZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5xdWV1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbnF1ZXVlKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2xvc2VkJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9zZXR0bGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICh0aGlzLl92YWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBpbnRlcm5hbCBzdGF0ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNldHRsZXIgPSB0aGlzLl9zZXR0bGVycy5zaGlmdCgpO1xuXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgc2V0dGxlci5yZWplY3QodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldHRsZXIucmVzb2x2ZSh7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIHdoaWxlICh0aGlzLl9zZXR0bGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBzZXR0bGVyID0gdGhpcy5fc2V0dGxlcnMuc2hpZnQoKTtcblxuICAgICAgICBzZXR0bGVyLnJlc29sdmUoe1xuICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5leHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl92YWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl92YWx1ZXMuc2hpZnQoKTtcblxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NldHRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaW50ZXJuYWwgc3RhdGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgX3RoaXMuX3NldHRsZXJzLnB1c2goe1xuICAgICAgICAgIHJlc29sdmU6IHJlc29sdmUsXG4gICAgICAgICAgcmVqZWN0OiByZWplY3RcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEFzeW5jUXVldWU7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEFzeW5jUXVldWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3luYy1xdWV1ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYXNzZXJ0ID0gYXNzZXJ0O1xuXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ2xvYWRlcnMuZ2wgYXNzZXJ0aW9uIGZhaWxlZC4nKTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzZXJ0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubm9kZVZlcnNpb24gPSBleHBvcnRzLmlzTW9iaWxlID0gZXhwb3J0cy5pc1dvcmtlciA9IGV4cG9ydHMuaXNCcm93c2VyID0gZXhwb3J0cy5kb2N1bWVudCA9IGV4cG9ydHMuZ2xvYmFsID0gZXhwb3J0cy53aW5kb3cgPSBleHBvcnRzLnNlbGYgPSB2b2lkIDA7XG5cbnZhciBfdHlwZW9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpKTtcblxudmFyIGdsb2JhbHMgPSB7XG4gIHNlbGY6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLFxuICB3aW5kb3c6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdyxcbiAgZ2xvYmFsOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwsXG4gIGRvY3VtZW50OiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50XG59O1xudmFyIHNlbGZfID0gZ2xvYmFscy5zZWxmIHx8IGdsb2JhbHMud2luZG93IHx8IGdsb2JhbHMuZ2xvYmFsIHx8IHt9O1xuZXhwb3J0cy5zZWxmID0gc2VsZl87XG52YXIgd2luZG93XyA9IGdsb2JhbHMud2luZG93IHx8IGdsb2JhbHMuc2VsZiB8fCBnbG9iYWxzLmdsb2JhbCB8fCB7fTtcbmV4cG9ydHMud2luZG93ID0gd2luZG93XztcbnZhciBnbG9iYWxfID0gZ2xvYmFscy5nbG9iYWwgfHwgZ2xvYmFscy5zZWxmIHx8IGdsb2JhbHMud2luZG93IHx8IHt9O1xuZXhwb3J0cy5nbG9iYWwgPSBnbG9iYWxfO1xudmFyIGRvY3VtZW50XyA9IGdsb2JhbHMuZG9jdW1lbnQgfHwge307XG5leHBvcnRzLmRvY3VtZW50ID0gZG9jdW1lbnRfO1xudmFyIGlzQnJvd3NlciA9ICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjIuZGVmYXVsdCkocHJvY2VzcykpICE9PSAnb2JqZWN0JyB8fCBTdHJpbmcocHJvY2VzcykgIT09ICdbb2JqZWN0IHByb2Nlc3NdJyB8fCBwcm9jZXNzLmJyb3dzZXI7XG5leHBvcnRzLmlzQnJvd3NlciA9IGlzQnJvd3NlcjtcbnZhciBpc1dvcmtlciA9IHR5cGVvZiBpbXBvcnRTY3JpcHRzID09PSAnZnVuY3Rpb24nO1xuZXhwb3J0cy5pc1dvcmtlciA9IGlzV29ya2VyO1xudmFyIGlzTW9iaWxlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5vcmllbnRhdGlvbiAhPT0gJ3VuZGVmaW5lZCc7XG5leHBvcnRzLmlzTW9iaWxlID0gaXNNb2JpbGU7XG52YXIgbWF0Y2hlcyA9IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnZlcnNpb24gJiYgL3YoWzAtOV0qKS8uZXhlYyhwcm9jZXNzLnZlcnNpb24pO1xudmFyIG5vZGVWZXJzaW9uID0gbWF0Y2hlcyAmJiBwYXJzZUZsb2F0KG1hdGNoZXNbMV0pIHx8IDA7XG5leHBvcnRzLm5vZGVWZXJzaW9uID0gbm9kZVZlcnNpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nbG9iYWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5WRVJTSU9OID0gdm9pZCAwO1xudmFyIERFRkFVTFRfVkVSU0lPTiA9ICdiZXRhJztcbnZhciBWRVJTSU9OID0gdHlwZW9mIFwiMy4wLjlcIiAhPT0gJ3VuZGVmaW5lZCcgPyBcIjMuMC45XCIgOiBERUZBVUxUX1ZFUlNJT047XG5leHBvcnRzLlZFUlNJT04gPSBWRVJTSU9OO1xuXG5pZiAodHlwZW9mIFwiMy4wLjlcIiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgY29uc29sZS5lcnJvcignbG9hZGVycy5nbDogVGhlIF9fVkVSU0lPTl9fIHZhcmlhYmxlIGlzIG5vdCBpbmplY3RlZCB1c2luZyBiYWJlbCBwbHVnaW4uIExhdGVzdCB1bnN0YWJsZSB3b3JrZXJzIHdvdWxkIGJlIGZldGNoZWQgZnJvbSB0aGUgQ0ROLicpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbnZhciBfdHlwZW9mID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5sb2FkTGlicmFyeSA9IGxvYWRMaWJyYXJ5O1xuZXhwb3J0cy5nZXRMaWJyYXJ5VXJsID0gZ2V0TGlicmFyeVVybDtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfZ2xvYmFscyA9IHJlcXVpcmUoXCIuLi9lbnYtdXRpbHMvZ2xvYmFsc1wiKTtcblxudmFyIG5vZGUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi4vbm9kZS9yZXF1aXJlLXV0aWxzLm5vZGVcIikpO1xuXG52YXIgX2Fzc2VydCA9IHJlcXVpcmUoXCIuLi9lbnYtdXRpbHMvYXNzZXJ0XCIpO1xuXG52YXIgX3ZlcnNpb24gPSByZXF1aXJlKFwiLi4vZW52LXV0aWxzL3ZlcnNpb25cIik7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOyB9KShub2RlSW50ZXJvcCk7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqLCBub2RlSW50ZXJvcCkgeyBpZiAoIW5vZGVJbnRlcm9wICYmIG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxudmFyIExBVEVTVCA9ICdiZXRhJztcbnZhciBWRVJTSU9OID0gdHlwZW9mIFwiMy4wLjlcIiAhPT0gJ3VuZGVmaW5lZCcgPyBcIjMuMC45XCIgOiBMQVRFU1Q7XG52YXIgbG9hZExpYnJhcnlQcm9taXNlcyA9IHt9O1xuXG5mdW5jdGlvbiBsb2FkTGlicmFyeShfeCkge1xuICByZXR1cm4gX2xvYWRMaWJyYXJ5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9sb2FkTGlicmFyeSgpIHtcbiAgX2xvYWRMaWJyYXJ5ID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUobGlicmFyeVVybCkge1xuICAgIHZhciBtb2R1bGVOYW1lLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBfYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIG1vZHVsZU5hbWUgPSBfYXJncy5sZW5ndGggPiAxICYmIF9hcmdzWzFdICE9PSB1bmRlZmluZWQgPyBfYXJnc1sxXSA6IG51bGw7XG4gICAgICAgICAgICBvcHRpb25zID0gX2FyZ3MubGVuZ3RoID4gMiAmJiBfYXJnc1syXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3NbMl0gOiB7fTtcblxuICAgICAgICAgICAgaWYgKG1vZHVsZU5hbWUpIHtcbiAgICAgICAgICAgICAgbGlicmFyeVVybCA9IGdldExpYnJhcnlVcmwobGlicmFyeVVybCwgbW9kdWxlTmFtZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxvYWRMaWJyYXJ5UHJvbWlzZXNbbGlicmFyeVVybF0gPSBsb2FkTGlicmFyeVByb21pc2VzW2xpYnJhcnlVcmxdIHx8IGxvYWRMaWJyYXJ5RnJvbUZpbGUobGlicmFyeVVybCk7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICAgIHJldHVybiBsb2FkTGlicmFyeVByb21pc2VzW2xpYnJhcnlVcmxdO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dC5zZW50KTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9sb2FkTGlicmFyeS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBnZXRMaWJyYXJ5VXJsKGxpYnJhcnksIG1vZHVsZU5hbWUsIG9wdGlvbnMpIHtcbiAgaWYgKGxpYnJhcnkuc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgcmV0dXJuIGxpYnJhcnk7XG4gIH1cblxuICB2YXIgbW9kdWxlcyA9IG9wdGlvbnMubW9kdWxlcyB8fCB7fTtcblxuICBpZiAobW9kdWxlc1tsaWJyYXJ5XSkge1xuICAgIHJldHVybiBtb2R1bGVzW2xpYnJhcnldO1xuICB9XG5cbiAgaWYgKCFfZ2xvYmFscy5pc0Jyb3dzZXIpIHtcbiAgICByZXR1cm4gXCJtb2R1bGVzL1wiLmNvbmNhdChtb2R1bGVOYW1lLCBcIi9kaXN0L2xpYnMvXCIpLmNvbmNhdChsaWJyYXJ5KTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLkNETikge1xuICAgICgwLCBfYXNzZXJ0LmFzc2VydCkob3B0aW9ucy5DRE4uc3RhcnRzV2l0aCgnaHR0cCcpKTtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQob3B0aW9ucy5DRE4sIFwiL1wiKS5jb25jYXQobW9kdWxlTmFtZSwgXCJAXCIpLmNvbmNhdChWRVJTSU9OLCBcIi9kaXN0L2xpYnMvXCIpLmNvbmNhdChsaWJyYXJ5KTtcbiAgfVxuXG4gIGlmIChfZ2xvYmFscy5pc1dvcmtlcikge1xuICAgIHJldHVybiBcIi4uL3NyYy9saWJzL1wiLmNvbmNhdChsaWJyYXJ5KTtcbiAgfVxuXG4gIHJldHVybiBcIm1vZHVsZXMvXCIuY29uY2F0KG1vZHVsZU5hbWUsIFwiL3NyYy9saWJzL1wiKS5jb25jYXQobGlicmFyeSk7XG59XG5cbmZ1bmN0aW9uIGxvYWRMaWJyYXJ5RnJvbUZpbGUoX3gyKSB7XG4gIHJldHVybiBfbG9hZExpYnJhcnlGcm9tRmlsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfbG9hZExpYnJhcnlGcm9tRmlsZSgpIHtcbiAgX2xvYWRMaWJyYXJ5RnJvbUZpbGUgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIobGlicmFyeVVybCkge1xuICAgIHZhciBfcmVzcG9uc2UsIHJlc3BvbnNlLCBzY3JpcHRTb3VyY2U7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoIWxpYnJhcnlVcmwuZW5kc1dpdGgoJ3dhc20nKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2gobGlicmFyeVVybCk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBfcmVzcG9uc2UgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNjtcbiAgICAgICAgICAgIHJldHVybiBfcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0Mi5zZW50KTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGlmIChfZ2xvYmFscy5pc0Jyb3dzZXIpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IG5vZGUucmVxdWlyZUZyb21GaWxlO1xuXG4gICAgICAgICAgICBpZiAoIV9jb250ZXh0Mi50MCkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMjtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnJlcXVpcmVGcm9tRmlsZShsaWJyYXJ5VXJsKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDIuc2VudDtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDIudDApO1xuXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIGlmICghX2dsb2JhbHMuaXNXb3JrZXIpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIGltcG9ydFNjcmlwdHMobGlicmFyeVVybCkpO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTg7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2gobGlicmFyeVVybCk7XG5cbiAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgcmVzcG9uc2UgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjE7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuXG4gICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgIHNjcmlwdFNvdXJjZSA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgbG9hZExpYnJhcnlGcm9tU3RyaW5nKHNjcmlwdFNvdXJjZSwgbGlicmFyeVVybCkpO1xuXG4gICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyKTtcbiAgfSkpO1xuICByZXR1cm4gX2xvYWRMaWJyYXJ5RnJvbUZpbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gbG9hZExpYnJhcnlGcm9tU3RyaW5nKHNjcmlwdFNvdXJjZSwgaWQpIHtcbiAgaWYgKCFfZ2xvYmFscy5pc0Jyb3dzZXIpIHtcbiAgICByZXR1cm4gbm9kZS5yZXF1aXJlRnJvbVN0cmluZyAmJiBub2RlLnJlcXVpcmVGcm9tU3RyaW5nKHNjcmlwdFNvdXJjZSwgaWQpO1xuICB9XG5cbiAgaWYgKF9nbG9iYWxzLmlzV29ya2VyKSB7XG4gICAgZXZhbC5jYWxsKF9nbG9iYWxzLmdsb2JhbCwgc2NyaXB0U291cmNlKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgc2NyaXB0LmlkID0gaWQ7XG5cbiAgdHJ5IHtcbiAgICBzY3JpcHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc2NyaXB0U291cmNlKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBzY3JpcHQudGV4dCA9IHNjcmlwdFNvdXJjZTtcbiAgfVxuXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgcmV0dXJuIG51bGw7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saWJyYXJ5LXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY3JlYXRlV29ya2VyID0gY3JlYXRlV29ya2VyO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY0l0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNJdGVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNRdWV1ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2FzeW5jLXF1ZXVlL2FzeW5jLXF1ZXVlXCIpKTtcblxudmFyIF93b3JrZXJCb2R5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vd29ya2VyLWZhcm0vd29ya2VyLWJvZHlcIikpO1xuXG52YXIgcmVxdWVzdElkID0gMDtcbnZhciBpbnB1dEJhdGNoZXM7XG52YXIgb3B0aW9ucztcblxuZnVuY3Rpb24gY3JlYXRlV29ya2VyKHByb2Nlc3MsIHByb2Nlc3NJbkJhdGNoZXMpIHtcbiAgaWYgKHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjb250ZXh0ID0ge1xuICAgIHByb2Nlc3M6IHByb2Nlc3NPbk1haW5UaHJlYWRcbiAgfTtcblxuICBfd29ya2VyQm9keS5kZWZhdWx0Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKHR5cGUsIHBheWxvYWQpIHtcbiAgICAgIHZhciByZXN1bHQsIHJlc3VsdEl0ZXJhdG9yLCBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uLCBfZGlkSXRlcmF0b3JFcnJvciwgX2l0ZXJhdG9yRXJyb3IsIF9pdGVyYXRvciwgX3N0ZXAsIF92YWx1ZSwgYmF0Y2gsIG1lc3NhZ2U7XG5cbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMDtcbiAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSB0eXBlO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gX2NvbnRleHQudDAgPT09ICdwcm9jZXNzJyA/IDQgOiBfY29udGV4dC50MCA9PT0gJ3Byb2Nlc3MtaW4tYmF0Y2hlcycgPyAxMSA6IF9jb250ZXh0LnQwID09PSAnaW5wdXQtYmF0Y2gnID8gNTEgOiBfY29udGV4dC50MCA9PT0gJ2lucHV0LWRvbmUnID8gNTMgOiA1NTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgaWYgKHByb2Nlc3MpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya2VyIGRvZXMgbm90IHN1cHBvcnQgYXRvbWljIHByb2Nlc3NpbmcnKTtcblxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gODtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3MocGF5bG9hZC5pbnB1dCwgcGF5bG9hZC5vcHRpb25zIHx8IHt9LCBjb250ZXh0KTtcblxuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgICAgIF93b3JrZXJCb2R5LmRlZmF1bHQucG9zdE1lc3NhZ2UoJ2RvbmUnLCB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHRcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcImJyZWFrXCIsIDU1KTtcblxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgaWYgKHByb2Nlc3NJbkJhdGNoZXMpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtlciBkb2VzIG5vdCBzdXBwb3J0IGJhdGNoZWQgcHJvY2Vzc2luZycpO1xuXG4gICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICBpbnB1dEJhdGNoZXMgPSBuZXcgX2FzeW5jUXVldWUuZGVmYXVsdCgpO1xuICAgICAgICAgICAgICBvcHRpb25zID0gcGF5bG9hZC5vcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgICByZXN1bHRJdGVyYXRvciA9IHByb2Nlc3NJbkJhdGNoZXMoaW5wdXRCYXRjaGVzLCBvcHRpb25zLCBjb250ZXh0ID09PSBudWxsIHx8IGNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRleHQucHJvY2Vzc0luQmF0Y2hlcyk7XG4gICAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTg7XG4gICAgICAgICAgICAgIF9pdGVyYXRvciA9ICgwLCBfYXN5bmNJdGVyYXRvcjIuZGVmYXVsdCkocmVzdWx0SXRlcmF0b3IpO1xuXG4gICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjI7XG4gICAgICAgICAgICAgIHJldHVybiBfaXRlcmF0b3IubmV4dCgpO1xuXG4gICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICBfc3RlcCA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSBfc3RlcC5kb25lO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjY7XG4gICAgICAgICAgICAgIHJldHVybiBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgICAgX3ZhbHVlID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgICBpZiAoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbikge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJhdGNoID0gX3ZhbHVlO1xuXG4gICAgICAgICAgICAgIF93b3JrZXJCb2R5LmRlZmF1bHQucG9zdE1lc3NhZ2UoJ291dHB1dC1iYXRjaCcsIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6IGJhdGNoXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjYXNlIDMwOlxuICAgICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIwO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAzMzpcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM5O1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAzNTpcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDM1O1xuICAgICAgICAgICAgICBfY29udGV4dC50MSA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMTgpO1xuICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gX2NvbnRleHQudDE7XG5cbiAgICAgICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAzOTtcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDQwO1xuXG4gICAgICAgICAgICAgIGlmICghKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDQ7XG4gICAgICAgICAgICAgIHJldHVybiBfaXRlcmF0b3IucmV0dXJuKCk7XG5cbiAgICAgICAgICAgIGNhc2UgNDQ6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA0NDtcblxuICAgICAgICAgICAgICBpZiAoIV9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG5cbiAgICAgICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5maW5pc2goNDQpO1xuXG4gICAgICAgICAgICBjYXNlIDQ4OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDM5KTtcblxuICAgICAgICAgICAgY2FzZSA0OTpcbiAgICAgICAgICAgICAgX3dvcmtlckJvZHkuZGVmYXVsdC5wb3N0TWVzc2FnZSgnZG9uZScsIHt9KTtcblxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwiYnJlYWtcIiwgNTUpO1xuXG4gICAgICAgICAgICBjYXNlIDUxOlxuICAgICAgICAgICAgICBpbnB1dEJhdGNoZXMucHVzaChwYXlsb2FkLmlucHV0KTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcImJyZWFrXCIsIDU1KTtcblxuICAgICAgICAgICAgY2FzZSA1MzpcbiAgICAgICAgICAgICAgaW5wdXRCYXRjaGVzLmNsb3NlKCk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJicmVha1wiLCA1NSk7XG5cbiAgICAgICAgICAgIGNhc2UgNTU6XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2MTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNTc6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA1NztcbiAgICAgICAgICAgICAgX2NvbnRleHQudDIgPSBfY29udGV4dFtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgICBtZXNzYWdlID0gX2NvbnRleHQudDIgaW5zdGFuY2VvZiBFcnJvciA/IF9jb250ZXh0LnQyLm1lc3NhZ2UgOiAnJztcblxuICAgICAgICAgICAgICBfd29ya2VyQm9keS5kZWZhdWx0LnBvc3RNZXNzYWdlKCdlcnJvcicsIHtcbiAgICAgICAgICAgICAgICBlcnJvcjogbWVzc2FnZVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY2FzZSA2MTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbMCwgNTddLCBbMTgsIDM1LCAzOSwgNDldLCBbNDAsLCA0NCwgNDhdXSk7XG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChfeCwgX3gyKSB7XG4gICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0oKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc09uTWFpblRocmVhZChhcnJheUJ1ZmZlcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIGlkID0gcmVxdWVzdElkKys7XG5cbiAgICB2YXIgb25NZXNzYWdlID0gZnVuY3Rpb24gb25NZXNzYWdlKHR5cGUsIHBheWxvYWQpIHtcbiAgICAgIGlmIChwYXlsb2FkLmlkICE9PSBpZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdkb25lJzpcbiAgICAgICAgICBfd29ya2VyQm9keS5kZWZhdWx0LnJlbW92ZUV2ZW50TGlzdGVuZXIob25NZXNzYWdlKTtcblxuICAgICAgICAgIHJlc29sdmUocGF5bG9hZC5yZXN1bHQpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICBfd29ya2VyQm9keS5kZWZhdWx0LnJlbW92ZUV2ZW50TGlzdGVuZXIob25NZXNzYWdlKTtcblxuICAgICAgICAgIHJlamVjdChwYXlsb2FkLmVycm9yKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgfVxuICAgIH07XG5cbiAgICBfd29ya2VyQm9keS5kZWZhdWx0LmFkZEV2ZW50TGlzdGVuZXIob25NZXNzYWdlKTtcblxuICAgIHZhciBwYXlsb2FkID0ge1xuICAgICAgaWQ6IGlkLFxuICAgICAgaW5wdXQ6IGFycmF5QnVmZmVyLFxuICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgIH07XG5cbiAgICBfd29ya2VyQm9keS5kZWZhdWx0LnBvc3RNZXNzYWdlKCdwcm9jZXNzJywgcGF5bG9hZCk7XG4gIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlLXdvcmtlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0V29ya2VyTmFtZSA9IGdldFdvcmtlck5hbWU7XG5leHBvcnRzLmdldFdvcmtlclVSTCA9IGdldFdvcmtlclVSTDtcblxudmFyIF9hc3NlcnQgPSByZXF1aXJlKFwiLi4vZW52LXV0aWxzL2Fzc2VydFwiKTtcblxudmFyIF92ZXJzaW9uID0gcmVxdWlyZShcIi4uL2Vudi11dGlscy92ZXJzaW9uXCIpO1xuXG52YXIgTlBNX1RBRyA9ICdsYXRlc3QnO1xudmFyIFZFUlNJT04gPSB0eXBlb2YgXCIzLjAuOVwiICE9PSAndW5kZWZpbmVkJyA/IFwiMy4wLjlcIiA6IE5QTV9UQUc7XG5cbmZ1bmN0aW9uIGdldFdvcmtlck5hbWUod29ya2VyKSB7XG4gIHZhciB3YXJuaW5nID0gd29ya2VyLnZlcnNpb24gIT09IFZFUlNJT04gPyBcIiAod29ya2VyLXV0aWxzQFwiLmNvbmNhdChWRVJTSU9OLCBcIilcIikgOiAnJztcbiAgcmV0dXJuIFwiXCIuY29uY2F0KHdvcmtlci5uYW1lLCBcIkBcIikuY29uY2F0KHdvcmtlci52ZXJzaW9uKS5jb25jYXQod2FybmluZyk7XG59XG5cbmZ1bmN0aW9uIGdldFdvcmtlclVSTCh3b3JrZXIpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgd29ya2VyT3B0aW9ucyA9IG9wdGlvbnNbd29ya2VyLmlkXSB8fCB7fTtcbiAgdmFyIHdvcmtlckZpbGUgPSBcIlwiLmNvbmNhdCh3b3JrZXIuaWQsIFwiLXdvcmtlci5qc1wiKTtcbiAgdmFyIHVybCA9IHdvcmtlck9wdGlvbnMud29ya2VyVXJsO1xuXG4gIGlmIChvcHRpb25zLl93b3JrZXJUeXBlID09PSAndGVzdCcpIHtcbiAgICB1cmwgPSBcIm1vZHVsZXMvXCIuY29uY2F0KHdvcmtlci5tb2R1bGUsIFwiL2Rpc3QvXCIpLmNvbmNhdCh3b3JrZXJGaWxlKTtcbiAgfVxuXG4gIGlmICghdXJsKSB7XG4gICAgdmFyIHZlcnNpb24gPSB3b3JrZXIudmVyc2lvbjtcblxuICAgIGlmICh2ZXJzaW9uID09PSAnbGF0ZXN0Jykge1xuICAgICAgdmVyc2lvbiA9IE5QTV9UQUc7XG4gICAgfVxuXG4gICAgdmFyIHZlcnNpb25UYWcgPSB2ZXJzaW9uID8gXCJAXCIuY29uY2F0KHZlcnNpb24pIDogJyc7XG4gICAgdXJsID0gXCJodHRwczovL3VucGtnLmNvbS9AbG9hZGVycy5nbC9cIi5jb25jYXQod29ya2VyLm1vZHVsZSkuY29uY2F0KHZlcnNpb25UYWcsIFwiL2Rpc3QvXCIpLmNvbmNhdCh3b3JrZXJGaWxlKTtcbiAgfVxuXG4gICgwLCBfYXNzZXJ0LmFzc2VydCkodXJsKTtcbiAgcmV0dXJuIHVybDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC13b3JrZXItdXJsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY2FuUHJvY2Vzc09uV29ya2VyID0gY2FuUHJvY2Vzc09uV29ya2VyO1xuZXhwb3J0cy5wcm9jZXNzT25Xb3JrZXIgPSBwcm9jZXNzT25Xb3JrZXI7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX3dvcmtlckZhcm0gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi93b3JrZXItZmFybS93b3JrZXItZmFybVwiKSk7XG5cbnZhciBfcmVtb3ZlTm9udHJhbnNmZXJhYmxlT3B0aW9ucyA9IHJlcXVpcmUoXCIuLi93b3JrZXItdXRpbHMvcmVtb3ZlLW5vbnRyYW5zZmVyYWJsZS1vcHRpb25zXCIpO1xuXG52YXIgX2dldFdvcmtlclVybCA9IHJlcXVpcmUoXCIuL2dldC13b3JrZXItdXJsXCIpO1xuXG5mdW5jdGlvbiBjYW5Qcm9jZXNzT25Xb3JrZXIod29ya2VyLCBvcHRpb25zKSB7XG4gIGlmICghX3dvcmtlckZhcm0uZGVmYXVsdC5pc1N1cHBvcnRlZCgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHdvcmtlci53b3JrZXIgJiYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy53b3JrZXIpO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzT25Xb3JrZXIoX3gsIF94Mikge1xuICByZXR1cm4gX3Byb2Nlc3NPbldvcmtlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfcHJvY2Vzc09uV29ya2VyKCkge1xuICBfcHJvY2Vzc09uV29ya2VyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUod29ya2VyLCBkYXRhKSB7XG4gICAgdmFyIG9wdGlvbnMsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHVybCxcbiAgICAgICAgd29ya2VyRmFybSxcbiAgICAgICAgd29ya2VyUG9vbCxcbiAgICAgICAgam9iTmFtZSxcbiAgICAgICAgam9iLFxuICAgICAgICB0cmFuc2ZlcmFibGVPcHRpb25zLFxuICAgICAgICByZXN1bHQsXG4gICAgICAgIF9hcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgb3B0aW9ucyA9IF9hcmdzLmxlbmd0aCA+IDIgJiYgX2FyZ3NbMl0gIT09IHVuZGVmaW5lZCA/IF9hcmdzWzJdIDoge307XG4gICAgICAgICAgICBjb250ZXh0ID0gX2FyZ3MubGVuZ3RoID4gMyAmJiBfYXJnc1szXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3NbM10gOiB7fTtcbiAgICAgICAgICAgIG5hbWUgPSAoMCwgX2dldFdvcmtlclVybC5nZXRXb3JrZXJOYW1lKSh3b3JrZXIpO1xuICAgICAgICAgICAgdXJsID0gKDAsIF9nZXRXb3JrZXJVcmwuZ2V0V29ya2VyVVJMKSh3b3JrZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgd29ya2VyRmFybSA9IF93b3JrZXJGYXJtLmRlZmF1bHQuZ2V0V29ya2VyRmFybShvcHRpb25zKTtcbiAgICAgICAgICAgIHdvcmtlclBvb2wgPSB3b3JrZXJGYXJtLmdldFdvcmtlclBvb2woe1xuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBqb2JOYW1lID0gb3B0aW9ucy5qb2JOYW1lIHx8IHdvcmtlci5uYW1lO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgICByZXR1cm4gd29ya2VyUG9vbC5zdGFydEpvYihqb2JOYW1lLCBvbk1lc3NhZ2UuYmluZChudWxsLCBjb250ZXh0KSk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBqb2IgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgdHJhbnNmZXJhYmxlT3B0aW9ucyA9ICgwLCBfcmVtb3ZlTm9udHJhbnNmZXJhYmxlT3B0aW9ucy5yZW1vdmVOb250cmFuc2ZlcmFibGVPcHRpb25zKShvcHRpb25zKTtcbiAgICAgICAgICAgIGpvYi5wb3N0TWVzc2FnZSgncHJvY2VzcycsIHtcbiAgICAgICAgICAgICAgaW5wdXQ6IGRhdGEsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IHRyYW5zZmVyYWJsZU9wdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE0O1xuICAgICAgICAgICAgcmV0dXJuIGpvYi5yZXN1bHQ7XG5cbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzdWx0LnJlc3VsdCk7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlKTtcbiAgfSkpO1xuICByZXR1cm4gX3Byb2Nlc3NPbldvcmtlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBvbk1lc3NhZ2UoX3gzLCBfeDQsIF94NSwgX3g2KSB7XG4gIHJldHVybiBfb25NZXNzYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9vbk1lc3NhZ2UoKSB7XG4gIF9vbk1lc3NhZ2UgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoY29udGV4dCwgam9iLCB0eXBlLCBwYXlsb2FkKSB7XG4gICAgdmFyIGlkLCBpbnB1dCwgb3B0aW9ucywgcmVzdWx0LCBtZXNzYWdlO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IHR5cGU7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IF9jb250ZXh0Mi50MCA9PT0gJ2RvbmUnID8gMyA6IF9jb250ZXh0Mi50MCA9PT0gJ2Vycm9yJyA/IDUgOiBfY29udGV4dDIudDAgPT09ICdwcm9jZXNzJyA/IDcgOiAyMztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgam9iLmRvbmUocGF5bG9hZCk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcImJyZWFrXCIsIDI0KTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGpvYi5lcnJvcihwYXlsb2FkLmVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwiYnJlYWtcIiwgMjQpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgaWQgPSBwYXlsb2FkLmlkLCBpbnB1dCA9IHBheWxvYWQuaW5wdXQsIG9wdGlvbnMgPSBwYXlsb2FkLm9wdGlvbnM7XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDg7XG5cbiAgICAgICAgICAgIGlmIChjb250ZXh0LnByb2Nlc3MpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGpvYi5wb3N0TWVzc2FnZSgnZXJyb3InLCB7XG4gICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgZXJyb3I6ICdXb3JrZXIgbm90IHNldCB1cCB0byBwcm9jZXNzIG9uIG1haW4gdGhyZWFkJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE0O1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQucHJvY2VzcyhpbnB1dCwgb3B0aW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICBqb2IucG9zdE1lc3NhZ2UoJ2RvbmUnLCB7XG4gICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyMjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTg7XG4gICAgICAgICAgICBfY29udGV4dDIudDEgPSBfY29udGV4dDJbXCJjYXRjaFwiXSg4KTtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBfY29udGV4dDIudDEgaW5zdGFuY2VvZiBFcnJvciA/IF9jb250ZXh0Mi50MS5tZXNzYWdlIDogJ3Vua25vd24gZXJyb3InO1xuICAgICAgICAgICAgam9iLnBvc3RNZXNzYWdlKCdlcnJvcicsIHtcbiAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICBlcnJvcjogbWVzc2FnZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJicmVha1wiLCAyNCk7XG5cbiAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwicHJvY2Vzcy1vbi13b3JrZXI6IHVua25vd24gbWVzc2FnZSBcIi5jb25jYXQodHlwZSkpO1xuXG4gICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyLCBudWxsLCBbWzgsIDE4XV0pO1xuICB9KSk7XG4gIHJldHVybiBfb25NZXNzYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9jZXNzLW9uLXdvcmtlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMudmFsaWRhdGVXb3JrZXJWZXJzaW9uID0gdmFsaWRhdGVXb3JrZXJWZXJzaW9uO1xuXG52YXIgX2Fzc2VydCA9IHJlcXVpcmUoXCIuLi9lbnYtdXRpbHMvYXNzZXJ0XCIpO1xuXG52YXIgX3ZlcnNpb24gPSByZXF1aXJlKFwiLi4vZW52LXV0aWxzL3ZlcnNpb25cIik7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlV29ya2VyVmVyc2lvbih3b3JrZXIpIHtcbiAgdmFyIGNvcmVWZXJzaW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBfdmVyc2lvbi5WRVJTSU9OO1xuICAoMCwgX2Fzc2VydC5hc3NlcnQpKHdvcmtlciwgJ25vIHdvcmtlciBwcm92aWRlZCcpO1xuICB2YXIgd29ya2VyVmVyc2lvbiA9IHdvcmtlci52ZXJzaW9uO1xuXG4gIGlmICghY29yZVZlcnNpb24gfHwgIXdvcmtlclZlcnNpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcGFyc2VWZXJzaW9uKHZlcnNpb24pIHtcbiAgdmFyIHBhcnRzID0gdmVyc2lvbi5zcGxpdCgnLicpLm1hcChOdW1iZXIpO1xuICByZXR1cm4ge1xuICAgIG1ham9yOiBwYXJ0c1swXSxcbiAgICBtaW5vcjogcGFydHNbMV1cbiAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkYXRlLXdvcmtlci12ZXJzaW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9nZXRUcmFuc2Zlckxpc3QgPSByZXF1aXJlKFwiLi4vd29ya2VyLXV0aWxzL2dldC10cmFuc2Zlci1saXN0XCIpO1xuXG52YXIgb25NZXNzYWdlV3JhcHBlck1hcCA9IG5ldyBNYXAoKTtcblxudmFyIFdvcmtlckJvZHkgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFdvcmtlckJvZHkoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgV29ya2VyQm9keSk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShXb3JrZXJCb2R5LCBudWxsLCBbe1xuICAgIGtleTogXCJvbm1lc3NhZ2VcIixcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChvbk1lc3NhZ2UpIHtcbiAgICAgIHNlbGYub25tZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCFpc0tub3duTWVzc2FnZShtZXNzYWdlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfbWVzc2FnZSRkYXRhID0gbWVzc2FnZS5kYXRhLFxuICAgICAgICAgICAgdHlwZSA9IF9tZXNzYWdlJGRhdGEudHlwZSxcbiAgICAgICAgICAgIHBheWxvYWQgPSBfbWVzc2FnZSRkYXRhLnBheWxvYWQ7XG4gICAgICAgIG9uTWVzc2FnZSh0eXBlLCBwYXlsb2FkKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZEV2ZW50TGlzdGVuZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihvbk1lc3NhZ2UpIHtcbiAgICAgIHZhciBvbk1lc3NhZ2VXcmFwcGVyID0gb25NZXNzYWdlV3JhcHBlck1hcC5nZXQob25NZXNzYWdlKTtcblxuICAgICAgaWYgKCFvbk1lc3NhZ2VXcmFwcGVyKSB7XG4gICAgICAgIG9uTWVzc2FnZVdyYXBwZXIgPSBmdW5jdGlvbiBvbk1lc3NhZ2VXcmFwcGVyKG1lc3NhZ2UpIHtcbiAgICAgICAgICBpZiAoIWlzS25vd25NZXNzYWdlKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9tZXNzYWdlJGRhdGEyID0gbWVzc2FnZS5kYXRhLFxuICAgICAgICAgICAgICB0eXBlID0gX21lc3NhZ2UkZGF0YTIudHlwZSxcbiAgICAgICAgICAgICAgcGF5bG9hZCA9IF9tZXNzYWdlJGRhdGEyLnBheWxvYWQ7XG4gICAgICAgICAgb25NZXNzYWdlKHR5cGUsIHBheWxvYWQpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbk1lc3NhZ2VXcmFwcGVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKG9uTWVzc2FnZSkge1xuICAgICAgdmFyIG9uTWVzc2FnZVdyYXBwZXIgPSBvbk1lc3NhZ2VXcmFwcGVyTWFwLmdldChvbk1lc3NhZ2UpO1xuICAgICAgb25NZXNzYWdlV3JhcHBlck1hcC5kZWxldGUob25NZXNzYWdlKTtcbiAgICAgIHNlbGYucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG9uTWVzc2FnZVdyYXBwZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3N0TWVzc2FnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3N0TWVzc2FnZSh0eXBlLCBwYXlsb2FkKSB7XG4gICAgICBpZiAoc2VsZikge1xuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICBzb3VyY2U6ICdsb2FkZXJzLmdsJyxcbiAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRyYW5zZmVyTGlzdCA9ICgwLCBfZ2V0VHJhbnNmZXJMaXN0LmdldFRyYW5zZmVyTGlzdCkocGF5bG9hZCk7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoZGF0YSwgdHJhbnNmZXJMaXN0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFdvcmtlckJvZHk7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFdvcmtlckJvZHk7XG5cbmZ1bmN0aW9uIGlzS25vd25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgdmFyIHR5cGUgPSBtZXNzYWdlLnR5cGUsXG4gICAgICBkYXRhID0gbWVzc2FnZS5kYXRhO1xuICByZXR1cm4gdHlwZSA9PT0gJ21lc3NhZ2UnICYmIGRhdGEgJiYgdHlwZW9mIGRhdGEuc291cmNlID09PSAnc3RyaW5nJyAmJiBkYXRhLnNvdXJjZS5zdGFydHNXaXRoKCdsb2FkZXJzLmdsJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JrZXItYm9keS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfd29ya2VyUG9vbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vd29ya2VyLXBvb2xcIikpO1xuXG52YXIgX3dvcmtlclRocmVhZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vd29ya2VyLXRocmVhZFwiKSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBERUZBVUxUX1BST1BTID0ge1xuICBtYXhDb25jdXJyZW5jeTogMyxcbiAgbWF4TW9iaWxlQ29uY3VycmVuY3k6IDEsXG4gIG9uRGVidWc6IGZ1bmN0aW9uIG9uRGVidWcoKSB7fSxcbiAgcmV1c2VXb3JrZXJzOiB0cnVlXG59O1xuXG52YXIgV29ya2VyRmFybSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gV29ya2VyRmFybShwcm9wcykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFdvcmtlckZhcm0pO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwicHJvcHNcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcIndvcmtlclBvb2xzXCIsIG5ldyBNYXAoKSk7XG4gICAgdGhpcy5wcm9wcyA9IF9vYmplY3RTcHJlYWQoe30sIERFRkFVTFRfUFJPUFMpO1xuICAgIHRoaXMuc2V0UHJvcHMocHJvcHMpO1xuICAgIHRoaXMud29ya2VyUG9vbHMgPSBuZXcgTWFwKCk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShXb3JrZXJGYXJtLCBbe1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy53b3JrZXJQb29scy52YWx1ZXMoKSksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHdvcmtlclBvb2wgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB3b3JrZXJQb29sLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRQcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQcm9wcyhwcm9wcykge1xuICAgICAgdGhpcy5wcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdGhpcy5wcm9wcyksIHByb3BzKTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLndvcmtlclBvb2xzLnZhbHVlcygpKSxcbiAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHdvcmtlclBvb2wgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgd29ya2VyUG9vbC5zZXRQcm9wcyh0aGlzLl9nZXRXb3JrZXJQb29sUHJvcHMoKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRXb3JrZXJQb29sXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFdvcmtlclBvb2wob3B0aW9ucykge1xuICAgICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUsXG4gICAgICAgICAgc291cmNlID0gb3B0aW9ucy5zb3VyY2UsXG4gICAgICAgICAgdXJsID0gb3B0aW9ucy51cmw7XG4gICAgICB2YXIgd29ya2VyUG9vbCA9IHRoaXMud29ya2VyUG9vbHMuZ2V0KG5hbWUpO1xuXG4gICAgICBpZiAoIXdvcmtlclBvb2wpIHtcbiAgICAgICAgd29ya2VyUG9vbCA9IG5ldyBfd29ya2VyUG9vbC5kZWZhdWx0KHtcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIHVybDogdXJsXG4gICAgICAgIH0pO1xuICAgICAgICB3b3JrZXJQb29sLnNldFByb3BzKHRoaXMuX2dldFdvcmtlclBvb2xQcm9wcygpKTtcbiAgICAgICAgdGhpcy53b3JrZXJQb29scy5zZXQobmFtZSwgd29ya2VyUG9vbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3b3JrZXJQb29sO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0V29ya2VyUG9vbFByb3BzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRXb3JrZXJQb29sUHJvcHMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXhDb25jdXJyZW5jeTogdGhpcy5wcm9wcy5tYXhDb25jdXJyZW5jeSxcbiAgICAgICAgbWF4TW9iaWxlQ29uY3VycmVuY3k6IHRoaXMucHJvcHMubWF4TW9iaWxlQ29uY3VycmVuY3ksXG4gICAgICAgIHJldXNlV29ya2VyczogdGhpcy5wcm9wcy5yZXVzZVdvcmtlcnMsXG4gICAgICAgIG9uRGVidWc6IHRoaXMucHJvcHMub25EZWJ1Z1xuICAgICAgfTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJpc1N1cHBvcnRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1N1cHBvcnRlZCgpIHtcbiAgICAgIHJldHVybiBfd29ya2VyVGhyZWFkLmRlZmF1bHQuaXNTdXBwb3J0ZWQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0V29ya2VyRmFybVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRXb3JrZXJGYXJtKCkge1xuICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgIFdvcmtlckZhcm0uX3dvcmtlckZhcm0gPSBXb3JrZXJGYXJtLl93b3JrZXJGYXJtIHx8IG5ldyBXb3JrZXJGYXJtKHt9KTtcblxuICAgICAgV29ya2VyRmFybS5fd29ya2VyRmFybS5zZXRQcm9wcyhwcm9wcyk7XG5cbiAgICAgIHJldHVybiBXb3JrZXJGYXJtLl93b3JrZXJGYXJtO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gV29ya2VyRmFybTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gV29ya2VyRmFybTtcbigwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKFdvcmtlckZhcm0sIFwiX3dvcmtlckZhcm1cIiwgdm9pZCAwKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmtlci1mYXJtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9hc3NlcnQgPSByZXF1aXJlKFwiLi4vZW52LXV0aWxzL2Fzc2VydFwiKTtcblxudmFyIFdvcmtlckpvYiA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gV29ya2VySm9iKGpvYk5hbWUsIHdvcmtlclRocmVhZCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBXb3JrZXJKb2IpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwibmFtZVwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwid29ya2VyVGhyZWFkXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJpc1J1bm5pbmdcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcInJlc3VsdFwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiX3Jlc29sdmVcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcIl9yZWplY3RcIiwgdm9pZCAwKTtcbiAgICB0aGlzLm5hbWUgPSBqb2JOYW1lO1xuICAgIHRoaXMud29ya2VyVGhyZWFkID0gd29ya2VyVGhyZWFkO1xuICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcblxuICAgIHRoaXMuX3Jlc29sdmUgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIHRoaXMuX3JlamVjdCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgdGhpcy5yZXN1bHQgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBfdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICBfdGhpcy5fcmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoV29ya2VySm9iLCBbe1xuICAgIGtleTogXCJwb3N0TWVzc2FnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3N0TWVzc2FnZSh0eXBlLCBwYXlsb2FkKSB7XG4gICAgICB0aGlzLndvcmtlclRocmVhZC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHNvdXJjZTogJ2xvYWRlcnMuZ2wnLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBwYXlsb2FkOiBwYXlsb2FkXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZG9uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb25lKHZhbHVlKSB7XG4gICAgICAoMCwgX2Fzc2VydC5hc3NlcnQpKHRoaXMuaXNSdW5uaW5nKTtcbiAgICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuX3Jlc29sdmUodmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcnJvcihfZXJyb3IpIHtcbiAgICAgICgwLCBfYXNzZXJ0LmFzc2VydCkodGhpcy5pc1J1bm5pbmcpO1xuICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcblxuICAgICAgdGhpcy5fcmVqZWN0KF9lcnJvcik7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBXb3JrZXJKb2I7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFdvcmtlckpvYjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmtlci1qb2IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9nbG9iYWxzID0gcmVxdWlyZShcIi4uL2Vudi11dGlscy9nbG9iYWxzXCIpO1xuXG52YXIgX3dvcmtlclRocmVhZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vd29ya2VyLXRocmVhZFwiKSk7XG5cbnZhciBfd29ya2VySm9iID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi93b3JrZXItam9iXCIpKTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBXb3JrZXJQb29sID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBXb3JrZXJQb29sKHByb3BzKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgV29ya2VyUG9vbCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJuYW1lXCIsICd1bm5hbWVkJyk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJzb3VyY2VcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcInVybFwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwibWF4Q29uY3VycmVuY3lcIiwgMSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJtYXhNb2JpbGVDb25jdXJyZW5jeVwiLCAxKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcIm9uRGVidWdcIiwgZnVuY3Rpb24gKCkge30pO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwicmV1c2VXb3JrZXJzXCIsIHRydWUpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwicHJvcHNcIiwge30pO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiam9iUXVldWVcIiwgW10pO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiaWRsZVF1ZXVlXCIsIFtdKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcImNvdW50XCIsIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiaXNEZXN0cm95ZWRcIiwgZmFsc2UpO1xuICAgIHRoaXMuc291cmNlID0gcHJvcHMuc291cmNlO1xuICAgIHRoaXMudXJsID0gcHJvcHMudXJsO1xuICAgIHRoaXMuc2V0UHJvcHMocHJvcHMpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoV29ya2VyUG9vbCwgW3tcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5pZGxlUXVldWUuZm9yRWFjaChmdW5jdGlvbiAod29ya2VyKSB7XG4gICAgICAgIHJldHVybiB3b3JrZXIuZGVzdHJveSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmlzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UHJvcHMocHJvcHMpIHtcbiAgICAgIHRoaXMucHJvcHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMucHJvcHMpLCBwcm9wcyk7XG5cbiAgICAgIGlmIChwcm9wcy5uYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gcHJvcHMubmFtZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3BzLm1heENvbmN1cnJlbmN5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5tYXhDb25jdXJyZW5jeSA9IHByb3BzLm1heENvbmN1cnJlbmN5O1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcHMubWF4TW9iaWxlQ29uY3VycmVuY3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLm1heE1vYmlsZUNvbmN1cnJlbmN5ID0gcHJvcHMubWF4TW9iaWxlQ29uY3VycmVuY3k7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wcy5yZXVzZVdvcmtlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnJldXNlV29ya2VycyA9IHByb3BzLnJldXNlV29ya2VycztcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3BzLm9uRGVidWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLm9uRGVidWcgPSBwcm9wcy5vbkRlYnVnO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydEpvYlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3N0YXJ0Sm9iID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUobmFtZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBvbk1lc3NhZ2UsXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgc3RhcnRQcm9taXNlLFxuICAgICAgICAgICAgX2FyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG9uTWVzc2FnZSA9IF9hcmdzLmxlbmd0aCA+IDEgJiYgX2FyZ3NbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzWzFdIDogZnVuY3Rpb24gKGpvYiwgdHlwZSwgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGpvYi5kb25lKGRhdGEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgb25FcnJvciA9IF9hcmdzLmxlbmd0aCA+IDIgJiYgX2FyZ3NbMl0gIT09IHVuZGVmaW5lZCA/IF9hcmdzWzJdIDogZnVuY3Rpb24gKGpvYiwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBqb2IuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc3RhcnRQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKG9uU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLmpvYlF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBvbk1lc3NhZ2U6IG9uTWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogb25FcnJvcixcbiAgICAgICAgICAgICAgICAgICAgb25TdGFydDogb25TdGFydFxuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0UXVldWVkSm9iKCk7XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRQcm9taXNlO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0LnNlbnQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gc3RhcnRKb2IoX3gpIHtcbiAgICAgICAgcmV0dXJuIF9zdGFydEpvYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhcnRKb2I7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX3N0YXJ0UXVldWVkSm9iXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfc3RhcnRRdWV1ZWRKb2IyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgICB2YXIgd29ya2VyVGhyZWFkLCBxdWV1ZWRKb2IsIF9qb2I7XG5cbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmpvYlF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIik7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHdvcmtlclRocmVhZCA9IHRoaXMuX2dldEF2YWlsYWJsZVdvcmtlcigpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHdvcmtlclRocmVhZCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA1O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIik7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIHF1ZXVlZEpvYiA9IHRoaXMuam9iUXVldWUuc2hpZnQoKTtcblxuICAgICAgICAgICAgICAgIGlmICghcXVldWVkSm9iKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE4O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5vbkRlYnVnKHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdTdGFydGluZyBqb2InLFxuICAgICAgICAgICAgICAgICAgbmFtZTogcXVldWVkSm9iLm5hbWUsXG4gICAgICAgICAgICAgICAgICB3b3JrZXJUaHJlYWQ6IHdvcmtlclRocmVhZCxcbiAgICAgICAgICAgICAgICAgIGJhY2tsb2c6IHRoaXMuam9iUXVldWUubGVuZ3RoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgX2pvYiA9IG5ldyBfd29ya2VySm9iLmRlZmF1bHQocXVldWVkSm9iLm5hbWUsIHdvcmtlclRocmVhZCk7XG5cbiAgICAgICAgICAgICAgICB3b3JrZXJUaHJlYWQub25NZXNzYWdlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBxdWV1ZWRKb2Iub25NZXNzYWdlKF9qb2IsIGRhdGEudHlwZSwgZGF0YS5wYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgd29ya2VyVGhyZWFkLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBxdWV1ZWRKb2Iub25FcnJvcihfam9iLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHF1ZXVlZEpvYi5vblN0YXJ0KF9qb2IpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTI7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2pvYi5yZXN1bHQ7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDE1O1xuICAgICAgICAgICAgICAgIHRoaXMucmV0dXJuV29ya2VyVG9RdWV1ZSh3b3JrZXJUaHJlYWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuZmluaXNoKDE1KTtcblxuICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcywgW1sxMiwsIDE1LCAxOF1dKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gX3N0YXJ0UXVldWVkSm9iKCkge1xuICAgICAgICByZXR1cm4gX3N0YXJ0UXVldWVkSm9iMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3N0YXJ0UXVldWVkSm9iO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcInJldHVybldvcmtlclRvUXVldWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmV0dXJuV29ya2VyVG9RdWV1ZSh3b3JrZXIpIHtcbiAgICAgIHZhciBzaG91bGREZXN0cm95V29ya2VyID0gdGhpcy5pc0Rlc3Ryb3llZCB8fCAhdGhpcy5yZXVzZVdvcmtlcnMgfHwgdGhpcy5jb3VudCA+IHRoaXMuX2dldE1heENvbmN1cnJlbmN5KCk7XG5cbiAgICAgIGlmIChzaG91bGREZXN0cm95V29ya2VyKSB7XG4gICAgICAgIHdvcmtlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuY291bnQtLTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaWRsZVF1ZXVlLnB1c2god29ya2VyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmlzRGVzdHJveWVkKSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0UXVldWVkSm9iKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRBdmFpbGFibGVXb3JrZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEF2YWlsYWJsZVdvcmtlcigpIHtcbiAgICAgIGlmICh0aGlzLmlkbGVRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkbGVRdWV1ZS5zaGlmdCgpIHx8IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNvdW50IDwgdGhpcy5fZ2V0TWF4Q29uY3VycmVuY3koKSkge1xuICAgICAgICB0aGlzLmNvdW50Kys7XG4gICAgICAgIHZhciBuYW1lID0gXCJcIi5jb25jYXQodGhpcy5uYW1lLnRvTG93ZXJDYXNlKCksIFwiICgjXCIpLmNvbmNhdCh0aGlzLmNvdW50LCBcIiBvZiBcIikuY29uY2F0KHRoaXMubWF4Q29uY3VycmVuY3ksIFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBfd29ya2VyVGhyZWFkLmRlZmF1bHQoe1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcbiAgICAgICAgICB1cmw6IHRoaXMudXJsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldE1heENvbmN1cnJlbmN5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRNYXhDb25jdXJyZW5jeSgpIHtcbiAgICAgIHJldHVybiBfZ2xvYmFscy5pc01vYmlsZSA/IHRoaXMubWF4TW9iaWxlQ29uY3VycmVuY3kgOiB0aGlzLm1heENvbmN1cnJlbmN5O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gV29ya2VyUG9vbDtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gV29ya2VyUG9vbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmtlci1wb29sLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9hc3NlcnQgPSByZXF1aXJlKFwiLi4vZW52LXV0aWxzL2Fzc2VydFwiKTtcblxudmFyIF9nZXRMb2FkYWJsZVdvcmtlclVybCA9IHJlcXVpcmUoXCIuLi93b3JrZXItdXRpbHMvZ2V0LWxvYWRhYmxlLXdvcmtlci11cmxcIik7XG5cbnZhciBfZ2V0VHJhbnNmZXJMaXN0ID0gcmVxdWlyZShcIi4uL3dvcmtlci11dGlscy9nZXQtdHJhbnNmZXItbGlzdFwiKTtcblxudmFyIE5PT1AgPSBmdW5jdGlvbiBOT09QKCkge307XG5cbnZhciBXb3JrZXJUaHJlYWQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFdvcmtlclRocmVhZChwcm9wcykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFdvcmtlclRocmVhZCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJuYW1lXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJzb3VyY2VcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcInVybFwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwidGVybWluYXRlZFwiLCBmYWxzZSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJ3b3JrZXJcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcIm9uTWVzc2FnZVwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwib25FcnJvclwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiX2xvYWRhYmxlVVJMXCIsICcnKTtcbiAgICB2YXIgbmFtZSA9IHByb3BzLm5hbWUsXG4gICAgICAgIHNvdXJjZSA9IHByb3BzLnNvdXJjZSxcbiAgICAgICAgdXJsID0gcHJvcHMudXJsO1xuICAgICgwLCBfYXNzZXJ0LmFzc2VydCkoc291cmNlIHx8IHVybCk7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLm9uTWVzc2FnZSA9IE5PT1A7XG5cbiAgICB0aGlzLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgfTtcblxuICAgIHRoaXMud29ya2VyID0gdGhpcy5fY3JlYXRlQnJvd3NlcldvcmtlcigpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoV29ya2VyVGhyZWFkLCBbe1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLm9uTWVzc2FnZSA9IE5PT1A7XG4gICAgICB0aGlzLm9uRXJyb3IgPSBOT09QO1xuICAgICAgdGhpcy53b3JrZXIudGVybWluYXRlKCk7XG4gICAgICB0aGlzLnRlcm1pbmF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1J1bm5pbmdcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBCb29sZWFuKHRoaXMub25NZXNzYWdlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9zdE1lc3NhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zdE1lc3NhZ2UoZGF0YSwgdHJhbnNmZXJMaXN0KSB7XG4gICAgICB0cmFuc2Zlckxpc3QgPSB0cmFuc2Zlckxpc3QgfHwgKDAsIF9nZXRUcmFuc2Zlckxpc3QuZ2V0VHJhbnNmZXJMaXN0KShkYXRhKTtcbiAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKGRhdGEsIHRyYW5zZmVyTGlzdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRFcnJvckZyb21FcnJvckV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRFcnJvckZyb21FcnJvckV2ZW50KGV2ZW50KSB7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdGYWlsZWQgdG8gbG9hZCAnO1xuICAgICAgbWVzc2FnZSArPSBcIndvcmtlciBcIi5jb25jYXQodGhpcy5uYW1lLCBcIi4gXCIpO1xuXG4gICAgICBpZiAoZXZlbnQubWVzc2FnZSkge1xuICAgICAgICBtZXNzYWdlICs9IFwiXCIuY29uY2F0KGV2ZW50Lm1lc3NhZ2UsIFwiIGluIFwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50LmxpbmVubykge1xuICAgICAgICBtZXNzYWdlICs9IFwiOlwiLmNvbmNhdChldmVudC5saW5lbm8sIFwiOlwiKS5jb25jYXQoZXZlbnQuY29sbm8pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlQnJvd3NlcldvcmtlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQnJvd3NlcldvcmtlcigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX2xvYWRhYmxlVVJMID0gKDAsIF9nZXRMb2FkYWJsZVdvcmtlclVybC5nZXRMb2FkYWJsZVdvcmtlclVSTCkoe1xuICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICB1cmw6IHRoaXMudXJsXG4gICAgICB9KTtcbiAgICAgIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKHRoaXMuX2xvYWRhYmxlVVJMLCB7XG4gICAgICAgIG5hbWU6IHRoaXMubmFtZVxuICAgICAgfSk7XG5cbiAgICAgIHdvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFldmVudC5kYXRhKSB7XG4gICAgICAgICAgX3RoaXMub25FcnJvcihuZXcgRXJyb3IoJ05vIGRhdGEgcmVjZWl2ZWQnKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMub25NZXNzYWdlKGV2ZW50LmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3b3JrZXIub25lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBfdGhpcy5vbkVycm9yKF90aGlzLl9nZXRFcnJvckZyb21FcnJvckV2ZW50KGVycm9yKSk7XG5cbiAgICAgICAgX3RoaXMudGVybWluYXRlZCA9IHRydWU7XG4gICAgICB9O1xuXG4gICAgICB3b3JrZXIub25tZXNzYWdlZXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoZXZlbnQpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHdvcmtlcjtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJpc1N1cHBvcnRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1N1cHBvcnRlZCgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJztcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFdvcmtlclRocmVhZDtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gV29ya2VyVGhyZWFkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d29ya2VyLXRocmVhZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0TG9hZGFibGVXb3JrZXJVUkwgPSBnZXRMb2FkYWJsZVdvcmtlclVSTDtcblxudmFyIF9hc3NlcnQgPSByZXF1aXJlKFwiLi4vZW52LXV0aWxzL2Fzc2VydFwiKTtcblxudmFyIHdvcmtlclVSTENhY2hlID0gbmV3IE1hcCgpO1xuXG5mdW5jdGlvbiBnZXRMb2FkYWJsZVdvcmtlclVSTChwcm9wcykge1xuICAoMCwgX2Fzc2VydC5hc3NlcnQpKHByb3BzLnNvdXJjZSAmJiAhcHJvcHMudXJsIHx8ICFwcm9wcy5zb3VyY2UgJiYgcHJvcHMudXJsKTtcbiAgdmFyIHdvcmtlclVSTCA9IHdvcmtlclVSTENhY2hlLmdldChwcm9wcy5zb3VyY2UgfHwgcHJvcHMudXJsKTtcblxuICBpZiAoIXdvcmtlclVSTCkge1xuICAgIGlmIChwcm9wcy51cmwpIHtcbiAgICAgIHdvcmtlclVSTCA9IGdldExvYWRhYmxlV29ya2VyVVJMRnJvbVVSTChwcm9wcy51cmwpO1xuICAgICAgd29ya2VyVVJMQ2FjaGUuc2V0KHByb3BzLnVybCwgd29ya2VyVVJMKTtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMuc291cmNlKSB7XG4gICAgICB3b3JrZXJVUkwgPSBnZXRMb2FkYWJsZVdvcmtlclVSTEZyb21Tb3VyY2UocHJvcHMuc291cmNlKTtcbiAgICAgIHdvcmtlclVSTENhY2hlLnNldChwcm9wcy5zb3VyY2UsIHdvcmtlclVSTCk7XG4gICAgfVxuICB9XG5cbiAgKDAsIF9hc3NlcnQuYXNzZXJ0KSh3b3JrZXJVUkwpO1xuICByZXR1cm4gd29ya2VyVVJMO1xufVxuXG5mdW5jdGlvbiBnZXRMb2FkYWJsZVdvcmtlclVSTEZyb21VUkwodXJsKSB7XG4gIGlmICghdXJsLnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICB2YXIgd29ya2VyU291cmNlID0gYnVpbGRTY3JpcHRTb3VyY2UodXJsKTtcbiAgcmV0dXJuIGdldExvYWRhYmxlV29ya2VyVVJMRnJvbVNvdXJjZSh3b3JrZXJTb3VyY2UpO1xufVxuXG5mdW5jdGlvbiBnZXRMb2FkYWJsZVdvcmtlclVSTEZyb21Tb3VyY2Uod29ya2VyU291cmNlKSB7XG4gIHZhciBibG9iID0gbmV3IEJsb2IoW3dvcmtlclNvdXJjZV0sIHtcbiAgICB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCdcbiAgfSk7XG4gIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xufVxuXG5mdW5jdGlvbiBidWlsZFNjcmlwdFNvdXJjZSh3b3JrZXJVcmwpIHtcbiAgcmV0dXJuIFwidHJ5IHtcXG4gIGltcG9ydFNjcmlwdHMoJ1wiLmNvbmNhdCh3b3JrZXJVcmwsIFwiJyk7XFxufSBjYXRjaCAoZXJyb3IpIHtcXG4gIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xcbiAgdGhyb3cgZXJyb3I7XFxufVwiKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1sb2FkYWJsZS13b3JrZXItdXJsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0VHJhbnNmZXJMaXN0ID0gZ2V0VHJhbnNmZXJMaXN0O1xuXG52YXIgX3R5cGVvZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKSk7XG5cbmZ1bmN0aW9uIGdldFRyYW5zZmVyTGlzdChvYmplY3QpIHtcbiAgdmFyIHJlY3Vyc2l2ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgdmFyIHRyYW5zZmVycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICB2YXIgdHJhbnNmZXJzU2V0ID0gdHJhbnNmZXJzIHx8IG5ldyBTZXQoKTtcblxuICBpZiAoIW9iamVjdCkge30gZWxzZSBpZiAoaXNUcmFuc2ZlcmFibGUob2JqZWN0KSkge1xuICAgIHRyYW5zZmVyc1NldC5hZGQob2JqZWN0KTtcbiAgfSBlbHNlIGlmIChpc1RyYW5zZmVyYWJsZShvYmplY3QuYnVmZmVyKSkge1xuICAgIHRyYW5zZmVyc1NldC5hZGQob2JqZWN0LmJ1ZmZlcik7XG4gIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KG9iamVjdCkpIHt9IGVsc2UgaWYgKHJlY3Vyc2l2ZSAmJiAoMCwgX3R5cGVvZjIuZGVmYXVsdCkob2JqZWN0KSA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBnZXRUcmFuc2Zlckxpc3Qob2JqZWN0W2tleV0sIHJlY3Vyc2l2ZSwgdHJhbnNmZXJzU2V0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJhbnNmZXJzID09PSB1bmRlZmluZWQgPyBBcnJheS5mcm9tKHRyYW5zZmVyc1NldCkgOiBbXTtcbn1cblxuZnVuY3Rpb24gaXNUcmFuc2ZlcmFibGUob2JqZWN0KSB7XG4gIGlmICghb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIE1lc3NhZ2VQb3J0ICE9PSAndW5kZWZpbmVkJyAmJiBvYmplY3QgaW5zdGFuY2VvZiBNZXNzYWdlUG9ydCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqZWN0IGluc3RhbmNlb2YgSW1hZ2VCaXRtYXApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJyAmJiBvYmplY3QgaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC10cmFuc2Zlci1saXN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucmVtb3ZlTm9udHJhbnNmZXJhYmxlT3B0aW9ucyA9IHJlbW92ZU5vbnRyYW5zZmVyYWJsZU9wdGlvbnM7XG5cbnZhciBfdHlwZW9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpKTtcblxuZnVuY3Rpb24gcmVtb3ZlTm9udHJhbnNmZXJhYmxlT3B0aW9ucyhvYmplY3QpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyaW5naWZ5SlNPTihvYmplY3QpKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5SlNPTih2KSB7XG4gIHZhciBjYWNoZSA9IG5ldyBTZXQoKTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgaWYgKCgwLCBfdHlwZW9mMi5kZWZhdWx0KSh2YWx1ZSkgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICBpZiAoY2FjaGUuaGFzKHZhbHVlKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2FjaGUuYWRkKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3ZlLW5vbnRyYW5zZmVyYWJsZS1vcHRpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN0YXRzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zdGF0cy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN0YXRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3N0YXQuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfZ2V0SGlSZXNUaW1lc3RhbXBcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2hpUmVzVGltZXN0YW1wLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX3N0YXRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvc3RhdHNcIikpO1xuXG52YXIgX3N0YXQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9zdGF0XCIpKTtcblxudmFyIF9oaVJlc1RpbWVzdGFtcCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbHMvaGktcmVzLXRpbWVzdGFtcFwiKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfaGlSZXNUaW1lc3RhbXAgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlscy9oaS1yZXMtdGltZXN0YW1wXCIpKTtcblxudmFyIFN0YXQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0YXQobmFtZSwgdHlwZSkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFN0YXQpO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnNhbXBsZVNpemUgPSAxO1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKFN0YXQsIFt7XG4gICAga2V5OiBcInNldFNhbXBsZVNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2FtcGxlU2l6ZShzYW1wbGVzKSB7XG4gICAgICB0aGlzLnNhbXBsZVNpemUgPSBzYW1wbGVzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluY3JlbWVudENvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluY3JlbWVudENvdW50KCkge1xuICAgICAgdGhpcy5hZGRDb3VudCgxKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWNyZW1lbnRDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNyZW1lbnRDb3VudCgpIHtcbiAgICAgIHRoaXMuc3VidHJhY3RDb3VudCgxKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRDb3VudCh2YWx1ZSkge1xuICAgICAgdGhpcy5fY291bnQgKz0gdmFsdWU7XG4gICAgICB0aGlzLl9zYW1wbGVzKys7XG5cbiAgICAgIHRoaXMuX2NoZWNrU2FtcGxpbmcoKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN1YnRyYWN0Q291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3VidHJhY3RDb3VudCh2YWx1ZSkge1xuICAgICAgdGhpcy5fY291bnQgLT0gdmFsdWU7XG4gICAgICB0aGlzLl9zYW1wbGVzKys7XG5cbiAgICAgIHRoaXMuX2NoZWNrU2FtcGxpbmcoKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFRpbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkVGltZSh0aW1lKSB7XG4gICAgICB0aGlzLl90aW1lICs9IHRpbWU7XG4gICAgICB0aGlzLmxhc3RUaW1pbmcgPSB0aW1lO1xuICAgICAgdGhpcy5fc2FtcGxlcysrO1xuXG4gICAgICB0aGlzLl9jaGVja1NhbXBsaW5nKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0aW1lU3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGltZVN0YXJ0KCkge1xuICAgICAgdGhpcy5fc3RhcnRUaW1lID0gKDAsIF9oaVJlc1RpbWVzdGFtcC5kZWZhdWx0KSgpO1xuICAgICAgdGhpcy5fdGltZXJQZW5kaW5nID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0aW1lRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRpbWVFbmQoKSB7XG4gICAgICBpZiAoIXRoaXMuX3RpbWVyUGVuZGluZykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5hZGRUaW1lKCgwLCBfaGlSZXNUaW1lc3RhbXAuZGVmYXVsdCkoKSAtIHRoaXMuX3N0YXJ0VGltZSk7XG4gICAgICB0aGlzLl90aW1lclBlbmRpbmcgPSBmYWxzZTtcblxuICAgICAgdGhpcy5fY2hlY2tTYW1wbGluZygpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2FtcGxlQXZlcmFnZUNvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNhbXBsZUF2ZXJhZ2VDb3VudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNhbXBsZVNpemUgPiAwID8gdGhpcy5sYXN0U2FtcGxlQ291bnQgLyB0aGlzLnNhbXBsZVNpemUgOiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTYW1wbGVBdmVyYWdlVGltZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTYW1wbGVBdmVyYWdlVGltZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNhbXBsZVNpemUgPiAwID8gdGhpcy5sYXN0U2FtcGxlVGltZSAvIHRoaXMuc2FtcGxlU2l6ZSA6IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFNhbXBsZUh6XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNhbXBsZUh6KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGFzdFNhbXBsZVRpbWUgPiAwID8gdGhpcy5zYW1wbGVTaXplIC8gKHRoaXMubGFzdFNhbXBsZVRpbWUgLyAxMDAwKSA6IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEF2ZXJhZ2VDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBdmVyYWdlQ291bnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zYW1wbGVzID4gMCA/IHRoaXMuY291bnQgLyB0aGlzLnNhbXBsZXMgOiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRBdmVyYWdlVGltZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBdmVyYWdlVGltZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNhbXBsZXMgPiAwID8gdGhpcy50aW1lIC8gdGhpcy5zYW1wbGVzIDogMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SHpcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SHooKSB7XG4gICAgICByZXR1cm4gdGhpcy50aW1lID4gMCA/IHRoaXMuc2FtcGxlcyAvICh0aGlzLnRpbWUgLyAxMDAwKSA6IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdGhpcy50aW1lID0gMDtcbiAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgdGhpcy5zYW1wbGVzID0gMDtcbiAgICAgIHRoaXMubGFzdFRpbWluZyA9IDA7XG4gICAgICB0aGlzLmxhc3RTYW1wbGVUaW1lID0gMDtcbiAgICAgIHRoaXMubGFzdFNhbXBsZUNvdW50ID0gMDtcbiAgICAgIHRoaXMuX2NvdW50ID0gMDtcbiAgICAgIHRoaXMuX3RpbWUgPSAwO1xuICAgICAgdGhpcy5fc2FtcGxlcyA9IDA7XG4gICAgICB0aGlzLl9zdGFydFRpbWUgPSAwO1xuICAgICAgdGhpcy5fdGltZXJQZW5kaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NoZWNrU2FtcGxpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NoZWNrU2FtcGxpbmcoKSB7XG4gICAgICBpZiAodGhpcy5fc2FtcGxlcyA9PT0gdGhpcy5zYW1wbGVTaXplKSB7XG4gICAgICAgIHRoaXMubGFzdFNhbXBsZVRpbWUgPSB0aGlzLl90aW1lO1xuICAgICAgICB0aGlzLmxhc3RTYW1wbGVDb3VudCA9IHRoaXMuX2NvdW50O1xuICAgICAgICB0aGlzLmNvdW50ICs9IHRoaXMuX2NvdW50O1xuICAgICAgICB0aGlzLnRpbWUgKz0gdGhpcy5fdGltZTtcbiAgICAgICAgdGhpcy5zYW1wbGVzICs9IHRoaXMuX3NhbXBsZXM7XG4gICAgICAgIHRoaXMuX3RpbWUgPSAwO1xuICAgICAgICB0aGlzLl9jb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX3NhbXBsZXMgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU3RhdDtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gU3RhdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX3N0YXQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3N0YXRcIikpO1xuXG52YXIgU3RhdHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0YXRzKF9yZWYpIHtcbiAgICB2YXIgaWQgPSBfcmVmLmlkLFxuICAgICAgICBzdGF0cyA9IF9yZWYuc3RhdHM7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgU3RhdHMpO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLnN0YXRzID0ge307XG5cbiAgICB0aGlzLl9pbml0aWFsaXplU3RhdHMoc3RhdHMpO1xuXG4gICAgT2JqZWN0LnNlYWwodGhpcyk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShTdGF0cywgW3tcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgICB2YXIgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ2NvdW50JztcbiAgICAgIHJldHVybiB0aGlzLl9nZXRPckNyZWF0ZSh7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHR5cGU6IHR5cGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaXplXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zdGF0cykubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnN0YXRzKSB7XG4gICAgICAgIHRoaXMuc3RhdHNba2V5XS5yZXNldCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9yRWFjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5zdGF0cykge1xuICAgICAgICBmbih0aGlzLnN0YXRzW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUYWJsZSgpIHtcbiAgICAgIHZhciB0YWJsZSA9IHt9O1xuICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0KSB7XG4gICAgICAgIHRhYmxlW3N0YXQubmFtZV0gPSB7XG4gICAgICAgICAgdGltZTogc3RhdC50aW1lIHx8IDAsXG4gICAgICAgICAgY291bnQ6IHN0YXQuY291bnQgfHwgMCxcbiAgICAgICAgICBhdmVyYWdlOiBzdGF0LmdldEF2ZXJhZ2VUaW1lKCkgfHwgMCxcbiAgICAgICAgICBoejogc3RhdC5nZXRIeigpIHx8IDBcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRhYmxlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaW5pdGlhbGl6ZVN0YXRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0aWFsaXplU3RhdHMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgc3RhdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgICAgc3RhdHMuZm9yRWFjaChmdW5jdGlvbiAoc3RhdCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuX2dldE9yQ3JlYXRlKHN0YXQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRPckNyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0T3JDcmVhdGUoc3RhdCkge1xuICAgICAgaWYgKCFzdGF0IHx8ICFzdGF0Lm5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBuYW1lID0gc3RhdC5uYW1lLFxuICAgICAgICAgIHR5cGUgPSBzdGF0LnR5cGU7XG5cbiAgICAgIGlmICghdGhpcy5zdGF0c1tuYW1lXSkge1xuICAgICAgICBpZiAoc3RhdCBpbnN0YW5jZW9mIF9zdGF0LmRlZmF1bHQpIHtcbiAgICAgICAgICB0aGlzLnN0YXRzW25hbWVdID0gc3RhdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXRzW25hbWVdID0gbmV3IF9zdGF0LmRlZmF1bHQobmFtZSwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc3RhdHNbbmFtZV07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTdGF0cztcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gU3RhdHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGF0cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGdldEhpUmVzVGltZXN0YW1wO1xuXG5mdW5jdGlvbiBnZXRIaVJlc1RpbWVzdGFtcCgpIHtcbiAgdmFyIHRpbWVzdGFtcDtcblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBlcmZvcm1hbmNlKSB7XG4gICAgdGltZXN0YW1wID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmhydGltZSkge1xuICAgIHZhciB0aW1lUGFydHMgPSBwcm9jZXNzLmhydGltZSgpO1xuICAgIHRpbWVzdGFtcCA9IHRpbWVQYXJ0c1swXSAqIDEwMDAgKyB0aW1lUGFydHNbMV0gLyAxZTY7XG4gIH0gZWxzZSB7XG4gICAgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgfVxuXG4gIHJldHVybiB0aW1lc3RhbXA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oaS1yZXMtdGltZXN0YW1wLmpzLm1hcCIsIiIsIm1vZHVsZS5leHBvcnRzID0gYXR0cmlidXRlVG9Qcm9wZXJ0eVxuXG52YXIgdHJhbnNmb3JtID0ge1xuICAnY2xhc3MnOiAnY2xhc3NOYW1lJyxcbiAgJ2Zvcic6ICdodG1sRm9yJyxcbiAgJ2h0dHAtZXF1aXYnOiAnaHR0cEVxdWl2J1xufVxuXG5mdW5jdGlvbiBhdHRyaWJ1dGVUb1Byb3BlcnR5IChoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGFnTmFtZSwgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgZm9yICh2YXIgYXR0ciBpbiBhdHRycykge1xuICAgICAgaWYgKGF0dHIgaW4gdHJhbnNmb3JtKSB7XG4gICAgICAgIGF0dHJzW3RyYW5zZm9ybVthdHRyXV0gPSBhdHRyc1thdHRyXVxuICAgICAgICBkZWxldGUgYXR0cnNbYXR0cl1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGgodGFnTmFtZSwgYXR0cnMsIGNoaWxkcmVuKVxuICB9XG59XG4iLCJ2YXIgYXR0clRvUHJvcCA9IHJlcXVpcmUoJ2h5cGVyc2NyaXB0LWF0dHJpYnV0ZS10by1wcm9wZXJ0eScpXG5cbnZhciBWQVIgPSAwLCBURVhUID0gMSwgT1BFTiA9IDIsIENMT1NFID0gMywgQVRUUiA9IDRcbnZhciBBVFRSX0tFWSA9IDUsIEFUVFJfS0VZX1cgPSA2XG52YXIgQVRUUl9WQUxVRV9XID0gNywgQVRUUl9WQUxVRSA9IDhcbnZhciBBVFRSX1ZBTFVFX1NRID0gOSwgQVRUUl9WQUxVRV9EUSA9IDEwXG52YXIgQVRUUl9FUSA9IDExLCBBVFRSX0JSRUFLID0gMTJcbnZhciBDT01NRU5UID0gMTNcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaCwgb3B0cykge1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuICB2YXIgY29uY2F0ID0gb3B0cy5jb25jYXQgfHwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gU3RyaW5nKGEpICsgU3RyaW5nKGIpXG4gIH1cbiAgaWYgKG9wdHMuYXR0clRvUHJvcCAhPT0gZmFsc2UpIHtcbiAgICBoID0gYXR0clRvUHJvcChoKVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChzdHJpbmdzKSB7XG4gICAgdmFyIHN0YXRlID0gVEVYVCwgcmVnID0gJydcbiAgICB2YXIgYXJnbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgIHZhciBwYXJ0cyA9IFtdXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpIDwgYXJnbGVuIC0gMSkge1xuICAgICAgICB2YXIgYXJnID0gYXJndW1lbnRzW2krMV1cbiAgICAgICAgdmFyIHAgPSBwYXJzZShzdHJpbmdzW2ldKVxuICAgICAgICB2YXIgeHN0YXRlID0gc3RhdGVcbiAgICAgICAgaWYgKHhzdGF0ZSA9PT0gQVRUUl9WQUxVRV9EUSkgeHN0YXRlID0gQVRUUl9WQUxVRVxuICAgICAgICBpZiAoeHN0YXRlID09PSBBVFRSX1ZBTFVFX1NRKSB4c3RhdGUgPSBBVFRSX1ZBTFVFXG4gICAgICAgIGlmICh4c3RhdGUgPT09IEFUVFJfVkFMVUVfVykgeHN0YXRlID0gQVRUUl9WQUxVRVxuICAgICAgICBpZiAoeHN0YXRlID09PSBBVFRSKSB4c3RhdGUgPSBBVFRSX0tFWVxuICAgICAgICBpZiAoeHN0YXRlID09PSBPUEVOKSB7XG4gICAgICAgICAgaWYgKHJlZyA9PT0gJy8nKSB7XG4gICAgICAgICAgICBwLnB1c2goWyBPUEVOLCAnLycsIGFyZyBdKVxuICAgICAgICAgICAgcmVnID0gJydcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcC5wdXNoKFsgT1BFTiwgYXJnIF0pXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHhzdGF0ZSA9PT0gQ09NTUVOVCAmJiBvcHRzLmNvbW1lbnRzKSB7XG4gICAgICAgICAgcmVnICs9IFN0cmluZyhhcmcpXG4gICAgICAgIH0gZWxzZSBpZiAoeHN0YXRlICE9PSBDT01NRU5UKSB7XG4gICAgICAgICAgcC5wdXNoKFsgVkFSLCB4c3RhdGUsIGFyZyBdKVxuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2guYXBwbHkocGFydHMsIHApXG4gICAgICB9IGVsc2UgcGFydHMucHVzaC5hcHBseShwYXJ0cywgcGFyc2Uoc3RyaW5nc1tpXSkpXG4gICAgfVxuXG4gICAgdmFyIHRyZWUgPSBbbnVsbCx7fSxbXV1cbiAgICB2YXIgc3RhY2sgPSBbW3RyZWUsLTFdXVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjdXIgPSBzdGFja1tzdGFjay5sZW5ndGgtMV1bMF1cbiAgICAgIHZhciBwID0gcGFydHNbaV0sIHMgPSBwWzBdXG4gICAgICBpZiAocyA9PT0gT1BFTiAmJiAvXlxcLy8udGVzdChwWzFdKSkge1xuICAgICAgICB2YXIgaXggPSBzdGFja1tzdGFjay5sZW5ndGgtMV1bMV1cbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBzdGFjay5wb3AoKVxuICAgICAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aC0xXVswXVsyXVtpeF0gPSBoKFxuICAgICAgICAgICAgY3VyWzBdLCBjdXJbMV0sIGN1clsyXS5sZW5ndGggPyBjdXJbMl0gOiB1bmRlZmluZWRcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocyA9PT0gT1BFTikge1xuICAgICAgICB2YXIgYyA9IFtwWzFdLHt9LFtdXVxuICAgICAgICBjdXJbMl0ucHVzaChjKVxuICAgICAgICBzdGFjay5wdXNoKFtjLGN1clsyXS5sZW5ndGgtMV0pXG4gICAgICB9IGVsc2UgaWYgKHMgPT09IEFUVFJfS0VZIHx8IChzID09PSBWQVIgJiYgcFsxXSA9PT0gQVRUUl9LRVkpKSB7XG4gICAgICAgIHZhciBrZXkgPSAnJ1xuICAgICAgICB2YXIgY29weUtleVxuICAgICAgICBmb3IgKDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHBhcnRzW2ldWzBdID09PSBBVFRSX0tFWSkge1xuICAgICAgICAgICAga2V5ID0gY29uY2F0KGtleSwgcGFydHNbaV1bMV0pXG4gICAgICAgICAgfSBlbHNlIGlmIChwYXJ0c1tpXVswXSA9PT0gVkFSICYmIHBhcnRzW2ldWzFdID09PSBBVFRSX0tFWSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0c1tpXVsyXSA9PT0gJ29iamVjdCcgJiYgIWtleSkge1xuICAgICAgICAgICAgICBmb3IgKGNvcHlLZXkgaW4gcGFydHNbaV1bMl0pIHtcbiAgICAgICAgICAgICAgICBpZiAocGFydHNbaV1bMl0uaGFzT3duUHJvcGVydHkoY29weUtleSkgJiYgIWN1clsxXVtjb3B5S2V5XSkge1xuICAgICAgICAgICAgICAgICAgY3VyWzFdW2NvcHlLZXldID0gcGFydHNbaV1bMl1bY29weUtleV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGtleSA9IGNvbmNhdChrZXksIHBhcnRzW2ldWzJdKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0c1tpXVswXSA9PT0gQVRUUl9FUSkgaSsrXG4gICAgICAgIHZhciBqID0gaVxuICAgICAgICBmb3IgKDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHBhcnRzW2ldWzBdID09PSBBVFRSX1ZBTFVFIHx8IHBhcnRzW2ldWzBdID09PSBBVFRSX0tFWSkge1xuICAgICAgICAgICAgaWYgKCFjdXJbMV1ba2V5XSkgY3VyWzFdW2tleV0gPSBzdHJmbihwYXJ0c1tpXVsxXSlcbiAgICAgICAgICAgIGVsc2UgcGFydHNbaV1bMV09PT1cIlwiIHx8IChjdXJbMV1ba2V5XSA9IGNvbmNhdChjdXJbMV1ba2V5XSwgcGFydHNbaV1bMV0pKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcnRzW2ldWzBdID09PSBWQVJcbiAgICAgICAgICAmJiAocGFydHNbaV1bMV0gPT09IEFUVFJfVkFMVUUgfHwgcGFydHNbaV1bMV0gPT09IEFUVFJfS0VZKSkge1xuICAgICAgICAgICAgaWYgKCFjdXJbMV1ba2V5XSkgY3VyWzFdW2tleV0gPSBzdHJmbihwYXJ0c1tpXVsyXSlcbiAgICAgICAgICAgIGVsc2UgcGFydHNbaV1bMl09PT1cIlwiIHx8IChjdXJbMV1ba2V5XSA9IGNvbmNhdChjdXJbMV1ba2V5XSwgcGFydHNbaV1bMl0pKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGtleS5sZW5ndGggJiYgIWN1clsxXVtrZXldICYmIGkgPT09IGpcbiAgICAgICAgICAgICYmIChwYXJ0c1tpXVswXSA9PT0gQ0xPU0UgfHwgcGFydHNbaV1bMF0gPT09IEFUVFJfQlJFQUspKSB7XG4gICAgICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZnJhc3RydWN0dXJlLmh0bWwjYm9vbGVhbi1hdHRyaWJ1dGVzXG4gICAgICAgICAgICAgIC8vIGVtcHR5IHN0cmluZyBpcyBmYWxzeSwgbm90IHdlbGwgYmVoYXZlZCB2YWx1ZSBpbiBicm93c2VyXG4gICAgICAgICAgICAgIGN1clsxXVtrZXldID0ga2V5LnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJ0c1tpXVswXSA9PT0gQ0xPU0UpIHtcbiAgICAgICAgICAgICAgaS0tXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzID09PSBBVFRSX0tFWSkge1xuICAgICAgICBjdXJbMV1bcFsxXV0gPSB0cnVlXG4gICAgICB9IGVsc2UgaWYgKHMgPT09IFZBUiAmJiBwWzFdID09PSBBVFRSX0tFWSkge1xuICAgICAgICBjdXJbMV1bcFsyXV0gPSB0cnVlXG4gICAgICB9IGVsc2UgaWYgKHMgPT09IENMT1NFKSB7XG4gICAgICAgIGlmIChzZWxmQ2xvc2luZyhjdXJbMF0pICYmIHN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBpeCA9IHN0YWNrW3N0YWNrLmxlbmd0aC0xXVsxXVxuICAgICAgICAgIHN0YWNrLnBvcCgpXG4gICAgICAgICAgc3RhY2tbc3RhY2subGVuZ3RoLTFdWzBdWzJdW2l4XSA9IGgoXG4gICAgICAgICAgICBjdXJbMF0sIGN1clsxXSwgY3VyWzJdLmxlbmd0aCA/IGN1clsyXSA6IHVuZGVmaW5lZFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzID09PSBWQVIgJiYgcFsxXSA9PT0gVEVYVCkge1xuICAgICAgICBpZiAocFsyXSA9PT0gdW5kZWZpbmVkIHx8IHBbMl0gPT09IG51bGwpIHBbMl0gPSAnJ1xuICAgICAgICBlbHNlIGlmICghcFsyXSkgcFsyXSA9IGNvbmNhdCgnJywgcFsyXSlcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocFsyXVswXSkpIHtcbiAgICAgICAgICBjdXJbMl0ucHVzaC5hcHBseShjdXJbMl0sIHBbMl0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VyWzJdLnB1c2gocFsyXSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzID09PSBURVhUKSB7XG4gICAgICAgIGN1clsyXS5wdXNoKHBbMV0pXG4gICAgICB9IGVsc2UgaWYgKHMgPT09IEFUVFJfRVEgfHwgcyA9PT0gQVRUUl9CUkVBSykge1xuICAgICAgICAvLyBuby1vcFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmhhbmRsZWQ6ICcgKyBzKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0cmVlWzJdLmxlbmd0aCA+IDEgJiYgL15cXHMqJC8udGVzdCh0cmVlWzJdWzBdKSkge1xuICAgICAgdHJlZVsyXS5zaGlmdCgpXG4gICAgfVxuXG4gICAgaWYgKHRyZWVbMl0ubGVuZ3RoID4gMlxuICAgIHx8ICh0cmVlWzJdLmxlbmd0aCA9PT0gMiAmJiAvXFxTLy50ZXN0KHRyZWVbMl1bMV0pKSkge1xuICAgICAgaWYgKG9wdHMuY3JlYXRlRnJhZ21lbnQpIHJldHVybiBvcHRzLmNyZWF0ZUZyYWdtZW50KHRyZWVbMl0pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdtdWx0aXBsZSByb290IGVsZW1lbnRzIG11c3QgYmUgd3JhcHBlZCBpbiBhbiBlbmNsb3NpbmcgdGFnJ1xuICAgICAgKVxuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlWzJdWzBdKSAmJiB0eXBlb2YgdHJlZVsyXVswXVswXSA9PT0gJ3N0cmluZydcbiAgICAmJiBBcnJheS5pc0FycmF5KHRyZWVbMl1bMF1bMl0pKSB7XG4gICAgICB0cmVlWzJdWzBdID0gaCh0cmVlWzJdWzBdWzBdLCB0cmVlWzJdWzBdWzFdLCB0cmVlWzJdWzBdWzJdKVxuICAgIH1cbiAgICByZXR1cm4gdHJlZVsyXVswXVxuXG4gICAgZnVuY3Rpb24gcGFyc2UgKHN0cikge1xuICAgICAgdmFyIHJlcyA9IFtdXG4gICAgICBpZiAoc3RhdGUgPT09IEFUVFJfVkFMVUVfVykgc3RhdGUgPSBBVFRSXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSlcbiAgICAgICAgaWYgKHN0YXRlID09PSBURVhUICYmIGMgPT09ICc8Jykge1xuICAgICAgICAgIGlmIChyZWcubGVuZ3RoKSByZXMucHVzaChbVEVYVCwgcmVnXSlcbiAgICAgICAgICByZWcgPSAnJ1xuICAgICAgICAgIHN0YXRlID0gT1BFTlxuICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc+JyAmJiAhcXVvdChzdGF0ZSkgJiYgc3RhdGUgIT09IENPTU1FTlQpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IE9QRU4gJiYgcmVnLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzLnB1c2goW09QRU4scmVnXSlcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBBVFRSX0tFWSkge1xuICAgICAgICAgICAgcmVzLnB1c2goW0FUVFJfS0VZLHJlZ10pXG4gICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQVRUUl9WQUxVRSAmJiByZWcubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXMucHVzaChbQVRUUl9WQUxVRSxyZWddKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXMucHVzaChbQ0xPU0VdKVxuICAgICAgICAgIHJlZyA9ICcnXG4gICAgICAgICAgc3RhdGUgPSBURVhUXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IENPTU1FTlQgJiYgLy0kLy50ZXN0KHJlZykgJiYgYyA9PT0gJy0nKSB7XG4gICAgICAgICAgaWYgKG9wdHMuY29tbWVudHMpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKFtBVFRSX1ZBTFVFLHJlZy5zdWJzdHIoMCwgcmVnLmxlbmd0aCAtIDEpXSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVnID0gJydcbiAgICAgICAgICBzdGF0ZSA9IFRFWFRcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gT1BFTiAmJiAvXiEtLSQvLnRlc3QocmVnKSkge1xuICAgICAgICAgIGlmIChvcHRzLmNvbW1lbnRzKSB7XG4gICAgICAgICAgICByZXMucHVzaChbT1BFTiwgcmVnXSxbQVRUUl9LRVksJ2NvbW1lbnQnXSxbQVRUUl9FUV0pXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlZyA9IGNcbiAgICAgICAgICBzdGF0ZSA9IENPTU1FTlRcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gVEVYVCB8fCBzdGF0ZSA9PT0gQ09NTUVOVCkge1xuICAgICAgICAgIHJlZyArPSBjXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IE9QRU4gJiYgYyA9PT0gJy8nICYmIHJlZy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBuby1vcCwgc2VsZiBjbG9zaW5nIHRhZyB3aXRob3V0IGEgc3BhY2UgPGJyLz5cbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gT1BFTiAmJiAvXFxzLy50ZXN0KGMpKSB7XG4gICAgICAgICAgaWYgKHJlZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKFtPUEVOLCByZWddKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZWcgPSAnJ1xuICAgICAgICAgIHN0YXRlID0gQVRUUlxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBPUEVOKSB7XG4gICAgICAgICAgcmVnICs9IGNcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQVRUUiAmJiAvW15cXHNcIic9L10vLnRlc3QoYykpIHtcbiAgICAgICAgICBzdGF0ZSA9IEFUVFJfS0VZXG4gICAgICAgICAgcmVnID0gY1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBBVFRSICYmIC9cXHMvLnRlc3QoYykpIHtcbiAgICAgICAgICBpZiAocmVnLmxlbmd0aCkgcmVzLnB1c2goW0FUVFJfS0VZLHJlZ10pXG4gICAgICAgICAgcmVzLnB1c2goW0FUVFJfQlJFQUtdKVxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBBVFRSX0tFWSAmJiAvXFxzLy50ZXN0KGMpKSB7XG4gICAgICAgICAgcmVzLnB1c2goW0FUVFJfS0VZLHJlZ10pXG4gICAgICAgICAgcmVnID0gJydcbiAgICAgICAgICBzdGF0ZSA9IEFUVFJfS0VZX1dcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQVRUUl9LRVkgJiYgYyA9PT0gJz0nKSB7XG4gICAgICAgICAgcmVzLnB1c2goW0FUVFJfS0VZLHJlZ10sW0FUVFJfRVFdKVxuICAgICAgICAgIHJlZyA9ICcnXG4gICAgICAgICAgc3RhdGUgPSBBVFRSX1ZBTFVFX1dcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQVRUUl9LRVkpIHtcbiAgICAgICAgICByZWcgKz0gY1xuICAgICAgICB9IGVsc2UgaWYgKChzdGF0ZSA9PT0gQVRUUl9LRVlfVyB8fCBzdGF0ZSA9PT0gQVRUUikgJiYgYyA9PT0gJz0nKSB7XG4gICAgICAgICAgcmVzLnB1c2goW0FUVFJfRVFdKVxuICAgICAgICAgIHN0YXRlID0gQVRUUl9WQUxVRV9XXG4gICAgICAgIH0gZWxzZSBpZiAoKHN0YXRlID09PSBBVFRSX0tFWV9XIHx8IHN0YXRlID09PSBBVFRSKSAmJiAhL1xccy8udGVzdChjKSkge1xuICAgICAgICAgIHJlcy5wdXNoKFtBVFRSX0JSRUFLXSlcbiAgICAgICAgICBpZiAoL1tcXHctXS8udGVzdChjKSkge1xuICAgICAgICAgICAgcmVnICs9IGNcbiAgICAgICAgICAgIHN0YXRlID0gQVRUUl9LRVlcbiAgICAgICAgICB9IGVsc2Ugc3RhdGUgPSBBVFRSXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IEFUVFJfVkFMVUVfVyAmJiBjID09PSAnXCInKSB7XG4gICAgICAgICAgc3RhdGUgPSBBVFRSX1ZBTFVFX0RRXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IEFUVFJfVkFMVUVfVyAmJiBjID09PSBcIidcIikge1xuICAgICAgICAgIHN0YXRlID0gQVRUUl9WQUxVRV9TUVxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBBVFRSX1ZBTFVFX0RRICYmIGMgPT09ICdcIicpIHtcbiAgICAgICAgICByZXMucHVzaChbQVRUUl9WQUxVRSxyZWddLFtBVFRSX0JSRUFLXSlcbiAgICAgICAgICByZWcgPSAnJ1xuICAgICAgICAgIHN0YXRlID0gQVRUUlxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBBVFRSX1ZBTFVFX1NRICYmIGMgPT09IFwiJ1wiKSB7XG4gICAgICAgICAgcmVzLnB1c2goW0FUVFJfVkFMVUUscmVnXSxbQVRUUl9CUkVBS10pXG4gICAgICAgICAgcmVnID0gJydcbiAgICAgICAgICBzdGF0ZSA9IEFUVFJcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQVRUUl9WQUxVRV9XICYmICEvXFxzLy50ZXN0KGMpKSB7XG4gICAgICAgICAgc3RhdGUgPSBBVFRSX1ZBTFVFXG4gICAgICAgICAgaS0tXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IEFUVFJfVkFMVUUgJiYgL1xccy8udGVzdChjKSkge1xuICAgICAgICAgIHJlcy5wdXNoKFtBVFRSX1ZBTFVFLHJlZ10sW0FUVFJfQlJFQUtdKVxuICAgICAgICAgIHJlZyA9ICcnXG4gICAgICAgICAgc3RhdGUgPSBBVFRSXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IEFUVFJfVkFMVUUgfHwgc3RhdGUgPT09IEFUVFJfVkFMVUVfU1FcbiAgICAgICAgfHwgc3RhdGUgPT09IEFUVFJfVkFMVUVfRFEpIHtcbiAgICAgICAgICByZWcgKz0gY1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUgPT09IFRFWFQgJiYgcmVnLmxlbmd0aCkge1xuICAgICAgICByZXMucHVzaChbVEVYVCxyZWddKVxuICAgICAgICByZWcgPSAnJ1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQVRUUl9WQUxVRSAmJiByZWcubGVuZ3RoKSB7XG4gICAgICAgIHJlcy5wdXNoKFtBVFRSX1ZBTFVFLHJlZ10pXG4gICAgICAgIHJlZyA9ICcnXG4gICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBBVFRSX1ZBTFVFX0RRICYmIHJlZy5sZW5ndGgpIHtcbiAgICAgICAgcmVzLnB1c2goW0FUVFJfVkFMVUUscmVnXSlcbiAgICAgICAgcmVnID0gJydcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IEFUVFJfVkFMVUVfU1EgJiYgcmVnLmxlbmd0aCkge1xuICAgICAgICByZXMucHVzaChbQVRUUl9WQUxVRSxyZWddKVxuICAgICAgICByZWcgPSAnJ1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQVRUUl9LRVkpIHtcbiAgICAgICAgcmVzLnB1c2goW0FUVFJfS0VZLHJlZ10pXG4gICAgICAgIHJlZyA9ICcnXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RyZm4gKHgpIHtcbiAgICBpZiAodHlwZW9mIHggPT09ICdmdW5jdGlvbicpIHJldHVybiB4XG4gICAgZWxzZSBpZiAodHlwZW9mIHggPT09ICdzdHJpbmcnKSByZXR1cm4geFxuICAgIGVsc2UgaWYgKHggJiYgdHlwZW9mIHggPT09ICdvYmplY3QnKSByZXR1cm4geFxuICAgIGVsc2UgaWYgKHggPT09IG51bGwgfHwgeCA9PT0gdW5kZWZpbmVkKSByZXR1cm4geFxuICAgIGVsc2UgcmV0dXJuIGNvbmNhdCgnJywgeClcbiAgfVxufVxuXG5mdW5jdGlvbiBxdW90IChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUgPT09IEFUVFJfVkFMVUVfU1EgfHwgc3RhdGUgPT09IEFUVFJfVkFMVUVfRFFcbn1cblxudmFyIGNsb3NlUkUgPSBSZWdFeHAoJ14oJyArIFtcbiAgJ2FyZWEnLCAnYmFzZScsICdiYXNlZm9udCcsICdiZ3NvdW5kJywgJ2JyJywgJ2NvbCcsICdjb21tYW5kJywgJ2VtYmVkJyxcbiAgJ2ZyYW1lJywgJ2hyJywgJ2ltZycsICdpbnB1dCcsICdpc2luZGV4JywgJ2tleWdlbicsICdsaW5rJywgJ21ldGEnLCAncGFyYW0nLFxuICAnc291cmNlJywgJ3RyYWNrJywgJ3dicicsICchLS0nLFxuICAvLyBTVkcgVEFHU1xuICAnYW5pbWF0ZScsICdhbmltYXRlVHJhbnNmb3JtJywgJ2NpcmNsZScsICdjdXJzb3InLCAnZGVzYycsICdlbGxpcHNlJyxcbiAgJ2ZlQmxlbmQnLCAnZmVDb2xvck1hdHJpeCcsICdmZUNvbXBvc2l0ZScsXG4gICdmZUNvbnZvbHZlTWF0cml4JywgJ2ZlRGlmZnVzZUxpZ2h0aW5nJywgJ2ZlRGlzcGxhY2VtZW50TWFwJyxcbiAgJ2ZlRGlzdGFudExpZ2h0JywgJ2ZlRmxvb2QnLCAnZmVGdW5jQScsICdmZUZ1bmNCJywgJ2ZlRnVuY0cnLCAnZmVGdW5jUicsXG4gICdmZUdhdXNzaWFuQmx1cicsICdmZUltYWdlJywgJ2ZlTWVyZ2VOb2RlJywgJ2ZlTW9ycGhvbG9neScsXG4gICdmZU9mZnNldCcsICdmZVBvaW50TGlnaHQnLCAnZmVTcGVjdWxhckxpZ2h0aW5nJywgJ2ZlU3BvdExpZ2h0JywgJ2ZlVGlsZScsXG4gICdmZVR1cmJ1bGVuY2UnLCAnZm9udC1mYWNlLWZvcm1hdCcsICdmb250LWZhY2UtbmFtZScsICdmb250LWZhY2UtdXJpJyxcbiAgJ2dseXBoJywgJ2dseXBoUmVmJywgJ2hrZXJuJywgJ2ltYWdlJywgJ2xpbmUnLCAnbWlzc2luZy1nbHlwaCcsICdtcGF0aCcsXG4gICdwYXRoJywgJ3BvbHlnb24nLCAncG9seWxpbmUnLCAncmVjdCcsICdzZXQnLCAnc3RvcCcsICd0cmVmJywgJ3VzZScsICd2aWV3JyxcbiAgJ3ZrZXJuJ1xuXS5qb2luKCd8JykgKyAnKSg/OltcXC4jXVthLXpBLVowLTlcXHUwMDdGLVxcdUZGRkZfOi1dKykqJCcpXG5mdW5jdGlvbiBzZWxmQ2xvc2luZyAodGFnKSB7IHJldHVybiBjbG9zZVJFLnRlc3QodGFnKSB9XG4iLCIndXNlIHN0cmljdCdcblxudmFyIHRyYWlsaW5nTmV3bGluZVJlZ2V4ID0gL1xcbltcXHNdKyQvXG52YXIgbGVhZGluZ05ld2xpbmVSZWdleCA9IC9eXFxuW1xcc10rL1xudmFyIHRyYWlsaW5nU3BhY2VSZWdleCA9IC9bXFxzXSskL1xudmFyIGxlYWRpbmdTcGFjZVJlZ2V4ID0gL15bXFxzXSsvXG52YXIgbXVsdGlTcGFjZVJlZ2V4ID0gL1tcXG5cXHNdKy9nXG5cbnZhciBURVhUX1RBR1MgPSBbXG4gICdhJywgJ2FiYnInLCAnYicsICdiZGknLCAnYmRvJywgJ2JyJywgJ2NpdGUnLCAnZGF0YScsICdkZm4nLCAnZW0nLCAnaScsXG4gICdrYmQnLCAnbWFyaycsICdxJywgJ3JwJywgJ3J0JywgJ3J0YycsICdydWJ5JywgJ3MnLCAnYW1wJywgJ3NtYWxsJywgJ3NwYW4nLFxuICAnc3Ryb25nJywgJ3N1YicsICdzdXAnLCAndGltZScsICd1JywgJ3ZhcicsICd3YnInXG5dXG5cbnZhciBWRVJCQVRJTV9UQUdTID0gW1xuICAnY29kZScsICdwcmUnLCAndGV4dGFyZWEnXG5dXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKGVsLCBjaGlsZHMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcykpIHJldHVyblxuXG4gIHZhciBub2RlTmFtZSA9IGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKClcblxuICB2YXIgaGFkVGV4dCA9IGZhbHNlXG4gIHZhciB2YWx1ZSwgbGVhZGVyXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNoaWxkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBub2RlID0gY2hpbGRzW2ldXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGFwcGVuZENoaWxkKGVsLCBub2RlKVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdudW1iZXInIHx8XG4gICAgICB0eXBlb2Ygbm9kZSA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB0eXBlb2Ygbm9kZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgbm9kZSBpbnN0YW5jZW9mIERhdGUgfHxcbiAgICAgIG5vZGUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIG5vZGUgPSBub2RlLnRvU3RyaW5nKClcbiAgICB9XG5cbiAgICB2YXIgbGFzdENoaWxkID0gZWwuY2hpbGROb2Rlc1tlbC5jaGlsZE5vZGVzLmxlbmd0aCAtIDFdXG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgdGV4dCBub2Rlc1xuICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGhhZFRleHQgPSB0cnVlXG5cbiAgICAgIC8vIElmIHdlIGFscmVhZHkgaGFkIHRleHQsIGFwcGVuZCB0byB0aGUgZXhpc3RpbmcgdGV4dFxuICAgICAgaWYgKGxhc3RDaGlsZCAmJiBsYXN0Q2hpbGQubm9kZU5hbWUgPT09ICcjdGV4dCcpIHtcbiAgICAgICAgbGFzdENoaWxkLm5vZGVWYWx1ZSArPSBub2RlXG5cbiAgICAgIC8vIFdlIGRpZG4ndCBoYXZlIGEgdGV4dCBub2RlIHlldCwgY3JlYXRlIG9uZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZSA9IGVsLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobm9kZSlcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQobm9kZSlcbiAgICAgICAgbGFzdENoaWxkID0gbm9kZVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGlzIGlzIHRoZSBsYXN0IG9mIHRoZSBjaGlsZCBub2RlcywgbWFrZSBzdXJlIHdlIGNsb3NlIGl0IG91dFxuICAgICAgLy8gcmlnaHRcbiAgICAgIGlmIChpID09PSBsZW4gLSAxKSB7XG4gICAgICAgIGhhZFRleHQgPSBmYWxzZVxuICAgICAgICAvLyBUcmltIHRoZSBjaGlsZCB0ZXh0IG5vZGVzIGlmIHRoZSBjdXJyZW50IG5vZGUgaXNuJ3QgYVxuICAgICAgICAvLyBub2RlIHdoZXJlIHdoaXRlc3BhY2UgbWF0dGVycy5cbiAgICAgICAgaWYgKFRFWFRfVEFHUy5pbmRleE9mKG5vZGVOYW1lKSA9PT0gLTEgJiZcbiAgICAgICAgICBWRVJCQVRJTV9UQUdTLmluZGV4T2Yobm9kZU5hbWUpID09PSAtMSkge1xuICAgICAgICAgIHZhbHVlID0gbGFzdENoaWxkLm5vZGVWYWx1ZVxuICAgICAgICAgICAgLnJlcGxhY2UobGVhZGluZ05ld2xpbmVSZWdleCwgJycpXG4gICAgICAgICAgICAucmVwbGFjZSh0cmFpbGluZ1NwYWNlUmVnZXgsICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UodHJhaWxpbmdOZXdsaW5lUmVnZXgsICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UobXVsdGlTcGFjZVJlZ2V4LCAnICcpXG4gICAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgZWwucmVtb3ZlQ2hpbGQobGFzdENoaWxkKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYXN0Q2hpbGQubm9kZVZhbHVlID0gdmFsdWVcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoVkVSQkFUSU1fVEFHUy5pbmRleE9mKG5vZGVOYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAvLyBUaGUgdmVyeSBmaXJzdCBub2RlIGluIHRoZSBsaXN0IHNob3VsZCBub3QgaGF2ZSBsZWFkaW5nXG4gICAgICAgICAgLy8gd2hpdGVzcGFjZS4gU2libGluZyB0ZXh0IG5vZGVzIHNob3VsZCBoYXZlIHdoaXRlc3BhY2UgaWYgdGhlcmVcbiAgICAgICAgICAvLyB3YXMgYW55LlxuICAgICAgICAgIGxlYWRlciA9IGkgPT09IDAgPyAnJyA6ICcgJ1xuICAgICAgICAgIHZhbHVlID0gbGFzdENoaWxkLm5vZGVWYWx1ZVxuICAgICAgICAgICAgLnJlcGxhY2UobGVhZGluZ05ld2xpbmVSZWdleCwgbGVhZGVyKVxuICAgICAgICAgICAgLnJlcGxhY2UobGVhZGluZ1NwYWNlUmVnZXgsICcgJylcbiAgICAgICAgICAgIC5yZXBsYWNlKHRyYWlsaW5nU3BhY2VSZWdleCwgJycpXG4gICAgICAgICAgICAucmVwbGFjZSh0cmFpbGluZ05ld2xpbmVSZWdleCwgJycpXG4gICAgICAgICAgICAucmVwbGFjZShtdWx0aVNwYWNlUmVnZXgsICcgJylcbiAgICAgICAgICBsYXN0Q2hpbGQubm9kZVZhbHVlID0gdmFsdWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIERPTSBub2Rlc1xuICAgIH0gZWxzZSBpZiAobm9kZSAmJiBub2RlLm5vZGVUeXBlKSB7XG4gICAgICAvLyBJZiB0aGUgbGFzdCBub2RlIHdhcyBhIHRleHQgbm9kZSwgbWFrZSBzdXJlIGl0IGlzIHByb3Blcmx5IGNsb3NlZCBvdXRcbiAgICAgIGlmIChoYWRUZXh0KSB7XG4gICAgICAgIGhhZFRleHQgPSBmYWxzZVxuXG4gICAgICAgIC8vIFRyaW0gdGhlIGNoaWxkIHRleHQgbm9kZXMgaWYgdGhlIGN1cnJlbnQgbm9kZSBpc24ndCBhXG4gICAgICAgIC8vIHRleHQgbm9kZSBvciBhIGNvZGUgbm9kZVxuICAgICAgICBpZiAoVEVYVF9UQUdTLmluZGV4T2Yobm9kZU5hbWUpID09PSAtMSAmJlxuICAgICAgICAgIFZFUkJBVElNX1RBR1MuaW5kZXhPZihub2RlTmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgdmFsdWUgPSBsYXN0Q2hpbGQubm9kZVZhbHVlXG4gICAgICAgICAgICAucmVwbGFjZShsZWFkaW5nTmV3bGluZVJlZ2V4LCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKHRyYWlsaW5nTmV3bGluZVJlZ2V4LCAnICcpXG4gICAgICAgICAgICAucmVwbGFjZShtdWx0aVNwYWNlUmVnZXgsICcgJylcblxuICAgICAgICAgIC8vIFJlbW92ZSBlbXB0eSB0ZXh0IG5vZGVzLCBhcHBlbmQgb3RoZXJ3aXNlXG4gICAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgZWwucmVtb3ZlQ2hpbGQobGFzdENoaWxkKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYXN0Q2hpbGQubm9kZVZhbHVlID0gdmFsdWVcbiAgICAgICAgICB9XG4gICAgICAgIC8vIFRyaW0gdGhlIGNoaWxkIG5vZGVzIGJ1dCBwcmVzZXJ2ZSB0aGUgYXBwcm9wcmlhdGUgd2hpdGVzcGFjZVxuICAgICAgICB9IGVsc2UgaWYgKFZFUkJBVElNX1RBR1MuaW5kZXhPZihub2RlTmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgdmFsdWUgPSBsYXN0Q2hpbGQubm9kZVZhbHVlXG4gICAgICAgICAgICAucmVwbGFjZShsZWFkaW5nU3BhY2VSZWdleCwgJyAnKVxuICAgICAgICAgICAgLnJlcGxhY2UobGVhZGluZ05ld2xpbmVSZWdleCwgJycpXG4gICAgICAgICAgICAucmVwbGFjZSh0cmFpbGluZ05ld2xpbmVSZWdleCwgJyAnKVxuICAgICAgICAgICAgLnJlcGxhY2UobXVsdGlTcGFjZVJlZ2V4LCAnICcpXG4gICAgICAgICAgbGFzdENoaWxkLm5vZGVWYWx1ZSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gU3RvcmUgdGhlIGxhc3Qgbm9kZW5hbWVcbiAgICAgIHZhciBfbm9kZU5hbWUgPSBub2RlLm5vZGVOYW1lXG4gICAgICBpZiAoX25vZGVOYW1lKSBub2RlTmFtZSA9IF9ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXG5cbiAgICAgIC8vIEFwcGVuZCB0aGUgbm9kZSB0byB0aGUgRE9NXG4gICAgICBlbC5hcHBlbmRDaGlsZChub2RlKVxuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gW1xuICAnYXN5bmMnLCAnYXV0b2ZvY3VzJywgJ2F1dG9wbGF5JywgJ2NoZWNrZWQnLCAnY29udHJvbHMnLCAnZGVmYXVsdCcsXG4gICdkZWZhdWx0Y2hlY2tlZCcsICdkZWZlcicsICdkaXNhYmxlZCcsICdmb3Jtbm92YWxpZGF0ZScsICdoaWRkZW4nLFxuICAnaXNtYXAnLCAnbG9vcCcsICdtdWx0aXBsZScsICdtdXRlZCcsICdub3ZhbGlkYXRlJywgJ29wZW4nLCAncGxheXNpbmxpbmUnLFxuICAncmVhZG9ubHknLCAncmVxdWlyZWQnLCAncmV2ZXJzZWQnLCAnc2VsZWN0ZWQnXG5dXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZG9tJykoZG9jdW1lbnQpXG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBbXG4gICdpbmRldGVybWluYXRlJ1xuXVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBoeXBlcnggPSByZXF1aXJlKCdoeXBlcngnKVxudmFyIGFwcGVuZENoaWxkID0gcmVxdWlyZSgnLi9hcHBlbmQtY2hpbGQnKVxudmFyIFNWR19UQUdTID0gcmVxdWlyZSgnLi9zdmctdGFncycpXG52YXIgQk9PTF9QUk9QUyA9IHJlcXVpcmUoJy4vYm9vbC1wcm9wcycpXG4vLyBQcm9wcyB0aGF0IG5lZWQgdG8gYmUgc2V0IGRpcmVjdGx5IHJhdGhlciB0aGFuIHdpdGggZWwuc2V0QXR0cmlidXRlKClcbnZhciBESVJFQ1RfUFJPUFMgPSByZXF1aXJlKCcuL2RpcmVjdC1wcm9wcycpXG5cbnZhciBTVkdOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZydcbnZhciBYTElOS05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnXG5cbnZhciBDT01NRU5UX1RBRyA9ICchLS0nXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRvY3VtZW50KSB7XG4gIGZ1bmN0aW9uIG5hbm9IdG1sQ3JlYXRlRWxlbWVudCAodGFnLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgICB2YXIgZWxcblxuICAgIC8vIElmIGFuIHN2ZyB0YWcsIGl0IG5lZWRzIGEgbmFtZXNwYWNlXG4gICAgaWYgKFNWR19UQUdTLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIHByb3BzLm5hbWVzcGFjZSA9IFNWR05TXG4gICAgfVxuXG4gICAgLy8gSWYgd2UgYXJlIHVzaW5nIGEgbmFtZXNwYWNlXG4gICAgdmFyIG5zID0gZmFsc2VcbiAgICBpZiAocHJvcHMubmFtZXNwYWNlKSB7XG4gICAgICBucyA9IHByb3BzLm5hbWVzcGFjZVxuICAgICAgZGVsZXRlIHByb3BzLm5hbWVzcGFjZVxuICAgIH1cblxuICAgIC8vIElmIHdlIGFyZSBleHRlbmRpbmcgYSBidWlsdGluIGVsZW1lbnRcbiAgICB2YXIgaXNDdXN0b21FbGVtZW50ID0gZmFsc2VcbiAgICBpZiAocHJvcHMuaXMpIHtcbiAgICAgIGlzQ3VzdG9tRWxlbWVudCA9IHByb3BzLmlzXG4gICAgICBkZWxldGUgcHJvcHMuaXNcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgdGhlIGVsZW1lbnRcbiAgICBpZiAobnMpIHtcbiAgICAgIGlmIChpc0N1c3RvbUVsZW1lbnQpIHtcbiAgICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsIHRhZywgeyBpczogaXNDdXN0b21FbGVtZW50IH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucywgdGFnKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGFnID09PSBDT01NRU5UX1RBRykge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQocHJvcHMuY29tbWVudClcbiAgICB9IGVsc2UgaWYgKGlzQ3VzdG9tRWxlbWVudCkge1xuICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZywgeyBpczogaXNDdXN0b21FbGVtZW50IH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpXG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIHRoZSBwcm9wZXJ0aWVzXG4gICAgZm9yICh2YXIgcCBpbiBwcm9wcykge1xuICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgIHZhciBrZXkgPSBwLnRvTG93ZXJDYXNlKClcbiAgICAgICAgdmFyIHZhbCA9IHByb3BzW3BdXG4gICAgICAgIC8vIE5vcm1hbGl6ZSBjbGFzc05hbWVcbiAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzbmFtZScpIHtcbiAgICAgICAgICBrZXkgPSAnY2xhc3MnXG4gICAgICAgICAgcCA9ICdjbGFzcydcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgZm9yIGF0dHJpYnV0ZSBnZXRzIHRyYW5zZm9ybWVkIHRvIGh0bWxGb3IsIGJ1dCB3ZSBqdXN0IHNldCBhcyBmb3JcbiAgICAgICAgaWYgKHAgPT09ICdodG1sRm9yJykge1xuICAgICAgICAgIHAgPSAnZm9yJ1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGEgcHJvcGVydHkgaXMgYm9vbGVhbiwgc2V0IGl0c2VsZiB0byB0aGUga2V5XG4gICAgICAgIGlmIChCT09MX1BST1BTLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcbiAgICAgICAgICBpZiAoU3RyaW5nKHZhbCkgPT09ICd0cnVlJykgdmFsID0ga2V5XG4gICAgICAgICAgZWxzZSBpZiAoU3RyaW5nKHZhbCkgPT09ICdmYWxzZScpIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYSBwcm9wZXJ0eSBwcmVmZXJzIGJlaW5nIHNldCBkaXJlY3RseSB2cyBzZXRBdHRyaWJ1dGVcbiAgICAgICAgaWYgKGtleS5zbGljZSgwLCAyKSA9PT0gJ29uJyB8fCBESVJFQ1RfUFJPUFMuaW5kZXhPZihrZXkpICE9PSAtMSkge1xuICAgICAgICAgIGVsW3BdID0gdmFsXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG5zKSB7XG4gICAgICAgICAgICBpZiAocCA9PT0gJ3hsaW5rOmhyZWYnKSB7XG4gICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKFhMSU5LTlMsIHAsIHZhbClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL154bWxucygkfDopL2kudGVzdChwKSkge1xuICAgICAgICAgICAgICAvLyBza2lwIHhtbG5zIGRlZmluaXRpb25zXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBwLCB2YWwpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShwLCB2YWwpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXBwZW5kQ2hpbGQoZWwsIGNoaWxkcmVuKVxuICAgIHJldHVybiBlbFxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnQgKG5vZGVzKSB7XG4gICAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG5vZGVzW2ldID09IG51bGwpIGNvbnRpbnVlXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShub2Rlc1tpXSkpIHtcbiAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY3JlYXRlRnJhZ21lbnQobm9kZXNbaV0pKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBub2Rlc1tpXSA9PT0gJ3N0cmluZycpIG5vZGVzW2ldID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobm9kZXNbaV0pXG4gICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKG5vZGVzW2ldKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnRcbiAgfVxuXG4gIHZhciBleHBvcnRzID0gaHlwZXJ4KG5hbm9IdG1sQ3JlYXRlRWxlbWVudCwge1xuICAgIGNvbW1lbnRzOiB0cnVlLFxuICAgIGNyZWF0ZUZyYWdtZW50OiBjcmVhdGVGcmFnbWVudFxuICB9KVxuICBleHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzXG4gIGV4cG9ydHMuY3JlYXRlQ29tbWVudCA9IG5hbm9IdG1sQ3JlYXRlRWxlbWVudFxuICByZXR1cm4gZXhwb3J0c1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gW1xuICAnc3ZnJywgJ2FsdEdseXBoJywgJ2FsdEdseXBoRGVmJywgJ2FsdEdseXBoSXRlbScsICdhbmltYXRlJywgJ2FuaW1hdGVDb2xvcicsXG4gICdhbmltYXRlTW90aW9uJywgJ2FuaW1hdGVUcmFuc2Zvcm0nLCAnY2lyY2xlJywgJ2NsaXBQYXRoJywgJ2NvbG9yLXByb2ZpbGUnLFxuICAnY3Vyc29yJywgJ2RlZnMnLCAnZGVzYycsICdlbGxpcHNlJywgJ2ZlQmxlbmQnLCAnZmVDb2xvck1hdHJpeCcsXG4gICdmZUNvbXBvbmVudFRyYW5zZmVyJywgJ2ZlQ29tcG9zaXRlJywgJ2ZlQ29udm9sdmVNYXRyaXgnLFxuICAnZmVEaWZmdXNlTGlnaHRpbmcnLCAnZmVEaXNwbGFjZW1lbnRNYXAnLCAnZmVEaXN0YW50TGlnaHQnLCAnZmVGbG9vZCcsXG4gICdmZUZ1bmNBJywgJ2ZlRnVuY0InLCAnZmVGdW5jRycsICdmZUZ1bmNSJywgJ2ZlR2F1c3NpYW5CbHVyJywgJ2ZlSW1hZ2UnLFxuICAnZmVNZXJnZScsICdmZU1lcmdlTm9kZScsICdmZU1vcnBob2xvZ3knLCAnZmVPZmZzZXQnLCAnZmVQb2ludExpZ2h0JyxcbiAgJ2ZlU3BlY3VsYXJMaWdodGluZycsICdmZVNwb3RMaWdodCcsICdmZVRpbGUnLCAnZmVUdXJidWxlbmNlJywgJ2ZpbHRlcicsXG4gICdmb250JywgJ2ZvbnQtZmFjZScsICdmb250LWZhY2UtZm9ybWF0JywgJ2ZvbnQtZmFjZS1uYW1lJywgJ2ZvbnQtZmFjZS1zcmMnLFxuICAnZm9udC1mYWNlLXVyaScsICdmb3JlaWduT2JqZWN0JywgJ2cnLCAnZ2x5cGgnLCAnZ2x5cGhSZWYnLCAnaGtlcm4nLCAnaW1hZ2UnLFxuICAnbGluZScsICdsaW5lYXJHcmFkaWVudCcsICdtYXJrZXInLCAnbWFzaycsICdtZXRhZGF0YScsICdtaXNzaW5nLWdseXBoJyxcbiAgJ21wYXRoJywgJ3BhdGgnLCAncGF0dGVybicsICdwb2x5Z29uJywgJ3BvbHlsaW5lJywgJ3JhZGlhbEdyYWRpZW50JywgJ3JlY3QnLFxuICAnc2V0JywgJ3N0b3AnLCAnc3dpdGNoJywgJ3N5bWJvbCcsICd0ZXh0JywgJ3RleHRQYXRoJywgJ3RpdGxlJywgJ3RyZWYnLFxuICAndHNwYW4nLCAndXNlJywgJ3ZpZXcnLCAndmtlcm4nXG5dXG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmlzTW9iaWxlID0gaXNNb2JpbGU7XG5leHBvcnRzLmRlZmF1bHQgPSBnZXRCcm93c2VyO1xuXG52YXIgX2dsb2JhbHMgPSByZXF1aXJlKFwiLi9nbG9iYWxzXCIpO1xuXG52YXIgX2lzQnJvd3NlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaXMtYnJvd3NlclwiKSk7XG5cbnZhciBfaXNFbGVjdHJvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaXMtZWxlY3Ryb25cIikpO1xuXG5mdW5jdGlvbiBpc01vYmlsZSgpIHtcbiAgcmV0dXJuIHR5cGVvZiBfZ2xvYmFscy53aW5kb3cub3JpZW50YXRpb24gIT09ICd1bmRlZmluZWQnO1xufVxuXG5mdW5jdGlvbiBnZXRCcm93c2VyKG1vY2tVc2VyQWdlbnQpIHtcbiAgaWYgKCFtb2NrVXNlckFnZW50ICYmICEoMCwgX2lzQnJvd3Nlci5kZWZhdWx0KSgpKSB7XG4gICAgcmV0dXJuICdOb2RlJztcbiAgfVxuXG4gIGlmICgoMCwgX2lzRWxlY3Ryb24uZGVmYXVsdCkobW9ja1VzZXJBZ2VudCkpIHtcbiAgICByZXR1cm4gJ0VsZWN0cm9uJztcbiAgfVxuXG4gIHZhciBuYXZpZ2F0b3JfID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgPyBuYXZpZ2F0b3IgOiB7fTtcbiAgdmFyIHVzZXJBZ2VudCA9IG1vY2tVc2VyQWdlbnQgfHwgbmF2aWdhdG9yXy51c2VyQWdlbnQgfHwgJyc7XG5cbiAgaWYgKHVzZXJBZ2VudC5pbmRleE9mKCdFZGdlJykgPiAtMSkge1xuICAgIHJldHVybiAnRWRnZSc7XG4gIH1cblxuICB2YXIgaXNNU0lFID0gdXNlckFnZW50LmluZGV4T2YoJ01TSUUgJykgIT09IC0xO1xuICB2YXIgaXNUcmlkZW50ID0gdXNlckFnZW50LmluZGV4T2YoJ1RyaWRlbnQvJykgIT09IC0xO1xuXG4gIGlmIChpc01TSUUgfHwgaXNUcmlkZW50KSB7XG4gICAgcmV0dXJuICdJRSc7XG4gIH1cblxuICBpZiAoX2dsb2JhbHMud2luZG93LmNocm9tZSkge1xuICAgIHJldHVybiAnQ2hyb21lJztcbiAgfVxuXG4gIGlmIChfZ2xvYmFscy53aW5kb3cuc2FmYXJpKSB7XG4gICAgcmV0dXJuICdTYWZhcmknO1xuICB9XG5cbiAgaWYgKF9nbG9iYWxzLndpbmRvdy5tb3pJbm5lclNjcmVlblgpIHtcbiAgICByZXR1cm4gJ0ZpcmVmb3gnO1xuICB9XG5cbiAgcmV0dXJuICdVbmtub3duJztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1icm93c2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY29uc29sZSA9IGV4cG9ydHMucHJvY2VzcyA9IGV4cG9ydHMuZG9jdW1lbnQgPSBleHBvcnRzLmdsb2JhbCA9IGV4cG9ydHMud2luZG93ID0gZXhwb3J0cy5zZWxmID0gdm9pZCAwO1xuXG52YXIgX3R5cGVvZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKSk7XG5cbnZhciBnbG9iYWxzID0ge1xuICBzZWxmOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZixcbiAgd2luZG93OiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3csXG4gIGdsb2JhbDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLFxuICBkb2N1bWVudDogdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudCxcbiAgcHJvY2VzczogKHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMi5kZWZhdWx0KShwcm9jZXNzKSkgPT09ICdvYmplY3QnICYmIHByb2Nlc3Ncbn07XG52YXIgc2VsZl8gPSBnbG9iYWxzLnNlbGYgfHwgZ2xvYmFscy53aW5kb3cgfHwgZ2xvYmFscy5nbG9iYWw7XG5leHBvcnRzLnNlbGYgPSBzZWxmXztcbnZhciB3aW5kb3dfID0gZ2xvYmFscy53aW5kb3cgfHwgZ2xvYmFscy5zZWxmIHx8IGdsb2JhbHMuZ2xvYmFsO1xuZXhwb3J0cy53aW5kb3cgPSB3aW5kb3dfO1xudmFyIGdsb2JhbF8gPSBnbG9iYWxzLmdsb2JhbCB8fCBnbG9iYWxzLnNlbGYgfHwgZ2xvYmFscy53aW5kb3c7XG5leHBvcnRzLmdsb2JhbCA9IGdsb2JhbF87XG52YXIgZG9jdW1lbnRfID0gZ2xvYmFscy5kb2N1bWVudCB8fCB7fTtcbmV4cG9ydHMuZG9jdW1lbnQgPSBkb2N1bWVudF87XG52YXIgcHJvY2Vzc18gPSBnbG9iYWxzLnByb2Nlc3MgfHwge307XG5leHBvcnRzLnByb2Nlc3MgPSBwcm9jZXNzXztcbnZhciBjb25zb2xlXyA9IGNvbnNvbGU7XG5leHBvcnRzLmNvbnNvbGUgPSBjb25zb2xlXztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsb2JhbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNCcm93c2VyO1xuZXhwb3J0cy5pc0Jyb3dzZXJNYWluVGhyZWFkID0gaXNCcm93c2VyTWFpblRocmVhZDtcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG52YXIgX2lzRWxlY3Ryb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2lzLWVsZWN0cm9uXCIpKTtcblxuZnVuY3Rpb24gaXNCcm93c2VyKCkge1xuICB2YXIgaXNOb2RlID0gKHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMi5kZWZhdWx0KShwcm9jZXNzKSkgPT09ICdvYmplY3QnICYmIFN0cmluZyhwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nICYmICFwcm9jZXNzLmJyb3dzZXI7XG4gIHJldHVybiAhaXNOb2RlIHx8ICgwLCBfaXNFbGVjdHJvbi5kZWZhdWx0KSgpO1xufVxuXG5mdW5jdGlvbiBpc0Jyb3dzZXJNYWluVGhyZWFkKCkge1xuICByZXR1cm4gaXNCcm93c2VyKCkgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWJyb3dzZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNFbGVjdHJvbjtcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG5mdW5jdGlvbiBpc0VsZWN0cm9uKG1vY2tVc2VyQWdlbnQpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICgwLCBfdHlwZW9mMi5kZWZhdWx0KSh3aW5kb3cucHJvY2VzcykgPT09ICdvYmplY3QnICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgKDAsIF90eXBlb2YyLmRlZmF1bHQpKHByb2Nlc3MudmVyc2lvbnMpID09PSAnb2JqZWN0JyAmJiBCb29sZWFuKHByb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb24pKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgcmVhbFVzZXJBZ2VudCA9ICh0eXBlb2YgbmF2aWdhdG9yID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMi5kZWZhdWx0KShuYXZpZ2F0b3IpKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG5hdmlnYXRvci51c2VyQWdlbnQgPT09ICdzdHJpbmcnICYmIG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gIHZhciB1c2VyQWdlbnQgPSBtb2NrVXNlckFnZW50IHx8IHJlYWxVc2VyQWdlbnQ7XG5cbiAgaWYgKHVzZXJBZ2VudCAmJiB1c2VyQWdlbnQuaW5kZXhPZignRWxlY3Ryb24nKSA+PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1lbGVjdHJvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbnZhciBfdHlwZW9mID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTG9nXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9sb2cuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWRVJTSU9OXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxzLlZFUlNJT047XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2VsZlwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2xvYmFsczIuc2VsZjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ3aW5kb3dcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dsb2JhbHMyLndpbmRvdztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnbG9iYWxcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dsb2JhbHMyLmdsb2JhbDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkb2N1bWVudFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2xvYmFsczIuZG9jdW1lbnQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicHJvY2Vzc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2xvYmFsczIucHJvY2VzcztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb25zb2xlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxzMi5jb25zb2xlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzQnJvd3NlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaXNCcm93c2VyLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNCcm93c2VyTWFpblRocmVhZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaXNCcm93c2VyLmlzQnJvd3Nlck1haW5UaHJlYWQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0QnJvd3NlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2V0QnJvd3Nlci5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzTW9iaWxlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nZXRCcm93c2VyLmlzTW9iaWxlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzRWxlY3Ryb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2lzRWxlY3Ryb24uZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhc3NlcnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2Fzc2VydC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNPTE9SXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9jb2xvci5DT0xPUjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhZGRDb2xvclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfY29sb3IuYWRkQ29sb3I7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibGVmdFBhZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZm9ybWF0dGVycy5sZWZ0UGFkO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJpZ2h0UGFkXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9mb3JtYXR0ZXJzLnJpZ2h0UGFkO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImF1dG9iaW5kXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hdXRvYmluZC5hdXRvYmluZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMb2NhbFN0b3JhZ2VcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2xvY2FsU3RvcmFnZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEhpUmVzVGltZXN0YW1wXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9oaVJlc1RpbWVzdGFtcC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN0YXRzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zdGF0cy5TdGF0cztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdGF0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zdGF0cy5TdGF0O1xuICB9XG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxucmVxdWlyZShcIi4vaW5pdFwiKTtcblxudmFyIF9sb2cgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9sb2dcIikpO1xuXG52YXIgX2dsb2JhbHMgPSByZXF1aXJlKFwiLi91dGlscy9nbG9iYWxzXCIpO1xuXG52YXIgX2dsb2JhbHMyID0gcmVxdWlyZShcIi4vZW52L2dsb2JhbHNcIik7XG5cbnZhciBfaXNCcm93c2VyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vZW52L2lzLWJyb3dzZXJcIikpO1xuXG52YXIgX2dldEJyb3dzZXIgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9lbnYvZ2V0LWJyb3dzZXJcIikpO1xuXG52YXIgX2lzRWxlY3Ryb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Vudi9pcy1lbGVjdHJvblwiKSk7XG5cbnZhciBfYXNzZXJ0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlscy9hc3NlcnRcIikpO1xuXG52YXIgX2NvbG9yID0gcmVxdWlyZShcIi4vdXRpbHMvY29sb3JcIik7XG5cbnZhciBfZm9ybWF0dGVycyA9IHJlcXVpcmUoXCIuL3V0aWxzL2Zvcm1hdHRlcnNcIik7XG5cbnZhciBfYXV0b2JpbmQgPSByZXF1aXJlKFwiLi91dGlscy9hdXRvYmluZFwiKTtcblxudmFyIF9sb2NhbFN0b3JhZ2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWxzL2xvY2FsLXN0b3JhZ2VcIikpO1xuXG52YXIgX2hpUmVzVGltZXN0YW1wID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlscy9oaS1yZXMtdGltZXN0YW1wXCIpKTtcblxudmFyIF9zdGF0cyA9IHJlcXVpcmUoXCJAcHJvYmUuZ2wvc3RhdHNcIik7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOyB9KShub2RlSW50ZXJvcCk7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqLCBub2RlSW50ZXJvcCkgeyBpZiAoIW5vZGVJbnRlcm9wICYmIG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxudmFyIF9kZWZhdWx0ID0gbmV3IF9sb2cuZGVmYXVsdCh7XG4gIGlkOiAncHJvYmUuZ2wnXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9nbG9iYWxzID0gcmVxdWlyZShcIi4vdXRpbHMvZ2xvYmFsc1wiKTtcblxuX2dsb2JhbHMuZ2xvYmFsLnByb2JlID0ge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbml0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubm9ybWFsaXplQXJndW1lbnRzID0gbm9ybWFsaXplQXJndW1lbnRzO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3R5cGVvZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKSk7XG5cbnZhciBfdG9Db25zdW1hYmxlQXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheVwiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfZ2xvYmFscyA9IHJlcXVpcmUoXCIuLi91dGlscy9nbG9iYWxzXCIpO1xuXG52YXIgX2xvY2FsU3RvcmFnZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3V0aWxzL2xvY2FsLXN0b3JhZ2VcIikpO1xuXG52YXIgX2Zvcm1hdHRlcnMgPSByZXF1aXJlKFwiLi4vdXRpbHMvZm9ybWF0dGVyc1wiKTtcblxudmFyIF9jb2xvciA9IHJlcXVpcmUoXCIuLi91dGlscy9jb2xvclwiKTtcblxudmFyIF9hdXRvYmluZCA9IHJlcXVpcmUoXCIuLi91dGlscy9hdXRvYmluZFwiKTtcblxudmFyIF9hc3NlcnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdXRpbHMvYXNzZXJ0XCIpKTtcblxudmFyIF9oaVJlc1RpbWVzdGFtcCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3V0aWxzL2hpLXJlcy10aW1lc3RhbXBcIikpO1xuXG52YXIgb3JpZ2luYWxDb25zb2xlID0ge1xuICBkZWJ1ZzogX2dsb2JhbHMuaXNCcm93c2VyID8gY29uc29sZS5kZWJ1ZyB8fCBjb25zb2xlLmxvZyA6IGNvbnNvbGUubG9nLFxuICBsb2c6IGNvbnNvbGUubG9nLFxuICBpbmZvOiBjb25zb2xlLmluZm8sXG4gIHdhcm46IGNvbnNvbGUud2FybixcbiAgZXJyb3I6IGNvbnNvbGUuZXJyb3Jcbn07XG52YXIgREVGQVVMVF9TRVRUSU5HUyA9IHtcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgbGV2ZWw6IDBcbn07XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgY2FjaGUgPSB7fTtcbnZhciBPTkNFID0ge1xuICBvbmNlOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBnZXRUYWJsZUhlYWRlcih0YWJsZSkge1xuICBmb3IgKHZhciBrZXkgaW4gdGFibGUpIHtcbiAgICBmb3IgKHZhciB0aXRsZSBpbiB0YWJsZVtrZXldKSB7XG4gICAgICByZXR1cm4gdGl0bGUgfHwgJ3VudGl0bGVkJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJ2VtcHR5Jztcbn1cblxudmFyIExvZyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTG9nKCkge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7XG4gICAgICBpZDogJydcbiAgICB9LFxuICAgICAgICBpZCA9IF9yZWYuaWQ7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBMb2cpO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLlZFUlNJT04gPSBfZ2xvYmFscy5WRVJTSU9OO1xuICAgIHRoaXMuX3N0YXJ0VHMgPSAoMCwgX2hpUmVzVGltZXN0YW1wLmRlZmF1bHQpKCk7XG4gICAgdGhpcy5fZGVsdGFUcyA9ICgwLCBfaGlSZXNUaW1lc3RhbXAuZGVmYXVsdCkoKTtcbiAgICB0aGlzLkxPR19USFJPVFRMRV9USU1FT1VUID0gMDtcbiAgICB0aGlzLl9zdG9yYWdlID0gbmV3IF9sb2NhbFN0b3JhZ2UuZGVmYXVsdChcIl9fcHJvYmUtXCIuY29uY2F0KHRoaXMuaWQsIFwiX19cIiksIERFRkFVTFRfU0VUVElOR1MpO1xuICAgIHRoaXMudXNlckRhdGEgPSB7fTtcbiAgICB0aGlzLnRpbWVTdGFtcChcIlwiLmNvbmNhdCh0aGlzLmlkLCBcIiBzdGFydGVkXCIpKTtcbiAgICAoMCwgX2F1dG9iaW5kLmF1dG9iaW5kKSh0aGlzKTtcbiAgICBPYmplY3Quc2VhbCh0aGlzKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKExvZywgW3tcbiAgICBrZXk6IFwibGV2ZWxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldExldmVsKCk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdMZXZlbCkge1xuICAgICAgdGhpcy5zZXRMZXZlbChuZXdMZXZlbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzRW5hYmxlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0VuYWJsZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RvcmFnZS5jb25maWcuZW5hYmxlZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TGV2ZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGV2ZWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RvcmFnZS5jb25maWcubGV2ZWw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRvdGFsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRvdGFsKCkge1xuICAgICAgcmV0dXJuIE51bWJlcigoKDAsIF9oaVJlc1RpbWVzdGFtcC5kZWZhdWx0KSgpIC0gdGhpcy5fc3RhcnRUcykudG9QcmVjaXNpb24oMTApKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGVsdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVsdGEoKSB7XG4gICAgICByZXR1cm4gTnVtYmVyKCgoMCwgX2hpUmVzVGltZXN0YW1wLmRlZmF1bHQpKCkgLSB0aGlzLl9kZWx0YVRzKS50b1ByZWNpc2lvbigxMCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcmlvcml0eVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGV2ZWw7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdQcmlvcml0eSkge1xuICAgICAgdGhpcy5sZXZlbCA9IG5ld1ByaW9yaXR5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQcmlvcml0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQcmlvcml0eSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxldmVsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmFibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgICAgdmFyIGVuYWJsZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG5cbiAgICAgIHRoaXMuX3N0b3JhZ2UudXBkYXRlQ29uZmlndXJhdGlvbih7XG4gICAgICAgIGVuYWJsZWQ6IGVuYWJsZWRcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TGV2ZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TGV2ZWwobGV2ZWwpIHtcbiAgICAgIHRoaXMuX3N0b3JhZ2UudXBkYXRlQ29uZmlndXJhdGlvbih7XG4gICAgICAgIGxldmVsOiBsZXZlbFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhc3NlcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgICAgKDAsIF9hc3NlcnQyLmRlZmF1bHQpKGNvbmRpdGlvbiwgbWVzc2FnZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndhcm5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2FybihtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0TG9nRnVuY3Rpb24oMCwgbWVzc2FnZSwgb3JpZ2luYWxDb25zb2xlLndhcm4sIGFyZ3VtZW50cywgT05DRSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRMb2dGdW5jdGlvbigwLCBtZXNzYWdlLCBvcmlnaW5hbENvbnNvbGUuZXJyb3IsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlcHJlY2F0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVwcmVjYXRlZChvbGRVc2FnZSwgbmV3VXNhZ2UpIHtcbiAgICAgIHJldHVybiB0aGlzLndhcm4oXCJgXCIuY29uY2F0KG9sZFVzYWdlLCBcImAgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgbGF0ZXIgdmVyc2lvbi4gVXNlIGBcIikuY29uY2F0KG5ld1VzYWdlLCBcImAgaW5zdGVhZFwiKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlZChvbGRVc2FnZSwgbmV3VXNhZ2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmVycm9yKFwiYFwiLmNvbmNhdChvbGRVc2FnZSwgXCJgIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBgXCIpLmNvbmNhdChuZXdVc2FnZSwgXCJgIGluc3RlYWRcIikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcm9iZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9iZShsb2dMZXZlbCwgbWVzc2FnZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldExvZ0Z1bmN0aW9uKGxvZ0xldmVsLCBtZXNzYWdlLCBvcmlnaW5hbENvbnNvbGUubG9nLCBhcmd1bWVudHMsIHtcbiAgICAgICAgdGltZTogdHJ1ZSxcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxvZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2cobG9nTGV2ZWwsIG1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRMb2dGdW5jdGlvbihsb2dMZXZlbCwgbWVzc2FnZSwgb3JpZ2luYWxDb25zb2xlLmRlYnVnLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbmZvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluZm8obG9nTGV2ZWwsIG1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRMb2dGdW5jdGlvbihsb2dMZXZlbCwgbWVzc2FnZSwgY29uc29sZS5pbmZvLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvbmNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uY2UobG9nTGV2ZWwsIG1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRMb2dGdW5jdGlvbihsb2dMZXZlbCwgbWVzc2FnZSwgb3JpZ2luYWxDb25zb2xlLmRlYnVnIHx8IG9yaWdpbmFsQ29uc29sZS5pbmZvLCBhcmd1bWVudHMsIE9OQ0UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0YWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0YWJsZShsb2dMZXZlbCwgX3RhYmxlLCBjb2x1bW5zKSB7XG4gICAgICBpZiAoX3RhYmxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRMb2dGdW5jdGlvbihsb2dMZXZlbCwgX3RhYmxlLCBjb25zb2xlLnRhYmxlIHx8IG5vb3AsIGNvbHVtbnMgJiYgW2NvbHVtbnNdLCB7XG4gICAgICAgICAgdGFnOiBnZXRUYWJsZUhlYWRlcihfdGFibGUpXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9vcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW1hZ2UoX3JlZjIpIHtcbiAgICAgIHZhciBsb2dMZXZlbCA9IF9yZWYyLmxvZ0xldmVsLFxuICAgICAgICAgIHByaW9yaXR5ID0gX3JlZjIucHJpb3JpdHksXG4gICAgICAgICAgX2ltYWdlID0gX3JlZjIuaW1hZ2UsXG4gICAgICAgICAgX3JlZjIkbWVzc2FnZSA9IF9yZWYyLm1lc3NhZ2UsXG4gICAgICAgICAgbWVzc2FnZSA9IF9yZWYyJG1lc3NhZ2UgPT09IHZvaWQgMCA/ICcnIDogX3JlZjIkbWVzc2FnZSxcbiAgICAgICAgICBfcmVmMiRzY2FsZSA9IF9yZWYyLnNjYWxlLFxuICAgICAgICAgIHNjYWxlID0gX3JlZjIkc2NhbGUgPT09IHZvaWQgMCA/IDEgOiBfcmVmMiRzY2FsZTtcblxuICAgICAgaWYgKCF0aGlzLl9zaG91bGRMb2cobG9nTGV2ZWwgfHwgcHJpb3JpdHkpKSB7XG4gICAgICAgIHJldHVybiBub29wO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2dsb2JhbHMuaXNCcm93c2VyID8gbG9nSW1hZ2VJbkJyb3dzZXIoe1xuICAgICAgICBpbWFnZTogX2ltYWdlLFxuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICBzY2FsZTogc2NhbGVcbiAgICAgIH0pIDogbG9nSW1hZ2VJbk5vZGUoe1xuICAgICAgICBpbWFnZTogX2ltYWdlLFxuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICBzY2FsZTogc2NhbGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXR0aW5nc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR0aW5ncygpIHtcbiAgICAgIGlmIChjb25zb2xlLnRhYmxlKSB7XG4gICAgICAgIGNvbnNvbGUudGFibGUodGhpcy5fc3RvcmFnZS5jb25maWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2codGhpcy5fc3RvcmFnZS5jb25maWcpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KHNldHRpbmcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdG9yYWdlLmNvbmZpZ1tzZXR0aW5nXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChzZXR0aW5nLCB2YWx1ZSkge1xuICAgICAgdGhpcy5fc3RvcmFnZS51cGRhdGVDb25maWd1cmF0aW9uKCgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHt9LCBzZXR0aW5nLCB2YWx1ZSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0aW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRpbWUobG9nTGV2ZWwsIG1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRMb2dGdW5jdGlvbihsb2dMZXZlbCwgbWVzc2FnZSwgY29uc29sZS50aW1lID8gY29uc29sZS50aW1lIDogY29uc29sZS5pbmZvKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGltZUVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aW1lRW5kKGxvZ0xldmVsLCBtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0TG9nRnVuY3Rpb24obG9nTGV2ZWwsIG1lc3NhZ2UsIGNvbnNvbGUudGltZUVuZCA/IGNvbnNvbGUudGltZUVuZCA6IGNvbnNvbGUuaW5mbyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRpbWVTdGFtcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aW1lU3RhbXAobG9nTGV2ZWwsIG1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRMb2dGdW5jdGlvbihsb2dMZXZlbCwgbWVzc2FnZSwgY29uc29sZS50aW1lU3RhbXAgfHwgbm9vcCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdyb3VwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdyb3VwKGxvZ0xldmVsLCBtZXNzYWdlKSB7XG4gICAgICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge1xuICAgICAgICBjb2xsYXBzZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgb3B0cyA9IG5vcm1hbGl6ZUFyZ3VtZW50cyh7XG4gICAgICAgIGxvZ0xldmVsOiBsb2dMZXZlbCxcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgb3B0czogb3B0c1xuICAgICAgfSk7XG4gICAgICB2YXIgX29wdHMgPSBvcHRzLFxuICAgICAgICAgIGNvbGxhcHNlZCA9IF9vcHRzLmNvbGxhcHNlZDtcbiAgICAgIG9wdHMubWV0aG9kID0gKGNvbGxhcHNlZCA/IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQgOiBjb25zb2xlLmdyb3VwKSB8fCBjb25zb2xlLmluZm87XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0TG9nRnVuY3Rpb24ob3B0cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdyb3VwQ29sbGFwc2VkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdyb3VwQ29sbGFwc2VkKGxvZ0xldmVsLCBtZXNzYWdlKSB7XG4gICAgICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICByZXR1cm4gdGhpcy5ncm91cChsb2dMZXZlbCwgbWVzc2FnZSwgT2JqZWN0LmFzc2lnbih7fSwgb3B0cywge1xuICAgICAgICBjb2xsYXBzZWQ6IHRydWVcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ3JvdXBFbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ3JvdXBFbmQobG9nTGV2ZWwpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRMb2dGdW5jdGlvbihsb2dMZXZlbCwgJycsIGNvbnNvbGUuZ3JvdXBFbmQgfHwgbm9vcCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhHcm91cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoR3JvdXAobG9nTGV2ZWwsIG1lc3NhZ2UsIGZ1bmMpIHtcbiAgICAgIHRoaXMuZ3JvdXAobG9nTGV2ZWwsIG1lc3NhZ2UpKCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZ1bmMoKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuZ3JvdXBFbmQobG9nTGV2ZWwpKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRyYWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYWNlKCkge1xuICAgICAgaWYgKGNvbnNvbGUudHJhY2UpIHtcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc2hvdWxkTG9nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zaG91bGRMb2cobG9nTGV2ZWwpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzRW5hYmxlZCgpICYmIHRoaXMuZ2V0TGV2ZWwoKSA+PSBub3JtYWxpemVMb2dMZXZlbChsb2dMZXZlbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRMb2dGdW5jdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0TG9nRnVuY3Rpb24obG9nTGV2ZWwsIG1lc3NhZ2UsIG1ldGhvZCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IFtdO1xuICAgICAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/IGFyZ3VtZW50c1s0XSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHRoaXMuX3Nob3VsZExvZyhsb2dMZXZlbCkpIHtcbiAgICAgICAgdmFyIF9tZXRob2Q7XG5cbiAgICAgICAgb3B0cyA9IG5vcm1hbGl6ZUFyZ3VtZW50cyh7XG4gICAgICAgICAgbG9nTGV2ZWw6IGxvZ0xldmVsLFxuICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgYXJnczogYXJncyxcbiAgICAgICAgICBvcHRzOiBvcHRzXG4gICAgICAgIH0pO1xuICAgICAgICBtZXRob2QgPSBtZXRob2QgfHwgb3B0cy5tZXRob2Q7XG4gICAgICAgICgwLCBfYXNzZXJ0Mi5kZWZhdWx0KShtZXRob2QpO1xuICAgICAgICBvcHRzLnRvdGFsID0gdGhpcy5nZXRUb3RhbCgpO1xuICAgICAgICBvcHRzLmRlbHRhID0gdGhpcy5nZXREZWx0YSgpO1xuICAgICAgICB0aGlzLl9kZWx0YVRzID0gKDAsIF9oaVJlc1RpbWVzdGFtcC5kZWZhdWx0KSgpO1xuICAgICAgICB2YXIgdGFnID0gb3B0cy50YWcgfHwgb3B0cy5tZXNzYWdlO1xuXG4gICAgICAgIGlmIChvcHRzLm9uY2UpIHtcbiAgICAgICAgICBpZiAoIWNhY2hlW3RhZ10pIHtcbiAgICAgICAgICAgIGNhY2hlW3RhZ10gPSAoMCwgX2hpUmVzVGltZXN0YW1wLmRlZmF1bHQpKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBub29wO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lc3NhZ2UgPSBkZWNvcmF0ZU1lc3NhZ2UodGhpcy5pZCwgb3B0cy5tZXNzYWdlLCBvcHRzKTtcbiAgICAgICAgcmV0dXJuIChfbWV0aG9kID0gbWV0aG9kKS5iaW5kLmFwcGx5KF9tZXRob2QsIFtjb25zb2xlLCBtZXNzYWdlXS5jb25jYXQoKDAsIF90b0NvbnN1bWFibGVBcnJheTIuZGVmYXVsdCkob3B0cy5hcmdzKSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9vcDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIExvZztcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gTG9nO1xuTG9nLlZFUlNJT04gPSBfZ2xvYmFscy5WRVJTSU9OO1xuXG5mdW5jdGlvbiBub3JtYWxpemVMb2dMZXZlbChsb2dMZXZlbCkge1xuICBpZiAoIWxvZ0xldmVsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgcmVzb2x2ZWRMZXZlbDtcblxuICBzd2l0Y2ggKCgwLCBfdHlwZW9mMi5kZWZhdWx0KShsb2dMZXZlbCkpIHtcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmVzb2x2ZWRMZXZlbCA9IGxvZ0xldmVsO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgcmVzb2x2ZWRMZXZlbCA9IGxvZ0xldmVsLmxvZ0xldmVsIHx8IGxvZ0xldmVsLnByaW9yaXR5IHx8IDA7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gMDtcbiAgfVxuXG4gICgwLCBfYXNzZXJ0Mi5kZWZhdWx0KShOdW1iZXIuaXNGaW5pdGUocmVzb2x2ZWRMZXZlbCkgJiYgcmVzb2x2ZWRMZXZlbCA+PSAwKTtcbiAgcmV0dXJuIHJlc29sdmVkTGV2ZWw7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFyZ3VtZW50cyhvcHRzKSB7XG4gIHZhciBsb2dMZXZlbCA9IG9wdHMubG9nTGV2ZWwsXG4gICAgICBtZXNzYWdlID0gb3B0cy5tZXNzYWdlO1xuICBvcHRzLmxvZ0xldmVsID0gbm9ybWFsaXplTG9nTGV2ZWwobG9nTGV2ZWwpO1xuICB2YXIgYXJncyA9IG9wdHMuYXJncyA/IEFycmF5LmZyb20ob3B0cy5hcmdzKSA6IFtdO1xuXG4gIHdoaWxlIChhcmdzLmxlbmd0aCAmJiBhcmdzLnNoaWZ0KCkgIT09IG1lc3NhZ2UpIHt9XG5cbiAgb3B0cy5hcmdzID0gYXJncztcblxuICBzd2l0Y2ggKCgwLCBfdHlwZW9mMi5kZWZhdWx0KShsb2dMZXZlbCkpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIGlmIChtZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXJncy51bnNoaWZ0KG1lc3NhZ2UpO1xuICAgICAgfVxuXG4gICAgICBvcHRzLm1lc3NhZ2UgPSBsb2dMZXZlbDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIE9iamVjdC5hc3NpZ24ob3B0cywgbG9nTGV2ZWwpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRzLm1lc3NhZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRzLm1lc3NhZ2UgPSBvcHRzLm1lc3NhZ2UoKTtcbiAgfVxuXG4gIHZhciBtZXNzYWdlVHlwZSA9ICgwLCBfdHlwZW9mMi5kZWZhdWx0KShvcHRzLm1lc3NhZ2UpO1xuICAoMCwgX2Fzc2VydDIuZGVmYXVsdCkobWVzc2FnZVR5cGUgPT09ICdzdHJpbmcnIHx8IG1lc3NhZ2VUeXBlID09PSAnb2JqZWN0Jyk7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG9wdHMsIG9wdHMub3B0cyk7XG59XG5cbmZ1bmN0aW9uIGRlY29yYXRlTWVzc2FnZShpZCwgbWVzc2FnZSwgb3B0cykge1xuICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHRpbWUgPSBvcHRzLnRpbWUgPyAoMCwgX2Zvcm1hdHRlcnMubGVmdFBhZCkoKDAsIF9mb3JtYXR0ZXJzLmZvcm1hdFRpbWUpKG9wdHMudG90YWwpKSA6ICcnO1xuICAgIG1lc3NhZ2UgPSBvcHRzLnRpbWUgPyBcIlwiLmNvbmNhdChpZCwgXCI6IFwiKS5jb25jYXQodGltZSwgXCIgIFwiKS5jb25jYXQobWVzc2FnZSkgOiBcIlwiLmNvbmNhdChpZCwgXCI6IFwiKS5jb25jYXQobWVzc2FnZSk7XG4gICAgbWVzc2FnZSA9ICgwLCBfY29sb3IuYWRkQ29sb3IpKG1lc3NhZ2UsIG9wdHMuY29sb3IsIG9wdHMuYmFja2dyb3VuZCk7XG4gIH1cblxuICByZXR1cm4gbWVzc2FnZTtcbn1cblxuZnVuY3Rpb24gbG9nSW1hZ2VJbk5vZGUoX3JlZjMpIHtcbiAgdmFyIGltYWdlID0gX3JlZjMuaW1hZ2UsXG4gICAgICBfcmVmMyRtZXNzYWdlID0gX3JlZjMubWVzc2FnZSxcbiAgICAgIG1lc3NhZ2UgPSBfcmVmMyRtZXNzYWdlID09PSB2b2lkIDAgPyAnJyA6IF9yZWYzJG1lc3NhZ2UsXG4gICAgICBfcmVmMyRzY2FsZSA9IF9yZWYzLnNjYWxlLFxuICAgICAgc2NhbGUgPSBfcmVmMyRzY2FsZSA9PT0gdm9pZCAwID8gMSA6IF9yZWYzJHNjYWxlO1xuICB2YXIgYXNjaWlmeSA9IG51bGw7XG5cbiAgdHJ5IHtcbiAgICBhc2NpaWZ5ID0gbW9kdWxlLnJlcXVpcmUoJ2FzY2lpZnktaW1hZ2UnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHt9XG5cbiAgaWYgKGFzY2lpZnkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFzY2lpZnkoaW1hZ2UsIHtcbiAgICAgICAgZml0OiAnYm94JyxcbiAgICAgICAgd2lkdGg6IFwiXCIuY29uY2F0KE1hdGgucm91bmQoODAgKiBzY2FsZSksIFwiJVwiKVxuICAgICAgfSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gY29uc29sZS5sb2coZGF0YSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG5vb3A7XG59XG5cbmZ1bmN0aW9uIGxvZ0ltYWdlSW5Ccm93c2VyKF9yZWY0KSB7XG4gIHZhciBpbWFnZSA9IF9yZWY0LmltYWdlLFxuICAgICAgX3JlZjQkbWVzc2FnZSA9IF9yZWY0Lm1lc3NhZ2UsXG4gICAgICBtZXNzYWdlID0gX3JlZjQkbWVzc2FnZSA9PT0gdm9pZCAwID8gJycgOiBfcmVmNCRtZXNzYWdlLFxuICAgICAgX3JlZjQkc2NhbGUgPSBfcmVmNC5zY2FsZSxcbiAgICAgIHNjYWxlID0gX3JlZjQkc2NhbGUgPT09IHZvaWQgMCA/IDEgOiBfcmVmNCRzY2FsZTtcblxuICBpZiAodHlwZW9mIGltYWdlID09PSAnc3RyaW5nJykge1xuICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcblxuICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2NvbnNvbGU7XG5cbiAgICAgIHZhciBhcmdzID0gKDAsIF9mb3JtYXR0ZXJzLmZvcm1hdEltYWdlKShpbWcsIG1lc3NhZ2UsIHNjYWxlKTtcblxuICAgICAgKF9jb25zb2xlID0gY29uc29sZSkubG9nLmFwcGx5KF9jb25zb2xlLCAoMCwgX3RvQ29uc3VtYWJsZUFycmF5Mi5kZWZhdWx0KShhcmdzKSk7XG4gICAgfTtcblxuICAgIGltZy5zcmMgPSBpbWFnZTtcbiAgICByZXR1cm4gbm9vcDtcbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gaW1hZ2Uubm9kZU5hbWUgfHwgJyc7XG5cbiAgaWYgKGVsZW1lbnQudG9Mb3dlckNhc2UoKSA9PT0gJ2ltZycpIHtcbiAgICB2YXIgX2NvbnNvbGUyO1xuXG4gICAgKF9jb25zb2xlMiA9IGNvbnNvbGUpLmxvZy5hcHBseShfY29uc29sZTIsICgwLCBfdG9Db25zdW1hYmxlQXJyYXkyLmRlZmF1bHQpKCgwLCBfZm9ybWF0dGVycy5mb3JtYXRJbWFnZSkoaW1hZ2UsIG1lc3NhZ2UsIHNjYWxlKSkpO1xuXG4gICAgcmV0dXJuIG5vb3A7XG4gIH1cblxuICBpZiAoZWxlbWVudC50b0xvd2VyQ2FzZSgpID09PSAnY2FudmFzJykge1xuICAgIHZhciBfaW1nID0gbmV3IEltYWdlKCk7XG5cbiAgICBfaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfY29uc29sZTM7XG5cbiAgICAgIHJldHVybiAoX2NvbnNvbGUzID0gY29uc29sZSkubG9nLmFwcGx5KF9jb25zb2xlMywgKDAsIF90b0NvbnN1bWFibGVBcnJheTIuZGVmYXVsdCkoKDAsIF9mb3JtYXR0ZXJzLmZvcm1hdEltYWdlKShfaW1nLCBtZXNzYWdlLCBzY2FsZSkpKTtcbiAgICB9O1xuXG4gICAgX2ltZy5zcmMgPSBpbWFnZS50b0RhdGFVUkwoKTtcbiAgICByZXR1cm4gbm9vcDtcbiAgfVxuXG4gIHJldHVybiBub29wO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gYXNzZXJ0O1xuXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzZXJ0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5hdXRvYmluZCA9IGF1dG9iaW5kO1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIGF1dG9iaW5kKG9iaikge1xuICB2YXIgcHJlZGVmaW5lZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogWydjb25zdHJ1Y3RvciddO1xuICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgdmFyIHByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKTtcblxuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocHJvcE5hbWVzKSxcbiAgICAgIF9zdGVwO1xuXG4gIHRyeSB7XG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICB2YXIga2V5ID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKCFwcmVkZWZpbmVkLmZpbmQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4ga2V5ID09PSBuYW1lO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIG9ialtrZXldID0gb2JqW2tleV0uYmluZChvYmopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICBfbG9vcCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRvYmluZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYWRkQ29sb3IgPSBhZGRDb2xvcjtcbmV4cG9ydHMuQ09MT1IgPSB2b2lkIDA7XG5cbnZhciBfZ2xvYmFscyA9IHJlcXVpcmUoXCIuL2dsb2JhbHNcIik7XG5cbnZhciBDT0xPUiA9IHtcbiAgQkxBQ0s6IDMwLFxuICBSRUQ6IDMxLFxuICBHUkVFTjogMzIsXG4gIFlFTExPVzogMzMsXG4gIEJMVUU6IDM0LFxuICBNQUdFTlRBOiAzNSxcbiAgQ1lBTjogMzYsXG4gIFdISVRFOiAzNyxcbiAgQlJJR0hUX0JMQUNLOiA5MCxcbiAgQlJJR0hUX1JFRDogOTEsXG4gIEJSSUdIVF9HUkVFTjogOTIsXG4gIEJSSUdIVF9ZRUxMT1c6IDkzLFxuICBCUklHSFRfQkxVRTogOTQsXG4gIEJSSUdIVF9NQUdFTlRBOiA5NSxcbiAgQlJJR0hUX0NZQU46IDk2LFxuICBCUklHSFRfV0hJVEU6IDk3XG59O1xuZXhwb3J0cy5DT0xPUiA9IENPTE9SO1xuXG5mdW5jdGlvbiBnZXRDb2xvcihjb2xvcikge1xuICByZXR1cm4gdHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJyA/IENPTE9SW2NvbG9yLnRvVXBwZXJDYXNlKCldIHx8IENPTE9SLldISVRFIDogY29sb3I7XG59XG5cbmZ1bmN0aW9uIGFkZENvbG9yKHN0cmluZywgY29sb3IsIGJhY2tncm91bmQpIHtcbiAgaWYgKCFfZ2xvYmFscy5pc0Jyb3dzZXIgJiYgdHlwZW9mIHN0cmluZyA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIGNvbG9yID0gZ2V0Q29sb3IoY29sb3IpO1xuICAgICAgc3RyaW5nID0gXCJcXHgxQltcIi5jb25jYXQoY29sb3IsIFwibVwiKS5jb25jYXQoc3RyaW5nLCBcIlxceDFCWzM5bVwiKTtcbiAgICB9XG5cbiAgICBpZiAoYmFja2dyb3VuZCkge1xuICAgICAgY29sb3IgPSBnZXRDb2xvcihiYWNrZ3JvdW5kKTtcbiAgICAgIHN0cmluZyA9IFwiXFx4MUJbXCIuY29uY2F0KGJhY2tncm91bmQgKyAxMCwgXCJtXCIpLmNvbmNhdChzdHJpbmcsIFwiXFx4MUJbNDltXCIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHJpbmc7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb2xvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZm9ybWF0VGltZSA9IGZvcm1hdFRpbWU7XG5leHBvcnRzLmxlZnRQYWQgPSBsZWZ0UGFkO1xuZXhwb3J0cy5yaWdodFBhZCA9IHJpZ2h0UGFkO1xuZXhwb3J0cy5mb3JtYXRWYWx1ZSA9IGZvcm1hdFZhbHVlO1xuZXhwb3J0cy5mb3JtYXRJbWFnZSA9IGZvcm1hdEltYWdlO1xuXG5mdW5jdGlvbiBmb3JtYXRUaW1lKG1zKSB7XG4gIHZhciBmb3JtYXR0ZWQ7XG5cbiAgaWYgKG1zIDwgMTApIHtcbiAgICBmb3JtYXR0ZWQgPSBcIlwiLmNvbmNhdChtcy50b0ZpeGVkKDIpLCBcIm1zXCIpO1xuICB9IGVsc2UgaWYgKG1zIDwgMTAwKSB7XG4gICAgZm9ybWF0dGVkID0gXCJcIi5jb25jYXQobXMudG9GaXhlZCgxKSwgXCJtc1wiKTtcbiAgfSBlbHNlIGlmIChtcyA8IDEwMDApIHtcbiAgICBmb3JtYXR0ZWQgPSBcIlwiLmNvbmNhdChtcy50b0ZpeGVkKDApLCBcIm1zXCIpO1xuICB9IGVsc2Uge1xuICAgIGZvcm1hdHRlZCA9IFwiXCIuY29uY2F0KChtcyAvIDEwMDApLnRvRml4ZWQoMiksIFwic1wiKTtcbiAgfVxuXG4gIHJldHVybiBmb3JtYXR0ZWQ7XG59XG5cbmZ1bmN0aW9uIGxlZnRQYWQoc3RyaW5nKSB7XG4gIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDg7XG4gIHZhciBwYWRMZW5ndGggPSBNYXRoLm1heChsZW5ndGggLSBzdHJpbmcubGVuZ3RoLCAwKTtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KCcgJy5yZXBlYXQocGFkTGVuZ3RoKSkuY29uY2F0KHN0cmluZyk7XG59XG5cbmZ1bmN0aW9uIHJpZ2h0UGFkKHN0cmluZykge1xuICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiA4O1xuICB2YXIgcGFkTGVuZ3RoID0gTWF0aC5tYXgobGVuZ3RoIC0gc3RyaW5nLmxlbmd0aCwgMCk7XG4gIHJldHVybiBcIlwiLmNvbmNhdChzdHJpbmcpLmNvbmNhdCgnICcucmVwZWF0KHBhZExlbmd0aCkpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZSh2KSB7XG4gIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIEVQU0lMT04gPSAxZS0xNjtcbiAgdmFyIF9vcHRzJGlzSW50ZWdlciA9IG9wdHMuaXNJbnRlZ2VyLFxuICAgICAgaXNJbnRlZ2VyID0gX29wdHMkaXNJbnRlZ2VyID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRzJGlzSW50ZWdlcjtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh2KSB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcodikpIHtcbiAgICByZXR1cm4gZm9ybWF0QXJyYXlWYWx1ZSh2LCBvcHRzKTtcbiAgfVxuXG4gIGlmICghTnVtYmVyLmlzRmluaXRlKHYpKSB7XG4gICAgcmV0dXJuIFN0cmluZyh2KTtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyh2KSA8IEVQU0lMT04pIHtcbiAgICByZXR1cm4gaXNJbnRlZ2VyID8gJzAnIDogJzAuJztcbiAgfVxuXG4gIGlmIChpc0ludGVnZXIpIHtcbiAgICByZXR1cm4gdi50b0ZpeGVkKDApO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKHYpID4gMTAwICYmIE1hdGguYWJzKHYpIDwgMTAwMDApIHtcbiAgICByZXR1cm4gdi50b0ZpeGVkKDApO1xuICB9XG5cbiAgdmFyIHN0cmluZyA9IHYudG9QcmVjaXNpb24oMik7XG4gIHZhciBkZWNpbWFsID0gc3RyaW5nLmluZGV4T2YoJy4wJyk7XG4gIHJldHVybiBkZWNpbWFsID09PSBzdHJpbmcubGVuZ3RoIC0gMiA/IHN0cmluZy5zbGljZSgwLCAtMSkgOiBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5VmFsdWUodiwgb3B0cykge1xuICB2YXIgX29wdHMkbWF4RWx0cyA9IG9wdHMubWF4RWx0cyxcbiAgICAgIG1heEVsdHMgPSBfb3B0cyRtYXhFbHRzID09PSB2b2lkIDAgPyAxNiA6IF9vcHRzJG1heEVsdHMsXG4gICAgICBfb3B0cyRzaXplID0gb3B0cy5zaXplLFxuICAgICAgc2l6ZSA9IF9vcHRzJHNpemUgPT09IHZvaWQgMCA/IDEgOiBfb3B0cyRzaXplO1xuICB2YXIgc3RyaW5nID0gJ1snO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGggJiYgaSA8IG1heEVsdHM7ICsraSkge1xuICAgIGlmIChpID4gMCkge1xuICAgICAgc3RyaW5nICs9IFwiLFwiLmNvbmNhdChpICUgc2l6ZSA9PT0gMCA/ICcgJyA6ICcnKTtcbiAgICB9XG5cbiAgICBzdHJpbmcgKz0gZm9ybWF0VmFsdWUodltpXSwgb3B0cyk7XG4gIH1cblxuICB2YXIgdGVybWluYXRvciA9IHYubGVuZ3RoID4gbWF4RWx0cyA/ICcuLi4nIDogJ10nO1xuICByZXR1cm4gXCJcIi5jb25jYXQoc3RyaW5nKS5jb25jYXQodGVybWluYXRvcik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEltYWdlKGltYWdlLCBtZXNzYWdlLCBzY2FsZSkge1xuICB2YXIgbWF4V2lkdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDYwMDtcbiAgdmFyIGltYWdlVXJsID0gaW1hZ2Uuc3JjLnJlcGxhY2UoL1xcKC9nLCAnJTI4JykucmVwbGFjZSgvXFwpL2csICclMjknKTtcblxuICBpZiAoaW1hZ2Uud2lkdGggPiBtYXhXaWR0aCkge1xuICAgIHNjYWxlID0gTWF0aC5taW4oc2NhbGUsIG1heFdpZHRoIC8gaW1hZ2Uud2lkdGgpO1xuICB9XG5cbiAgdmFyIHdpZHRoID0gaW1hZ2Uud2lkdGggKiBzY2FsZTtcbiAgdmFyIGhlaWdodCA9IGltYWdlLmhlaWdodCAqIHNjYWxlO1xuICB2YXIgc3R5bGUgPSBbJ2ZvbnQtc2l6ZToxcHg7JywgXCJwYWRkaW5nOlwiLmNvbmNhdChNYXRoLmZsb29yKGhlaWdodCAvIDIpLCBcInB4IFwiKS5jb25jYXQoTWF0aC5mbG9vcih3aWR0aCAvIDIpLCBcInB4O1wiKSwgXCJsaW5lLWhlaWdodDpcIi5jb25jYXQoaGVpZ2h0LCBcInB4O1wiKSwgXCJiYWNrZ3JvdW5kOnVybChcIi5jb25jYXQoaW1hZ2VVcmwsIFwiKTtcIiksIFwiYmFja2dyb3VuZC1zaXplOlwiLmNvbmNhdCh3aWR0aCwgXCJweCBcIikuY29uY2F0KGhlaWdodCwgXCJweDtcIiksICdjb2xvcjp0cmFuc3BhcmVudDsnXS5qb2luKCcnKTtcbiAgcmV0dXJuIFtcIlwiLmNvbmNhdChtZXNzYWdlLCBcIiAlYytcIiksIHN0eWxlXTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdHRlcnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2VsZlwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2xvYmFscy5zZWxmO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIndpbmRvd1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2xvYmFscy53aW5kb3c7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2xvYmFsXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxzLmdsb2JhbDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkb2N1bWVudFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2xvYmFscy5kb2N1bWVudDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwcm9jZXNzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxzLnByb2Nlc3M7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29uc29sZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2xvYmFscy5jb25zb2xlO1xuICB9XG59KTtcbmV4cG9ydHMuaXNCcm93c2VyID0gZXhwb3J0cy5WRVJTSU9OID0gdm9pZCAwO1xuXG52YXIgX2lzQnJvd3NlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2Vudi9pcy1icm93c2VyXCIpKTtcblxudmFyIF9nbG9iYWxzID0gcmVxdWlyZShcIi4uL2Vudi9nbG9iYWxzXCIpO1xuXG52YXIgVkVSU0lPTiA9IHR5cGVvZiBfX1ZFUlNJT05fXyAhPT0gJ3VuZGVmaW5lZCcgPyBfX1ZFUlNJT05fXyA6ICd1bnRyYW5zcGlsZWQgc291cmNlJztcbmV4cG9ydHMuVkVSU0lPTiA9IFZFUlNJT047XG52YXIgaXNCcm93c2VyID0gKDAsIF9pc0Jyb3dzZXIuZGVmYXVsdCkoKTtcbmV4cG9ydHMuaXNCcm93c2VyID0gaXNCcm93c2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2xvYmFscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGdldEhpUmVzVGltZXN0YW1wO1xuXG52YXIgX2dsb2JhbHMgPSByZXF1aXJlKFwiLi9nbG9iYWxzXCIpO1xuXG5mdW5jdGlvbiBnZXRIaVJlc1RpbWVzdGFtcCgpIHtcbiAgdmFyIHRpbWVzdGFtcDtcblxuICBpZiAoX2dsb2JhbHMuaXNCcm93c2VyICYmIF9nbG9iYWxzLndpbmRvdy5wZXJmb3JtYW5jZSkge1xuICAgIHRpbWVzdGFtcCA9IF9nbG9iYWxzLndpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgfSBlbHNlIGlmIChfZ2xvYmFscy5wcm9jZXNzLmhydGltZSkge1xuICAgIHZhciB0aW1lUGFydHMgPSBfZ2xvYmFscy5wcm9jZXNzLmhydGltZSgpO1xuXG4gICAgdGltZXN0YW1wID0gdGltZVBhcnRzWzBdICogMTAwMCArIHRpbWVQYXJ0c1sxXSAvIDFlNjtcbiAgfSBlbHNlIHtcbiAgICB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICB9XG5cbiAgcmV0dXJuIHRpbWVzdGFtcDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhpLXJlcy10aW1lc3RhbXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG5mdW5jdGlvbiBnZXRTdG9yYWdlKHR5cGUpIHtcbiAgdHJ5IHtcbiAgICB2YXIgc3RvcmFnZSA9IHdpbmRvd1t0eXBlXTtcbiAgICB2YXIgeCA9ICdfX3N0b3JhZ2VfdGVzdF9fJztcbiAgICBzdG9yYWdlLnNldEl0ZW0oeCwgeCk7XG4gICAgc3RvcmFnZS5yZW1vdmVJdGVtKHgpO1xuICAgIHJldHVybiBzdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxudmFyIExvY2FsU3RvcmFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTG9jYWxTdG9yYWdlKGlkLCBkZWZhdWx0U2V0dGluZ3MpIHtcbiAgICB2YXIgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ3Nlc3Npb25TdG9yYWdlJztcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBMb2NhbFN0b3JhZ2UpO1xuICAgIHRoaXMuc3RvcmFnZSA9IGdldFN0b3JhZ2UodHlwZSk7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuY29uZmlnID0ge307XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLmNvbmZpZywgZGVmYXVsdFNldHRpbmdzKTtcblxuICAgIHRoaXMuX2xvYWRDb25maWd1cmF0aW9uKCk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShMb2NhbFN0b3JhZ2UsIFt7XG4gICAga2V5OiBcImdldENvbmZpZ3VyYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29uZmlndXJhdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q29uZmlndXJhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgIHRoaXMuY29uZmlnID0ge307XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGVDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVDb25maWd1cmF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUNvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbikge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmNvbmZpZywgY29uZmlndXJhdGlvbik7XG5cbiAgICAgIGlmICh0aGlzLnN0b3JhZ2UpIHtcbiAgICAgICAgdmFyIHNlcmlhbGl6ZWQgPSBKU09OLnN0cmluZ2lmeSh0aGlzLmNvbmZpZyk7XG4gICAgICAgIHRoaXMuc3RvcmFnZS5zZXRJdGVtKHRoaXMuaWQsIHNlcmlhbGl6ZWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2xvYWRDb25maWd1cmF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9sb2FkQ29uZmlndXJhdGlvbigpIHtcbiAgICAgIHZhciBjb25maWd1cmF0aW9uID0ge307XG5cbiAgICAgIGlmICh0aGlzLnN0b3JhZ2UpIHtcbiAgICAgICAgdmFyIHNlcmlhbGl6ZWRDb25maWd1cmF0aW9uID0gdGhpcy5zdG9yYWdlLmdldEl0ZW0odGhpcy5pZCk7XG4gICAgICAgIGNvbmZpZ3VyYXRpb24gPSBzZXJpYWxpemVkQ29uZmlndXJhdGlvbiA/IEpTT04ucGFyc2Uoc2VyaWFsaXplZENvbmZpZ3VyYXRpb24pIDoge307XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5jb25maWcsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBMb2NhbFN0b3JhZ2U7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IExvY2FsU3RvcmFnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2FsLXN0b3JhZ2UuanMubWFwIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBJRSA4IGhhcyBhIGJyb2tlbiBPYmplY3QuZGVmaW5lUHJvcGVydHkgdGhhdCBvbmx5IHdvcmtzIG9uIERPTSBvYmplY3RzLlxuICAgIGRlZmluZSh7fSwgXCJcIik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRlZmluZSA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG9ialtrZXldID0gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIGRlZmluZShJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgZGVmaW5lKEdwLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoXG4gICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXG4gICAgdG9TdHJpbmdUYWdTeW1ib2wsXG4gICAgXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICk7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkgUHJvbWlzZUltcGwgPSBQcm9taXNlO1xuXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLFxuICAgICAgUHJvbWlzZUltcGxcbiAgICApO1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgZGVmaW5lKEdwLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIGRlZmluZShHcCwgXCJ0b1N0cmluZ1wiLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgaW4gbW9kZXJuIGVuZ2luZXNcbiAgLy8gd2UgY2FuIGV4cGxpY2l0bHkgYWNjZXNzIGdsb2JhbFRoaXMuIEluIG9sZGVyIGVuZ2luZXMgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiKSB7XG4gICAgZ2xvYmFsVGhpcy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xuICB9IGVsc2Uge1xuICAgIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG4gIH1cbn1cbiJdfQ==

(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

var _core = require("@loaders.gl/core");

var _csv = require("@loaders.gl/csv");

var _nanohtml = _interopRequireDefault(require("nanohtml"));

var _templateObject, _templateObject2, _templateObject3;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

/*
* To do:
* - how to update tooltip when date is updated? 
* - definition file for datasets
* - make dataset files that only contain values, not geoid
* - implement start date and end date
* - add sample data for timeseries
* - loading spinner while data is loading
* - show selected elements as separate array
* 
* assumptions: geo id in tileset refers to data order (?)
* are there datasets that only exist at certain geolevels?
* https://deck.gl/docs/api-reference/geo-layers/mvt-layer
*/
var _deck = deck,
    DeckGL = _deck.DeckGL,
    MVTLayer = _deck.MVTLayer; //import { csv } from 'd3'

var viz;
var geoRegion;
var dataset = 'mobility';
var baseURL = window.location.href.replace('/example-data-loading/', '');
var datasetPath = "/sample-data/datasets/";
var tilesetPath = "/sample-data/tilesets/"; // sets of vector tilesets representing different geo-regions

var tilesets = [{
  label: 'gemeinden',
  // 
  id: 'gemeinden',
  // 
  url: 'gemeinden',
  numEntries: 11431
}, {
  label: 'kreise',
  id: 'kreise',
  url: 'kreise',
  numEntries: 432
}, {
  label: 'laender',
  id: 'laender',
  url: 'laender',
  numEntries: 34
}];
var datasets = [{
  label: 'Mobility by Date',
  id: 'mobility',
  url: '',
  startDate: '2021-05-23',
  endDate: '2021-08-30',
  tilesets: ['laendergeo', 'kreisegeo', 'gemeindengeo']
}];
tilesets.forEach(function (tileset, i) {
  var URL = "".concat(baseURL).concat(tilesetPath).concat(tileset.url, "/{z}/{x}/{y}.pbf");
  tileset.tiles = [URL];
  tileset.visibile = false;
  tileset.mobility = new Array(tileset.numEntries).fill(0).map(function (_, i) {
    return Math.random();
  });
});
var numDates = 100;
var currentDateIndex = 0;
selectGeoLevel('gemeinden'); //geoRegion = tilesets[0]

console.log('base url', tilesets, geoRegion);
var footer = (0, _nanohtml["default"])(_templateObject || (_templateObject = _taggedTemplateLiteral(["<div style=\"position:absolute;bottom:0px;right:0px;width:100%\"></div>"])));

var generateDate = function generateDate() {
  var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'hi';
  return "<div style=\"font-size:4rem;color:white;background:rgba(0, 0, 0, 0.4)\">".concat(date, "</div>");
};

var dateEl = document.createElement('div');
var geoSelect = (0, _nanohtml["default"])(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["<label for=\"geolevel\">Select map geo level</label>\n<select label=\"geolevel\" onchange=", " id=\"geolevel\">\n ", "\n</select>"])), function (e) {
  selectGeoLevel(e.target.value);
}, tilesets.map(function (tileset) {
  return (0, _nanohtml["default"])(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["<option value=\"", "\" ", ">", "</option>"])), tileset.id, tileset.id === geoRegion.id ? 'selected' : '', tileset.label);
}));
footer.appendChild(geoSelect);
footer.appendChild(dateEl); // optimizations for this: load directly as an array and do not parse into objects
// store already loaded data in some way and only load new data as necessary
// read more about deckgl / webgl performance
// show loading animation while loading

function getData() {
  return _getData.apply(this, arguments);
}

function _getData() {
  _getData = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
    var d, dateStr, newData;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            currentDateIndex++;
            if (currentDateIndex > numDates) currentDateIndex = 0;
            d = new Date();
            d.setDate(-numDates + currentDateIndex);
            dateStr = d.toLocaleDateString('en-CA'); //date.format(d, 'YYYY-MM-DD')

            dateEl.innerHTML = generateDate(dateStr);
            _context.next = 8;
            return (0, _core.load)("".concat(baseURL).concat(datasetPath).concat(dataset, "/").concat(geoRegion.id, "/values-by-date/").concat(dateStr, ".csv"), _csv.CSVLoader);

          case 8:
            newData = _context.sent;
            // console.log('loaded', newData, geoRegion)
            geoRegion.mobility = geoRegion.mobility.map(function (_, i) {
              return newData[i].mobility;
            }); //gemeinden: new Array(11431).fill(0).map((_, i) => Math.random()),
            //kreise: new Array(432).fill(0).map((_, i) => Math.random())

            render();

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _getData.apply(this, arguments);
}

getData();

function selectGeoLevel(id) {
  tilesets.forEach(function (tileset) {
    if (tileset.id === id) {
      tileset.visible = true;
      geoRegion = tileset;
    } else {
      tileset.visible = false;
    }
  });
}

function render() {
  // console.log(tilesets, 'tilesets')
  var layers = tilesets.map(function (tileset) {
    return new MVTLayer({
      // id: tileset.id,
      id: tileset.id,
      data: tileset.tiles,
      pickable: tileset.visible,
      getFillColor: function getFillColor(obj) {
        //console.log('getting mobility at', obj.id, tileset.mobility)
        var j = tileset.mobility[obj.id];
        return [j * 255, j * 255, j * 255]; //return [Math.random() * 255, Math.random() * 255, Math.random() * 255]
      },
      getLineWidth: 4,
      transitions: {
        getFillColor: 100
      },
      updateTriggers: {
        // if currentDateIndex changes, recompute getFillColor for each point
        getFillColor: [currentDateIndex]
      },
      visible: tileset.visible,
      lineWidthMinPixels: 0,
      maxZoom: 13,
      minZoom: 0
    });
  });
  viz.setProps({
    layers: layers
  });
}

viz = new DeckGL({
  initialViewState: {
    // longitude: -122.4,
    latitude: 51.66403781658121,
    longitude: 10.6460952758789,
    // latitude: 37.74,
    // longitude: 13.765869,
    //13.765869,54.117382
    zoom: 6,
    maxZoom: 20,
    pitch: 30,
    bearing: 0
  },
  controller: true,
  getTooltip: function getTooltip(_ref) {
    var object = _ref.object;

    if (object) {
      console.log(object);
      return "".concat(object.properties.GEN, " mobility ").concat(geoRegion.mobility[object.id]);
    }

    return null;
  } //layers: [layer]

});
setInterval(function () {
  //  console.log(shouldUpdate)
  // fakeData.laender = fakeData.laender.map((_, i) => Math.random())
  // fakeData.kreise = fakeData.kreise.map((_, i) => Math.random())
  //fakeData[geoRegion] = fakeData[geoRegion].map((_, i) => Math.random())
  //gemeinden: new Array(11431).fill(0).map((_, i) => Math.random()),
  //kreise: new Array(432).fill(0).map((_, i) => Math.random())
  //render()
  getData(); // shouldUpdate ++
}, 2000);
document.body.appendChild(footer); //   const tileURL = `${window.location.origin}/gemeinden-z7-uncompressed/{z}/{x}/{y}.pbf`
// const DATA = [
//     tileURL
//     //'https://tiles-a.basemaps.cartocdn.com/vectortiles/carto.streets/v1/{z}/{x}/{y}.mvt'
//   ]
// function render () {
// const gemeinden = new MVTLayer({
//   id: 'gemeindengeo',
//   data: DATA,
//   pickable: true,
//   getFillColor: () => {
//    // console.log(shouldUpdate)
//    return [Math.random() * 255, Math.random() * 255, Math.random() * 255]
//   },
//   getLineColor: () => [Math.random() * 255, Math.random() * 255, Math.random() * 255],
//   getLineWidth: 4,
//   transitions: {
//     getFillColor: 100,
//   },
//   updateTriggers: {
//     // if showLibraries changes, recompute getFillColor for each point
//     getFillColor: [shouldUpdate]
//   },
//   lineWidthMinPixels: 1,
//   /* props from MVTLayer class */
//   // binary: false,
//   // highlightedFeatureId: null,
//   // loaders: ,
//   // uniqueIdProperty: '',
//   /* props inherited from TileLayer class */
//   // extent: null,
//   // getTileData: null,
//   // maxCacheByteSize: null,
//   // maxCacheSize: null,
//   // maxRequests: 6,
//   maxZoom: 13,
//   minZoom: 7,
//   // onTileError: null,
//   // onTileLoad: null,
//   // onTileUnload: null,
//   // onViewportLoad: null,
//   // refinementStrategy: 'best-available',
//   // renderSubLayers: null,
//   // tileSize: 512,
//   // zRange: null,
//   /* props inherited from Layer class */
//   // autoHighlight: false,
//   // coordinateOrigin: [0, 0, 0],
//   // coordinateSystem: COORDINATE_SYSTEM.LNGLAT,
//   // highlightColor: [0, 0, 128, 128],
//   // modelMatrix: null,
//   // opacity: 1,
//   // pickable: false,
//   // visible: true,
//   // wrapLongitude: false,
// });

},{"@loaders.gl/core":34,"@loaders.gl/csv":70,"nanohtml":135}],2:[function(require,module,exports){
var AwaitValue = require("./AwaitValue.js");

function AsyncGenerator(gen) {
  var front, back;

  function send(key, arg) {
    return new Promise(function (resolve, reject) {
      var request = {
        key: key,
        arg: arg,
        resolve: resolve,
        reject: reject,
        next: null
      };

      if (back) {
        back = back.next = request;
      } else {
        front = back = request;
        resume(key, arg);
      }
    });
  }

  function resume(key, arg) {
    try {
      var result = gen[key](arg);
      var value = result.value;
      var wrappedAwait = value instanceof AwaitValue;
      Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {
        if (wrappedAwait) {
          resume(key === "return" ? "return" : "next", arg);
          return;
        }

        settle(result.done ? "return" : "normal", arg);
      }, function (err) {
        resume("throw", err);
      });
    } catch (err) {
      settle("throw", err);
    }
  }

  function settle(type, value) {
    switch (type) {
      case "return":
        front.resolve({
          value: value,
          done: true
        });
        break;

      case "throw":
        front.reject(value);
        break;

      default:
        front.resolve({
          value: value,
          done: false
        });
        break;
    }

    front = front.next;

    if (front) {
      resume(front.key, front.arg);
    } else {
      back = null;
    }
  }

  this._invoke = send;

  if (typeof gen["return"] !== "function") {
    this["return"] = undefined;
  }
}

AsyncGenerator.prototype[typeof Symbol === "function" && Symbol.asyncIterator || "@@asyncIterator"] = function () {
  return this;
};

AsyncGenerator.prototype.next = function (arg) {
  return this._invoke("next", arg);
};

AsyncGenerator.prototype["throw"] = function (arg) {
  return this._invoke("throw", arg);
};

AsyncGenerator.prototype["return"] = function (arg) {
  return this._invoke("return", arg);
};

module.exports = AsyncGenerator;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./AwaitValue.js":3}],3:[function(require,module,exports){
function _AwaitValue(value) {
  this.wrapped = value;
}

module.exports = _AwaitValue;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],4:[function(require,module,exports){
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],5:[function(require,module,exports){
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],6:[function(require,module,exports){
var arrayLikeToArray = require("./arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./arrayLikeToArray.js":4}],7:[function(require,module,exports){
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],8:[function(require,module,exports){
function _asyncGeneratorDelegate(inner, awaitWrap) {
  var iter = {},
      waiting = false;

  function pump(key, value) {
    waiting = true;
    value = new Promise(function (resolve) {
      resolve(inner[key](value));
    });
    return {
      done: false,
      value: awaitWrap(value)
    };
  }

  ;

  iter[typeof Symbol !== "undefined" && Symbol.iterator || "@@iterator"] = function () {
    return this;
  };

  iter.next = function (value) {
    if (waiting) {
      waiting = false;
      return value;
    }

    return pump("next", value);
  };

  if (typeof inner["throw"] === "function") {
    iter["throw"] = function (value) {
      if (waiting) {
        waiting = false;
        throw value;
      }

      return pump("throw", value);
    };
  }

  if (typeof inner["return"] === "function") {
    iter["return"] = function (value) {
      if (waiting) {
        waiting = false;
        return value;
      }

      return pump("return", value);
    };
  }

  return iter;
}

module.exports = _asyncGeneratorDelegate;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],9:[function(require,module,exports){
function _asyncIterator(iterable) {
  var method;

  if (typeof Symbol !== "undefined") {
    if (Symbol.asyncIterator) method = iterable[Symbol.asyncIterator];
    if (method == null && Symbol.iterator) method = iterable[Symbol.iterator];
  }

  if (method == null) method = iterable["@@asyncIterator"];
  if (method == null) method = iterable["@@iterator"];
  if (method == null) throw new TypeError("Object is not async iterable");
  return method.call(iterable);
}

module.exports = _asyncIterator;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],10:[function(require,module,exports){
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],11:[function(require,module,exports){
var AwaitValue = require("./AwaitValue.js");

function _awaitAsyncGenerator(value) {
  return new AwaitValue(value);
}

module.exports = _awaitAsyncGenerator;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./AwaitValue.js":3}],12:[function(require,module,exports){
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],13:[function(require,module,exports){
var setPrototypeOf = require("./setPrototypeOf.js");

var isNativeReflectConstruct = require("./isNativeReflectConstruct.js");

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./isNativeReflectConstruct.js":20,"./setPrototypeOf.js":26}],14:[function(require,module,exports){
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],15:[function(require,module,exports){
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],16:[function(require,module,exports){
function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],17:[function(require,module,exports){
var setPrototypeOf = require("./setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./setPrototypeOf.js":26}],18:[function(require,module,exports){
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],19:[function(require,module,exports){
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

module.exports = _isNativeFunction;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],20:[function(require,module,exports){
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = _isNativeReflectConstruct;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],21:[function(require,module,exports){
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

module.exports = _iterableToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],22:[function(require,module,exports){
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],23:[function(require,module,exports){
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],24:[function(require,module,exports){
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],25:[function(require,module,exports){
var _typeof = require("@babel/runtime/helpers/typeof")["default"];

var assertThisInitialized = require("./assertThisInitialized.js");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./assertThisInitialized.js":7,"@babel/runtime/helpers/typeof":29}],26:[function(require,module,exports){
function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],27:[function(require,module,exports){
var arrayWithHoles = require("./arrayWithHoles.js");

var iterableToArrayLimit = require("./iterableToArrayLimit.js");

var unsupportedIterableToArray = require("./unsupportedIterableToArray.js");

var nonIterableRest = require("./nonIterableRest.js");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./arrayWithHoles.js":5,"./iterableToArrayLimit.js":22,"./nonIterableRest.js":23,"./unsupportedIterableToArray.js":30}],28:[function(require,module,exports){
var arrayWithoutHoles = require("./arrayWithoutHoles.js");

var iterableToArray = require("./iterableToArray.js");

var unsupportedIterableToArray = require("./unsupportedIterableToArray.js");

var nonIterableSpread = require("./nonIterableSpread.js");

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./arrayWithoutHoles.js":6,"./iterableToArray.js":21,"./nonIterableSpread.js":24,"./unsupportedIterableToArray.js":30}],29:[function(require,module,exports){
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }

  return _typeof(obj);
}

module.exports = _typeof;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{}],30:[function(require,module,exports){
var arrayLikeToArray = require("./arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./arrayLikeToArray.js":4}],31:[function(require,module,exports){
var AsyncGenerator = require("./AsyncGenerator.js");

function _wrapAsyncGenerator(fn) {
  return function () {
    return new AsyncGenerator(fn.apply(this, arguments));
  };
}

module.exports = _wrapAsyncGenerator;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./AsyncGenerator.js":2}],32:[function(require,module,exports){
var getPrototypeOf = require("./getPrototypeOf.js");

var setPrototypeOf = require("./setPrototypeOf.js");

var isNativeFunction = require("./isNativeFunction.js");

var construct = require("./construct.js");

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return construct(Class, arguments, getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return setPrototypeOf(Wrapper, Class);
  };

  module.exports["default"] = module.exports, module.exports.__esModule = true;
  return _wrapNativeSuper(Class);
}

module.exports = _wrapNativeSuper;
module.exports["default"] = module.exports, module.exports.__esModule = true;
},{"./construct.js":13,"./getPrototypeOf.js":16,"./isNativeFunction.js":19,"./setPrototypeOf.js":26}],33:[function(require,module,exports){
module.exports = require("regenerator-runtime");

},{"regenerator-runtime":154}],34:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "fetchFile", {
  enumerable: true,
  get: function get() {
    return _fetchFile.fetchFile;
  }
});
Object.defineProperty(exports, "readArrayBuffer", {
  enumerable: true,
  get: function get() {
    return _readArrayBuffer.readArrayBuffer;
  }
});
Object.defineProperty(exports, "readFileSync", {
  enumerable: true,
  get: function get() {
    return _readFile.readFileSync;
  }
});
Object.defineProperty(exports, "writeFile", {
  enumerable: true,
  get: function get() {
    return _writeFile.writeFile;
  }
});
Object.defineProperty(exports, "writeFileSync", {
  enumerable: true,
  get: function get() {
    return _writeFile.writeFileSync;
  }
});
Object.defineProperty(exports, "setLoaderOptions", {
  enumerable: true,
  get: function get() {
    return _setLoaderOptions.setLoaderOptions;
  }
});
Object.defineProperty(exports, "registerLoaders", {
  enumerable: true,
  get: function get() {
    return _registerLoaders.registerLoaders;
  }
});
Object.defineProperty(exports, "_unregisterLoaders", {
  enumerable: true,
  get: function get() {
    return _registerLoaders._unregisterLoaders;
  }
});
Object.defineProperty(exports, "selectLoader", {
  enumerable: true,
  get: function get() {
    return _selectLoader.selectLoader;
  }
});
Object.defineProperty(exports, "selectLoaderSync", {
  enumerable: true,
  get: function get() {
    return _selectLoader.selectLoaderSync;
  }
});
Object.defineProperty(exports, "parse", {
  enumerable: true,
  get: function get() {
    return _parse.parse;
  }
});
Object.defineProperty(exports, "parseSync", {
  enumerable: true,
  get: function get() {
    return _parseSync.parseSync;
  }
});
Object.defineProperty(exports, "parseInBatches", {
  enumerable: true,
  get: function get() {
    return _parseInBatches.parseInBatches;
  }
});
Object.defineProperty(exports, "load", {
  enumerable: true,
  get: function get() {
    return _load.load;
  }
});
Object.defineProperty(exports, "loadInBatches", {
  enumerable: true,
  get: function get() {
    return _loadInBatches.loadInBatches;
  }
});
Object.defineProperty(exports, "encode", {
  enumerable: true,
  get: function get() {
    return _encode.encode;
  }
});
Object.defineProperty(exports, "encodeSync", {
  enumerable: true,
  get: function get() {
    return _encode.encodeSync;
  }
});
Object.defineProperty(exports, "encodeInBatches", {
  enumerable: true,
  get: function get() {
    return _encode.encodeInBatches;
  }
});
Object.defineProperty(exports, "encodeText", {
  enumerable: true,
  get: function get() {
    return _encode.encodeText;
  }
});
Object.defineProperty(exports, "encodeURLtoURL", {
  enumerable: true,
  get: function get() {
    return _encode.encodeURLtoURL;
  }
});
Object.defineProperty(exports, "save", {
  enumerable: true,
  get: function get() {
    return _save.save;
  }
});
Object.defineProperty(exports, "saveSync", {
  enumerable: true,
  get: function get() {
    return _save.saveSync;
  }
});
Object.defineProperty(exports, "setPathPrefix", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.setPathPrefix;
  }
});
Object.defineProperty(exports, "getPathPrefix", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.getPathPrefix;
  }
});
Object.defineProperty(exports, "resolvePath", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.resolvePath;
  }
});
Object.defineProperty(exports, "RequestScheduler", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.RequestScheduler;
  }
});
Object.defineProperty(exports, "JSONLoader", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.JSONLoader;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.isBrowser;
  }
});
Object.defineProperty(exports, "isWorker", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.isWorker;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.window;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.global;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.document;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.assert;
  }
});
Object.defineProperty(exports, "forEach", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.forEach;
  }
});
Object.defineProperty(exports, "concatenateArrayBuffersAsync", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.concatenateArrayBuffersAsync;
  }
});
Object.defineProperty(exports, "makeTextDecoderIterator", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.makeTextDecoderIterator;
  }
});
Object.defineProperty(exports, "makeTextEncoderIterator", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.makeTextEncoderIterator;
  }
});
Object.defineProperty(exports, "makeLineIterator", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.makeLineIterator;
  }
});
Object.defineProperty(exports, "makeNumberedLineIterator", {
  enumerable: true,
  get: function get() {
    return _loaderUtils.makeNumberedLineIterator;
  }
});
Object.defineProperty(exports, "makeIterator", {
  enumerable: true,
  get: function get() {
    return _makeIterator.makeIterator;
  }
});
Object.defineProperty(exports, "makeStream", {
  enumerable: true,
  get: function get() {
    return _makeStream.makeStream;
  }
});
Object.defineProperty(exports, "makeDOMStream", {
  enumerable: true,
  get: function get() {
    return _makeDomStream.makeDOMStream;
  }
});
Object.defineProperty(exports, "makeNodeStream", {
  enumerable: true,
  get: function get() {
    return _makeNodeStream.default;
  }
});
Object.defineProperty(exports, "NullWorkerLoader", {
  enumerable: true,
  get: function get() {
    return _nullLoader.NullWorkerLoader;
  }
});
Object.defineProperty(exports, "NullLoader", {
  enumerable: true,
  get: function get() {
    return _nullLoader.NullLoader;
  }
});
Object.defineProperty(exports, "_fetchProgress", {
  enumerable: true,
  get: function get() {
    return _fetchProgress.default;
  }
});
Object.defineProperty(exports, "_BrowserFileSystem", {
  enumerable: true,
  get: function get() {
    return _browserFilesystem.default;
  }
});
Object.defineProperty(exports, "isPureObject", {
  enumerable: true,
  get: function get() {
    return _isType.isPureObject;
  }
});
Object.defineProperty(exports, "isPromise", {
  enumerable: true,
  get: function get() {
    return _isType.isPromise;
  }
});
Object.defineProperty(exports, "isIterable", {
  enumerable: true,
  get: function get() {
    return _isType.isIterable;
  }
});
Object.defineProperty(exports, "isAsyncIterable", {
  enumerable: true,
  get: function get() {
    return _isType.isAsyncIterable;
  }
});
Object.defineProperty(exports, "isIterator", {
  enumerable: true,
  get: function get() {
    return _isType.isIterator;
  }
});
Object.defineProperty(exports, "isResponse", {
  enumerable: true,
  get: function get() {
    return _isType.isResponse;
  }
});
Object.defineProperty(exports, "isReadableStream", {
  enumerable: true,
  get: function get() {
    return _isType.isReadableStream;
  }
});
Object.defineProperty(exports, "isWritableStream", {
  enumerable: true,
  get: function get() {
    return _isType.isWritableStream;
  }
});

var _fetchFile = require("./lib/fetch/fetch-file");

var _readArrayBuffer = require("./lib/fetch/read-array-buffer");

var _readFile = require("./lib/fetch/read-file");

var _writeFile = require("./lib/fetch/write-file");

var _setLoaderOptions = require("./lib/api/set-loader-options");

var _registerLoaders = require("./lib/api/register-loaders");

var _selectLoader = require("./lib/api/select-loader");

var _parse = require("./lib/api/parse");

var _parseSync = require("./lib/api/parse-sync");

var _parseInBatches = require("./lib/api/parse-in-batches");

var _load = require("./lib/api/load");

var _loadInBatches = require("./lib/api/load-in-batches");

var _encode = require("./lib/api/encode");

var _save = require("./lib/api/save");

var _loaderUtils = require("@loaders.gl/loader-utils");

var _makeIterator = require("./iterators/make-iterator/make-iterator");

var _makeStream = require("./iterators/make-stream/make-stream");

var _makeDomStream = require("./iterators/make-stream/make-dom-stream");

var _makeNodeStream = _interopRequireDefault(require("./iterators/make-stream/make-node-stream"));

var _nullLoader = require("./null-loader");

var _fetchProgress = _interopRequireDefault(require("./lib/progress/fetch-progress"));

var _browserFilesystem = _interopRequireDefault(require("./lib/filesystems/browser-filesystem"));

var _isType = require("./javascript-utils/is-type");

},{"./iterators/make-iterator/make-iterator":37,"./iterators/make-stream/make-dom-stream":40,"./iterators/make-stream/make-node-stream":130,"./iterators/make-stream/make-stream":41,"./javascript-utils/is-type":42,"./lib/api/encode":43,"./lib/api/load":45,"./lib/api/load-in-batches":44,"./lib/api/parse":48,"./lib/api/parse-in-batches":46,"./lib/api/parse-sync":47,"./lib/api/register-loaders":49,"./lib/api/save":50,"./lib/api/select-loader":51,"./lib/api/set-loader-options":52,"./lib/fetch/fetch-file":53,"./lib/fetch/read-array-buffer":54,"./lib/fetch/read-file":55,"./lib/fetch/write-file":56,"./lib/filesystems/browser-filesystem":57,"./lib/progress/fetch-progress":64,"./null-loader":68,"@babel/runtime/helpers/interopRequireDefault":18,"@loaders.gl/loader-utils":73}],35:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeArrayBufferIterator = makeArrayBufferIterator;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _marked = _regenerator.default.mark(makeArrayBufferIterator);

var DEFAULT_CHUNK_SIZE = 256 * 1024;

function makeArrayBufferIterator(arrayBuffer) {
  var options,
      _options$chunkSize,
      chunkSize,
      byteOffset,
      chunkByteLength,
      chunk,
      sourceArray,
      chunkArray,
      _args = arguments;

  return _regenerator.default.wrap(function makeArrayBufferIterator$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
          _options$chunkSize = options.chunkSize, chunkSize = _options$chunkSize === void 0 ? DEFAULT_CHUNK_SIZE : _options$chunkSize;
          byteOffset = 0;

        case 3:
          if (!(byteOffset < arrayBuffer.byteLength)) {
            _context.next = 14;
            break;
          }

          chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);
          chunk = new ArrayBuffer(chunkByteLength);
          sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);
          chunkArray = new Uint8Array(chunk);
          chunkArray.set(sourceArray);
          byteOffset += chunkByteLength;
          _context.next = 12;
          return chunk;

        case 12:
          _context.next = 3;
          break;

        case 14:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}

},{"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],36:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeBlobIterator = makeBlobIterator;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _awaitAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/awaitAsyncGenerator"));

var _wrapAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapAsyncGenerator"));

var DEFAULT_CHUNK_SIZE = 1024 * 1024;

function makeBlobIterator(_x, _x2) {
  return _makeBlobIterator.apply(this, arguments);
}

function _makeBlobIterator() {
  _makeBlobIterator = (0, _wrapAsyncGenerator2.default)(_regenerator.default.mark(function _callee(blob, options) {
    var chunkSize, offset, end, chunk;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE;
            offset = 0;

          case 2:
            if (!(offset < blob.size)) {
              _context.next = 12;
              break;
            }

            end = offset + chunkSize;
            _context.next = 6;
            return (0, _awaitAsyncGenerator2.default)(blob.slice(offset, end).arrayBuffer());

          case 6:
            chunk = _context.sent;
            offset = end;
            _context.next = 10;
            return chunk;

          case 10:
            _context.next = 2;
            break;

          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _makeBlobIterator.apply(this, arguments);
}

},{"@babel/runtime/helpers/awaitAsyncGenerator":11,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/wrapAsyncGenerator":31,"@babel/runtime/regenerator":33}],37:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeIterator = makeIterator;

var _makeStringIterator = require("./make-string-iterator");

var _makeArrayBufferIterator = require("./make-array-buffer-iterator");

var _makeBlobIterator = require("./make-blob-iterator");

var _makeStreamIterator = require("./make-stream-iterator");

var _isType = require("../../javascript-utils/is-type");

function makeIterator(data, options) {
  if (typeof data === 'string') {
    return (0, _makeStringIterator.makeStringIterator)(data, options);
  }

  if (data instanceof ArrayBuffer) {
    return (0, _makeArrayBufferIterator.makeArrayBufferIterator)(data, options);
  }

  if ((0, _isType.isBlob)(data)) {
    return (0, _makeBlobIterator.makeBlobIterator)(data, options);
  }

  if ((0, _isType.isReadableStream)(data)) {
    return (0, _makeStreamIterator.makeStreamIterator)(data, options);
  }

  if ((0, _isType.isResponse)(data)) {
    var response = data;
    return (0, _makeStreamIterator.makeStreamIterator)(response.body, options);
  }

  throw new Error('makeIterator');
}

},{"../../javascript-utils/is-type":42,"./make-array-buffer-iterator":35,"./make-blob-iterator":36,"./make-stream-iterator":38,"./make-string-iterator":39}],38:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeStreamIterator = makeStreamIterator;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

var _awaitAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/awaitAsyncGenerator"));

var _wrapAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapAsyncGenerator"));

var _loaderUtils = require("@loaders.gl/loader-utils");

function makeStreamIterator(stream, options) {
  return _loaderUtils.isBrowser ? makeBrowserStreamIterator(stream, options) : makeNodeStreamIterator(stream, options);
}

function makeBrowserStreamIterator(_x, _x2) {
  return _makeBrowserStreamIterator.apply(this, arguments);
}

function _makeBrowserStreamIterator() {
  _makeBrowserStreamIterator = (0, _wrapAsyncGenerator2.default)(_regenerator.default.mark(function _callee(stream, options) {
    var reader, nextBatchPromise, currentBatchPromise, _yield$_awaitAsyncGen, done, value;

    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            reader = stream.getReader();
            _context.prev = 1;

          case 2:
            if (!true) {
              _context.next = 16;
              break;
            }

            currentBatchPromise = nextBatchPromise || reader.read();

            if (options !== null && options !== void 0 && options._streamReadAhead) {
              nextBatchPromise = reader.read();
            }

            _context.next = 7;
            return (0, _awaitAsyncGenerator2.default)(currentBatchPromise);

          case 7:
            _yield$_awaitAsyncGen = _context.sent;
            done = _yield$_awaitAsyncGen.done;
            value = _yield$_awaitAsyncGen.value;

            if (!done) {
              _context.next = 12;
              break;
            }

            return _context.abrupt("return");

          case 12:
            _context.next = 14;
            return (0, _loaderUtils.toArrayBuffer)(value);

          case 14:
            _context.next = 2;
            break;

          case 16:
            _context.next = 21;
            break;

          case 18:
            _context.prev = 18;
            _context.t0 = _context["catch"](1);
            reader.releaseLock();

          case 21:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[1, 18]]);
  }));
  return _makeBrowserStreamIterator.apply(this, arguments);
}

function makeNodeStreamIterator(_x3, _x4) {
  return _makeNodeStreamIterator.apply(this, arguments);
}

function _makeNodeStreamIterator() {
  _makeNodeStreamIterator = (0, _wrapAsyncGenerator2.default)(_regenerator.default.mark(function _callee2(stream, options) {
    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk;

    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _context2.prev = 2;
            _iterator = (0, _asyncIterator2.default)(stream);

          case 4:
            _context2.next = 6;
            return (0, _awaitAsyncGenerator2.default)(_iterator.next());

          case 6:
            _step = _context2.sent;
            _iteratorNormalCompletion = _step.done;
            _context2.next = 10;
            return (0, _awaitAsyncGenerator2.default)(_step.value);

          case 10:
            _value = _context2.sent;

            if (_iteratorNormalCompletion) {
              _context2.next = 18;
              break;
            }

            chunk = _value;
            _context2.next = 15;
            return (0, _loaderUtils.toArrayBuffer)(chunk);

          case 15:
            _iteratorNormalCompletion = true;
            _context2.next = 4;
            break;

          case 18:
            _context2.next = 24;
            break;

          case 20:
            _context2.prev = 20;
            _context2.t0 = _context2["catch"](2);
            _didIteratorError = true;
            _iteratorError = _context2.t0;

          case 24:
            _context2.prev = 24;
            _context2.prev = 25;

            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
              _context2.next = 29;
              break;
            }

            _context2.next = 29;
            return (0, _awaitAsyncGenerator2.default)(_iterator.return());

          case 29:
            _context2.prev = 29;

            if (!_didIteratorError) {
              _context2.next = 32;
              break;
            }

            throw _iteratorError;

          case 32:
            return _context2.finish(29);

          case 33:
            return _context2.finish(24);

          case 34:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[2, 20, 24, 34], [25,, 29, 33]]);
  }));
  return _makeNodeStreamIterator.apply(this, arguments);
}

},{"@babel/runtime/helpers/asyncIterator":9,"@babel/runtime/helpers/awaitAsyncGenerator":11,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/wrapAsyncGenerator":31,"@babel/runtime/regenerator":33,"@loaders.gl/loader-utils":73}],39:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeStringIterator = makeStringIterator;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _marked = _regenerator.default.mark(makeStringIterator);

var DEFAULT_CHUNK_SIZE = 256 * 1024;

function makeStringIterator(string, options) {
  var chunkSize, offset, textEncoder, chunkLength, chunk;
  return _regenerator.default.wrap(function makeStringIterator$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE;
          offset = 0;
          textEncoder = new TextEncoder();

        case 3:
          if (!(offset < string.length)) {
            _context.next = 11;
            break;
          }

          chunkLength = Math.min(string.length - offset, chunkSize);
          chunk = string.slice(offset, offset + chunkLength);
          offset += chunkLength;
          _context.next = 9;
          return textEncoder.encode(chunk);

        case 9:
          _context.next = 3;
          break;

        case 11:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}

},{"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],40:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeDOMStream = makeDOMStream;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function makeDOMStream(source, options) {
  var iterator = source[Symbol.asyncIterator] ? source[Symbol.asyncIterator]() : source[Symbol.iterator]();
  return new ReadableStream({
    type: 'bytes',
    pull: function pull(controller) {
      return (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {
        var _yield$iterator$next, done, value;

        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _context.next = 3;
                return iterator.next();

              case 3:
                _yield$iterator$next = _context.sent;
                done = _yield$iterator$next.done;
                value = _yield$iterator$next.value;

                if (done) {
                  controller.close();
                } else {
                  controller.enqueue(new Uint8Array(value));
                }

                _context.next = 12;
                break;

              case 9:
                _context.prev = 9;
                _context.t0 = _context["catch"](0);
                controller.error(_context.t0);

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[0, 9]]);
      }))();
    },
    cancel: function cancel() {
      return (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2() {
        var _iterator$return;

        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return iterator === null || iterator === void 0 ? void 0 : (_iterator$return = iterator.return) === null || _iterator$return === void 0 ? void 0 : _iterator$return.call(iterator);

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }))();
    }
  }, _objectSpread({
    highWaterMark: Math.pow(2, 24)
  }, options));
}

},{"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],41:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeStream = makeStream;

var _loaderUtils = require("@loaders.gl/loader-utils");

var _makeDomStream = require("./make-dom-stream");

var _makeNodeStream = _interopRequireDefault(require("./make-node-stream"));

function makeStream(data, options) {
  return _loaderUtils.isBrowser ? (0, _makeDomStream.makeDOMStream)(data, options) : (0, _makeNodeStream.default)(data, options);
}

},{"./make-dom-stream":40,"./make-node-stream":130,"@babel/runtime/helpers/interopRequireDefault":18,"@loaders.gl/loader-utils":73}],42:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isWritableStream = exports.isReadableStream = exports.isReadableNodeStream = exports.isWritableNodeStream = exports.isBuffer = exports.isReadableDOMStream = exports.isWritableDOMStream = exports.isBlob = exports.isFile = exports.isResponse = exports.isIterator = exports.isAsyncIterable = exports.isIterable = exports.isPromise = exports.isPureObject = exports.isObject = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var isBoolean = function isBoolean(x) {
  return typeof x === 'boolean';
};

var isFunction = function isFunction(x) {
  return typeof x === 'function';
};

var isObject = function isObject(x) {
  return x !== null && (0, _typeof2.default)(x) === 'object';
};

exports.isObject = isObject;

var isPureObject = function isPureObject(x) {
  return isObject(x) && x.constructor === {}.constructor;
};

exports.isPureObject = isPureObject;

var isPromise = function isPromise(x) {
  return isObject(x) && isFunction(x.then);
};

exports.isPromise = isPromise;

var isIterable = function isIterable(x) {
  return x && typeof x[Symbol.iterator] === 'function';
};

exports.isIterable = isIterable;

var isAsyncIterable = function isAsyncIterable(x) {
  return x && typeof x[Symbol.asyncIterator] === 'function';
};

exports.isAsyncIterable = isAsyncIterable;

var isIterator = function isIterator(x) {
  return x && isFunction(x.next);
};

exports.isIterator = isIterator;

var isResponse = function isResponse(x) {
  return typeof Response !== 'undefined' && x instanceof Response || x && x.arrayBuffer && x.text && x.json;
};

exports.isResponse = isResponse;

var isFile = function isFile(x) {
  return typeof File !== 'undefined' && x instanceof File;
};

exports.isFile = isFile;

var isBlob = function isBlob(x) {
  return typeof Blob !== 'undefined' && x instanceof Blob;
};

exports.isBlob = isBlob;

var isWritableDOMStream = function isWritableDOMStream(x) {
  return isObject(x) && isFunction(x.abort) && isFunction(x.getWriter);
};

exports.isWritableDOMStream = isWritableDOMStream;

var isReadableDOMStream = function isReadableDOMStream(x) {
  return typeof ReadableStream !== 'undefined' && x instanceof ReadableStream || isObject(x) && isFunction(x.tee) && isFunction(x.cancel) && isFunction(x.getReader);
};

exports.isReadableDOMStream = isReadableDOMStream;

var isBuffer = function isBuffer(x) {
  return x && (0, _typeof2.default)(x) === 'object' && x.isBuffer;
};

exports.isBuffer = isBuffer;

var isWritableNodeStream = function isWritableNodeStream(x) {
  return isObject(x) && isFunction(x.end) && isFunction(x.write) && isBoolean(x.writable);
};

exports.isWritableNodeStream = isWritableNodeStream;

var isReadableNodeStream = function isReadableNodeStream(x) {
  return isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);
};

exports.isReadableNodeStream = isReadableNodeStream;

var isReadableStream = function isReadableStream(x) {
  return isReadableDOMStream(x) || isReadableNodeStream(x);
};

exports.isReadableStream = isReadableStream;

var isWritableStream = function isWritableStream(x) {
  return isWritableDOMStream(x) || isWritableNodeStream(x);
};

exports.isWritableStream = isWritableStream;

},{"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29}],43:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encode = encode;
exports.encodeSync = encodeSync;
exports.encodeText = encodeText;
exports.encodeInBatches = encodeInBatches;
exports.encodeURLtoURL = encodeURLtoURL;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

var _loaderUtils = require("@loaders.gl/loader-utils");

var _writeFile = require("../fetch/write-file");

var _fetchFile = require("../fetch/fetch-file");

function encode(_x, _x2, _x3) {
  return _encode.apply(this, arguments);
}

function _encode() {
  _encode = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(data, writer, options) {
    var batches, chunks, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, batch, tmpInputFilename, tmpOutputFilename, outputFilename, response;

    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!writer.encode) {
              _context.next = 4;
              break;
            }

            _context.next = 3;
            return writer.encode(data, options);

          case 3:
            return _context.abrupt("return", _context.sent);

          case 4:
            if (!writer.encodeSync) {
              _context.next = 6;
              break;
            }

            return _context.abrupt("return", writer.encodeSync(data, options));

          case 6:
            if (!writer.encodeText) {
              _context.next = 12;
              break;
            }

            _context.t0 = new TextEncoder();
            _context.next = 10;
            return writer.encodeText(data, options);

          case 10:
            _context.t1 = _context.sent;
            return _context.abrupt("return", _context.t0.encode.call(_context.t0, _context.t1));

          case 12:
            if (!writer.encodeInBatches) {
              _context.next = 49;
              break;
            }

            batches = encodeInBatches(data, writer, options);
            chunks = [];
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _context.prev = 17;
            _iterator = (0, _asyncIterator2.default)(batches);

          case 19:
            _context.next = 21;
            return _iterator.next();

          case 21:
            _step = _context.sent;
            _iteratorNormalCompletion = _step.done;
            _context.next = 25;
            return _step.value;

          case 25:
            _value = _context.sent;

            if (_iteratorNormalCompletion) {
              _context.next = 32;
              break;
            }

            batch = _value;
            chunks.push(batch);

          case 29:
            _iteratorNormalCompletion = true;
            _context.next = 19;
            break;

          case 32:
            _context.next = 38;
            break;

          case 34:
            _context.prev = 34;
            _context.t2 = _context["catch"](17);
            _didIteratorError = true;
            _iteratorError = _context.t2;

          case 38:
            _context.prev = 38;
            _context.prev = 39;

            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
              _context.next = 43;
              break;
            }

            _context.next = 43;
            return _iterator.return();

          case 43:
            _context.prev = 43;

            if (!_didIteratorError) {
              _context.next = 46;
              break;
            }

            throw _iteratorError;

          case 46:
            return _context.finish(43);

          case 47:
            return _context.finish(38);

          case 48:
            return _context.abrupt("return", _loaderUtils.concatenateArrayBuffers.apply(void 0, chunks));

          case 49:
            if (!(!_loaderUtils.isBrowser && writer.encodeURLtoURL)) {
              _context.next = 61;
              break;
            }

            tmpInputFilename = getTemporaryFilename('input');
            _context.next = 53;
            return (0, _writeFile.writeFile)(tmpInputFilename, data);

          case 53:
            tmpOutputFilename = getTemporaryFilename('output');
            _context.next = 56;
            return encodeURLtoURL(tmpInputFilename, tmpOutputFilename, writer, options);

          case 56:
            outputFilename = _context.sent;
            _context.next = 59;
            return (0, _fetchFile.fetchFile)(outputFilename);

          case 59:
            response = _context.sent;
            return _context.abrupt("return", response.arrayBuffer());

          case 61:
            throw new Error('Writer could not encode data');

          case 62:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[17, 34, 38, 48], [39,, 43, 47]]);
  }));
  return _encode.apply(this, arguments);
}

function encodeSync(data, writer, options) {
  if (writer.encodeSync) {
    return writer.encodeSync(data, options);
  }

  throw new Error('Writer could not synchronously encode data');
}

function encodeText(_x4, _x5, _x6) {
  return _encodeText.apply(this, arguments);
}

function _encodeText() {
  _encodeText = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(data, writer, options) {
    var arrayBuffer;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(writer.text && writer.encodeText)) {
              _context2.next = 4;
              break;
            }

            _context2.next = 3;
            return writer.encodeText(data, options);

          case 3:
            return _context2.abrupt("return", _context2.sent);

          case 4:
            if (!(writer.text && (writer.encode || writer.encodeInBatches))) {
              _context2.next = 9;
              break;
            }

            _context2.next = 7;
            return encode(data, writer, options);

          case 7:
            arrayBuffer = _context2.sent;
            return _context2.abrupt("return", new TextDecoder().decode(arrayBuffer));

          case 9:
            throw new Error('Writer could not encode data as text');

          case 10:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _encodeText.apply(this, arguments);
}

function encodeInBatches(data, writer, options) {
  if (writer.encodeInBatches) {
    var dataIterator = getIterator(data);
    return writer.encodeInBatches(dataIterator, options);
  }

  throw new Error('Writer could not encode data in batches');
}

function encodeURLtoURL(_x7, _x8, _x9, _x10) {
  return _encodeURLtoURL.apply(this, arguments);
}

function _encodeURLtoURL() {
  _encodeURLtoURL = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(inputUrl, outputUrl, writer, options) {
    var outputFilename;
    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            inputUrl = (0, _loaderUtils.resolvePath)(inputUrl);
            outputUrl = (0, _loaderUtils.resolvePath)(outputUrl);

            if (!(_loaderUtils.isBrowser || !writer.encodeURLtoURL)) {
              _context3.next = 4;
              break;
            }

            throw new Error();

          case 4:
            _context3.next = 6;
            return writer.encodeURLtoURL(inputUrl, outputUrl, options);

          case 6:
            outputFilename = _context3.sent;
            return _context3.abrupt("return", outputFilename);

          case 8:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _encodeURLtoURL.apply(this, arguments);
}

function getIterator(data) {
  var dataIterator = [{
    table: data,
    start: 0,
    end: data.length
  }];
  return dataIterator;
}

function getTemporaryFilename(filename) {
  return "/tmp/".concat(filename);
}

},{"../fetch/fetch-file":53,"../fetch/write-file":56,"@babel/runtime/helpers/asyncIterator":9,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33,"@loaders.gl/loader-utils":73}],44:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadInBatches = loadInBatches;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _normalizeLoader = require("../loader-utils/normalize-loader");

var _optionUtils = require("../loader-utils/option-utils");

var _parseInBatches = require("./parse-in-batches");

function loadInBatches(files, loaders, options, context) {
  if (!Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
    context = undefined;
    options = loaders;
    loaders = null;
  }

  var fetch = (0, _optionUtils.getFetchFunction)(options || {});

  if (!Array.isArray(files)) {
    return loadOneFileInBatches(files, loaders, options, fetch);
  }

  var promises = files.map(function (file) {
    return loadOneFileInBatches(file, loaders, options, fetch);
  });
  return promises;
}

function loadOneFileInBatches(_x, _x2, _x3, _x4) {
  return _loadOneFileInBatches.apply(this, arguments);
}

function _loadOneFileInBatches() {
  _loadOneFileInBatches = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(file, loaders, options, fetch) {
    var url, response;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(typeof file === 'string')) {
              _context.next = 8;
              break;
            }

            url = file;
            _context.next = 4;
            return fetch(url);

          case 4:
            response = _context.sent;
            _context.next = 7;
            return (0, _parseInBatches.parseInBatches)(response, loaders, options);

          case 7:
            return _context.abrupt("return", _context.sent);

          case 8:
            _context.next = 10;
            return (0, _parseInBatches.parseInBatches)(file, loaders, options);

          case 10:
            return _context.abrupt("return", _context.sent);

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _loadOneFileInBatches.apply(this, arguments);
}

},{"../loader-utils/normalize-loader":61,"../loader-utils/option-utils":63,"./parse-in-batches":46,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],45:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.load = load;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _isType = require("../../javascript-utils/is-type");

var _normalizeLoader = require("../loader-utils/normalize-loader");

var _optionUtils = require("../loader-utils/option-utils");

var _parse = require("./parse");

function load(_x, _x2, _x3, _x4) {
  return _load.apply(this, arguments);
}

function _load() {
  _load = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(url, loaders, options, context) {
    var fetch, data;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
              context = undefined;
              options = loaders;
              loaders = undefined;
            }

            fetch = (0, _optionUtils.getFetchFunction)(options);
            data = url;

            if (!(typeof url === 'string')) {
              _context.next = 7;
              break;
            }

            _context.next = 6;
            return fetch(url);

          case 6:
            data = _context.sent;

          case 7:
            if (!(0, _isType.isBlob)(url)) {
              _context.next = 11;
              break;
            }

            _context.next = 10;
            return fetch(url);

          case 10:
            data = _context.sent;

          case 11:
            _context.next = 13;
            return (0, _parse.parse)(data, loaders, options);

          case 13:
            return _context.abrupt("return", _context.sent);

          case 14:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _load.apply(this, arguments);
}

},{"../../javascript-utils/is-type":42,"../loader-utils/normalize-loader":61,"../loader-utils/option-utils":63,"./parse":48,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],46:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseInBatches = parseInBatches;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _wrapAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapAsyncGenerator"));

var _awaitAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/awaitAsyncGenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

var _asyncGeneratorDelegate2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncGeneratorDelegate"));

var _loaderUtils = require("@loaders.gl/loader-utils");

var _normalizeLoader = require("../loader-utils/normalize-loader");

var _optionUtils = require("../loader-utils/option-utils");

var _loaderContext = require("../loader-utils/loader-context");

var _getData = require("../loader-utils/get-data");

var _resourceUtils = require("../utils/resource-utils");

var _selectLoader = require("./select-loader");

var _parse = require("./parse");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function parseInBatches(_x2, _x3, _x4, _x5) {
  return _parseInBatches.apply(this, arguments);
}

function _parseInBatches() {
  _parseInBatches = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(data, loaders, options, context) {
    var _getResourceUrlAndTyp, url, loader;

    return _regenerator.default.wrap(function _callee2$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            (0, _loaderUtils.assert)(!context || (0, _typeof2.default)(context) === 'object');

            if (!Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
              context = undefined;
              options = loaders;
              loaders = undefined;
            }

            _context3.next = 4;
            return data;

          case 4:
            data = _context3.sent;
            options = options || {};
            _getResourceUrlAndTyp = (0, _resourceUtils.getResourceUrlAndType)(data), url = _getResourceUrlAndTyp.url;
            _context3.next = 9;
            return (0, _selectLoader.selectLoader)(data, loaders, options);

          case 9:
            loader = _context3.sent;

            if (loader) {
              _context3.next = 12;
              break;
            }

            return _context3.abrupt("return", null);

          case 12:
            options = (0, _optionUtils.normalizeOptions)(options, loader, loaders, url);
            context = (0, _loaderContext.getLoaderContext)({
              url: url,
              parseInBatches: parseInBatches,
              parse: _parse.parse,
              loaders: loaders
            }, options, context);
            _context3.next = 16;
            return parseWithLoaderInBatches(loader, data, options, context);

          case 16:
            return _context3.abrupt("return", _context3.sent);

          case 17:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee2);
  }));
  return _parseInBatches.apply(this, arguments);
}

function parseWithLoaderInBatches(loader, data, options, context) {
  var outputIterator, metadataBatch, makeMetadataBatchIterator, _makeMetadataBatchIterator;

  return _regenerator.default.async(function parseWithLoaderInBatches$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _makeMetadataBatchIterator = function _makeMetadataBatchIte2() {
            _makeMetadataBatchIterator = (0, _wrapAsyncGenerator2.default)(_regenerator.default.mark(function _callee(iterator) {
              return _regenerator.default.wrap(function _callee$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      _context2.next = 2;
                      return metadataBatch;

                    case 2:
                      return _context2.delegateYield((0, _asyncGeneratorDelegate2.default)((0, _asyncIterator2.default)(iterator), _awaitAsyncGenerator2.default), "t0", 3);

                    case 3:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee);
            }));
            return _makeMetadataBatchIterator.apply(this, arguments);
          };

          makeMetadataBatchIterator = function _makeMetadataBatchIte(_x) {
            return _makeMetadataBatchIterator.apply(this, arguments);
          };

          _context.next = 4;
          return _regenerator.default.awrap(parseToOutputIterator(loader, data, options, context));

        case 4:
          outputIterator = _context.sent;

          if (options.metadata) {
            _context.next = 7;
            break;
          }

          return _context.abrupt("return", outputIterator);

        case 7:
          metadataBatch = {
            batchType: 'metadata',
            metadata: {
              _loader: loader,
              _context: context
            },
            data: [],
            bytesUsed: 0
          };
          return _context.abrupt("return", makeMetadataBatchIterator(outputIterator));

        case 9:
        case "end":
          return _context.stop();
      }
    }
  }, null, null, null, Promise);
}

function parseToOutputIterator(_x6, _x7, _x8, _x9) {
  return _parseToOutputIterator.apply(this, arguments);
}

function _parseToOutputIterator() {
  _parseToOutputIterator = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee4(loader, data, options, context) {
    var inputIterator, transformedIterator, parseChunkInBatches, _parseChunkInBatches;

    return _regenerator.default.wrap(function _callee4$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _parseChunkInBatches = function _parseChunkInBatches3() {
              _parseChunkInBatches = (0, _wrapAsyncGenerator2.default)(_regenerator.default.mark(function _callee3() {
                var arrayBuffer, parsedData, batch;
                return _regenerator.default.wrap(function _callee3$(_context4) {
                  while (1) {
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        _context4.next = 2;
                        return (0, _awaitAsyncGenerator2.default)((0, _loaderUtils.concatenateArrayBuffersAsync)(transformedIterator));

                      case 2:
                        arrayBuffer = _context4.sent;
                        _context4.next = 5;
                        return (0, _awaitAsyncGenerator2.default)((0, _parse.parse)(arrayBuffer, loader, _objectSpread(_objectSpread({}, options), {}, {
                          mimeType: loader.mimeTypes[0]
                        }), context));

                      case 5:
                        parsedData = _context4.sent;
                        batch = {
                          mimeType: loader.mimeTypes[0],
                          shape: Array.isArray(parsedData) ? 'row-table' : 'unknown',
                          batchType: 'data',
                          data: parsedData,
                          length: Array.isArray(parsedData) ? parsedData.length : 1
                        };
                        _context4.next = 9;
                        return batch;

                      case 9:
                      case "end":
                        return _context4.stop();
                    }
                  }
                }, _callee3);
              }));
              return _parseChunkInBatches.apply(this, arguments);
            };

            parseChunkInBatches = function _parseChunkInBatches2() {
              return _parseChunkInBatches.apply(this, arguments);
            };

            _context5.next = 4;
            return (0, _getData.getAsyncIterableFromData)(data, options);

          case 4:
            inputIterator = _context5.sent;
            _context5.next = 7;
            return applyInputTransforms(inputIterator, (options === null || options === void 0 ? void 0 : options.transforms) || []);

          case 7:
            transformedIterator = _context5.sent;

            if (!loader.parseInBatches) {
              _context5.next = 10;
              break;
            }

            return _context5.abrupt("return", loader.parseInBatches(transformedIterator, options, context));

          case 10:
            return _context5.abrupt("return", parseChunkInBatches());

          case 11:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee4);
  }));
  return _parseToOutputIterator.apply(this, arguments);
}

function applyInputTransforms(_x10) {
  return _applyInputTransforms.apply(this, arguments);
}

function _applyInputTransforms() {
  _applyInputTransforms = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee5(inputIterator) {
    var transforms,
        iteratorChain,
        _iteratorNormalCompletion,
        _didIteratorError,
        _iteratorError,
        _iterator,
        _step,
        _value,
        transformBatches,
        _args6 = arguments;

    return _regenerator.default.wrap(function _callee5$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            transforms = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : [];
            iteratorChain = inputIterator;
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _context6.prev = 4;
            _iterator = (0, _asyncIterator2.default)(transforms);

          case 6:
            _context6.next = 8;
            return _iterator.next();

          case 8:
            _step = _context6.sent;
            _iteratorNormalCompletion = _step.done;
            _context6.next = 12;
            return _step.value;

          case 12:
            _value = _context6.sent;

            if (_iteratorNormalCompletion) {
              _context6.next = 19;
              break;
            }

            transformBatches = _value;
            iteratorChain = transformBatches(iteratorChain);

          case 16:
            _iteratorNormalCompletion = true;
            _context6.next = 6;
            break;

          case 19:
            _context6.next = 25;
            break;

          case 21:
            _context6.prev = 21;
            _context6.t0 = _context6["catch"](4);
            _didIteratorError = true;
            _iteratorError = _context6.t0;

          case 25:
            _context6.prev = 25;
            _context6.prev = 26;

            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
              _context6.next = 30;
              break;
            }

            _context6.next = 30;
            return _iterator.return();

          case 30:
            _context6.prev = 30;

            if (!_didIteratorError) {
              _context6.next = 33;
              break;
            }

            throw _iteratorError;

          case 33:
            return _context6.finish(30);

          case 34:
            return _context6.finish(25);

          case 35:
            return _context6.abrupt("return", iteratorChain);

          case 36:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee5, null, [[4, 21, 25, 35], [26,, 30, 34]]);
  }));
  return _applyInputTransforms.apply(this, arguments);
}

},{"../loader-utils/get-data":58,"../loader-utils/loader-context":59,"../loader-utils/normalize-loader":61,"../loader-utils/option-utils":63,"../utils/resource-utils":66,"./parse":48,"./select-loader":51,"@babel/runtime/helpers/asyncGeneratorDelegate":8,"@babel/runtime/helpers/asyncIterator":9,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/awaitAsyncGenerator":11,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"@babel/runtime/helpers/wrapAsyncGenerator":31,"@babel/runtime/regenerator":33,"@loaders.gl/loader-utils":73}],47:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseSync = parseSync;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _loaderUtils = require("@loaders.gl/loader-utils");

var _selectLoader = require("./select-loader");

var _normalizeLoader = require("../loader-utils/normalize-loader");

var _optionUtils = require("../loader-utils/option-utils");

var _getData = require("../loader-utils/get-data");

var _loaderContext = require("../loader-utils/loader-context");

var _resourceUtils = require("../utils/resource-utils");

function parseSync(data, loaders, options, context) {
  (0, _loaderUtils.assert)(!context || (0, _typeof2.default)(context) === 'object');

  if (!Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
    context = undefined;
    options = loaders;
    loaders = undefined;
  }

  options = options || {};
  var typedLoaders = loaders;
  var candidateLoaders = (0, _loaderContext.getLoadersFromContext)(typedLoaders, context);
  var loader = (0, _selectLoader.selectLoaderSync)(data, candidateLoaders, options);

  if (!loader) {
    return null;
  }

  options = (0, _optionUtils.normalizeOptions)(options, loader, candidateLoaders);

  var _getResourceUrlAndTyp = (0, _resourceUtils.getResourceUrlAndType)(data),
      url = _getResourceUrlAndTyp.url;

  var parse = function parse() {
    throw new Error('parseSync called parse');
  };

  context = (0, _loaderContext.getLoaderContext)({
    url: url,
    parseSync: parseSync,
    parse: parse,
    loaders: loaders
  }, options);
  return parseWithLoaderSync(loader, data, options, context);
}

function parseWithLoaderSync(loader, data, options, context) {
  data = (0, _getData.getArrayBufferOrStringFromDataSync)(data, loader, options);

  if (loader.parseTextSync && typeof data === 'string') {
    return loader.parseTextSync(data, options);
  }

  if (loader.parseSync && data instanceof ArrayBuffer) {
    return loader.parseSync(data, options, context);
  }

  throw new Error("".concat(loader.name, " loader: 'parseSync' not supported by this loader, use 'parse' instead. ").concat(context.url || ''));
}

},{"../loader-utils/get-data":58,"../loader-utils/loader-context":59,"../loader-utils/normalize-loader":61,"../loader-utils/option-utils":63,"../utils/resource-utils":66,"./select-loader":51,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"@loaders.gl/loader-utils":73}],48:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = parse;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _workerUtils = require("@loaders.gl/worker-utils");

var _loaderUtils = require("@loaders.gl/loader-utils");

var _normalizeLoader = require("../loader-utils/normalize-loader");

var _optionUtils = require("../loader-utils/option-utils");

var _getData = require("../loader-utils/get-data");

var _loaderContext = require("../loader-utils/loader-context");

var _resourceUtils = require("../utils/resource-utils");

var _selectLoader = require("./select-loader");

function parse(_x, _x2, _x3, _x4) {
  return _parse.apply(this, arguments);
}

function _parse() {
  _parse = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(data, loaders, options, context) {
    var _getResourceUrlAndTyp, url, typedLoaders, candidateLoaders, loader;

    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            (0, _workerUtils.assert)(!context || (0, _typeof2.default)(context) === 'object');

            if (loaders && !Array.isArray(loaders) && !(0, _normalizeLoader.isLoaderObject)(loaders)) {
              context = undefined;
              options = loaders;
              loaders = undefined;
            }

            _context.next = 4;
            return data;

          case 4:
            data = _context.sent;
            options = options || {};
            _getResourceUrlAndTyp = (0, _resourceUtils.getResourceUrlAndType)(data), url = _getResourceUrlAndTyp.url;
            typedLoaders = loaders;
            candidateLoaders = (0, _loaderContext.getLoadersFromContext)(typedLoaders, context);
            _context.next = 11;
            return (0, _selectLoader.selectLoader)(data, candidateLoaders, options);

          case 11:
            loader = _context.sent;

            if (loader) {
              _context.next = 14;
              break;
            }

            return _context.abrupt("return", null);

          case 14:
            options = (0, _optionUtils.normalizeOptions)(options, loader, candidateLoaders, url);
            context = (0, _loaderContext.getLoaderContext)({
              url: url,
              parse: parse,
              loaders: candidateLoaders
            }, options, context);
            _context.next = 18;
            return parseWithLoader(loader, data, options, context);

          case 18:
            return _context.abrupt("return", _context.sent);

          case 19:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _parse.apply(this, arguments);
}

function parseWithLoader(_x5, _x6, _x7, _x8) {
  return _parseWithLoader.apply(this, arguments);
}

function _parseWithLoader() {
  _parseWithLoader = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(loader, data, options, context) {
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            (0, _workerUtils.validateWorkerVersion)(loader);
            _context2.next = 3;
            return (0, _getData.getArrayBufferOrStringFromData)(data, loader, options);

          case 3:
            data = _context2.sent;

            if (!(loader.parseTextSync && typeof data === 'string')) {
              _context2.next = 7;
              break;
            }

            options.dataType = 'text';
            return _context2.abrupt("return", loader.parseTextSync(data, options, context, loader));

          case 7:
            if (!(0, _loaderUtils.canParseWithWorker)(loader, options)) {
              _context2.next = 11;
              break;
            }

            _context2.next = 10;
            return (0, _loaderUtils.parseWithWorker)(loader, data, options, context, parse);

          case 10:
            return _context2.abrupt("return", _context2.sent);

          case 11:
            if (!(loader.parseText && typeof data === 'string')) {
              _context2.next = 15;
              break;
            }

            _context2.next = 14;
            return loader.parseText(data, options, context, loader);

          case 14:
            return _context2.abrupt("return", _context2.sent);

          case 15:
            if (!loader.parse) {
              _context2.next = 19;
              break;
            }

            _context2.next = 18;
            return loader.parse(data, options, context, loader);

          case 18:
            return _context2.abrupt("return", _context2.sent);

          case 19:
            (0, _workerUtils.assert)(!loader.parseSync);
            throw new Error("".concat(loader.id, " loader - no parser found and worker is disabled"));

          case 21:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _parseWithLoader.apply(this, arguments);
}

},{"../loader-utils/get-data":58,"../loader-utils/loader-context":59,"../loader-utils/normalize-loader":61,"../loader-utils/option-utils":63,"../utils/resource-utils":66,"./select-loader":51,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"@babel/runtime/regenerator":33,"@loaders.gl/loader-utils":73,"@loaders.gl/worker-utils":108}],49:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerLoaders = registerLoaders;
exports.getRegisteredLoaders = getRegisteredLoaders;
exports._unregisterLoaders = _unregisterLoaders;

var _normalizeLoader = require("../loader-utils/normalize-loader");

var _optionUtils = require("../loader-utils/option-utils");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var getGlobalLoaderRegistry = function getGlobalLoaderRegistry() {
  var state = (0, _optionUtils.getGlobalLoaderState)();
  state.loaderRegistry = state.loaderRegistry || [];
  return state.loaderRegistry;
};

function registerLoaders(loaders) {
  var loaderRegistry = getGlobalLoaderRegistry();
  loaders = Array.isArray(loaders) ? loaders : [loaders];

  var _iterator = _createForOfIteratorHelper(loaders),
      _step;

  try {
    var _loop = function _loop() {
      var loader = _step.value;
      var normalizedLoader = (0, _normalizeLoader.normalizeLoader)(loader);

      if (!loaderRegistry.find(function (registeredLoader) {
        return normalizedLoader === registeredLoader;
      })) {
        loaderRegistry.unshift(normalizedLoader);
      }
    };

    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      _loop();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}

function getRegisteredLoaders() {
  return getGlobalLoaderRegistry();
}

function _unregisterLoaders() {
  var state = (0, _optionUtils.getGlobalLoaderState)();
  state.loaderRegistry = [];
}

},{"../loader-utils/normalize-loader":61,"../loader-utils/option-utils":63}],50:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.save = save;
exports.saveSync = saveSync;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _encode = require("./encode");

var _writeFile = require("../fetch/write-file");

function save(_x, _x2, _x3, _x4) {
  return _save.apply(this, arguments);
}

function _save() {
  _save = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(data, url, writer, options) {
    var encodedData;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return (0, _encode.encode)(data, writer, options);

          case 2:
            encodedData = _context.sent;
            _context.next = 5;
            return (0, _writeFile.writeFile)(url, encodedData);

          case 5:
            return _context.abrupt("return", _context.sent);

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _save.apply(this, arguments);
}

function saveSync(data, url, writer, options) {
  var encodedData = (0, _encode.encodeSync)(data, writer, options);
  return (0, _writeFile.writeFileSync)(url, encodedData);
}

},{"../fetch/write-file":56,"./encode":43,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],51:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.selectLoader = selectLoader;
exports.selectLoaderSync = selectLoaderSync;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _loaderUtils = require("@loaders.gl/loader-utils");

var _normalizeLoader = require("../loader-utils/normalize-loader");

var _resourceUtils = require("../utils/resource-utils");

var _registerLoaders = require("./register-loaders");

var _isType = require("../../javascript-utils/is-type");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var EXT_PATTERN = /\.([^.]+)$/;

function selectLoader(_x) {
  return _selectLoader.apply(this, arguments);
}

function _selectLoader() {
  _selectLoader = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(data) {
    var loaders,
        options,
        context,
        loader,
        _args = arguments;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            loaders = _args.length > 1 && _args[1] !== undefined ? _args[1] : [];
            options = _args.length > 2 ? _args[2] : undefined;
            context = _args.length > 3 ? _args[3] : undefined;

            if (validHTTPResponse(data)) {
              _context.next = 5;
              break;
            }

            return _context.abrupt("return", null);

          case 5:
            loader = selectLoaderSync(data, loaders, _objectSpread(_objectSpread({}, options), {}, {
              nothrow: true
            }), context);

            if (!loader) {
              _context.next = 8;
              break;
            }

            return _context.abrupt("return", loader);

          case 8:
            if (!(0, _isType.isBlob)(data)) {
              _context.next = 13;
              break;
            }

            _context.next = 11;
            return data.slice(0, 10).arrayBuffer();

          case 11:
            data = _context.sent;
            loader = selectLoaderSync(data, loaders, options, context);

          case 13:
            if (!(!loader && !(options !== null && options !== void 0 && options.nothrow))) {
              _context.next = 15;
              break;
            }

            throw new Error(getNoValidLoaderMessage(data));

          case 15:
            return _context.abrupt("return", loader);

          case 16:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _selectLoader.apply(this, arguments);
}

function selectLoaderSync(data) {
  var loaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var options = arguments.length > 2 ? arguments[2] : undefined;
  var context = arguments.length > 3 ? arguments[3] : undefined;

  if (!validHTTPResponse(data)) {
    return null;
  }

  if (loaders && !Array.isArray(loaders)) {
    return (0, _normalizeLoader.normalizeLoader)(loaders);
  }

  var candidateLoaders = [];

  if (loaders) {
    candidateLoaders = candidateLoaders.concat(loaders);
  }

  if (!(options !== null && options !== void 0 && options.ignoreRegisteredLoaders)) {
    var _candidateLoaders;

    (_candidateLoaders = candidateLoaders).push.apply(_candidateLoaders, (0, _toConsumableArray2.default)((0, _registerLoaders.getRegisteredLoaders)()));
  }

  normalizeLoaders(candidateLoaders);
  var loader = selectLoaderInternal(data, candidateLoaders, options, context);

  if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {
    throw new Error(getNoValidLoaderMessage(data));
  }

  return loader;
}

function selectLoaderInternal(data, loaders, options, context) {
  var _getResourceUrlAndTyp = (0, _resourceUtils.getResourceUrlAndType)(data),
      url = _getResourceUrlAndTyp.url,
      type = _getResourceUrlAndTyp.type;

  var testUrl = url || (context === null || context === void 0 ? void 0 : context.url);
  var loader = null;

  if (options !== null && options !== void 0 && options.mimeType) {
    loader = findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.mimeType);
  }

  loader = loader || findLoaderByUrl(loaders, testUrl);
  loader = loader || findLoaderByMIMEType(loaders, type);
  loader = loader || findLoaderByInitialBytes(loaders, data);
  loader = loader || findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.fallbackMimeType);
  return loader;
}

function validHTTPResponse(data) {
  if (data instanceof Response) {
    if (data.status === 204) {
      return false;
    }
  }

  return true;
}

function getNoValidLoaderMessage(data) {
  var _getResourceUrlAndTyp2 = (0, _resourceUtils.getResourceUrlAndType)(data),
      url = _getResourceUrlAndTyp2.url,
      type = _getResourceUrlAndTyp2.type;

  var message = 'No valid loader found';

  if (data) {
    message += " data: \"".concat(getFirstCharacters(data), "\", contentType: \"").concat(type, "\"");
  }

  if (url) {
    message += " url: ".concat(url);
  }

  return message;
}

function normalizeLoaders(loaders) {
  var _iterator = _createForOfIteratorHelper(loaders),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var loader = _step.value;
      (0, _normalizeLoader.normalizeLoader)(loader);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}

function findLoaderByUrl(loaders, url) {
  var match = url && EXT_PATTERN.exec(url);
  var extension = match && match[1];
  return extension ? findLoaderByExtension(loaders, extension) : null;
}

function findLoaderByExtension(loaders, extension) {
  extension = extension.toLowerCase();

  var _iterator2 = _createForOfIteratorHelper(loaders),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var loader = _step2.value;

      var _iterator3 = _createForOfIteratorHelper(loader.extensions),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var loaderExtension = _step3.value;

          if (loaderExtension.toLowerCase() === extension) {
            return loader;
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return null;
}

function findLoaderByMIMEType(loaders, mimeType) {
  var _iterator4 = _createForOfIteratorHelper(loaders),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var loader = _step4.value;

      if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {
        return loader;
      }

      if (mimeType === "application/x.".concat(loader.id)) {
        return loader;
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  return null;
}

function findLoaderByInitialBytes(loaders, data) {
  if (!data) {
    return null;
  }

  var _iterator5 = _createForOfIteratorHelper(loaders),
      _step5;

  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var loader = _step5.value;

      if (typeof data === 'string') {
        if (testDataAgainstText(data, loader)) {
          return loader;
        }
      } else if (ArrayBuffer.isView(data)) {
        if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {
          return loader;
        }
      } else if (data instanceof ArrayBuffer) {
        var byteOffset = 0;

        if (testDataAgainstBinary(data, byteOffset, loader)) {
          return loader;
        }
      }
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }

  return null;
}

function testDataAgainstText(data, loader) {
  if (loader.testText) {
    return loader.testText(data);
  }

  var tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some(function (test) {
    return data.startsWith(test);
  });
}

function testDataAgainstBinary(data, byteOffset, loader) {
  var tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some(function (test) {
    return testBinary(data, byteOffset, loader, test);
  });
}

function testBinary(data, byteOffset, loader, test) {
  if (test instanceof ArrayBuffer) {
    return (0, _loaderUtils.compareArrayBuffers)(test, data, test.byteLength);
  }

  switch ((0, _typeof2.default)(test)) {
    case 'function':
      return test(data, loader);

    case 'string':
      var magic = getMagicString(data, byteOffset, test.length);
      return test === magic;

    default:
      return false;
  }
}

function getFirstCharacters(data) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;

  if (typeof data === 'string') {
    return data.slice(0, length);
  } else if (ArrayBuffer.isView(data)) {
    return getMagicString(data.buffer, data.byteOffset, length);
  } else if (data instanceof ArrayBuffer) {
    var byteOffset = 0;
    return getMagicString(data, byteOffset, length);
  }

  return '';
}

function getMagicString(arrayBuffer, byteOffset, length) {
  if (arrayBuffer.byteLength < byteOffset + length) {
    return '';
  }

  var dataView = new DataView(arrayBuffer);
  var magic = '';

  for (var i = 0; i < length; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }

  return magic;
}

},{"../../javascript-utils/is-type":42,"../loader-utils/normalize-loader":61,"../utils/resource-utils":66,"./register-loaders":49,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/toConsumableArray":28,"@babel/runtime/helpers/typeof":29,"@babel/runtime/regenerator":33,"@loaders.gl/loader-utils":73}],52:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setLoaderOptions = setLoaderOptions;

var _optionUtils = require("../loader-utils/option-utils");

function setLoaderOptions(options) {
  (0, _optionUtils.setGlobalOptions)(options);
}

},{"../loader-utils/option-utils":63}],53:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchFile = fetchFile;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _loaderUtils = require("@loaders.gl/loader-utils");

var _responseUtils = require("../utils/response-utils");

function fetchFile(_x, _x2) {
  return _fetchFile.apply(this, arguments);
}

function _fetchFile() {
  _fetchFile = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(url, options) {
    var fetchOptions;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(typeof url === 'string')) {
              _context.next = 7;
              break;
            }

            url = (0, _loaderUtils.resolvePath)(url);
            fetchOptions = options;

            if (options !== null && options !== void 0 && options.fetch && typeof (options === null || options === void 0 ? void 0 : options.fetch) !== 'function') {
              fetchOptions = options.fetch;
            }

            _context.next = 6;
            return fetch(url, fetchOptions);

          case 6:
            return _context.abrupt("return", _context.sent);

          case 7:
            _context.next = 9;
            return (0, _responseUtils.makeResponse)(url);

          case 9:
            return _context.abrupt("return", _context.sent);

          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _fetchFile.apply(this, arguments);
}

},{"../utils/response-utils":67,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33,"@loaders.gl/loader-utils":73}],54:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readArrayBuffer = readArrayBuffer;
exports.readBlob = readBlob;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _loaderUtils = require("@loaders.gl/loader-utils");

function readArrayBuffer(_x, _x2, _x3) {
  return _readArrayBuffer.apply(this, arguments);
}

function _readArrayBuffer() {
  _readArrayBuffer = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(file, start, length) {
    var slice;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(typeof file === 'number')) {
              _context.next = 4;
              break;
            }

            _context.next = 3;
            return _loaderUtils.fs._readToArrayBuffer(file, start, length);

          case 3:
            return _context.abrupt("return", _context.sent);

          case 4:
            if (!(file instanceof Blob)) {
              file = new Blob([file]);
            }

            slice = file.slice(start, start + length);
            _context.next = 8;
            return readBlob(slice);

          case 8:
            return _context.abrupt("return", _context.sent);

          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _readArrayBuffer.apply(this, arguments);
}

function readBlob(_x4) {
  return _readBlob.apply(this, arguments);
}

function _readBlob() {
  _readBlob = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(blob) {
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return new Promise(function (resolve, reject) {
              var fileReader = new FileReader();

              fileReader.onload = function (event) {
                var _event$target;

                return resolve(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);
              };

              fileReader.onerror = function (error) {
                return reject(error);
              };

              fileReader.readAsArrayBuffer(blob);
            });

          case 2:
            return _context2.abrupt("return", _context2.sent);

          case 3:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _readBlob.apply(this, arguments);
}

},{"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33,"@loaders.gl/loader-utils":73}],55:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readFileSync = readFileSync;

var _loaderUtils = require("@loaders.gl/loader-utils");

function readFileSync(url) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  url = (0, _loaderUtils.resolvePath)(url);

  if (!_loaderUtils.isBrowser) {
    var buffer = _loaderUtils.fs.readFileSync(url, options);

    return typeof buffer !== 'string' ? (0, _loaderUtils.toArrayBuffer)(buffer) : buffer;
  }

  if (!options.nothrow) {
    (0, _loaderUtils.assert)(false);
  }

  return null;
}

},{"@loaders.gl/loader-utils":73}],56:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.writeFile = writeFile;
exports.writeFileSync = writeFileSync;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _loaderUtils = require("@loaders.gl/loader-utils");

function writeFile(_x, _x2, _x3) {
  return _writeFile.apply(this, arguments);
}

function _writeFile() {
  _writeFile = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(filePath, arrayBufferOrString, options) {
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            filePath = (0, _loaderUtils.resolvePath)(filePath);

            if (_loaderUtils.isBrowser) {
              _context.next = 4;
              break;
            }

            _context.next = 4;
            return _loaderUtils.fs.writeFile(filePath, (0, _loaderUtils.toBuffer)(arrayBufferOrString), {
              flag: 'w'
            });

          case 4:
            (0, _loaderUtils.assert)(false);

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _writeFile.apply(this, arguments);
}

function writeFileSync(filePath, arrayBufferOrString, options) {
  filePath = (0, _loaderUtils.resolvePath)(filePath);

  if (!_loaderUtils.isBrowser) {
    _loaderUtils.fs.writeFileSync(filePath, (0, _loaderUtils.toBuffer)(arrayBufferOrString), {
      flag: 'w'
    });
  }

  (0, _loaderUtils.assert)(false);
}

},{"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33,"@loaders.gl/loader-utils":73}],57:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var BrowserFileSystem = function () {
  function BrowserFileSystem(files, options) {
    (0, _classCallCheck2.default)(this, BrowserFileSystem);
    (0, _defineProperty2.default)(this, "_fetch", void 0);
    (0, _defineProperty2.default)(this, "files", {});
    (0, _defineProperty2.default)(this, "lowerCaseFiles", {});
    (0, _defineProperty2.default)(this, "usedFiles", {});
    this._fetch = (options === null || options === void 0 ? void 0 : options.fetch) || fetch;

    for (var i = 0; i < files.length; ++i) {
      var file = files[i];
      this.files[file.name] = file;
      this.lowerCaseFiles[file.name.toLowerCase()] = file;
      this.usedFiles[file.name] = false;
    }

    this.fetch = this.fetch.bind(this);
  }

  (0, _createClass2.default)(BrowserFileSystem, [{
    key: "fetch",
    value: function () {
      var _fetch = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(path, options) {
        var file, headers, range, bytes, start, end, data, _response, response;

        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!path.includes('://')) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return", this._fetch(path, options));

              case 2:
                file = this.files[path];

                if (file) {
                  _context.next = 5;
                  break;
                }

                return _context.abrupt("return", new Response(path, {
                  status: 400,
                  statusText: 'NOT FOUND'
                }));

              case 5:
                headers = new Headers(options === null || options === void 0 ? void 0 : options.headers);
                range = headers.get('Range');
                bytes = range && /bytes=($1)-($2)/.exec(range);

                if (!bytes) {
                  _context.next = 17;
                  break;
                }

                start = parseInt(bytes[1]);
                end = parseInt(bytes[2]);
                _context.next = 13;
                return file.slice(start, end).arrayBuffer();

              case 13:
                data = _context.sent;
                _response = new Response(data);
                Object.defineProperty(_response, 'url', {
                  value: path
                });
                return _context.abrupt("return", _response);

              case 17:
                response = new Response(file);
                Object.defineProperty(response, 'url', {
                  value: path
                });
                return _context.abrupt("return", response);

              case 20:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function fetch(_x, _x2) {
        return _fetch.apply(this, arguments);
      }

      return fetch;
    }()
  }, {
    key: "readdir",
    value: function () {
      var _readdir = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(dirname) {
        var files, path;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                files = [];

                for (path in this.files) {
                  files.push(path);
                }

                return _context2.abrupt("return", files);

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function readdir(_x3) {
        return _readdir.apply(this, arguments);
      }

      return readdir;
    }()
  }, {
    key: "stat",
    value: function () {
      var _stat = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(path, options) {
        var file;
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                file = this.files[path];

                if (file) {
                  _context3.next = 3;
                  break;
                }

                throw new Error(path);

              case 3:
                return _context3.abrupt("return", {
                  size: file.size
                });

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function stat(_x4, _x5) {
        return _stat.apply(this, arguments);
      }

      return stat;
    }()
  }, {
    key: "unlink",
    value: function () {
      var _unlink = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee4(path) {
        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                delete this.files[path];
                delete this.lowerCaseFiles[path];
                this.usedFiles[path] = true;

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function unlink(_x6) {
        return _unlink.apply(this, arguments);
      }

      return unlink;
    }()
  }, {
    key: "open",
    value: function () {
      var _open = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee5(pathname, flags, mode) {
        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                return _context5.abrupt("return", this.files[pathname]);

              case 1:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function open(_x7, _x8, _x9) {
        return _open.apply(this, arguments);
      }

      return open;
    }()
  }, {
    key: "read",
    value: function () {
      var _read = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee6(fd, buffer) {
        var offset,
            length,
            position,
            file,
            startPosition,
            arrayBuffer,
            _args6 = arguments;
        return _regenerator.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                offset = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : 0;
                length = _args6.length > 3 && _args6[3] !== undefined ? _args6[3] : buffer.byteLength;
                position = _args6.length > 4 && _args6[4] !== undefined ? _args6[4] : null;
                file = fd;
                startPosition = 0;
                _context6.next = 7;
                return file.slice(startPosition, startPosition + length).arrayBuffer();

              case 7:
                arrayBuffer = _context6.sent;
                return _context6.abrupt("return", {
                  bytesRead: length,
                  buffer: arrayBuffer
                });

              case 9:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));

      function read(_x10, _x11) {
        return _read.apply(this, arguments);
      }

      return read;
    }()
  }, {
    key: "close",
    value: function () {
      var _close = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee7(fd) {
        return _regenerator.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));

      function close(_x12) {
        return _close.apply(this, arguments);
      }

      return close;
    }()
  }, {
    key: "_getFile",
    value: function _getFile(path, used) {
      var file = this.files[path] || this.lowerCaseFiles[path];

      if (file && used) {
        this.usedFiles[path] = true;
      }

      return file;
    }
  }]);
  return BrowserFileSystem;
}();

exports.default = BrowserFileSystem;

},{"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],58:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getArrayBufferOrStringFromDataSync = getArrayBufferOrStringFromDataSync;
exports.getArrayBufferOrStringFromData = getArrayBufferOrStringFromData;
exports.getAsyncIterableFromData = getAsyncIterableFromData;
exports.getReadableStream = getReadableStream;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _loaderUtils = require("@loaders.gl/loader-utils");

var _isType = require("../../javascript-utils/is-type");

var _makeIterator = require("../../iterators/make-iterator/make-iterator");

var _responseUtils = require("../utils/response-utils");

var ERR_DATA = 'Cannot convert supplied data type';

function getArrayBufferOrStringFromDataSync(data, loader, options) {
  if (loader.text && typeof data === 'string') {
    return data;
  }

  if ((0, _isType.isBuffer)(data)) {
    data = data.buffer;
  }

  if (data instanceof ArrayBuffer) {
    var arrayBuffer = data;

    if (loader.text && !loader.binary) {
      var textDecoder = new TextDecoder('utf8');
      return textDecoder.decode(arrayBuffer);
    }

    return arrayBuffer;
  }

  if (ArrayBuffer.isView(data)) {
    if (loader.text && !loader.binary) {
      var _textDecoder = new TextDecoder('utf8');

      return _textDecoder.decode(data);
    }

    var _arrayBuffer = data.buffer;
    var byteLength = data.byteLength || data.length;

    if (data.byteOffset !== 0 || byteLength !== _arrayBuffer.byteLength) {
      _arrayBuffer = _arrayBuffer.slice(data.byteOffset, data.byteOffset + byteLength);
    }

    return _arrayBuffer;
  }

  throw new Error(ERR_DATA);
}

function getArrayBufferOrStringFromData(_x, _x2, _x3) {
  return _getArrayBufferOrStringFromData.apply(this, arguments);
}

function _getArrayBufferOrStringFromData() {
  _getArrayBufferOrStringFromData = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(data, loader, options) {
    var isArrayBuffer, response;
    return _regenerator.default.wrap(function _callee$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);

            if (!(typeof data === 'string' || isArrayBuffer)) {
              _context3.next = 3;
              break;
            }

            return _context3.abrupt("return", getArrayBufferOrStringFromDataSync(data, loader, options));

          case 3:
            if (!(0, _isType.isBlob)(data)) {
              _context3.next = 7;
              break;
            }

            _context3.next = 6;
            return (0, _responseUtils.makeResponse)(data);

          case 6:
            data = _context3.sent;

          case 7:
            if (!(0, _isType.isResponse)(data)) {
              _context3.next = 21;
              break;
            }

            response = data;
            _context3.next = 11;
            return (0, _responseUtils.checkResponse)(response);

          case 11:
            if (!loader.binary) {
              _context3.next = 17;
              break;
            }

            _context3.next = 14;
            return response.arrayBuffer();

          case 14:
            _context3.t0 = _context3.sent;
            _context3.next = 20;
            break;

          case 17:
            _context3.next = 19;
            return response.text();

          case 19:
            _context3.t0 = _context3.sent;

          case 20:
            return _context3.abrupt("return", _context3.t0);

          case 21:
            if ((0, _isType.isReadableStream)(data)) {
              data = (0, _makeIterator.makeIterator)(data, options);
            }

            if (!((0, _isType.isIterable)(data) || (0, _isType.isAsyncIterable)(data))) {
              _context3.next = 24;
              break;
            }

            return _context3.abrupt("return", (0, _loaderUtils.concatenateArrayBuffersAsync)(data));

          case 24:
            throw new Error(ERR_DATA);

          case 25:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee);
  }));
  return _getArrayBufferOrStringFromData.apply(this, arguments);
}

function getAsyncIterableFromData(_x4, _x5) {
  return _getAsyncIterableFromData.apply(this, arguments);
}

function _getAsyncIterableFromData() {
  _getAsyncIterableFromData = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(data, options) {
    var response, body;
    return _regenerator.default.wrap(function _callee2$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (!(0, _isType.isIterator)(data)) {
              _context4.next = 2;
              break;
            }

            return _context4.abrupt("return", data);

          case 2:
            if (!(0, _isType.isResponse)(data)) {
              _context4.next = 10;
              break;
            }

            response = data;
            _context4.next = 6;
            return (0, _responseUtils.checkResponse)(response);

          case 6:
            _context4.next = 8;
            return response.body;

          case 8:
            body = _context4.sent;
            return _context4.abrupt("return", (0, _makeIterator.makeIterator)(body, options));

          case 10:
            if (!((0, _isType.isBlob)(data) || (0, _isType.isReadableStream)(data))) {
              _context4.next = 12;
              break;
            }

            return _context4.abrupt("return", (0, _makeIterator.makeIterator)(data, options));

          case 12:
            if (!(0, _isType.isAsyncIterable)(data)) {
              _context4.next = 14;
              break;
            }

            return _context4.abrupt("return", data[Symbol.asyncIterator]());

          case 14:
            return _context4.abrupt("return", getIterableFromData(data));

          case 15:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee2);
  }));
  return _getAsyncIterableFromData.apply(this, arguments);
}

function getReadableStream(_x6) {
  return _getReadableStream.apply(this, arguments);
}

function _getReadableStream() {
  _getReadableStream = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(data) {
    var response;
    return _regenerator.default.wrap(function _callee3$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            if (!(0, _isType.isReadableStream)(data)) {
              _context5.next = 2;
              break;
            }

            return _context5.abrupt("return", data);

          case 2:
            if (!(0, _isType.isResponse)(data)) {
              _context5.next = 4;
              break;
            }

            return _context5.abrupt("return", data.body);

          case 4:
            _context5.next = 6;
            return (0, _responseUtils.makeResponse)(data);

          case 6:
            response = _context5.sent;
            return _context5.abrupt("return", response.body);

          case 8:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee3);
  }));
  return _getReadableStream.apply(this, arguments);
}

function getIterableFromData(data) {
  if (ArrayBuffer.isView(data)) {
    return _regenerator.default.mark(function oneChunk() {
      return _regenerator.default.wrap(function oneChunk$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return data.buffer;

            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, oneChunk);
    })();
  }

  if (data instanceof ArrayBuffer) {
    return _regenerator.default.mark(function oneChunk() {
      return _regenerator.default.wrap(function oneChunk$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return data;

            case 2:
            case "end":
              return _context2.stop();
          }
        }
      }, oneChunk);
    })();
  }

  if ((0, _isType.isIterator)(data)) {
    return data;
  }

  if ((0, _isType.isIterable)(data)) {
    return data[Symbol.iterator]();
  }

  throw new Error(ERR_DATA);
}

},{"../../iterators/make-iterator/make-iterator":37,"../../javascript-utils/is-type":42,"../utils/response-utils":67,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33,"@loaders.gl/loader-utils":73}],59:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLoaderContext = getLoaderContext;
exports.getLoadersFromContext = getLoadersFromContext;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _optionUtils = require("./option-utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function getLoaderContext(context, options) {
  var previousContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  if (previousContext) {
    return previousContext;
  }

  var resolvedContext = _objectSpread({
    fetch: (0, _optionUtils.getFetchFunction)(options, context)
  }, context);

  if (!Array.isArray(resolvedContext.loaders)) {
    resolvedContext.loaders = null;
  }

  return resolvedContext;
}

function getLoadersFromContext(loaders, context) {
  if (!context && loaders && !Array.isArray(loaders)) {
    return loaders;
  }

  var candidateLoaders;

  if (loaders) {
    candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];
  }

  if (context && context.loaders) {
    var contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];
    candidateLoaders = candidateLoaders ? [].concat((0, _toConsumableArray2.default)(candidateLoaders), (0, _toConsumableArray2.default)(contextLoaders)) : contextLoaders;
  }

  return candidateLoaders && candidateLoaders.length ? candidateLoaders : null;
}

},{"./option-utils":63,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/toConsumableArray":28}],60:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConsoleLog = exports.NullLog = exports.probeLog = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _probe = require("probe.gl");

var probeLog = new _probe.Log({
  id: 'loaders.gl'
});
exports.probeLog = probeLog;

var NullLog = function () {
  function NullLog() {
    (0, _classCallCheck2.default)(this, NullLog);
  }

  (0, _createClass2.default)(NullLog, [{
    key: "log",
    value: function log() {
      return function () {};
    }
  }, {
    key: "info",
    value: function info() {
      return function () {};
    }
  }, {
    key: "warn",
    value: function warn() {
      return function () {};
    }
  }, {
    key: "error",
    value: function error() {
      return function () {};
    }
  }]);
  return NullLog;
}();

exports.NullLog = NullLog;

var ConsoleLog = function () {
  function ConsoleLog() {
    (0, _classCallCheck2.default)(this, ConsoleLog);
    (0, _defineProperty2.default)(this, "console", void 0);
    this.console = console;
  }

  (0, _createClass2.default)(ConsoleLog, [{
    key: "log",
    value: function log() {
      var _this$console$log;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return (_this$console$log = this.console.log).bind.apply(_this$console$log, [this.console].concat(args));
    }
  }, {
    key: "info",
    value: function info() {
      var _this$console$info;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return (_this$console$info = this.console.info).bind.apply(_this$console$info, [this.console].concat(args));
    }
  }, {
    key: "warn",
    value: function warn() {
      var _this$console$warn;

      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return (_this$console$warn = this.console.warn).bind.apply(_this$console$warn, [this.console].concat(args));
    }
  }, {
    key: "error",
    value: function error() {
      var _this$console$error;

      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return (_this$console$error = this.console.error).bind.apply(_this$console$error, [this.console].concat(args));
    }
  }]);
  return ConsoleLog;
}();

exports.ConsoleLog = ConsoleLog;

},{"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"probe.gl":143}],61:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isLoaderObject = isLoaderObject;
exports.normalizeLoader = normalizeLoader;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _loaderUtils = require("@loaders.gl/loader-utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function isLoaderObject(loader) {
  var _loader;

  if (!loader) {
    return false;
  }

  if (Array.isArray(loader)) {
    loader = loader[0];
  }

  var hasExtensions = Array.isArray((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.extensions);
  return hasExtensions;
}

function normalizeLoader(loader) {
  var _loader2, _loader3;

  (0, _loaderUtils.assert)(loader, 'null loader');
  (0, _loaderUtils.assert)(isLoaderObject(loader), 'invalid loader');
  var options;

  if (Array.isArray(loader)) {
    options = loader[1];
    loader = loader[0];
    loader = _objectSpread(_objectSpread({}, loader), {}, {
      options: _objectSpread(_objectSpread({}, loader.options), options)
    });
  }

  if ((_loader2 = loader) !== null && _loader2 !== void 0 && _loader2.parseTextSync || (_loader3 = loader) !== null && _loader3 !== void 0 && _loader3.parseText) {
    loader.text = true;
  }

  if (!loader.text) {
    loader.binary = true;
  }

  return loader;
}

},{"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@loaders.gl/loader-utils":73}],62:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.REMOVED_LOADER_OPTIONS = exports.DEFAULT_LOADER_OPTIONS = void 0;

var _loggers = require("./loggers");

var DEFAULT_LOADER_OPTIONS = {
  fetch: null,
  mimeType: undefined,
  nothrow: false,
  log: new _loggers.ConsoleLog(),
  CDN: 'https://unpkg.com/@loaders.gl',
  worker: true,
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: true,
  _workerType: '',
  limit: 0,
  _limitMB: 0,
  batchSize: 'auto',
  batchDebounceMs: 0,
  metadata: false,
  transforms: []
};
exports.DEFAULT_LOADER_OPTIONS = DEFAULT_LOADER_OPTIONS;
var REMOVED_LOADER_OPTIONS = {
  throws: 'nothrow',
  dataType: '(no longer used)',
  uri: 'baseUri',
  method: 'fetch.method',
  headers: 'fetch.headers',
  body: 'fetch.body',
  mode: 'fetch.mode',
  credentials: 'fetch.credentials',
  cache: 'fetch.cache',
  redirect: 'fetch.redirect',
  referrer: 'fetch.referrer',
  referrerPolicy: 'fetch.referrerPolicy',
  integrity: 'fetch.integrity',
  keepalive: 'fetch.keepalive',
  signal: 'fetch.signal'
};
exports.REMOVED_LOADER_OPTIONS = REMOVED_LOADER_OPTIONS;

},{"./loggers":60}],63:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getGlobalLoaderState = getGlobalLoaderState;
exports.setGlobalOptions = setGlobalOptions;
exports.normalizeOptions = normalizeOptions;
exports.getFetchFunction = getFetchFunction;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _loaderUtils = require("@loaders.gl/loader-utils");

var _isType = require("../../javascript-utils/is-type");

var _fetchFile = require("../fetch/fetch-file");

var _loggers = require("./loggers");

var _optionDefaults = require("./option-defaults");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function getGlobalLoaderState() {
  _loaderUtils.global.loaders = _loaderUtils.global.loaders || {};
  var loaders = _loaderUtils.global.loaders;
  loaders._state = loaders._state || {};
  return loaders._state;
}

var getGlobalLoaderOptions = function getGlobalLoaderOptions() {
  var state = getGlobalLoaderState();
  state.globalOptions = state.globalOptions || _objectSpread({}, _optionDefaults.DEFAULT_LOADER_OPTIONS);
  return state.globalOptions;
};

function setGlobalOptions(options) {
  var state = getGlobalLoaderState();
  var globalOptions = getGlobalLoaderOptions();
  state.globalOptions = normalizeOptionsInternal(globalOptions, options);
}

function normalizeOptions(options, loader, loaders, url) {
  loaders = loaders || [];
  loaders = Array.isArray(loaders) ? loaders : [loaders];
  validateOptions(options, loaders);
  return normalizeOptionsInternal(loader, options, url);
}

function getFetchFunction(options, context) {
  var globalOptions = getGlobalLoaderOptions();
  var fetchOptions = options || globalOptions;

  if (typeof fetchOptions.fetch === 'function') {
    return fetchOptions.fetch;
  }

  if ((0, _isType.isObject)(fetchOptions.fetch)) {
    return function (url) {
      return (0, _fetchFile.fetchFile)(url, fetchOptions);
    };
  }

  if (context !== null && context !== void 0 && context.fetch) {
    return context === null || context === void 0 ? void 0 : context.fetch;
  }

  return _fetchFile.fetchFile;
}

function validateOptions(options, loaders) {
  validateOptionsObject(options, null, _optionDefaults.DEFAULT_LOADER_OPTIONS, _optionDefaults.REMOVED_LOADER_OPTIONS, loaders);

  var _iterator = _createForOfIteratorHelper(loaders),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var loader = _step.value;
      var idOptions = options && options[loader.id] || {};
      var loaderOptions = loader.options && loader.options[loader.id] || {};
      var deprecatedOptions = loader.deprecatedOptions && loader.deprecatedOptions[loader.id] || {};
      validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}

function validateOptionsObject(options, id, defaultOptions, deprecatedOptions, loaders) {
  var loaderName = id || 'Top level';
  var prefix = id ? "".concat(id, ".") : '';

  for (var _key in options) {
    var isSubOptions = !id && (0, _isType.isObject)(options[_key]);
    var isBaseUriOption = _key === 'baseUri' && !id;
    var isWorkerUrlOption = _key === 'workerUrl' && id;

    if (!(_key in defaultOptions) && !isBaseUriOption && !isWorkerUrlOption) {
      if (_key in deprecatedOptions) {
        _loggers.probeLog.warn("".concat(loaderName, " loader option '").concat(prefix).concat(_key, "' no longer supported, use '").concat(deprecatedOptions[_key], "'"))();
      } else if (!isSubOptions) {
        var suggestion = findSimilarOption(_key, loaders);

        _loggers.probeLog.warn("".concat(loaderName, " loader option '").concat(prefix).concat(_key, "' not recognized. ").concat(suggestion))();
      }
    }
  }
}

function findSimilarOption(optionKey, loaders) {
  var lowerCaseOptionKey = optionKey.toLowerCase();
  var bestSuggestion = '';

  var _iterator2 = _createForOfIteratorHelper(loaders),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var loader = _step2.value;

      for (var _key2 in loader.options) {
        if (optionKey === _key2) {
          return "Did you mean '".concat(loader.id, ".").concat(_key2, "'?");
        }

        var lowerCaseKey = _key2.toLowerCase();

        var isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);

        if (isPartialMatch) {
          bestSuggestion = bestSuggestion || "Did you mean '".concat(loader.id, ".").concat(_key2, "'?");
        }
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return bestSuggestion;
}

function normalizeOptionsInternal(loader, options, url) {
  var loaderDefaultOptions = loader.options || {};

  var mergedOptions = _objectSpread({}, loaderDefaultOptions);

  addUrlOptions(mergedOptions, url);

  if (mergedOptions.log === null) {
    mergedOptions.log = new _loggers.NullLog();
  }

  mergeNestedFields(mergedOptions, getGlobalLoaderOptions());
  mergeNestedFields(mergedOptions, options);
  return mergedOptions;
}

function mergeNestedFields(mergedOptions, options) {
  for (var _key3 in options) {
    if (_key3 in options) {
      var value = options[_key3];

      if ((0, _isType.isPureObject)(value) && (0, _isType.isPureObject)(mergedOptions[_key3])) {
        mergedOptions[_key3] = _objectSpread(_objectSpread({}, mergedOptions[_key3]), options[_key3]);
      } else {
        mergedOptions[_key3] = options[_key3];
      }
    }
  }
}

function addUrlOptions(options, url) {
  if (url && !('baseUri' in options)) {
    options.baseUri = url;
  }
}

},{"../../javascript-utils/is-type":42,"../fetch/fetch-file":53,"./loggers":60,"./option-defaults":62,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@loaders.gl/loader-utils":73}],64:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fetchProgress;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

function fetchProgress(_x, _x2) {
  return _fetchProgress.apply(this, arguments);
}

function _fetchProgress() {
  _fetchProgress = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(response, onProgress) {
    var onDone,
        onError,
        body,
        contentLength,
        totalBytes,
        progressStream,
        _args2 = arguments;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            onDone = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : function () {};
            onError = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : function () {};
            _context2.next = 4;
            return response;

          case 4:
            response = _context2.sent;

            if (response.ok) {
              _context2.next = 7;
              break;
            }

            return _context2.abrupt("return", response);

          case 7:
            body = response.body;

            if (body) {
              _context2.next = 10;
              break;
            }

            return _context2.abrupt("return", response);

          case 10:
            contentLength = response.headers.get('content-length') || 0;
            totalBytes = contentLength && parseInt(contentLength);

            if (contentLength > 0) {
              _context2.next = 14;
              break;
            }

            return _context2.abrupt("return", response);

          case 14:
            if (!(typeof ReadableStream === 'undefined' || !body.getReader)) {
              _context2.next = 16;
              break;
            }

            return _context2.abrupt("return", response);

          case 16:
            progressStream = new ReadableStream({
              start: function start(controller) {
                return (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {
                  var reader;
                  return _regenerator.default.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          reader = body.getReader();
                          _context.next = 3;
                          return read(controller, reader, 0, totalBytes, onProgress, onDone, onError);

                        case 3:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee);
                }))();
              }
            });
            return _context2.abrupt("return", new Response(progressStream));

          case 18:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _fetchProgress.apply(this, arguments);
}

function read(_x3, _x4, _x5, _x6, _x7, _x8, _x9) {
  return _read.apply(this, arguments);
}

function _read() {
  _read = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError) {
    var _yield$reader$read, done, value, percent;

    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.prev = 0;
            _context3.next = 3;
            return reader.read();

          case 3:
            _yield$reader$read = _context3.sent;
            done = _yield$reader$read.done;
            value = _yield$reader$read.value;

            if (!done) {
              _context3.next = 10;
              break;
            }

            onDone();
            controller.close();
            return _context3.abrupt("return");

          case 10:
            loadedBytes += value.byteLength;
            percent = Math.round(loadedBytes / totalBytes * 100);
            onProgress(percent, {
              loadedBytes: loadedBytes,
              totalBytes: totalBytes
            });
            controller.enqueue(value);
            _context3.next = 16;
            return read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError);

          case 16:
            _context3.next = 22;
            break;

          case 18:
            _context3.prev = 18;
            _context3.t0 = _context3["catch"](0);
            controller.error(_context3.t0);
            onError(_context3.t0);

          case 22:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[0, 18]]);
  }));
  return _read.apply(this, arguments);
}

},{"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],65:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseMIMEType = parseMIMEType;
exports.parseMIMETypeFromURL = parseMIMETypeFromURL;
var DATA_URL_PATTERN = /^data:([-\w.]+\/[-\w.+]+)(;|,)/;
var MIME_TYPE_PATTERN = /^([-\w.]+\/[-\w.+]+)/;

function parseMIMEType(mimeString) {
  var matches = MIME_TYPE_PATTERN.exec(mimeString);

  if (matches) {
    return matches[1];
  }

  return mimeString;
}

function parseMIMETypeFromURL(url) {
  var matches = DATA_URL_PATTERN.exec(url);

  if (matches) {
    return matches[1];
  }

  return '';
}

},{}],66:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getResourceUrlAndType = getResourceUrlAndType;
exports.getResourceContentLength = getResourceContentLength;

var _isType = require("../../javascript-utils/is-type");

var _mimeTypeUtils = require("./mime-type-utils");

var QUERY_STRING_PATTERN = /\?.*/;

function getResourceUrlAndType(resource) {
  if ((0, _isType.isResponse)(resource)) {
    var url = stripQueryString(resource.url || '');
    var contentTypeHeader = resource.headers.get('content-type') || '';
    return {
      url: url,
      type: (0, _mimeTypeUtils.parseMIMEType)(contentTypeHeader) || (0, _mimeTypeUtils.parseMIMETypeFromURL)(url)
    };
  }

  if ((0, _isType.isBlob)(resource)) {
    return {
      url: stripQueryString(resource.name || ''),
      type: resource.type || ''
    };
  }

  if (typeof resource === 'string') {
    return {
      url: stripQueryString(resource),
      type: (0, _mimeTypeUtils.parseMIMETypeFromURL)(resource)
    };
  }

  return {
    url: '',
    type: ''
  };
}

function getResourceContentLength(resource) {
  if ((0, _isType.isResponse)(resource)) {
    return resource.headers['content-length'] || -1;
  }

  if ((0, _isType.isBlob)(resource)) {
    return resource.size;
  }

  if (typeof resource === 'string') {
    return resource.length;
  }

  if (resource instanceof ArrayBuffer) {
    return resource.byteLength;
  }

  if (ArrayBuffer.isView(resource)) {
    return resource.byteLength;
  }

  return -1;
}

function stripQueryString(url) {
  return url.replace(QUERY_STRING_PATTERN, '');
}

},{"../../javascript-utils/is-type":42,"./mime-type-utils":65}],67:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeResponse = makeResponse;
exports.checkResponse = checkResponse;
exports.checkResponseSync = checkResponseSync;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _isType = require("../../javascript-utils/is-type");

var _resourceUtils = require("./resource-utils");

function makeResponse(_x) {
  return _makeResponse.apply(this, arguments);
}

function _makeResponse() {
  _makeResponse = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(resource) {
    var headers, contentLength, _getResourceUrlAndTyp, url, type, initialDataUrl, response;

    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(0, _isType.isResponse)(resource)) {
              _context.next = 2;
              break;
            }

            return _context.abrupt("return", resource);

          case 2:
            headers = {};
            contentLength = (0, _resourceUtils.getResourceContentLength)(resource);

            if (contentLength >= 0) {
              headers['content-length'] = String(contentLength);
            }

            _getResourceUrlAndTyp = (0, _resourceUtils.getResourceUrlAndType)(resource), url = _getResourceUrlAndTyp.url, type = _getResourceUrlAndTyp.type;

            if (type) {
              headers['content-type'] = type;
            }

            _context.next = 9;
            return getInitialDataUrl(resource);

          case 9:
            initialDataUrl = _context.sent;

            if (initialDataUrl) {
              headers['x-first-bytes'] = initialDataUrl;
            }

            if (typeof resource === 'string') {
              resource = new TextEncoder().encode(resource);
            }

            response = new Response(resource, {
              headers: headers
            });
            Object.defineProperty(response, 'url', {
              value: url
            });
            return _context.abrupt("return", response);

          case 15:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _makeResponse.apply(this, arguments);
}

function checkResponse(_x2) {
  return _checkResponse.apply(this, arguments);
}

function _checkResponse() {
  _checkResponse = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(response) {
    var message;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (response.ok) {
              _context2.next = 5;
              break;
            }

            _context2.next = 3;
            return getResponseError(response);

          case 3:
            message = _context2.sent;
            throw new Error(message);

          case 5:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _checkResponse.apply(this, arguments);
}

function checkResponseSync(response) {
  if (!response.ok) {
    var message = "".concat(response.status, " ").concat(response.statusText);
    message = message.length > 60 ? "".concat(message.slice(60), "...") : message;
    throw new Error(message);
  }
}

function getResponseError(_x3) {
  return _getResponseError.apply(this, arguments);
}

function _getResponseError() {
  _getResponseError = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(response) {
    var message, contentType, text;
    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            message = "Failed to fetch resource ".concat(response.url, " (").concat(response.status, "): ");
            _context3.prev = 1;
            contentType = response.headers.get('Content-Type');
            text = response.statusText;

            if (!contentType.includes('application/json')) {
              _context3.next = 11;
              break;
            }

            _context3.t0 = text;
            _context3.t1 = " ";
            _context3.next = 9;
            return response.text();

          case 9:
            _context3.t2 = _context3.sent;
            text = _context3.t0 += _context3.t1.concat.call(_context3.t1, _context3.t2);

          case 11:
            message += text;
            message = message.length > 60 ? "".concat(message.slice(60), "...") : message;
            _context3.next = 17;
            break;

          case 15:
            _context3.prev = 15;
            _context3.t3 = _context3["catch"](1);

          case 17:
            return _context3.abrupt("return", message);

          case 18:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[1, 15]]);
  }));
  return _getResponseError.apply(this, arguments);
}

function getInitialDataUrl(_x4) {
  return _getInitialDataUrl.apply(this, arguments);
}

function _getInitialDataUrl() {
  _getInitialDataUrl = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee4(resource) {
    var INITIAL_DATA_LENGTH, blobSlice, slice, base64;
    return _regenerator.default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            INITIAL_DATA_LENGTH = 5;

            if (!(typeof resource === 'string')) {
              _context4.next = 3;
              break;
            }

            return _context4.abrupt("return", "data:,".concat(resource.slice(0, INITIAL_DATA_LENGTH)));

          case 3:
            if (!(resource instanceof Blob)) {
              _context4.next = 8;
              break;
            }

            blobSlice = resource.slice(0, 5);
            _context4.next = 7;
            return new Promise(function (resolve) {
              var reader = new FileReader();

              reader.onload = function (event) {
                var _event$target;

                return resolve(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);
              };

              reader.readAsDataURL(blobSlice);
            });

          case 7:
            return _context4.abrupt("return", _context4.sent);

          case 8:
            if (!(resource instanceof ArrayBuffer)) {
              _context4.next = 12;
              break;
            }

            slice = resource.slice(0, INITIAL_DATA_LENGTH);
            base64 = arrayBufferToBase64(slice);
            return _context4.abrupt("return", "data:base64,".concat(base64));

          case 12:
            return _context4.abrupt("return", null);

          case 13:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _getInitialDataUrl.apply(this, arguments);
}

function arrayBufferToBase64(buffer) {
  var binary = '';
  var bytes = new Uint8Array(buffer);

  for (var i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }

  return btoa(binary);
}

},{"../../javascript-utils/is-type":42,"./resource-utils":66,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],68:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NullLoader = exports.NullWorkerLoader = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _awaitAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/awaitAsyncGenerator"));

var _wrapAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapAsyncGenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

var VERSION = typeof "3.0.9" !== 'undefined' ? "3.0.9" : 'latest';
var NullWorkerLoader = {
  name: 'Null loader',
  id: 'null',
  module: 'core',
  version: VERSION,
  worker: true,
  mimeTypes: ['application/x.empty'],
  extensions: ['null'],
  tests: [function () {
    return false;
  }],
  options: {
    null: {}
  }
};
exports.NullWorkerLoader = NullWorkerLoader;
var NullLoader = {
  name: 'Null loader',
  id: 'null',
  module: 'core',
  version: VERSION,
  mimeTypes: ['application/x.empty'],
  extensions: ['null'],
  parse: function () {
    var _parse = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(arrayBuffer) {
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", arrayBuffer);

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function parse(_x2) {
      return _parse.apply(this, arguments);
    }

    return parse;
  }(),
  parseSync: function parseSync(arrayBuffer) {
    return arrayBuffer;
  },
  parseInBatches: function () {
    var _generator = (0, _wrapAsyncGenerator2.default)(_regenerator.default.mark(function _callee2(asyncIterator) {
      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, batch;

      return _regenerator.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _context2.prev = 2;
              _iterator = (0, _asyncIterator2.default)(asyncIterator);

            case 4:
              _context2.next = 6;
              return (0, _awaitAsyncGenerator2.default)(_iterator.next());

            case 6:
              _step = _context2.sent;
              _iteratorNormalCompletion = _step.done;
              _context2.next = 10;
              return (0, _awaitAsyncGenerator2.default)(_step.value);

            case 10:
              _value = _context2.sent;

              if (_iteratorNormalCompletion) {
                _context2.next = 18;
                break;
              }

              batch = _value;
              _context2.next = 15;
              return batch;

            case 15:
              _iteratorNormalCompletion = true;
              _context2.next = 4;
              break;

            case 18:
              _context2.next = 24;
              break;

            case 20:
              _context2.prev = 20;
              _context2.t0 = _context2["catch"](2);
              _didIteratorError = true;
              _iteratorError = _context2.t0;

            case 24:
              _context2.prev = 24;
              _context2.prev = 25;

              if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
                _context2.next = 29;
                break;
              }

              _context2.next = 29;
              return (0, _awaitAsyncGenerator2.default)(_iterator.return());

            case 29:
              _context2.prev = 29;

              if (!_didIteratorError) {
                _context2.next = 32;
                break;
              }

              throw _iteratorError;

            case 32:
              return _context2.finish(29);

            case 33:
              return _context2.finish(24);

            case 34:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[2, 20, 24, 34], [25,, 29, 33]]);
    }));

    function generator(_x) {
      return _generator.apply(this, arguments);
    }

    return generator;
  }(),
  tests: [function () {
    return false;
  }],
  options: {
    null: {}
  }
};
exports.NullLoader = NullLoader;

},{"@babel/runtime/helpers/asyncIterator":9,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/awaitAsyncGenerator":11,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/wrapAsyncGenerator":31,"@babel/runtime/regenerator":33}],69:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._typecheckCSVLoader = exports.CSVLoader = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _schema = require("@loaders.gl/schema");

var _papaparse = _interopRequireDefault(require("./libs/papaparse"));

var _asyncIteratorStreamer = _interopRequireDefault(require("./lib/async-iterator-streamer"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var VERSION = typeof "3.0.9" !== 'undefined' ? "3.0.9" : 'latest';
var DEFAULT_CSV_LOADER_OPTIONS = {
  csv: {
    shape: 'object-row-table',
    optimizeMemoryUsage: false,
    header: 'auto',
    columnPrefix: 'column',
    quoteChar: '"',
    escapeChar: '"',
    dynamicTyping: true,
    comments: false,
    skipEmptyLines: true,
    delimitersToGuess: [',', '\t', '|', ';']
  }
};
var CSVLoader = {
  id: 'csv',
  module: 'csv',
  name: 'CSV',
  version: VERSION,
  extensions: ['csv'],
  mimeTypes: ['text/csv'],
  category: 'table',
  parse: function () {
    var _parse = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(arrayBuffer, options) {
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", parseCSV(new TextDecoder().decode(arrayBuffer), options));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function parse(_x, _x2) {
      return _parse.apply(this, arguments);
    }

    return parse;
  }(),
  parseText: function parseText(text, options) {
    return parseCSV(text, options);
  },
  parseInBatches: parseCSVInBatches,
  options: DEFAULT_CSV_LOADER_OPTIONS
};
exports.CSVLoader = CSVLoader;

function parseCSV(_x3, _x4) {
  return _parseCSV.apply(this, arguments);
}

function _parseCSV() {
  _parseCSV = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(csvText, options) {
    var csvOptions, firstRow, header, parseWithHeader, papaparseConfig, result, rows, headerRow;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            csvOptions = _objectSpread(_objectSpread({}, DEFAULT_CSV_LOADER_OPTIONS.csv), options === null || options === void 0 ? void 0 : options.csv);
            firstRow = readFirstRow(csvText);
            header = csvOptions.header === 'auto' ? isHeaderRow(firstRow) : Boolean(csvOptions.header);
            parseWithHeader = header;
            papaparseConfig = _objectSpread(_objectSpread({}, csvOptions), {}, {
              header: parseWithHeader,
              download: false,
              transformHeader: parseWithHeader ? duplicateColumnTransformer() : undefined,
              error: function error(e) {
                throw new Error(e);
              }
            });
            result = _papaparse.default.parse(csvText, papaparseConfig);
            rows = result.data;
            headerRow = result.meta.fields || generateHeader(csvOptions.columnPrefix, firstRow.length);
            _context2.t0 = csvOptions.shape;
            _context2.next = _context2.t0 === 'object-row-table' ? 11 : _context2.t0 === 'array-row-table' ? 13 : 15;
            break;

          case 11:
            rows = rows.map(function (row) {
              return Array.isArray(row) ? (0, _schema.convertToObjectRow)(row, headerRow) : row;
            });
            return _context2.abrupt("break", 15);

          case 13:
            rows = rows.map(function (row) {
              return Array.isArray(row) ? row : (0, _schema.convertToArrayRow)(row, headerRow);
            });
            return _context2.abrupt("break", 15);

          case 15:
            return _context2.abrupt("return", rows);

          case 16:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _parseCSV.apply(this, arguments);
}

function parseCSVInBatches(asyncIterator, options) {
  var _options;

  options = _objectSpread({}, options);

  if (options.batchSize === 'auto') {
    options.batchSize = 4000;
  }

  var csvOptions = _objectSpread(_objectSpread({}, DEFAULT_CSV_LOADER_OPTIONS.csv), (_options = options) === null || _options === void 0 ? void 0 : _options.csv);

  var asyncQueue = new _schema.AsyncQueue();
  var isFirstRow = true;
  var headerRow = null;
  var tableBatchBuilder = null;
  var schema = null;

  var config = _objectSpread(_objectSpread({}, csvOptions), {}, {
    header: false,
    download: false,
    chunkSize: 1024 * 1024 * 5,
    skipEmptyLines: false,
    step: function step(results) {
      var row = results.data;

      if (csvOptions.skipEmptyLines) {
        var collapsedRow = row.flat().join('').trim();

        if (collapsedRow === '') {
          return;
        }
      }

      var bytesUsed = results.meta.cursor;

      if (isFirstRow && !headerRow) {
        var header = csvOptions.header === 'auto' ? isHeaderRow(row) : Boolean(csvOptions.header);

        if (header) {
          headerRow = row.map(duplicateColumnTransformer());
          return;
        }
      }

      if (isFirstRow) {
        isFirstRow = false;

        if (!headerRow) {
          headerRow = generateHeader(csvOptions.columnPrefix, row.length);
        }

        schema = deduceSchema(row, headerRow);
      }

      if (csvOptions.optimizeMemoryUsage) {
        row = JSON.parse(JSON.stringify(row));
      }

      tableBatchBuilder = tableBatchBuilder || new _schema.TableBatchBuilder(schema, _objectSpread({
        shape: csvOptions.shape || 'array-row-table'
      }, options));

      try {
        tableBatchBuilder.addRow(row);
        var batch = tableBatchBuilder && tableBatchBuilder.getFullBatch({
          bytesUsed: bytesUsed
        });

        if (batch) {
          asyncQueue.enqueue(batch);
        }
      } catch (error) {
        asyncQueue.enqueue(error);
      }
    },
    complete: function complete(results) {
      try {
        var bytesUsed = results.meta.cursor;
        var batch = tableBatchBuilder && tableBatchBuilder.getFinalBatch({
          bytesUsed: bytesUsed
        });

        if (batch) {
          asyncQueue.enqueue(batch);
        }
      } catch (error) {
        asyncQueue.enqueue(error);
      }

      asyncQueue.close();
    }
  });

  _papaparse.default.parse(asyncIterator, config, _asyncIteratorStreamer.default);

  return asyncQueue;
}

function isHeaderRow(row) {
  return row && row.every(function (value) {
    return typeof value === 'string';
  });
}

function readFirstRow(csvText) {
  var result = _papaparse.default.parse(csvText, {
    download: false,
    dynamicTyping: true,
    preview: 1
  });

  return result.data[0];
}

function duplicateColumnTransformer() {
  var observedColumns = new Set();
  return function (col) {
    var colName = col;
    var counter = 1;

    while (observedColumns.has(colName)) {
      colName = "".concat(col, ".").concat(counter);
      counter++;
    }

    observedColumns.add(colName);
    return colName;
  };
}

function generateHeader(columnPrefix) {
  var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var headers = [];

  for (var i = 0; i < count; i++) {
    headers.push("".concat(columnPrefix).concat(i + 1));
  }

  return headers;
}

function deduceSchema(row, headerRow) {
  var schema = headerRow ? {} : [];

  for (var i = 0; i < row.length; i++) {
    var columnName = headerRow && headerRow[i] || i;
    var value = row[i];

    switch ((0, _typeof2.default)(value)) {
      case 'number':
      case 'boolean':
        schema[columnName] = {
          name: String(columnName),
          index: i,
          type: Float32Array
        };
        break;

      case 'string':
      default:
        schema[columnName] = {
          name: String(columnName),
          index: i,
          type: Array
        };
    }
  }

  return schema;
}

var _typecheckCSVLoader = CSVLoader;
exports._typecheckCSVLoader = _typecheckCSVLoader;

},{"./lib/async-iterator-streamer":71,"./libs/papaparse":72,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"@babel/runtime/regenerator":33,"@loaders.gl/schema":92}],70:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "CSVLoader", {
  enumerable: true,
  get: function get() {
    return _csvLoader.CSVLoader;
  }
});

var _csvLoader = require("./csv-loader");

},{"./csv-loader":69}],71:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = AsyncIteratorStreamer;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

var _papaparse = _interopRequireDefault(require("../libs/papaparse"));

var ChunkStreamer = _papaparse.default.ChunkStreamer;

function AsyncIteratorStreamer(config) {
  config = config || {};
  ChunkStreamer.call(this, config);
  this.textDecoder = new TextDecoder(this._config.encoding);

  this.stream = function () {
    var _ref = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(asyncIterator) {
      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk;

      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              this._input = asyncIterator;
              _context.prev = 1;
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _context.prev = 4;
              _iterator = (0, _asyncIterator2.default)(asyncIterator);

            case 6:
              _context.next = 8;
              return _iterator.next();

            case 8:
              _step = _context.sent;
              _iteratorNormalCompletion = _step.done;
              _context.next = 12;
              return _step.value;

            case 12:
              _value = _context.sent;

              if (_iteratorNormalCompletion) {
                _context.next = 19;
                break;
              }

              chunk = _value;
              this.parseChunk(this.getStringChunk(chunk));

            case 16:
              _iteratorNormalCompletion = true;
              _context.next = 6;
              break;

            case 19:
              _context.next = 25;
              break;

            case 21:
              _context.prev = 21;
              _context.t0 = _context["catch"](4);
              _didIteratorError = true;
              _iteratorError = _context.t0;

            case 25:
              _context.prev = 25;
              _context.prev = 26;

              if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
                _context.next = 30;
                break;
              }

              _context.next = 30;
              return _iterator.return();

            case 30:
              _context.prev = 30;

              if (!_didIteratorError) {
                _context.next = 33;
                break;
              }

              throw _iteratorError;

            case 33:
              return _context.finish(30);

            case 34:
              return _context.finish(25);

            case 35:
              this._finished = true;
              this.parseChunk('');
              _context.next = 42;
              break;

            case 39:
              _context.prev = 39;
              _context.t1 = _context["catch"](1);

              this._sendError(_context.t1);

            case 42:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[1, 39], [4, 21, 25, 35], [26,, 30, 34]]);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }();

  this._nextChunk = function nextChunk() {};

  this.getStringChunk = function (chunk) {
    return typeof chunk === 'string' ? chunk : this.textDecoder.decode(chunk, {
      stream: true
    });
  };
}

AsyncIteratorStreamer.prototype = Object.create(ChunkStreamer.prototype);
AsyncIteratorStreamer.prototype.constructor = AsyncIteratorStreamer;

},{"../libs/papaparse":72,"@babel/runtime/helpers/asyncIterator":9,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],72:[function(require,module,exports){
// This is a fork of papaparse
// https://github.com/mholt/PapaParse
/* @license
Papa Parse
v5.0.0-beta.0
https://github.com/mholt/PapaParse
License: MIT
*/
// FORK SUMMARY:
// - Adopt ES6 exports
// - Implement new AsyncIteratorStreamer
// - Remove non Async Iterator streamers (can all be handled by new streamer)
// - Remove unused Worker support (loaders.gl worker system used instead)
// - Remove unused jQuery plugin support

/* eslint-disable */
// @ts-nocheck
var global = (function() {
  // alternative method, similar to `Function('return this')()`
  // but without using `eval` (which is disabled when
  // using Content Security Policy).

  if (typeof self !== 'undefined') {
    return self;
  }
  if (typeof window !== 'undefined') {
    return window;
  }
  if (typeof global !== 'undefined') {
    return global;
  }

  // When running tests none of the above have been defined
  return {};
})();

var IS_PAPA_WORKER = false;

var Papa = {};
module.exports = Papa;
Papa.parse = CsvToJson;
Papa.unparse = JsonToCsv;

Papa.RECORD_SEP = String.fromCharCode(30);
Papa.UNIT_SEP = String.fromCharCode(31);
Papa.BYTE_ORDER_MARK = '\ufeff';
Papa.BAD_DELIMITERS = ['\r', '\n', '"', Papa.BYTE_ORDER_MARK];
Papa.WORKERS_SUPPORTED = false; // !IS_WORKER && !!global.Worker;
Papa.NODE_STREAM_INPUT = 1;

// Configurable chunk sizes for local and remote files, respectively
Papa.LocalChunkSize = 1024 * 1024 * 10; // 10 MB
Papa.RemoteChunkSize = 1024 * 1024 * 5; // 5 MB
Papa.DefaultDelimiter = ','; // Used if not specified and detection fails

// Exposed for testing and development only
Papa.Parser = Parser;
Papa.ParserHandle = ParserHandle;

// BEGIN FORK
Papa.ChunkStreamer = ChunkStreamer;
Papa.StringStreamer = StringStreamer;
/*
Papa.NetworkStreamer = NetworkStreamer;
Papa.FileStreamer = FileStreamer;
Papa.ReadableStreamStreamer = ReadableStreamStreamer;
if (typeof PAPA_BROWSER_CONTEXT === 'undefined') {
  Papa.DuplexStreamStreamer = DuplexStreamStreamer;
}
*/
// END FORK

// BEGIN FORK
// Adds an argument to papa.parse
// function CsvToJson(_input, _config)
function CsvToJson(
  _input,
  _config,
  UserDefinedStreamer // BEGIN FORK
) {
  _config = _config || {};
  var dynamicTyping = _config.dynamicTyping || false;
  if (isFunction(dynamicTyping)) {
    _config.dynamicTypingFunction = dynamicTyping;
    // Will be filled on first row call
    dynamicTyping = {};
  }
  _config.dynamicTyping = dynamicTyping;

  _config.transform = isFunction(_config.transform) ? _config.transform : false;

  if (_config.worker && Papa.WORKERS_SUPPORTED) {
    var w = newWorker();

    w.userStep = _config.step;
    w.userChunk = _config.chunk;
    w.userComplete = _config.complete;
    w.userError = _config.error;

    _config.step = isFunction(_config.step);
    _config.chunk = isFunction(_config.chunk);
    _config.complete = isFunction(_config.complete);
    _config.error = isFunction(_config.error);
    delete _config.worker; // prevent infinite loop

    w.postMessage({
      input: _input,
      config: _config,
      workerId: w.id
    });

    return;
  }

  var streamer = null;
  /*
  if (_input === Papa.NODE_STREAM_INPUT && typeof PAPA_BROWSER_CONTEXT === 'undefined') {
    // create a node Duplex stream for use
    // with .pipe
    streamer = new DuplexStreamStreamer(_config);
    return streamer.getStream();
  } else
  */
  if (typeof _input === 'string') {
    // if (_config.download) streamer = new NetworkStreamer(_config);
    // else
    streamer = new StringStreamer(_config);
  }
  /*
  else if (_input.readable === true && isFunction(_input.read) && isFunction(_input.on)) {
    streamer = new ReadableStreamStreamer(_config);
  } else if ((global.File && _input instanceof File) || _input instanceof Object)
    // ...Safari. (see issue #106)
    streamer = new FileStreamer(_config);
  */

  // BEGIN FORK
  if (!streamer) {
    streamer = new UserDefinedStreamer(_config);
  }
  // END FORK

  return streamer.stream(_input);
}

function JsonToCsv(_input, _config) {
  // Default configuration

  /** whether to surround every datum with quotes */
  var _quotes = false;

  /** whether to write headers */
  var _writeHeader = true;

  /** delimiting character(s) */
  var _delimiter = ',';

  /** newline character(s) */
  var _newline = '\r\n';

  /** quote character */
  var _quoteChar = '"';

  /** escaped quote character, either "" or <config.escapeChar>" */
  var _escapedQuote = _quoteChar + _quoteChar;

  /** whether to skip empty lines */
  var _skipEmptyLines = false;

  /** the columns (keys) we expect when we unparse objects */
  var _columns = null;

  unpackConfig();

  var quoteCharRegex = new RegExp(escapeRegExp(_quoteChar), 'g');

  if (typeof _input === 'string') _input = JSON.parse(_input);

  if (Array.isArray(_input)) {
    if (!_input.length || Array.isArray(_input[0])) return serialize(null, _input, _skipEmptyLines);
    else if (typeof _input[0] === 'object')
      return serialize(_columns || objectKeys(_input[0]), _input, _skipEmptyLines);
  } else if (typeof _input === 'object') {
    if (typeof _input.data === 'string') _input.data = JSON.parse(_input.data);

    if (Array.isArray(_input.data)) {
      if (!_input.fields) _input.fields = _input.meta && _input.meta.fields;

      if (!_input.fields)
        _input.fields = Array.isArray(_input.data[0]) ? _input.fields : objectKeys(_input.data[0]);

      if (!Array.isArray(_input.data[0]) && typeof _input.data[0] !== 'object')
        _input.data = [_input.data]; // handles input like [1,2,3] or ['asdf']
    }

    return serialize(_input.fields || [], _input.data || [], _skipEmptyLines);
  }

  // Default (any valid paths should return before this)
  throw new Error('Unable to serialize unrecognized input');

  function unpackConfig() {
    if (typeof _config !== 'object') return;

    if (
      typeof _config.delimiter === 'string' &&
      !Papa.BAD_DELIMITERS.filter(function(value) {
        return _config.delimiter.indexOf(value) !== -1;
      }).length
    ) {
      _delimiter = _config.delimiter;
    }

    if (typeof _config.quotes === 'boolean' || Array.isArray(_config.quotes))
      _quotes = _config.quotes;

    if (typeof _config.skipEmptyLines === 'boolean' || typeof _config.skipEmptyLines === 'string')
      _skipEmptyLines = _config.skipEmptyLines;

    if (typeof _config.newline === 'string') _newline = _config.newline;

    if (typeof _config.quoteChar === 'string') _quoteChar = _config.quoteChar;

    if (typeof _config.header === 'boolean') _writeHeader = _config.header;

    if (Array.isArray(_config.columns)) {
      if (_config.columns.length === 0) throw new Error('Option columns is empty');

      _columns = _config.columns;
    }

    if (_config.escapeChar !== undefined) {
      _escapedQuote = _config.escapeChar + _quoteChar;
    }
  }

  /** Turns an object's keys into an array */
  function objectKeys(obj) {
    if (typeof obj !== 'object') return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    return keys;
  }

  /** The double for loop that iterates the data and writes out a CSV string including header row */
  function serialize(fields, data, skipEmptyLines) {
    var csv = '';

    if (typeof fields === 'string') fields = JSON.parse(fields);
    if (typeof data === 'string') data = JSON.parse(data);

    var hasHeader = Array.isArray(fields) && fields.length > 0;
    var dataKeyedByField = !Array.isArray(data[0]);

    // If there a header row, write it first
    if (hasHeader && _writeHeader) {
      for (var i = 0; i < fields.length; i++) {
        if (i > 0) csv += _delimiter;
        csv += safe(fields[i], i);
      }
      if (data.length > 0) csv += _newline;
    }

    // Then write out the data
    for (var row = 0; row < data.length; row++) {
      var maxCol = hasHeader ? fields.length : data[row].length;

      var emptyLine = false;
      var nullLine = hasHeader ? Object.keys(data[row]).length === 0 : data[row].length === 0;
      if (skipEmptyLines && !hasHeader) {
        emptyLine =
          skipEmptyLines === 'greedy'
            ? data[row].join('').trim() === ''
            : data[row].length === 1 && data[row][0].length === 0;
      }
      if (skipEmptyLines === 'greedy' && hasHeader) {
        var line = [];
        for (var c = 0; c < maxCol; c++) {
          var cx = dataKeyedByField ? fields[c] : c;
          line.push(data[row][cx]);
        }
        emptyLine = line.join('').trim() === '';
      }
      if (!emptyLine) {
        for (var col = 0; col < maxCol; col++) {
          if (col > 0 && !nullLine) csv += _delimiter;
          var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;
          csv += safe(data[row][colIdx], col);
        }
        if (row < data.length - 1 && (!skipEmptyLines || (maxCol > 0 && !nullLine))) {
          csv += _newline;
        }
      }
    }
    return csv;
  }

  /** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */
  function safe(str, col) {
    if (typeof str === 'undefined' || str === null) return '';

    if (str.constructor === Date) return JSON.stringify(str).slice(1, 25);

    str = str.toString().replace(quoteCharRegex, _escapedQuote);

    var needsQuotes =
      (typeof _quotes === 'boolean' && _quotes) ||
      (Array.isArray(_quotes) && _quotes[col]) ||
      hasAny(str, Papa.BAD_DELIMITERS) ||
      str.indexOf(_delimiter) > -1 ||
      str.charAt(0) === ' ' ||
      str.charAt(str.length - 1) === ' ';

    return needsQuotes ? _quoteChar + str + _quoteChar : str;
  }

  function hasAny(str, substrings) {
    for (var i = 0; i < substrings.length; i++) if (str.indexOf(substrings[i]) > -1) return true;
    return false;
  }
}

/** ChunkStreamer is the base prototype for various streamer implementations. */
function ChunkStreamer(config) {
  this._handle = null;
  this._finished = false;
  this._completed = false;
  this._input = null;
  this._baseIndex = 0;
  this._partialLine = '';
  this._rowCount = 0;
  this._start = 0;
  this._nextChunk = null;
  this.isFirstChunk = true;
  this._completeResults = {
    data: [],
    errors: [],
    meta: {}
  };
  replaceConfig.call(this, config);

  this.parseChunk = function(chunk, isFakeChunk) {
    // First chunk pre-processing
    if (this.isFirstChunk && isFunction(this._config.beforeFirstChunk)) {
      var modifiedChunk = this._config.beforeFirstChunk(chunk);
      if (modifiedChunk !== undefined) chunk = modifiedChunk;
    }
    this.isFirstChunk = false;

    // Rejoin the line we likely just split in two by chunking the file
    var aggregate = this._partialLine + chunk;
    this._partialLine = '';

    var results = this._handle.parse(aggregate, this._baseIndex, !this._finished);

    if (this._handle.paused() || this._handle.aborted()) return;

    var lastIndex = results.meta.cursor;

    if (!this._finished) {
      this._partialLine = aggregate.substring(lastIndex - this._baseIndex);
      this._baseIndex = lastIndex;
    }

    if (results && results.data) this._rowCount += results.data.length;

    var finishedIncludingPreview =
      this._finished || (this._config.preview && this._rowCount >= this._config.preview);

    if (IS_PAPA_WORKER) {
      global.postMessage({
        results: results,
        workerId: Papa.WORKER_ID,
        finished: finishedIncludingPreview
      });
    } else if (isFunction(this._config.chunk) && !isFakeChunk) {
      this._config.chunk(results, this._handle);
      if (this._handle.paused() || this._handle.aborted()) return;
      results = undefined;
      this._completeResults = undefined;
    }

    if (!this._config.step && !this._config.chunk) {
      this._completeResults.data = this._completeResults.data.concat(results.data);
      this._completeResults.errors = this._completeResults.errors.concat(results.errors);
      this._completeResults.meta = results.meta;
    }

    if (
      !this._completed &&
      finishedIncludingPreview &&
      isFunction(this._config.complete) &&
      (!results || !results.meta.aborted)
    ) {
      this._config.complete(this._completeResults, this._input);
      this._completed = true;
    }

    if (!finishedIncludingPreview && (!results || !results.meta.paused)) this._nextChunk();

    return results;
  };

  this._sendError = function(error) {
    if (isFunction(this._config.error)) this._config.error(error);
    else if (IS_PAPA_WORKER && this._config.error) {
      global.postMessage({
        workerId: Papa.WORKER_ID,
        error: error,
        finished: false
      });
    }
  };

  function replaceConfig(config) {
    // Deep-copy the config so we can edit it
    var configCopy = copy(config);
    configCopy.chunkSize = parseInt(configCopy.chunkSize); // parseInt VERY important so we don't concatenate strings!
    if (!config.step && !config.chunk) configCopy.chunkSize = null; // disable Range header if not streaming; bad values break IIS - see issue #196
    this._handle = new ParserHandle(configCopy);
    this._handle.streamer = this;
    this._config = configCopy; // persist the copy to the caller
  }
}
function StringStreamer(config) {
  config = config || {};
  ChunkStreamer.call(this, config);

  var remaining;
  this.stream = function(s) {
    remaining = s;
    return this._nextChunk();
  };
  this._nextChunk = function() {
    if (this._finished) return;
    var size = this._config.chunkSize;
    var chunk = size ? remaining.substr(0, size) : remaining;
    remaining = size ? remaining.substr(size) : '';
    this._finished = !remaining;
    return this.parseChunk(chunk);
  };
}
StringStreamer.prototype = Object.create(StringStreamer.prototype);
StringStreamer.prototype.constructor = StringStreamer;

// Use one ParserHandle per entire CSV file or string
function ParserHandle(_config) {
  // One goal is to minimize the use of regular expressions...
  var FLOAT = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i;
  var ISO_DATE = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/;

  var self = this;
  var _stepCounter = 0; // Number of times step was called (number of rows parsed)
  var _rowCounter = 0; // Number of rows that have been parsed so far
  var _input; // The input being parsed
  var _parser; // The core parser being used
  var _paused = false; // Whether we are paused or not
  var _aborted = false; // Whether the parser has aborted or not
  var _delimiterError; // Temporary state between delimiter detection and processing results
  var _fields = []; // Fields are from the header row of the input, if there is one
  var _results = {
    // The last results returned from the parser
    data: [],
    errors: [],
    meta: {}
  };

  if (isFunction(_config.step)) {
    var userStep = _config.step;
    _config.step = function(results) {
      _results = results;

      if (needsHeaderRow()) processResults();
      // only call user's step function after header row
      else {
        processResults();

        // It's possbile that this line was empty and there's no row here after all
        if (!_results.data || _results.data.length === 0) return;

        _stepCounter += results.data.length;
        if (_config.preview && _stepCounter > _config.preview) _parser.abort();
        else userStep(_results, self);
      }
    };
  }

  /**
   * Parses input. Most users won't need, and shouldn't mess with, the baseIndex
   * and ignoreLastRow parameters. They are used by streamers (wrapper functions)
   * when an input comes in multiple chunks, like from a file.
   */
  this.parse = function(input, baseIndex, ignoreLastRow) {
    var quoteChar = _config.quoteChar || '"';
    if (!_config.newline) _config.newline = guessLineEndings(input, quoteChar);

    _delimiterError = false;
    if (!_config.delimiter) {
      var delimGuess = guessDelimiter(
        input,
        _config.newline,
        _config.skipEmptyLines,
        _config.comments,
        _config.delimitersToGuess
      );
      if (delimGuess.successful) _config.delimiter = delimGuess.bestDelimiter;
      else {
        _delimiterError = true; // add error after parsing (otherwise it would be overwritten)
        _config.delimiter = Papa.DefaultDelimiter;
      }
      _results.meta.delimiter = _config.delimiter;
    } else if (isFunction(_config.delimiter)) {
      _config.delimiter = _config.delimiter(input);
      _results.meta.delimiter = _config.delimiter;
    }

    var parserConfig = copy(_config);
    if (_config.preview && _config.header) parserConfig.preview++; // to compensate for header row

    _input = input;
    _parser = new Parser(parserConfig);
    _results = _parser.parse(_input, baseIndex, ignoreLastRow);
    processResults();
    return _paused ? {meta: {paused: true}} : _results || {meta: {paused: false}};
  };

  this.paused = function() {
    return _paused;
  };

  this.pause = function() {
    _paused = true;
    _parser.abort();
    _input = _input.substr(_parser.getCharIndex());
  };

  this.resume = function() {
    _paused = false;
    self.streamer.parseChunk(_input, true);
  };

  this.aborted = function() {
    return _aborted;
  };

  this.abort = function() {
    _aborted = true;
    _parser.abort();
    _results.meta.aborted = true;
    if (isFunction(_config.complete)) _config.complete(_results);
    _input = '';
  };

  function testEmptyLine(s) {
    return _config.skipEmptyLines === 'greedy'
      ? s.join('').trim() === ''
      : s.length === 1 && s[0].length === 0;
  }

  function processResults() {
    if (_results && _delimiterError) {
      addError(
        'Delimiter',
        'UndetectableDelimiter',
        "Unable to auto-detect delimiting character; defaulted to '" + Papa.DefaultDelimiter + "'"
      );
      _delimiterError = false;
    }

    if (_config.skipEmptyLines) {
      for (var i = 0; i < _results.data.length; i++)
        if (testEmptyLine(_results.data[i])) _results.data.splice(i--, 1);
    }

    if (needsHeaderRow()) fillHeaderFields();

    return applyHeaderAndDynamicTypingAndTransformation();
  }

  function needsHeaderRow() {
    return _config.header && _fields.length === 0;
  }

  function fillHeaderFields() {
    if (!_results) return;

    function addHeder(header) {
      if (isFunction(_config.transformHeader)) header = _config.transformHeader(header);

      _fields.push(header);
    }

    if (Array.isArray(_results.data[0])) {
      for (var i = 0; needsHeaderRow() && i < _results.data.length; i++)
        _results.data[i].forEach(addHeder);

      _results.data.splice(0, 1);
    }
    // if _results.data[0] is not an array, we are in a step where _results.data is the row.
    else _results.data.forEach(addHeder);
  }

  function shouldApplyDynamicTyping(field) {
    // Cache function values to avoid calling it for each row
    if (_config.dynamicTypingFunction && _config.dynamicTyping[field] === undefined) {
      _config.dynamicTyping[field] = _config.dynamicTypingFunction(field);
    }
    return (_config.dynamicTyping[field] || _config.dynamicTyping) === true;
  }

  function parseDynamic(field, value) {
    if (shouldApplyDynamicTyping(field)) {
      if (value === 'true' || value === 'TRUE') return true;
      else if (value === 'false' || value === 'FALSE') return false;
      else if (FLOAT.test(value)) return parseFloat(value);
      else if (ISO_DATE.test(value)) return new Date(value);
      else return value === '' ? null : value;
    }
    return value;
  }

  function applyHeaderAndDynamicTypingAndTransformation() {
    if (!_results || !_results.data || (!_config.header && !_config.dynamicTyping && !_config.transform))
      return _results;

    function processRow(rowSource, i) {
      var row = _config.header ? {} : [];

      var j;
      for (j = 0; j < rowSource.length; j++) {
        var field = j;
        var value = rowSource[j];

        if (_config.header) field = j >= _fields.length ? '__parsed_extra' : _fields[j];

        if (_config.transform) value = _config.transform(value, field);

        value = parseDynamic(field, value);

        if (field === '__parsed_extra') {
          row[field] = row[field] || [];
          row[field].push(value);
        } else row[field] = value;
      }

      if (_config.header) {
        if (j > _fields.length)
          addError(
            'FieldMismatch',
            'TooManyFields',
            'Too many fields: expected ' + _fields.length + ' fields but parsed ' + j,
            _rowCounter + i
          );
        else if (j < _fields.length)
          addError(
            'FieldMismatch',
            'TooFewFields',
            'Too few fields: expected ' + _fields.length + ' fields but parsed ' + j,
            _rowCounter + i
          );
      }

      return row;
    }

    var incrementBy = 1;
    if (!_results.data[0] || Array.isArray(_results.data[0])) {
      _results.data = _results.data.map(processRow);
      incrementBy = _results.data.length;
    } else _results.data = processRow(_results.data, 0);

    if (_config.header && _results.meta) _results.meta.fields = _fields;

    _rowCounter += incrementBy;
    return _results;
  }

  function guessDelimiter(input, newline, skipEmptyLines, comments, delimitersToGuess) {
    var bestDelim, bestDelta, fieldCountPrevRow;

    delimitersToGuess = delimitersToGuess || [',', '\t', '|', ';', Papa.RECORD_SEP, Papa.UNIT_SEP];

    for (var i = 0; i < delimitersToGuess.length; i++) {
      var delim = delimitersToGuess[i];
      var delta = 0,
        avgFieldCount = 0,
        emptyLinesCount = 0;
      fieldCountPrevRow = undefined;

      var preview = new Parser({
        comments: comments,
        delimiter: delim,
        newline: newline,
        preview: 10
      }).parse(input);

      for (var j = 0; j < preview.data.length; j++) {
        if (skipEmptyLines && testEmptyLine(preview.data[j])) {
          emptyLinesCount++;
          continue;
        }
        var fieldCount = preview.data[j].length;
        avgFieldCount += fieldCount;

        if (typeof fieldCountPrevRow === 'undefined') {
          fieldCountPrevRow = 0;
          continue;
        } else if (fieldCount > 1) {
          delta += Math.abs(fieldCount - fieldCountPrevRow);
          fieldCountPrevRow = fieldCount;
        }
      }

      if (preview.data.length > 0) avgFieldCount /= preview.data.length - emptyLinesCount;

      if ((typeof bestDelta === 'undefined' || delta > bestDelta) && avgFieldCount > 1.99) {
        bestDelta = delta;
        bestDelim = delim;
      }
    }

    _config.delimiter = bestDelim;

    return {
      successful: !!bestDelim,
      bestDelimiter: bestDelim
    };
  }

  function guessLineEndings(input, quoteChar) {
    input = input.substr(0, 1024 * 1024); // max length 1 MB
    // Replace all the text inside quotes
    var re = new RegExp(escapeRegExp(quoteChar) + '([^]*?)' + escapeRegExp(quoteChar), 'gm');
    input = input.replace(re, '');

    var r = input.split('\r');

    var n = input.split('\n');

    var nAppearsFirst = n.length > 1 && n[0].length < r[0].length;

    if (r.length === 1 || nAppearsFirst) return '\n';

    var numWithN = 0;
    for (var i = 0; i < r.length; i++) {
      if (r[i][0] === '\n') numWithN++;
    }

    return numWithN >= r.length / 2 ? '\r\n' : '\r';
  }

  function addError(type, code, msg, row) {
    _results.errors.push({
      type: type,
      code: code,
      message: msg,
      row: row
    });
  }
}

/** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions */
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
}

/** The core parser implements speedy and correct CSV parsing */
function Parser(config) {
  // Unpack the config object
  config = config || {};
  var delim = config.delimiter;
  var newline = config.newline;
  var comments = config.comments;
  var step = config.step;
  var preview = config.preview;
  var fastMode = config.fastMode;
  var quoteChar;
  /** Allows for no quoteChar by setting quoteChar to undefined in config */
  if (config.quoteChar === undefined) {
    quoteChar = '"';
  } else {
    quoteChar = config.quoteChar;
  }
  var escapeChar = quoteChar;
  if (config.escapeChar !== undefined) {
    escapeChar = config.escapeChar;
  }

  // Delimiter must be valid
  if (typeof delim !== 'string' || Papa.BAD_DELIMITERS.indexOf(delim) > -1) delim = ',';

  // Comment character must be valid
  if (comments === delim) throw new Error('Comment character same as delimiter');
  else if (comments === true) comments = '#';
  else if (typeof comments !== 'string' || Papa.BAD_DELIMITERS.indexOf(comments) > -1)
    comments = false;

  // Newline must be valid: \r, \n, or \r\n
  if (newline !== '\n' && newline !== '\r' && newline !== '\r\n') newline = '\n';

  // We're gonna need these at the Parser scope
  var cursor = 0;
  var aborted = false;

  this.parse = function(input, baseIndex, ignoreLastRow) {
    // For some reason, in Chrome, this speeds things up (!?)
    if (typeof input !== 'string') throw new Error('Input must be a string');

    // We don't need to compute some of these every time parse() is called,
    // but having them in a more local scope seems to perform better
    var inputLen = input.length,
      delimLen = delim.length,
      newlineLen = newline.length,
      commentsLen = comments.length;
    var stepIsFunction = isFunction(step);

    // Establish starting state
    cursor = 0;
    var data = [],
      errors = [],
      row = [],
      lastCursor = 0;

    if (!input) return returnable();

    if (fastMode || (fastMode !== false && input.indexOf(quoteChar) === -1)) {
      var rows = input.split(newline);
      for (var i = 0; i < rows.length; i++) {
        row = rows[i];
        cursor += row.length;
        if (i !== rows.length - 1) cursor += newline.length;
        else if (ignoreLastRow) return returnable();
        if (comments && row.substr(0, commentsLen) === comments) continue;
        if (stepIsFunction) {
          data = [];
          pushRow(row.split(delim));
          doStep();
          if (aborted) return returnable();
        } else pushRow(row.split(delim));
        if (preview && i >= preview) {
          data = data.slice(0, preview);
          return returnable(true);
        }
      }
      return returnable();
    }

    var nextDelim = input.indexOf(delim, cursor);
    var nextNewline = input.indexOf(newline, cursor);
    var quoteCharRegex = new RegExp(escapeRegExp(escapeChar) + escapeRegExp(quoteChar), 'g');
    var quoteSearch;

    // Parser loop
    for (;;) {
      // Field has opening quote
      if (input[cursor] === quoteChar) {
        // Start our search for the closing quote where the cursor is
        quoteSearch = cursor;

        // Skip the opening quote
        cursor++;

        for (;;) {
          // Find closing quote
          quoteSearch = input.indexOf(quoteChar, quoteSearch + 1);

          //No other quotes are found - no other delimiters
          if (quoteSearch === -1) {
            if (!ignoreLastRow) {
              // No closing quote... what a pity
              errors.push({
                type: 'Quotes',
                code: 'MissingQuotes',
                message: 'Quoted field unterminated',
                row: data.length, // row has yet to be inserted
                index: cursor
              });
            }
            return finish();
          }

          // Closing quote at EOF
          if (quoteSearch === inputLen - 1) {
            var value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);
            return finish(value);
          }

          // If this quote is escaped, it's part of the data; skip it
          // If the quote character is the escape character, then check if the next character is the escape character
          if (quoteChar === escapeChar && input[quoteSearch + 1] === escapeChar) {
            quoteSearch++;
            continue;
          }

          // If the quote character is not the escape character, then check if the previous character was the escape character
          if (
            quoteChar !== escapeChar &&
            quoteSearch !== 0 &&
            input[quoteSearch - 1] === escapeChar
          ) {
            continue;
          }

          // Check up to nextDelim or nextNewline, whichever is closest
          var checkUpTo = nextNewline === -1 ? nextDelim : Math.min(nextDelim, nextNewline);
          var spacesBetweenQuoteAndDelimiter = extraSpaces(checkUpTo);

          // Closing quote followed by delimiter or 'unnecessary spaces + delimiter'
          if (input[quoteSearch + 1 + spacesBetweenQuoteAndDelimiter] === delim) {
            row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));
            cursor = quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen;
            nextDelim = input.indexOf(delim, cursor);
            nextNewline = input.indexOf(newline, cursor);

            if (stepIsFunction) {
              doStep();
              if (aborted) return returnable();
            }

            if (preview && data.length >= preview) return returnable(true);

            break;
          }

          var spacesBetweenQuoteAndNewLine = extraSpaces(nextNewline);

          // Closing quote followed by newline or 'unnecessary spaces + newLine'
          if (
            input.substr(quoteSearch + 1 + spacesBetweenQuoteAndNewLine, newlineLen) === newline
          ) {
            row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));
            saveRow(quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen);
            nextDelim = input.indexOf(delim, cursor); // because we may have skipped the nextDelim in the quoted field

            if (stepIsFunction) {
              doStep();
              if (aborted) return returnable();
            }

            if (preview && data.length >= preview) return returnable(true);

            break;
          }

          // Checks for valid closing quotes are complete (escaped quotes or quote followed by EOF/delimiter/newline) -- assume these quotes are part of an invalid text string
          errors.push({
            type: 'Quotes',
            code: 'InvalidQuotes',
            message: 'Trailing quote on quoted field is malformed',
            row: data.length, // row has yet to be inserted
            index: cursor
          });

          quoteSearch++;
          continue;
        }

        if (stepIsFunction) {
          doStep();
          if (aborted) return returnable();
        }

        if (preview && data.length >= preview) return returnable(true);
        continue;
      }

      // Comment found at start of new line
      if (comments && row.length === 0 && input.substr(cursor, commentsLen) === comments) {
        if (nextNewline === -1)
          // Comment ends at EOF
          return returnable();
        cursor = nextNewline + newlineLen;
        nextNewline = input.indexOf(newline, cursor);
        nextDelim = input.indexOf(delim, cursor);
        continue;
      }

      // Next delimiter comes before next newline, so we've reached end of field
      if (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1)) {
        row.push(input.substring(cursor, nextDelim));
        cursor = nextDelim + delimLen;
        nextDelim = input.indexOf(delim, cursor);
        continue;
      }

      // End of row
      if (nextNewline !== -1) {
        row.push(input.substring(cursor, nextNewline));
        saveRow(nextNewline + newlineLen);

        if (stepIsFunction) {
          doStep();
          if (aborted) return returnable();
        }

        if (preview && data.length >= preview) return returnable(true);

        continue;
      }

      break;
    }

    return finish();

    function pushRow(row) {
      data.push(row);
      lastCursor = cursor;
    }

    /**
     * checks if there are extra spaces after closing quote and given index without any text
     * if Yes, returns the number of spaces
     */
    function extraSpaces(index) {
      var spaceLength = 0;
      if (index !== -1) {
        var textBetweenClosingQuoteAndIndex = input.substring(quoteSearch + 1, index);
        if (textBetweenClosingQuoteAndIndex && textBetweenClosingQuoteAndIndex.trim() === '') {
          spaceLength = textBetweenClosingQuoteAndIndex.length;
        }
      }
      return spaceLength;
    }

    /**
     * Appends the remaining input from cursor to the end into
     * row, saves the row, calls step, and returns the results.
     */
    function finish(value) {
      if (ignoreLastRow) return returnable();
      if (typeof value === 'undefined') value = input.substr(cursor);
      row.push(value);
      cursor = inputLen; // important in case parsing is paused
      pushRow(row);
      if (stepIsFunction) doStep();
      return returnable();
    }

    /**
     * Appends the current row to the results. It sets the cursor
     * to newCursor and finds the nextNewline. The caller should
     * take care to execute user's step function and check for
     * preview and end parsing if necessary.
     */
    function saveRow(newCursor) {
      cursor = newCursor;
      pushRow(row);
      row = [];
      nextNewline = input.indexOf(newline, cursor);
    }

    /** Returns an object with the results, errors, and meta. */
    function returnable(stopped, step) {
      var isStep = step || false;
      return {
        data: isStep ? data[0] : data,
        errors: errors,
        meta: {
          delimiter: delim,
          linebreak: newline,
          aborted: aborted,
          truncated: !!stopped,
          cursor: lastCursor + (baseIndex || 0)
        }
      };
    }

    /** Executes the user's step function and resets data & errors. */
    function doStep() {
      step(returnable(undefined, true));
      data = [];
      errors = [];
    }
  };

  /** Sets the abort flag */
  this.abort = function() {
    aborted = true;
  };

  /** Gets the cursor position */
  this.getCharIndex = function() {
    return cursor;
  };
}

function notImplemented() {
  throw new Error('Not implemented.');
}

/** Makes a deep copy of an array or object (mostly) */
function copy(obj) {
  if (typeof obj !== 'object' || obj === null) return obj;
  var cpy = Array.isArray(obj) ? [] : {};
  for (var key in obj) cpy[key] = copy(obj[key]);
  return cpy;
}

function isFunction(func) {
  return typeof func === 'function';
}

},{}],73:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function get() {
    return _assert.assert;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function get() {
    return _globals.isBrowser;
  }
});
Object.defineProperty(exports, "isWorker", {
  enumerable: true,
  get: function get() {
    return _globals.isWorker;
  }
});
Object.defineProperty(exports, "nodeVersion", {
  enumerable: true,
  get: function get() {
    return _globals.nodeVersion;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function get() {
    return _globals.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function get() {
    return _globals.window;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function get() {
    return _globals.global;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function get() {
    return _globals.document;
  }
});
Object.defineProperty(exports, "createLoaderWorker", {
  enumerable: true,
  get: function get() {
    return _createLoaderWorker.createLoaderWorker;
  }
});
Object.defineProperty(exports, "parseWithWorker", {
  enumerable: true,
  get: function get() {
    return _parseWithWorker.parseWithWorker;
  }
});
Object.defineProperty(exports, "canParseWithWorker", {
  enumerable: true,
  get: function get() {
    return _parseWithWorker.canParseWithWorker;
  }
});
Object.defineProperty(exports, "parseJSON", {
  enumerable: true,
  get: function get() {
    return _parseJson.parseJSON;
  }
});
Object.defineProperty(exports, "toArrayBuffer", {
  enumerable: true,
  get: function get() {
    return _arrayBufferUtils.toArrayBuffer;
  }
});
Object.defineProperty(exports, "sliceArrayBuffer", {
  enumerable: true,
  get: function get() {
    return _arrayBufferUtils.sliceArrayBuffer;
  }
});
Object.defineProperty(exports, "concatenateArrayBuffers", {
  enumerable: true,
  get: function get() {
    return _arrayBufferUtils.concatenateArrayBuffers;
  }
});
Object.defineProperty(exports, "concatenateTypedArrays", {
  enumerable: true,
  get: function get() {
    return _arrayBufferUtils.concatenateTypedArrays;
  }
});
Object.defineProperty(exports, "compareArrayBuffers", {
  enumerable: true,
  get: function get() {
    return _arrayBufferUtils.compareArrayBuffers;
  }
});
Object.defineProperty(exports, "padToNBytes", {
  enumerable: true,
  get: function get() {
    return _memoryCopyUtils.padToNBytes;
  }
});
Object.defineProperty(exports, "copyToArray", {
  enumerable: true,
  get: function get() {
    return _memoryCopyUtils.copyToArray;
  }
});
Object.defineProperty(exports, "copyArrayBuffer", {
  enumerable: true,
  get: function get() {
    return _memoryCopyUtils.copyArrayBuffer;
  }
});
Object.defineProperty(exports, "copyPaddedArrayBufferToDataView", {
  enumerable: true,
  get: function get() {
    return _binaryCopyUtils.copyPaddedArrayBufferToDataView;
  }
});
Object.defineProperty(exports, "copyPaddedStringToDataView", {
  enumerable: true,
  get: function get() {
    return _binaryCopyUtils.copyPaddedStringToDataView;
  }
});
Object.defineProperty(exports, "padStringToByteAlignment", {
  enumerable: true,
  get: function get() {
    return _encodeUtils.padStringToByteAlignment;
  }
});
Object.defineProperty(exports, "copyStringToDataView", {
  enumerable: true,
  get: function get() {
    return _encodeUtils.copyStringToDataView;
  }
});
Object.defineProperty(exports, "copyBinaryToDataView", {
  enumerable: true,
  get: function get() {
    return _encodeUtils.copyBinaryToDataView;
  }
});
Object.defineProperty(exports, "getFirstCharacters", {
  enumerable: true,
  get: function get() {
    return _getFirstCharacters.getFirstCharacters;
  }
});
Object.defineProperty(exports, "getMagicString", {
  enumerable: true,
  get: function get() {
    return _getFirstCharacters.getMagicString;
  }
});
Object.defineProperty(exports, "makeTextEncoderIterator", {
  enumerable: true,
  get: function get() {
    return _textIterators.makeTextEncoderIterator;
  }
});
Object.defineProperty(exports, "makeTextDecoderIterator", {
  enumerable: true,
  get: function get() {
    return _textIterators.makeTextDecoderIterator;
  }
});
Object.defineProperty(exports, "makeLineIterator", {
  enumerable: true,
  get: function get() {
    return _textIterators.makeLineIterator;
  }
});
Object.defineProperty(exports, "makeNumberedLineIterator", {
  enumerable: true,
  get: function get() {
    return _textIterators.makeNumberedLineIterator;
  }
});
Object.defineProperty(exports, "forEach", {
  enumerable: true,
  get: function get() {
    return _asyncIteration.forEach;
  }
});
Object.defineProperty(exports, "concatenateArrayBuffersAsync", {
  enumerable: true,
  get: function get() {
    return _asyncIteration.concatenateArrayBuffersAsync;
  }
});
Object.defineProperty(exports, "RequestScheduler", {
  enumerable: true,
  get: function get() {
    return _requestScheduler.default;
  }
});
Object.defineProperty(exports, "setPathPrefix", {
  enumerable: true,
  get: function get() {
    return _fileAliases.setPathPrefix;
  }
});
Object.defineProperty(exports, "getPathPrefix", {
  enumerable: true,
  get: function get() {
    return _fileAliases.getPathPrefix;
  }
});
Object.defineProperty(exports, "resolvePath", {
  enumerable: true,
  get: function get() {
    return _fileAliases.resolvePath;
  }
});
Object.defineProperty(exports, "_addAliases", {
  enumerable: true,
  get: function get() {
    return _fileAliases.addAliases;
  }
});
Object.defineProperty(exports, "isBuffer", {
  enumerable: true,
  get: function get() {
    return _bufferUtils.isBuffer;
  }
});
Object.defineProperty(exports, "toBuffer", {
  enumerable: true,
  get: function get() {
    return _bufferUtils.toBuffer;
  }
});
Object.defineProperty(exports, "bufferToArrayBuffer", {
  enumerable: true,
  get: function get() {
    return _bufferUtils.bufferToArrayBuffer;
  }
});
Object.defineProperty(exports, "JSONLoader", {
  enumerable: true,
  get: function get() {
    return _jsonLoader.JSONLoader;
  }
});
exports.fs = exports.path = void 0;

var _assert = require("./lib/env-utils/assert");

var _globals = require("./lib/env-utils/globals");

var _createLoaderWorker = require("./lib/worker-loader-utils/create-loader-worker");

var _parseWithWorker = require("./lib/worker-loader-utils/parse-with-worker");

var _parseJson = require("./lib/parser-utils/parse-json");

var _arrayBufferUtils = require("./lib/binary-utils/array-buffer-utils");

var _memoryCopyUtils = require("./lib/binary-utils/memory-copy-utils");

var _binaryCopyUtils = require("./lib/binary-utils/binary-copy-utils");

var _encodeUtils = require("./lib/binary-utils/encode-utils");

var _getFirstCharacters = require("./lib/binary-utils/get-first-characters");

var _textIterators = require("./lib/iterators/text-iterators");

var _asyncIteration = require("./lib/iterators/async-iteration");

var _requestScheduler = _interopRequireDefault(require("./lib/request-utils/request-scheduler"));

var path = _interopRequireWildcard(require("./lib/path-utils/path"));

exports.path = path;

var _fileAliases = require("./lib/path-utils/file-aliases");

var fs = _interopRequireWildcard(require("./lib/node/fs"));

exports.fs = fs;

var _bufferUtils = require("./lib/binary-utils/buffer-utils");

var _jsonLoader = require("./json-loader");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

},{"./json-loader":74,"./lib/binary-utils/array-buffer-utils":75,"./lib/binary-utils/binary-copy-utils":76,"./lib/binary-utils/buffer-utils":77,"./lib/binary-utils/encode-utils":78,"./lib/binary-utils/get-first-characters":79,"./lib/binary-utils/memory-copy-utils":80,"./lib/env-utils/assert":81,"./lib/env-utils/globals":82,"./lib/iterators/async-iteration":83,"./lib/iterators/text-iterators":84,"./lib/node/fs":130,"./lib/parser-utils/parse-json":85,"./lib/path-utils/file-aliases":86,"./lib/path-utils/path":87,"./lib/request-utils/request-scheduler":88,"./lib/worker-loader-utils/create-loader-worker":89,"./lib/worker-loader-utils/parse-with-worker":90,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29}],74:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._typecheckJSONLoader = exports.JSONLoader = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var VERSION = typeof "3.0.9" !== 'undefined' ? "3.0.9" : 'latest';
var JSONLoader = {
  name: 'JSON',
  id: 'json',
  module: 'json',
  version: VERSION,
  extensions: ['json', 'geojson'],
  mimeTypes: ['application/json'],
  category: 'json',
  text: true,
  parseTextSync: parseTextSync,
  parse: function () {
    var _parse = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(arrayBuffer) {
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", parseTextSync(new TextDecoder().decode(arrayBuffer)));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    function parse(_x) {
      return _parse.apply(this, arguments);
    }

    return parse;
  }(),
  options: {}
};
exports.JSONLoader = JSONLoader;

function parseTextSync(text) {
  return JSON.parse(text);
}

var _typecheckJSONLoader = JSONLoader;
exports._typecheckJSONLoader = _typecheckJSONLoader;

},{"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],75:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof3 = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toArrayBuffer = toArrayBuffer;
exports.compareArrayBuffers = compareArrayBuffers;
exports.concatenateArrayBuffers = concatenateArrayBuffers;
exports.concatenateTypedArrays = concatenateTypedArrays;
exports.sliceArrayBuffer = sliceArrayBuffer;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var node = _interopRequireWildcard(require("../node/buffer-utils.node"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof3(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function toArrayBuffer(data) {
  if (node.toArrayBuffer) {
    data = node.toArrayBuffer(data);
  }

  if (data instanceof ArrayBuffer) {
    return data;
  }

  if (ArrayBuffer.isView(data)) {
    return data.buffer;
  }

  if (typeof data === 'string') {
    var text = data;
    var uint8Array = new TextEncoder().encode(text);
    return uint8Array.buffer;
  }

  if (data && (0, _typeof2.default)(data) === 'object' && data._toArrayBuffer) {
    return data._toArrayBuffer();
  }

  throw new Error('toArrayBuffer');
}

function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {
  byteLength = byteLength || arrayBuffer1.byteLength;

  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {
    return false;
  }

  var array1 = new Uint8Array(arrayBuffer1);
  var array2 = new Uint8Array(arrayBuffer2);

  for (var i = 0; i < array1.length; ++i) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }

  return true;
}

function concatenateArrayBuffers() {
  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
    sources[_key] = arguments[_key];
  }

  var sourceArrays = sources.map(function (source2) {
    return source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2;
  });
  var byteLength = sourceArrays.reduce(function (length, typedArray) {
    return length + typedArray.byteLength;
  }, 0);
  var result = new Uint8Array(byteLength);
  var offset = 0;

  var _iterator = _createForOfIteratorHelper(sourceArrays),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var sourceArray = _step.value;
      result.set(sourceArray, offset);
      offset += sourceArray.byteLength;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return result.buffer;
}

function concatenateTypedArrays() {
  for (var _len2 = arguments.length, typedArrays = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    typedArrays[_key2] = arguments[_key2];
  }

  var arrays = typedArrays;
  var TypedArrayConstructor = arrays && arrays.length > 1 && arrays[0].constructor || null;

  if (!TypedArrayConstructor) {
    throw new Error('"concatenateTypedArrays" - incorrect quantity of arguments or arguments have incompatible data types');
  }

  var sumLength = arrays.reduce(function (acc, value) {
    return acc + value.length;
  }, 0);
  var result = new TypedArrayConstructor(sumLength);
  var offset = 0;

  for (var _i = 0, _arrays = arrays; _i < _arrays.length; _i++) {
    var array = _arrays[_i];
    result.set(array, offset);
    offset += array.length;
  }

  return result;
}

function sliceArrayBuffer(arrayBuffer, byteOffset, byteLength) {
  var subArray = byteLength !== undefined ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer).subarray(byteOffset);
  var arrayCopy = new Uint8Array(subArray);
  return arrayCopy.buffer;
}

},{"../node/buffer-utils.node":130,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29}],76:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.copyPaddedArrayBufferToDataView = copyPaddedArrayBufferToDataView;
exports.copyPaddedStringToDataView = copyPaddedStringToDataView;

var _memoryCopyUtils = require("./memory-copy-utils");

function copyPaddedArrayBufferToDataView(dataView, byteOffset, sourceBuffer, padding) {
  var paddedLength = (0, _memoryCopyUtils.padToNBytes)(sourceBuffer.byteLength, padding);
  var padLength = paddedLength - sourceBuffer.byteLength;

  if (dataView) {
    var targetArray = new Uint8Array(dataView.buffer, dataView.byteOffset + byteOffset, sourceBuffer.byteLength);
    var sourceArray = new Uint8Array(sourceBuffer);
    targetArray.set(sourceArray);

    for (var i = 0; i < padLength; ++i) {
      dataView.setUint8(byteOffset + sourceBuffer.byteLength + i, 0x20);
    }
  }

  byteOffset += paddedLength;
  return byteOffset;
}

function copyPaddedStringToDataView(dataView, byteOffset, string, padding) {
  var textEncoder = new TextEncoder();
  var stringBuffer = textEncoder.encode(string);
  byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, stringBuffer, padding);
  return byteOffset;
}

},{"./memory-copy-utils":80}],77:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof3 = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isBuffer = isBuffer;
exports.toBuffer = toBuffer;
exports.bufferToArrayBuffer = bufferToArrayBuffer;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var node = _interopRequireWildcard(require("../node/buffer-utils.node"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof3(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function isBuffer(value) {
  return value && (0, _typeof2.default)(value) === 'object' && value.isBuffer;
}

function toBuffer(data) {
  return node.toBuffer ? node.toBuffer(data) : data;
}

function bufferToArrayBuffer(data) {
  if (node.toArrayBuffer) {
    return node.toArrayBuffer(data);
  }

  return data;
}

},{"../node/buffer-utils.node":130,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29}],78:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.padStringToByteAlignment = padStringToByteAlignment;
exports.copyStringToDataView = copyStringToDataView;
exports.copyBinaryToDataView = copyBinaryToDataView;

function padStringToByteAlignment(string, byteAlignment) {
  var length = string.length;
  var paddedLength = Math.ceil(length / byteAlignment) * byteAlignment;
  var padding = paddedLength - length;
  var whitespace = '';

  for (var i = 0; i < padding; ++i) {
    whitespace += ' ';
  }

  return string + whitespace;
}

function copyStringToDataView(dataView, byteOffset, string, byteLength) {
  if (dataView) {
    for (var i = 0; i < byteLength; i++) {
      dataView.setUint8(byteOffset + i, string.charCodeAt(i));
    }
  }

  return byteOffset + byteLength;
}

function copyBinaryToDataView(dataView, byteOffset, binary, byteLength) {
  if (dataView) {
    for (var i = 0; i < byteLength; i++) {
      dataView.setUint8(byteOffset + i, binary[i]);
    }
  }

  return byteOffset + byteLength;
}

},{}],79:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFirstCharacters = getFirstCharacters;
exports.getMagicString = getMagicString;

function getFirstCharacters(data) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;

  if (typeof data === 'string') {
    return data.slice(0, length);
  } else if (ArrayBuffer.isView(data)) {
    return getMagicString(data.buffer, data.byteOffset, length);
  } else if (data instanceof ArrayBuffer) {
    var byteOffset = 0;
    return getMagicString(data, byteOffset, length);
  }

  return '';
}

function getMagicString(arrayBuffer, byteOffset, length) {
  if (arrayBuffer.byteLength <= byteOffset + length) {
    return '';
  }

  var dataView = new DataView(arrayBuffer);
  var magic = '';

  for (var i = 0; i < length; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }

  return magic;
}

},{}],80:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.padToNBytes = padToNBytes;
exports.copyArrayBuffer = copyArrayBuffer;
exports.copyToArray = copyToArray;

var _assert = require("../env-utils/assert");

function padToNBytes(byteLength, padding) {
  (0, _assert.assert)(byteLength >= 0);
  (0, _assert.assert)(padding > 0);
  return byteLength + (padding - 1) & ~(padding - 1);
}

function copyArrayBuffer(targetBuffer, sourceBuffer, byteOffset) {
  var byteLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : sourceBuffer.byteLength;
  var targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);
  var sourceArray = new Uint8Array(sourceBuffer);
  targetArray.set(sourceArray);
  return targetBuffer;
}

function copyToArray(source, target, targetOffset) {
  var sourceArray;

  if (source instanceof ArrayBuffer) {
    sourceArray = new Uint8Array(source);
  } else {
    var srcByteOffset = source.byteOffset;
    var srcByteLength = source.byteLength;
    sourceArray = new Uint8Array(source.buffer || source.arrayBuffer, srcByteOffset, srcByteLength);
  }

  target.set(sourceArray, targetOffset);
  return targetOffset + padToNBytes(sourceArray.byteLength, 4);
}

},{"../env-utils/assert":81}],81:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assert = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'loader assertion failed.');
  }
}

},{}],82:[function(require,module,exports){
(function (process,global){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nodeVersion = exports.isWorker = exports.isBrowser = exports.document = exports.global = exports.window = exports.self = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};
var self_ = globals.self || globals.window || globals.global || {};
exports.self = self_;
var window_ = globals.window || globals.self || globals.global || {};
exports.window = window_;
var global_ = globals.global || globals.self || globals.window || {};
exports.global = global_;
var document_ = globals.document || {};
exports.document = document_;
var isBrowser = (typeof process === "undefined" ? "undefined" : (0, _typeof2.default)(process)) !== 'object' || String(process) !== '[object process]' || process.browser;
exports.isBrowser = isBrowser;
var isWorker = typeof importScripts === 'function';
exports.isWorker = isWorker;
var matches = typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);
var nodeVersion = matches && parseFloat(matches[1]) || 0;
exports.nodeVersion = nodeVersion;

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"_process":153}],83:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.forEach = forEach;
exports.concatenateArrayBuffersAsync = concatenateArrayBuffersAsync;
exports.concatenateStringsAsync = concatenateStringsAsync;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

var _arrayBufferUtils = require("../binary-utils/array-buffer-utils");

function forEach(_x, _x2) {
  return _forEach.apply(this, arguments);
}

function _forEach() {
  _forEach = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(iterator, visitor) {
    var _yield$iterator$next, done, value, cancel;

    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!true) {
              _context.next = 14;
              break;
            }

            _context.next = 3;
            return iterator.next();

          case 3:
            _yield$iterator$next = _context.sent;
            done = _yield$iterator$next.done;
            value = _yield$iterator$next.value;

            if (!done) {
              _context.next = 9;
              break;
            }

            iterator.return();
            return _context.abrupt("return");

          case 9:
            cancel = visitor(value);

            if (!cancel) {
              _context.next = 12;
              break;
            }

            return _context.abrupt("return");

          case 12:
            _context.next = 0;
            break;

          case 14:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _forEach.apply(this, arguments);
}

function concatenateArrayBuffersAsync(_x3) {
  return _concatenateArrayBuffersAsync.apply(this, arguments);
}

function _concatenateArrayBuffersAsync() {
  _concatenateArrayBuffersAsync = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(asyncIterator) {
    var arrayBuffers, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk;

    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            arrayBuffers = [];
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _context2.prev = 3;
            _iterator = (0, _asyncIterator2.default)(asyncIterator);

          case 5:
            _context2.next = 7;
            return _iterator.next();

          case 7:
            _step = _context2.sent;
            _iteratorNormalCompletion = _step.done;
            _context2.next = 11;
            return _step.value;

          case 11:
            _value = _context2.sent;

            if (_iteratorNormalCompletion) {
              _context2.next = 18;
              break;
            }

            chunk = _value;
            arrayBuffers.push(chunk);

          case 15:
            _iteratorNormalCompletion = true;
            _context2.next = 5;
            break;

          case 18:
            _context2.next = 24;
            break;

          case 20:
            _context2.prev = 20;
            _context2.t0 = _context2["catch"](3);
            _didIteratorError = true;
            _iteratorError = _context2.t0;

          case 24:
            _context2.prev = 24;
            _context2.prev = 25;

            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
              _context2.next = 29;
              break;
            }

            _context2.next = 29;
            return _iterator.return();

          case 29:
            _context2.prev = 29;

            if (!_didIteratorError) {
              _context2.next = 32;
              break;
            }

            throw _iteratorError;

          case 32:
            return _context2.finish(29);

          case 33:
            return _context2.finish(24);

          case 34:
            return _context2.abrupt("return", _arrayBufferUtils.concatenateArrayBuffers.apply(void 0, arrayBuffers));

          case 35:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[3, 20, 24, 34], [25,, 29, 33]]);
  }));
  return _concatenateArrayBuffersAsync.apply(this, arguments);
}

function concatenateStringsAsync(_x4) {
  return _concatenateStringsAsync.apply(this, arguments);
}

function _concatenateStringsAsync() {
  _concatenateStringsAsync = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee3(asyncIterator) {
    var strings, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, chunk;

    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            strings = [];
            _iteratorNormalCompletion2 = true;
            _didIteratorError2 = false;
            _context3.prev = 3;
            _iterator2 = (0, _asyncIterator2.default)(asyncIterator);

          case 5:
            _context3.next = 7;
            return _iterator2.next();

          case 7:
            _step2 = _context3.sent;
            _iteratorNormalCompletion2 = _step2.done;
            _context3.next = 11;
            return _step2.value;

          case 11:
            _value2 = _context3.sent;

            if (_iteratorNormalCompletion2) {
              _context3.next = 18;
              break;
            }

            chunk = _value2;
            strings.push(chunk);

          case 15:
            _iteratorNormalCompletion2 = true;
            _context3.next = 5;
            break;

          case 18:
            _context3.next = 24;
            break;

          case 20:
            _context3.prev = 20;
            _context3.t0 = _context3["catch"](3);
            _didIteratorError2 = true;
            _iteratorError2 = _context3.t0;

          case 24:
            _context3.prev = 24;
            _context3.prev = 25;

            if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {
              _context3.next = 29;
              break;
            }

            _context3.next = 29;
            return _iterator2.return();

          case 29:
            _context3.prev = 29;

            if (!_didIteratorError2) {
              _context3.next = 32;
              break;
            }

            throw _iteratorError2;

          case 32:
            return _context3.finish(29);

          case 33:
            return _context3.finish(24);

          case 34:
            return _context3.abrupt("return", strings.join(''));

          case 35:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[3, 20, 24, 34], [25,, 29, 33]]);
  }));
  return _concatenateStringsAsync.apply(this, arguments);
}

},{"../binary-utils/array-buffer-utils":75,"@babel/runtime/helpers/asyncIterator":9,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],84:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeTextDecoderIterator = makeTextDecoderIterator;
exports.makeTextEncoderIterator = makeTextEncoderIterator;
exports.makeLineIterator = makeLineIterator;
exports.makeNumberedLineIterator = makeNumberedLineIterator;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _awaitAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/awaitAsyncGenerator"));

var _wrapAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapAsyncGenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

function makeTextDecoderIterator(_x) {
  return _makeTextDecoderIterator.apply(this, arguments);
}

function _makeTextDecoderIterator() {
  _makeTextDecoderIterator = (0, _wrapAsyncGenerator2.default)(_regenerator.default.mark(function _callee(arrayBufferIterator) {
    var options,
        textDecoder,
        _iteratorNormalCompletion,
        _didIteratorError,
        _iteratorError,
        _iterator,
        _step,
        _value,
        arrayBuffer,
        _args = arguments;

    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
            textDecoder = new TextDecoder(undefined, options);
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _context.prev = 4;
            _iterator = (0, _asyncIterator2.default)(arrayBufferIterator);

          case 6:
            _context.next = 8;
            return (0, _awaitAsyncGenerator2.default)(_iterator.next());

          case 8:
            _step = _context.sent;
            _iteratorNormalCompletion = _step.done;
            _context.next = 12;
            return (0, _awaitAsyncGenerator2.default)(_step.value);

          case 12:
            _value = _context.sent;

            if (_iteratorNormalCompletion) {
              _context.next = 20;
              break;
            }

            arrayBuffer = _value;
            _context.next = 17;
            return typeof arrayBuffer === 'string' ? arrayBuffer : textDecoder.decode(arrayBuffer, {
              stream: true
            });

          case 17:
            _iteratorNormalCompletion = true;
            _context.next = 6;
            break;

          case 20:
            _context.next = 26;
            break;

          case 22:
            _context.prev = 22;
            _context.t0 = _context["catch"](4);
            _didIteratorError = true;
            _iteratorError = _context.t0;

          case 26:
            _context.prev = 26;
            _context.prev = 27;

            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
              _context.next = 31;
              break;
            }

            _context.next = 31;
            return (0, _awaitAsyncGenerator2.default)(_iterator.return());

          case 31:
            _context.prev = 31;

            if (!_didIteratorError) {
              _context.next = 34;
              break;
            }

            throw _iteratorError;

          case 34:
            return _context.finish(31);

          case 35:
            return _context.finish(26);

          case 36:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[4, 22, 26, 36], [27,, 31, 35]]);
  }));
  return _makeTextDecoderIterator.apply(this, arguments);
}

function makeTextEncoderIterator(_x2) {
  return _makeTextEncoderIterator.apply(this, arguments);
}

function _makeTextEncoderIterator() {
  _makeTextEncoderIterator = (0, _wrapAsyncGenerator2.default)(_regenerator.default.mark(function _callee2(textIterator) {
    var textEncoder, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, text;

    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            textEncoder = new TextEncoder();
            _iteratorNormalCompletion2 = true;
            _didIteratorError2 = false;
            _context2.prev = 3;
            _iterator2 = (0, _asyncIterator2.default)(textIterator);

          case 5:
            _context2.next = 7;
            return (0, _awaitAsyncGenerator2.default)(_iterator2.next());

          case 7:
            _step2 = _context2.sent;
            _iteratorNormalCompletion2 = _step2.done;
            _context2.next = 11;
            return (0, _awaitAsyncGenerator2.default)(_step2.value);

          case 11:
            _value2 = _context2.sent;

            if (_iteratorNormalCompletion2) {
              _context2.next = 19;
              break;
            }

            text = _value2;
            _context2.next = 16;
            return typeof text === 'string' ? textEncoder.encode(text) : text;

          case 16:
            _iteratorNormalCompletion2 = true;
            _context2.next = 5;
            break;

          case 19:
            _context2.next = 25;
            break;

          case 21:
            _context2.prev = 21;
            _context2.t0 = _context2["catch"](3);
            _didIteratorError2 = true;
            _iteratorError2 = _context2.t0;

          case 25:
            _context2.prev = 25;
            _context2.prev = 26;

            if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {
              _context2.next = 30;
              break;
            }

            _context2.next = 30;
            return (0, _awaitAsyncGenerator2.default)(_iterator2.return());

          case 30:
            _context2.prev = 30;

            if (!_didIteratorError2) {
              _context2.next = 33;
              break;
            }

            throw _iteratorError2;

          case 33:
            return _context2.finish(30);

          case 34:
            return _context2.finish(25);

          case 35:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[3, 21, 25, 35], [26,, 30, 34]]);
  }));
  return _makeTextEncoderIterator.apply(this, arguments);
}

function makeLineIterator(_x3) {
  return _makeLineIterator.apply(this, arguments);
}

function _makeLineIterator() {
  _makeLineIterator = (0, _wrapAsyncGenerator2.default)(_regenerator.default.mark(function _callee3(textIterator) {
    var previous, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _value3, textChunk, eolIndex, line;

    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            previous = '';
            _iteratorNormalCompletion3 = true;
            _didIteratorError3 = false;
            _context3.prev = 3;
            _iterator3 = (0, _asyncIterator2.default)(textIterator);

          case 5:
            _context3.next = 7;
            return (0, _awaitAsyncGenerator2.default)(_iterator3.next());

          case 7:
            _step3 = _context3.sent;
            _iteratorNormalCompletion3 = _step3.done;
            _context3.next = 11;
            return (0, _awaitAsyncGenerator2.default)(_step3.value);

          case 11:
            _value3 = _context3.sent;

            if (_iteratorNormalCompletion3) {
              _context3.next = 26;
              break;
            }

            textChunk = _value3;
            previous += textChunk;
            eolIndex = void 0;

          case 16:
            if (!((eolIndex = previous.indexOf('\n')) >= 0)) {
              _context3.next = 23;
              break;
            }

            line = previous.slice(0, eolIndex + 1);
            previous = previous.slice(eolIndex + 1);
            _context3.next = 21;
            return line;

          case 21:
            _context3.next = 16;
            break;

          case 23:
            _iteratorNormalCompletion3 = true;
            _context3.next = 5;
            break;

          case 26:
            _context3.next = 32;
            break;

          case 28:
            _context3.prev = 28;
            _context3.t0 = _context3["catch"](3);
            _didIteratorError3 = true;
            _iteratorError3 = _context3.t0;

          case 32:
            _context3.prev = 32;
            _context3.prev = 33;

            if (!(!_iteratorNormalCompletion3 && _iterator3.return != null)) {
              _context3.next = 37;
              break;
            }

            _context3.next = 37;
            return (0, _awaitAsyncGenerator2.default)(_iterator3.return());

          case 37:
            _context3.prev = 37;

            if (!_didIteratorError3) {
              _context3.next = 40;
              break;
            }

            throw _iteratorError3;

          case 40:
            return _context3.finish(37);

          case 41:
            return _context3.finish(32);

          case 42:
            if (!(previous.length > 0)) {
              _context3.next = 45;
              break;
            }

            _context3.next = 45;
            return previous;

          case 45:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[3, 28, 32, 42], [33,, 37, 41]]);
  }));
  return _makeLineIterator.apply(this, arguments);
}

function makeNumberedLineIterator(_x4) {
  return _makeNumberedLineIterator.apply(this, arguments);
}

function _makeNumberedLineIterator() {
  _makeNumberedLineIterator = (0, _wrapAsyncGenerator2.default)(_regenerator.default.mark(function _callee4(lineIterator) {
    var counter, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, _value4, line;

    return _regenerator.default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            counter = 1;
            _iteratorNormalCompletion4 = true;
            _didIteratorError4 = false;
            _context4.prev = 3;
            _iterator4 = (0, _asyncIterator2.default)(lineIterator);

          case 5:
            _context4.next = 7;
            return (0, _awaitAsyncGenerator2.default)(_iterator4.next());

          case 7:
            _step4 = _context4.sent;
            _iteratorNormalCompletion4 = _step4.done;
            _context4.next = 11;
            return (0, _awaitAsyncGenerator2.default)(_step4.value);

          case 11:
            _value4 = _context4.sent;

            if (_iteratorNormalCompletion4) {
              _context4.next = 20;
              break;
            }

            line = _value4;
            _context4.next = 16;
            return {
              counter: counter,
              line: line
            };

          case 16:
            counter++;

          case 17:
            _iteratorNormalCompletion4 = true;
            _context4.next = 5;
            break;

          case 20:
            _context4.next = 26;
            break;

          case 22:
            _context4.prev = 22;
            _context4.t0 = _context4["catch"](3);
            _didIteratorError4 = true;
            _iteratorError4 = _context4.t0;

          case 26:
            _context4.prev = 26;
            _context4.prev = 27;

            if (!(!_iteratorNormalCompletion4 && _iterator4.return != null)) {
              _context4.next = 31;
              break;
            }

            _context4.next = 31;
            return (0, _awaitAsyncGenerator2.default)(_iterator4.return());

          case 31:
            _context4.prev = 31;

            if (!_didIteratorError4) {
              _context4.next = 34;
              break;
            }

            throw _iteratorError4;

          case 34:
            return _context4.finish(31);

          case 35:
            return _context4.finish(26);

          case 36:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, null, [[3, 22, 26, 36], [27,, 31, 35]]);
  }));
  return _makeNumberedLineIterator.apply(this, arguments);
}

},{"@babel/runtime/helpers/asyncIterator":9,"@babel/runtime/helpers/awaitAsyncGenerator":11,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/wrapAsyncGenerator":31,"@babel/runtime/regenerator":33}],85:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseJSON = parseJSON;

var _getFirstCharacters = require("../binary-utils/get-first-characters");

function parseJSON(string) {
  try {
    return JSON.parse(string);
  } catch (_) {
    throw new Error("Failed to parse JSON from data starting with \"".concat((0, _getFirstCharacters.getFirstCharacters)(string), "\""));
  }
}

},{"../binary-utils/get-first-characters":79}],86:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setPathPrefix = setPathPrefix;
exports.getPathPrefix = getPathPrefix;
exports.addAliases = addAliases;
exports.resolvePath = resolvePath;
var pathPrefix = '';
var fileAliases = {};

function setPathPrefix(prefix) {
  pathPrefix = prefix;
}

function getPathPrefix() {
  return pathPrefix;
}

function addAliases(aliases) {
  Object.assign(fileAliases, aliases);
}

function resolvePath(filename) {
  for (var alias in fileAliases) {
    if (filename.startsWith(alias)) {
      var replacement = fileAliases[alias];
      filename = filename.replace(alias, replacement);
    }
  }

  if (!filename.startsWith('http://') && !filename.startsWith('https://')) {
    filename = "".concat(pathPrefix).concat(filename);
  }

  return filename;
}

},{}],87:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dirname = dirname;
exports.join = join;

function dirname(url) {
  var slashIndex = url && url.lastIndexOf('/');
  return slashIndex >= 0 ? url.substr(0, slashIndex) : '';
}

function join() {
  for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
    parts[_key] = arguments[_key];
  }

  var separator = '/';
  parts = parts.map(function (part, index) {
    if (index) {
      part = part.replace(new RegExp("^".concat(separator)), '');
    }

    if (index !== parts.length - 1) {
      part = part.replace(new RegExp("".concat(separator, "$")), '');
    }

    return part;
  });
  return parts.join(separator);
}

},{}],88:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _stats = require("@probe.gl/stats");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var STAT_QUEUED_REQUESTS = 'Queued Requests';
var STAT_ACTIVE_REQUESTS = 'Active Requests';
var STAT_CANCELLED_REQUESTS = 'Cancelled Requests';
var STAT_QUEUED_REQUESTS_EVER = 'Queued Requests Ever';
var STAT_ACTIVE_REQUESTS_EVER = 'Active Requests Ever';
var DEFAULT_PROPS = {
  id: 'request-scheduler',
  throttleRequests: true,
  maxRequests: 6
};

var RequestScheduler = function () {
  function RequestScheduler() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, RequestScheduler);
    (0, _defineProperty2.default)(this, "props", void 0);
    (0, _defineProperty2.default)(this, "stats", void 0);
    (0, _defineProperty2.default)(this, "activeRequestCount", 0);
    (0, _defineProperty2.default)(this, "requestQueue", []);
    (0, _defineProperty2.default)(this, "requestMap", new Map());
    (0, _defineProperty2.default)(this, "deferredUpdate", null);
    this.props = _objectSpread(_objectSpread({}, DEFAULT_PROPS), props);
    this.stats = new _stats.Stats({
      id: this.props.id
    });
    this.stats.get(STAT_QUEUED_REQUESTS);
    this.stats.get(STAT_ACTIVE_REQUESTS);
    this.stats.get(STAT_CANCELLED_REQUESTS);
    this.stats.get(STAT_QUEUED_REQUESTS_EVER);
    this.stats.get(STAT_ACTIVE_REQUESTS_EVER);
  }

  (0, _createClass2.default)(RequestScheduler, [{
    key: "scheduleRequest",
    value: function scheduleRequest(handle) {
      var getPriority = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
        return 0;
      };

      if (!this.props.throttleRequests) {
        return Promise.resolve({
          done: function done() {}
        });
      }

      if (this.requestMap.has(handle)) {
        return this.requestMap.get(handle);
      }

      var request = {
        handle: handle,
        priority: 0,
        getPriority: getPriority
      };
      var promise = new Promise(function (resolve) {
        request.resolve = resolve;
        return request;
      });
      this.requestQueue.push(request);
      this.requestMap.set(handle, promise);

      this._issueNewRequests();

      return promise;
    }
  }, {
    key: "_issueRequest",
    value: function _issueRequest(request) {
      var _this = this;

      var handle = request.handle,
          resolve = request.resolve;
      var isDone = false;

      var done = function done() {
        if (!isDone) {
          isDone = true;

          _this.requestMap.delete(handle);

          _this.activeRequestCount--;

          _this._issueNewRequests();
        }
      };

      this.activeRequestCount++;
      return resolve ? resolve({
        done: done
      }) : Promise.resolve({
        done: done
      });
    }
  }, {
    key: "_issueNewRequests",
    value: function _issueNewRequests() {
      var _this2 = this;

      if (!this.deferredUpdate) {
        this.deferredUpdate = setTimeout(function () {
          return _this2._issueNewRequestsAsync();
        }, 0);
      }
    }
  }, {
    key: "_issueNewRequestsAsync",
    value: function _issueNewRequestsAsync() {
      this.deferredUpdate = null;
      var freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);

      if (freeSlots === 0) {
        return;
      }

      this._updateAllRequests();

      for (var i = 0; i < freeSlots; ++i) {
        var request = this.requestQueue.shift();

        if (request) {
          this._issueRequest(request);
        }
      }
    }
  }, {
    key: "_updateAllRequests",
    value: function _updateAllRequests() {
      var requestQueue = this.requestQueue;

      for (var i = 0; i < requestQueue.length; ++i) {
        var request = requestQueue[i];

        if (!this._updateRequest(request)) {
          requestQueue.splice(i, 1);
          this.requestMap.delete(request.handle);
          i--;
        }
      }

      requestQueue.sort(function (a, b) {
        return a.priority - b.priority;
      });
    }
  }, {
    key: "_updateRequest",
    value: function _updateRequest(request) {
      request.priority = request.getPriority(request.handle);

      if (request.priority < 0) {
        request.resolve(null);
        return false;
      }

      return true;
    }
  }]);
  return RequestScheduler;
}();

exports.default = RequestScheduler;

},{"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@probe.gl/stats":126}],89:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createLoaderWorker = createLoaderWorker;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _workerUtils = require("@loaders.gl/worker-utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var requestId = 0;

function createLoaderWorker(loader) {
  if (typeof self === 'undefined') {
    return;
  }

  _workerUtils.WorkerBody.onmessage = function () {
    var _ref = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(type, payload) {
      var input, _payload$options, options, result, message;

      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.t0 = type;
              _context.next = _context.t0 === 'process' ? 3 : 16;
              break;

            case 3:
              _context.prev = 3;
              input = payload.input, _payload$options = payload.options, options = _payload$options === void 0 ? {} : _payload$options;
              _context.next = 7;
              return parseData({
                loader: loader,
                arrayBuffer: input,
                options: options,
                context: {
                  parse: parseOnMainThread
                }
              });

            case 7:
              result = _context.sent;

              _workerUtils.WorkerBody.postMessage('done', {
                result: result
              });

              _context.next = 15;
              break;

            case 11:
              _context.prev = 11;
              _context.t1 = _context["catch"](3);
              message = _context.t1 instanceof Error ? _context.t1.message : '';

              _workerUtils.WorkerBody.postMessage('error', {
                error: message
              });

            case 15:
              return _context.abrupt("break", 16);

            case 16:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[3, 11]]);
    }));

    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();
}

function parseOnMainThread(arrayBuffer, options) {
  return new Promise(function (resolve, reject) {
    var id = requestId++;

    var onMessage = function onMessage(type, payload) {
      if (payload.id !== id) {
        return;
      }

      switch (type) {
        case 'done':
          _workerUtils.WorkerBody.removeEventListener(onMessage);

          resolve(payload.result);
          break;

        case 'error':
          _workerUtils.WorkerBody.removeEventListener(onMessage);

          reject(payload.error);
          break;

        default:
      }
    };

    _workerUtils.WorkerBody.addEventListener(onMessage);

    var payload = {
      id: id,
      input: arrayBuffer,
      options: options
    };

    _workerUtils.WorkerBody.postMessage('process', payload);
  });
}

function parseData(_x3) {
  return _parseData.apply(this, arguments);
}

function _parseData() {
  _parseData = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(_ref2) {
    var loader, arrayBuffer, options, context, data, parser, textDecoder;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            loader = _ref2.loader, arrayBuffer = _ref2.arrayBuffer, options = _ref2.options, context = _ref2.context;

            if (!(loader.parseSync || loader.parse)) {
              _context2.next = 6;
              break;
            }

            data = arrayBuffer;
            parser = loader.parseSync || loader.parse;
            _context2.next = 13;
            break;

          case 6:
            if (!loader.parseTextSync) {
              _context2.next = 12;
              break;
            }

            textDecoder = new TextDecoder();
            data = textDecoder.decode(arrayBuffer);
            parser = loader.parseTextSync;
            _context2.next = 13;
            break;

          case 12:
            throw new Error("Could not load data with ".concat(loader.name, " loader"));

          case 13:
            options = _objectSpread(_objectSpread({}, options), {}, {
              modules: loader && loader.options && loader.options.modules || {},
              worker: false
            });
            _context2.next = 16;
            return parser(data, _objectSpread({}, options), context, loader);

          case 16:
            return _context2.abrupt("return", _context2.sent);

          case 17:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _parseData.apply(this, arguments);
}

},{"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33,"@loaders.gl/worker-utils":108}],90:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.canParseWithWorker = canParseWithWorker;
exports.parseWithWorker = parseWithWorker;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _workerUtils = require("@loaders.gl/worker-utils");

function canParseWithWorker(loader, options) {
  if (!_workerUtils.WorkerFarm.isSupported()) {
    return false;
  }

  return loader.worker && (options === null || options === void 0 ? void 0 : options.worker);
}

function parseWithWorker(_x, _x2, _x3, _x4, _x5) {
  return _parseWithWorker.apply(this, arguments);
}

function _parseWithWorker() {
  _parseWithWorker = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(loader, data, options, context, parseOnMainThread) {
    var name, url, workerFarm, workerPool, job, result;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            name = loader.id;
            url = (0, _workerUtils.getWorkerURL)(loader, options);
            workerFarm = _workerUtils.WorkerFarm.getWorkerFarm(options);
            workerPool = workerFarm.getWorkerPool({
              name: name,
              url: url
            });
            options = JSON.parse(JSON.stringify(options));
            _context.next = 7;
            return workerPool.startJob('process-on-worker', onMessage.bind(null, parseOnMainThread));

          case 7:
            job = _context.sent;
            job.postMessage('process', {
              input: data,
              options: options
            });
            _context.next = 11;
            return job.result;

          case 11:
            result = _context.sent;
            _context.next = 14;
            return result.result;

          case 14:
            return _context.abrupt("return", _context.sent);

          case 15:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _parseWithWorker.apply(this, arguments);
}

function onMessage(_x6, _x7, _x8, _x9) {
  return _onMessage.apply(this, arguments);
}

function _onMessage() {
  _onMessage = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(parseOnMainThread, job, type, payload) {
    var id, input, options, result, message;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.t0 = type;
            _context2.next = _context2.t0 === 'done' ? 3 : _context2.t0 === 'error' ? 5 : _context2.t0 === 'process' ? 7 : 20;
            break;

          case 3:
            job.done(payload);
            return _context2.abrupt("break", 21);

          case 5:
            job.error(payload.error);
            return _context2.abrupt("break", 21);

          case 7:
            id = payload.id, input = payload.input, options = payload.options;
            _context2.prev = 8;
            _context2.next = 11;
            return parseOnMainThread(input, options);

          case 11:
            result = _context2.sent;
            job.postMessage('done', {
              id: id,
              result: result
            });
            _context2.next = 19;
            break;

          case 15:
            _context2.prev = 15;
            _context2.t1 = _context2["catch"](8);
            message = _context2.t1 instanceof Error ? _context2.t1.message : 'unknown error';
            job.postMessage('error', {
              id: id,
              error: message
            });

          case 19:
            return _context2.abrupt("break", 21);

          case 20:
            console.warn("parse-with-worker unknown message ".concat(type));

          case 21:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[8, 15]]);
  }));
  return _onMessage.apply(this, arguments);
}

},{"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33,"@loaders.gl/worker-utils":108}],91:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMeshSize = getMeshSize;
exports.getMeshBoundingBox = getMeshBoundingBox;

function getMeshSize(attributes) {
  var size = 0;

  for (var attributeName in attributes) {
    var attribute = attributes[attributeName];

    if (ArrayBuffer.isView(attribute)) {
      size += attribute.byteLength * attribute.BYTES_PER_ELEMENT;
    }
  }

  return size;
}

function getMeshBoundingBox(attributes) {
  var minX = Infinity;
  var minY = Infinity;
  var minZ = Infinity;
  var maxX = -Infinity;
  var maxY = -Infinity;
  var maxZ = -Infinity;
  var positions = attributes.POSITION ? attributes.POSITION.value : [];
  var len = positions && positions.length;

  for (var i = 0; i < len; i += 3) {
    var x = positions[i];
    var y = positions[i + 1];
    var z = positions[i + 2];
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    minZ = z < minZ ? z : minZ;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    maxZ = z > maxZ ? z : maxZ;
  }

  return [[minX, minY, minZ], [maxX, maxY, maxZ]];
}

},{}],92:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "TableBatchBuilder", {
  enumerable: true,
  get: function get() {
    return _tableBatchBuilder.default;
  }
});
Object.defineProperty(exports, "RowTableBatchAggregator", {
  enumerable: true,
  get: function get() {
    return _rowTableBatchAggregator.default;
  }
});
Object.defineProperty(exports, "ColumnarTableBatchAggregator", {
  enumerable: true,
  get: function get() {
    return _columnarTableBatchAggregator.default;
  }
});
Object.defineProperty(exports, "convertToObjectRow", {
  enumerable: true,
  get: function get() {
    return _rowUtils.convertToObjectRow;
  }
});
Object.defineProperty(exports, "convertToArrayRow", {
  enumerable: true,
  get: function get() {
    return _rowUtils.convertToArrayRow;
  }
});
Object.defineProperty(exports, "getMeshSize", {
  enumerable: true,
  get: function get() {
    return _meshUtils.getMeshSize;
  }
});
Object.defineProperty(exports, "getMeshBoundingBox", {
  enumerable: true,
  get: function get() {
    return _meshUtils.getMeshBoundingBox;
  }
});
Object.defineProperty(exports, "Schema", {
  enumerable: true,
  get: function get() {
    return _schema.Schema;
  }
});
Object.defineProperty(exports, "Field", {
  enumerable: true,
  get: function get() {
    return _schema.Field;
  }
});
Object.defineProperty(exports, "DataType", {
  enumerable: true,
  get: function get() {
    return _schema.DataType;
  }
});
Object.defineProperty(exports, "Null", {
  enumerable: true,
  get: function get() {
    return _schema.Null;
  }
});
Object.defineProperty(exports, "Binary", {
  enumerable: true,
  get: function get() {
    return _schema.Binary;
  }
});
Object.defineProperty(exports, "Bool", {
  enumerable: true,
  get: function get() {
    return _schema.Bool;
  }
});
Object.defineProperty(exports, "Int", {
  enumerable: true,
  get: function get() {
    return _schema.Int;
  }
});
Object.defineProperty(exports, "Int8", {
  enumerable: true,
  get: function get() {
    return _schema.Int8;
  }
});
Object.defineProperty(exports, "Int16", {
  enumerable: true,
  get: function get() {
    return _schema.Int16;
  }
});
Object.defineProperty(exports, "Int32", {
  enumerable: true,
  get: function get() {
    return _schema.Int32;
  }
});
Object.defineProperty(exports, "Int64", {
  enumerable: true,
  get: function get() {
    return _schema.Int64;
  }
});
Object.defineProperty(exports, "Uint8", {
  enumerable: true,
  get: function get() {
    return _schema.Uint8;
  }
});
Object.defineProperty(exports, "Uint16", {
  enumerable: true,
  get: function get() {
    return _schema.Uint16;
  }
});
Object.defineProperty(exports, "Uint32", {
  enumerable: true,
  get: function get() {
    return _schema.Uint32;
  }
});
Object.defineProperty(exports, "Uint64", {
  enumerable: true,
  get: function get() {
    return _schema.Uint64;
  }
});
Object.defineProperty(exports, "Float", {
  enumerable: true,
  get: function get() {
    return _schema.Float;
  }
});
Object.defineProperty(exports, "Float16", {
  enumerable: true,
  get: function get() {
    return _schema.Float16;
  }
});
Object.defineProperty(exports, "Float32", {
  enumerable: true,
  get: function get() {
    return _schema.Float32;
  }
});
Object.defineProperty(exports, "Float64", {
  enumerable: true,
  get: function get() {
    return _schema.Float64;
  }
});
Object.defineProperty(exports, "Utf8", {
  enumerable: true,
  get: function get() {
    return _schema.Utf8;
  }
});
Object.defineProperty(exports, "Date", {
  enumerable: true,
  get: function get() {
    return _schema.Date;
  }
});
Object.defineProperty(exports, "DateDay", {
  enumerable: true,
  get: function get() {
    return _schema.DateDay;
  }
});
Object.defineProperty(exports, "DateMillisecond", {
  enumerable: true,
  get: function get() {
    return _schema.DateMillisecond;
  }
});
Object.defineProperty(exports, "Time", {
  enumerable: true,
  get: function get() {
    return _schema.Time;
  }
});
Object.defineProperty(exports, "TimeMillisecond", {
  enumerable: true,
  get: function get() {
    return _schema.TimeMillisecond;
  }
});
Object.defineProperty(exports, "TimeSecond", {
  enumerable: true,
  get: function get() {
    return _schema.TimeSecond;
  }
});
Object.defineProperty(exports, "Timestamp", {
  enumerable: true,
  get: function get() {
    return _schema.Timestamp;
  }
});
Object.defineProperty(exports, "TimestampSecond", {
  enumerable: true,
  get: function get() {
    return _schema.TimestampSecond;
  }
});
Object.defineProperty(exports, "TimestampMillisecond", {
  enumerable: true,
  get: function get() {
    return _schema.TimestampMillisecond;
  }
});
Object.defineProperty(exports, "TimestampMicrosecond", {
  enumerable: true,
  get: function get() {
    return _schema.TimestampMicrosecond;
  }
});
Object.defineProperty(exports, "TimestampNanosecond", {
  enumerable: true,
  get: function get() {
    return _schema.TimestampNanosecond;
  }
});
Object.defineProperty(exports, "Interval", {
  enumerable: true,
  get: function get() {
    return _schema.Interval;
  }
});
Object.defineProperty(exports, "IntervalDayTime", {
  enumerable: true,
  get: function get() {
    return _schema.IntervalDayTime;
  }
});
Object.defineProperty(exports, "IntervalYearMonth", {
  enumerable: true,
  get: function get() {
    return _schema.IntervalYearMonth;
  }
});
Object.defineProperty(exports, "FixedSizeList", {
  enumerable: true,
  get: function get() {
    return _schema.FixedSizeList;
  }
});
Object.defineProperty(exports, "deduceTableSchema", {
  enumerable: true,
  get: function get() {
    return _deduceTableSchema.deduceTableSchema;
  }
});
Object.defineProperty(exports, "getTypeInfo", {
  enumerable: true,
  get: function get() {
    return _getTypeInfo.getTypeInfo;
  }
});
Object.defineProperty(exports, "getArrowTypeFromTypedArray", {
  enumerable: true,
  get: function get() {
    return _typeUtils.getArrowTypeFromTypedArray;
  }
});
Object.defineProperty(exports, "AsyncQueue", {
  enumerable: true,
  get: function get() {
    return _asyncQueue.default;
  }
});

var _tableBatchBuilder = _interopRequireDefault(require("./lib/table/table-batch-builder"));

var _rowTableBatchAggregator = _interopRequireDefault(require("./lib/table/row-table-batch-aggregator"));

var _columnarTableBatchAggregator = _interopRequireDefault(require("./lib/table/columnar-table-batch-aggregator"));

var _rowUtils = require("./lib/utils/row-utils");

var _meshUtils = require("./category/mesh/mesh-utils");

var _schema = require("./lib/schema");

var _deduceTableSchema = require("./lib/schema-utils/deduce-table-schema");

var _getTypeInfo = require("./lib/schema-utils/get-type-info");

var _typeUtils = require("./lib/schema-utils/type-utils");

var _asyncQueue = _interopRequireDefault(require("./lib/utils/async-queue"));

},{"./category/mesh/mesh-utils":91,"./lib/schema":100,"./lib/schema-utils/deduce-table-schema":93,"./lib/schema-utils/get-type-info":94,"./lib/schema-utils/type-utils":95,"./lib/table/columnar-table-batch-aggregator":102,"./lib/table/row-table-batch-aggregator":103,"./lib/table/table-batch-builder":104,"./lib/utils/async-queue":106,"./lib/utils/row-utils":107,"@babel/runtime/helpers/interopRequireDefault":18}],93:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deduceTableSchema = deduceTableSchema;

function deduceTableSchema(table, schema) {
  var deducedSchema = Array.isArray(table) ? deduceSchemaForRowTable(table) : deduceSchemaForColumnarTable(table);
  return Object.assign(deducedSchema, schema);
}

function deduceSchemaForColumnarTable(columnarTable) {
  var schema = {};

  for (var field in columnarTable) {
    var column = columnarTable[field];

    if (ArrayBuffer.isView(column)) {
      schema[field] = column.constructor;
    } else if (column.length) {
      var value = column[0];
      schema[field] = deduceTypeFromValue(value);
    }

    schema[field] = schema[field] || null;
  }

  return schema;
}

function deduceSchemaForRowTable(rowTable) {
  var schema = {};

  if (rowTable.length) {
    var row = rowTable[0];

    for (var field in row) {
      var value = row[field];
      schema[field] = deduceTypeFromValue(value);
    }
  }

  return schema;
}

function deduceTypeFromValue(value) {
  if (value instanceof Date) {
    return Date;
  } else if (value instanceof Number) {
    return Float32Array;
  } else if (typeof value === 'string') {
    return String;
  }

  return null;
}

},{}],94:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTypeInfo = getTypeInfo;

var _schema = require("../schema");

function getTypeInfo(arrowTypeLike) {
  return {
    typeId: arrowTypeLike.typeId,
    ArrayType: arrowTypeLike.ArrayType,
    typeName: arrowTypeLike.toString(),
    typeEnumName: getTypeKey(arrowTypeLike.typeId),
    precision: arrowTypeLike.precision
  };
}

var ReverseType = null;

function getTypeKey(typeKey) {
  if (!ReverseType) {
    ReverseType = {};

    for (var _key in _schema.Type) {
      ReverseType[_schema.Type[_key]] = _key;
    }
  }

  return ReverseType[typeKey];
}

},{"../schema":100}],95:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getArrowTypeFromTypedArray = getArrowTypeFromTypedArray;

var _schema = require("../schema");

function getArrowTypeFromTypedArray(array) {
  switch (array.constructor) {
    case Int8Array:
      return new _schema.Int8();

    case Uint8Array:
      return new _schema.Uint8();

    case Int16Array:
      return new _schema.Int16();

    case Uint16Array:
      return new _schema.Uint16();

    case Int32Array:
      return new _schema.Int32();

    case Uint32Array:
      return new _schema.Uint32();

    case Float32Array:
      return new _schema.Float32();

    case Float64Array:
      return new _schema.Float64();

    default:
      throw new Error('array type not supported');
  }
}

},{"../schema":100}],96:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Type = void 0;
var Type;
exports.Type = Type;

(function (Type) {
  Type[Type["NONE"] = 0] = "NONE";
  Type[Type["Null"] = 1] = "Null";
  Type[Type["Int"] = 2] = "Int";
  Type[Type["Float"] = 3] = "Float";
  Type[Type["Binary"] = 4] = "Binary";
  Type[Type["Utf8"] = 5] = "Utf8";
  Type[Type["Bool"] = 6] = "Bool";
  Type[Type["Decimal"] = 7] = "Decimal";
  Type[Type["Date"] = 8] = "Date";
  Type[Type["Time"] = 9] = "Time";
  Type[Type["Timestamp"] = 10] = "Timestamp";
  Type[Type["Interval"] = 11] = "Interval";
  Type[Type["List"] = 12] = "List";
  Type[Type["Struct"] = 13] = "Struct";
  Type[Type["Union"] = 14] = "Union";
  Type[Type["FixedSizeBinary"] = 15] = "FixedSizeBinary";
  Type[Type["FixedSizeList"] = 16] = "FixedSizeList";
  Type[Type["Map"] = 17] = "Map";
  Type[Type["Dictionary"] = -1] = "Dictionary";
  Type[Type["Int8"] = -2] = "Int8";
  Type[Type["Int16"] = -3] = "Int16";
  Type[Type["Int32"] = -4] = "Int32";
  Type[Type["Int64"] = -5] = "Int64";
  Type[Type["Uint8"] = -6] = "Uint8";
  Type[Type["Uint16"] = -7] = "Uint16";
  Type[Type["Uint32"] = -8] = "Uint32";
  Type[Type["Uint64"] = -9] = "Uint64";
  Type[Type["Float16"] = -10] = "Float16";
  Type[Type["Float32"] = -11] = "Float32";
  Type[Type["Float64"] = -12] = "Float64";
  Type[Type["DateDay"] = -13] = "DateDay";
  Type[Type["DateMillisecond"] = -14] = "DateMillisecond";
  Type[Type["TimestampSecond"] = -15] = "TimestampSecond";
  Type[Type["TimestampMillisecond"] = -16] = "TimestampMillisecond";
  Type[Type["TimestampMicrosecond"] = -17] = "TimestampMicrosecond";
  Type[Type["TimestampNanosecond"] = -18] = "TimestampNanosecond";
  Type[Type["TimeSecond"] = -19] = "TimeSecond";
  Type[Type["TimeMillisecond"] = -20] = "TimeMillisecond";
  Type[Type["TimeMicrosecond"] = -21] = "TimeMicrosecond";
  Type[Type["TimeNanosecond"] = -22] = "TimeNanosecond";
  Type[Type["DenseUnion"] = -23] = "DenseUnion";
  Type[Type["SparseUnion"] = -24] = "SparseUnion";
  Type[Type["IntervalDayTime"] = -25] = "IntervalDayTime";
  Type[Type["IntervalYearMonth"] = -26] = "IntervalYearMonth";
})(Type || (exports.Type = Type = {}));

},{}],97:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var Field = function () {
  function Field(name, type) {
    var nullable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var metadata = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Map();
    (0, _classCallCheck2.default)(this, Field);
    (0, _defineProperty2.default)(this, "name", void 0);
    (0, _defineProperty2.default)(this, "type", void 0);
    (0, _defineProperty2.default)(this, "nullable", void 0);
    (0, _defineProperty2.default)(this, "metadata", void 0);
    this.name = name;
    this.type = type;
    this.nullable = nullable;
    this.metadata = metadata;
  }

  (0, _createClass2.default)(Field, [{
    key: "typeId",
    get: function get() {
      return this.type && this.type.typeId;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new Field(this.name, this.type, this.nullable, this.metadata);
    }
  }, {
    key: "compareTo",
    value: function compareTo(other) {
      return this.name === other.name && this.type === other.type && this.nullable === other.nullable && this.metadata === other.metadata;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "".concat(this.type).concat(this.nullable ? ', nullable' : '').concat(this.metadata ? ", metadata: ".concat(this.metadata) : '');
    }
  }]);
  return Field;
}();

exports.default = Field;

},{"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18}],98:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _assert = require("../../utils/assert");

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var Schema = function () {
  function Schema(fields, metadata) {
    (0, _classCallCheck2.default)(this, Schema);
    (0, _defineProperty2.default)(this, "fields", void 0);
    (0, _defineProperty2.default)(this, "metadata", void 0);
    (0, _assert.assert)(Array.isArray(fields));
    checkNames(fields);
    this.fields = fields;
    this.metadata = metadata || new Map();
  }

  (0, _createClass2.default)(Schema, [{
    key: "compareTo",
    value: function compareTo(other) {
      if (this.metadata !== other.metadata) {
        return false;
      }

      if (this.fields.length !== other.fields.length) {
        return false;
      }

      for (var i = 0; i < this.fields.length; ++i) {
        if (!this.fields[i].compareTo(other.fields[i])) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "select",
    value: function select() {
      var nameMap = Object.create(null);

      for (var _len = arguments.length, columnNames = new Array(_len), _key = 0; _key < _len; _key++) {
        columnNames[_key] = arguments[_key];
      }

      for (var _i = 0, _columnNames = columnNames; _i < _columnNames.length; _i++) {
        var name = _columnNames[_i];
        nameMap[name] = true;
      }

      var selectedFields = this.fields.filter(function (field) {
        return nameMap[field.name];
      });
      return new Schema(selectedFields, this.metadata);
    }
  }, {
    key: "selectAt",
    value: function selectAt() {
      var _this = this;

      for (var _len2 = arguments.length, columnIndices = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        columnIndices[_key2] = arguments[_key2];
      }

      var selectedFields = columnIndices.map(function (index) {
        return _this.fields[index];
      }).filter(Boolean);
      return new Schema(selectedFields, this.metadata);
    }
  }, {
    key: "assign",
    value: function assign(schemaOrFields) {
      var fields;
      var metadata = this.metadata;

      if (schemaOrFields instanceof Schema) {
        var otherSchema = schemaOrFields;
        fields = otherSchema.fields;
        metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);
      } else {
        fields = schemaOrFields;
      }

      var fieldMap = Object.create(null);

      var _iterator = _createForOfIteratorHelper(this.fields),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var field = _step.value;
          fieldMap[field.name] = field;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var _iterator2 = _createForOfIteratorHelper(fields),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _field = _step2.value;
          fieldMap[_field.name] = _field;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      var mergedFields = Object.values(fieldMap);
      return new Schema(mergedFields, metadata);
    }
  }]);
  return Schema;
}();

exports.default = Schema;

function checkNames(fields) {
  var usedNames = {};

  var _iterator3 = _createForOfIteratorHelper(fields),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var field = _step3.value;

      if (usedNames[field.name]) {
        console.warn('Schema: duplicated field name', field.name, field);
      }

      usedNames[field.name] = true;
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
}

function mergeMaps(m1, m2) {
  return new Map([].concat((0, _toConsumableArray2.default)(m1 || new Map()), (0, _toConsumableArray2.default)(m2 || new Map())));
}

},{"../../utils/assert":105,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/toConsumableArray":28}],99:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Type", {
  enumerable: true,
  get: function get() {
    return _enum.Type;
  }
});
exports.FixedSizeList = exports.IntervalYearMonth = exports.IntervalDayTime = exports.Interval = exports.TimestampNanosecond = exports.TimestampMicrosecond = exports.TimestampMillisecond = exports.TimestampSecond = exports.Timestamp = exports.TimeMillisecond = exports.TimeSecond = exports.Time = exports.DateMillisecond = exports.DateDay = exports.Date = exports.Utf8 = exports.Binary = exports.Float64 = exports.Float32 = exports.Float16 = exports.Float = exports.Uint64 = exports.Uint32 = exports.Uint16 = exports.Uint8 = exports.Int64 = exports.Int32 = exports.Int16 = exports.Int8 = exports.Int = exports.Bool = exports.Null = exports.DataType = void 0;

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _enum = require("./enum");

var _Symbol$toStringTag, _Symbol$toStringTag2, _Symbol$toStringTag3, _Symbol$toStringTag4, _Symbol$toStringTag5, _Symbol$toStringTag6, _Symbol$toStringTag7;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var DataType = function () {
  function DataType() {
    (0, _classCallCheck2.default)(this, DataType);
  }

  (0, _createClass2.default)(DataType, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.NONE;
    }
  }, {
    key: "compareTo",
    value: function compareTo(other) {
      return this === other;
    }
  }], [{
    key: "isNull",
    value: function isNull(x) {
      return x && x.typeId === _enum.Type.Null;
    }
  }, {
    key: "isInt",
    value: function isInt(x) {
      return x && x.typeId === _enum.Type.Int;
    }
  }, {
    key: "isFloat",
    value: function isFloat(x) {
      return x && x.typeId === _enum.Type.Float;
    }
  }, {
    key: "isBinary",
    value: function isBinary(x) {
      return x && x.typeId === _enum.Type.Binary;
    }
  }, {
    key: "isUtf8",
    value: function isUtf8(x) {
      return x && x.typeId === _enum.Type.Utf8;
    }
  }, {
    key: "isBool",
    value: function isBool(x) {
      return x && x.typeId === _enum.Type.Bool;
    }
  }, {
    key: "isDecimal",
    value: function isDecimal(x) {
      return x && x.typeId === _enum.Type.Decimal;
    }
  }, {
    key: "isDate",
    value: function isDate(x) {
      return x && x.typeId === _enum.Type.Date;
    }
  }, {
    key: "isTime",
    value: function isTime(x) {
      return x && x.typeId === _enum.Type.Time;
    }
  }, {
    key: "isTimestamp",
    value: function isTimestamp(x) {
      return x && x.typeId === _enum.Type.Timestamp;
    }
  }, {
    key: "isInterval",
    value: function isInterval(x) {
      return x && x.typeId === _enum.Type.Interval;
    }
  }, {
    key: "isList",
    value: function isList(x) {
      return x && x.typeId === _enum.Type.List;
    }
  }, {
    key: "isStruct",
    value: function isStruct(x) {
      return x && x.typeId === _enum.Type.Struct;
    }
  }, {
    key: "isUnion",
    value: function isUnion(x) {
      return x && x.typeId === _enum.Type.Union;
    }
  }, {
    key: "isFixedSizeBinary",
    value: function isFixedSizeBinary(x) {
      return x && x.typeId === _enum.Type.FixedSizeBinary;
    }
  }, {
    key: "isFixedSizeList",
    value: function isFixedSizeList(x) {
      return x && x.typeId === _enum.Type.FixedSizeList;
    }
  }, {
    key: "isMap",
    value: function isMap(x) {
      return x && x.typeId === _enum.Type.Map;
    }
  }, {
    key: "isDictionary",
    value: function isDictionary(x) {
      return x && x.typeId === _enum.Type.Dictionary;
    }
  }]);
  return DataType;
}();

exports.DataType = DataType;

var Null = function (_DataType) {
  (0, _inherits2.default)(Null, _DataType);

  var _super = _createSuper(Null);

  function Null() {
    (0, _classCallCheck2.default)(this, Null);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(Null, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.Null;
    }
  }, {
    key: Symbol.toStringTag,
    get: function get() {
      return 'Null';
    }
  }, {
    key: "toString",
    value: function toString() {
      return 'Null';
    }
  }]);
  return Null;
}(DataType);

exports.Null = Null;

var Bool = function (_DataType2) {
  (0, _inherits2.default)(Bool, _DataType2);

  var _super2 = _createSuper(Bool);

  function Bool() {
    (0, _classCallCheck2.default)(this, Bool);
    return _super2.apply(this, arguments);
  }

  (0, _createClass2.default)(Bool, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.Bool;
    }
  }, {
    key: Symbol.toStringTag,
    get: function get() {
      return 'Bool';
    }
  }, {
    key: "toString",
    value: function toString() {
      return 'Bool';
    }
  }]);
  return Bool;
}(DataType);

exports.Bool = Bool;
_Symbol$toStringTag = Symbol.toStringTag;

var Int = function (_DataType3) {
  (0, _inherits2.default)(Int, _DataType3);

  var _super3 = _createSuper(Int);

  function Int(isSigned, bitWidth) {
    var _this;

    (0, _classCallCheck2.default)(this, Int);
    _this = _super3.call(this);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "isSigned", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "bitWidth", void 0);
    _this.isSigned = isSigned;
    _this.bitWidth = bitWidth;
    return _this;
  }

  (0, _createClass2.default)(Int, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.Int;
    }
  }, {
    key: _Symbol$toStringTag,
    get: function get() {
      return 'Int';
    }
  }, {
    key: "toString",
    value: function toString() {
      return "".concat(this.isSigned ? 'I' : 'Ui', "nt").concat(this.bitWidth);
    }
  }]);
  return Int;
}(DataType);

exports.Int = Int;

var Int8 = function (_Int) {
  (0, _inherits2.default)(Int8, _Int);

  var _super4 = _createSuper(Int8);

  function Int8() {
    (0, _classCallCheck2.default)(this, Int8);
    return _super4.call(this, true, 8);
  }

  return Int8;
}(Int);

exports.Int8 = Int8;

var Int16 = function (_Int2) {
  (0, _inherits2.default)(Int16, _Int2);

  var _super5 = _createSuper(Int16);

  function Int16() {
    (0, _classCallCheck2.default)(this, Int16);
    return _super5.call(this, true, 16);
  }

  return Int16;
}(Int);

exports.Int16 = Int16;

var Int32 = function (_Int3) {
  (0, _inherits2.default)(Int32, _Int3);

  var _super6 = _createSuper(Int32);

  function Int32() {
    (0, _classCallCheck2.default)(this, Int32);
    return _super6.call(this, true, 32);
  }

  return Int32;
}(Int);

exports.Int32 = Int32;

var Int64 = function (_Int4) {
  (0, _inherits2.default)(Int64, _Int4);

  var _super7 = _createSuper(Int64);

  function Int64() {
    (0, _classCallCheck2.default)(this, Int64);
    return _super7.call(this, true, 64);
  }

  return Int64;
}(Int);

exports.Int64 = Int64;

var Uint8 = function (_Int5) {
  (0, _inherits2.default)(Uint8, _Int5);

  var _super8 = _createSuper(Uint8);

  function Uint8() {
    (0, _classCallCheck2.default)(this, Uint8);
    return _super8.call(this, false, 8);
  }

  return Uint8;
}(Int);

exports.Uint8 = Uint8;

var Uint16 = function (_Int6) {
  (0, _inherits2.default)(Uint16, _Int6);

  var _super9 = _createSuper(Uint16);

  function Uint16() {
    (0, _classCallCheck2.default)(this, Uint16);
    return _super9.call(this, false, 16);
  }

  return Uint16;
}(Int);

exports.Uint16 = Uint16;

var Uint32 = function (_Int7) {
  (0, _inherits2.default)(Uint32, _Int7);

  var _super10 = _createSuper(Uint32);

  function Uint32() {
    (0, _classCallCheck2.default)(this, Uint32);
    return _super10.call(this, false, 32);
  }

  return Uint32;
}(Int);

exports.Uint32 = Uint32;

var Uint64 = function (_Int8) {
  (0, _inherits2.default)(Uint64, _Int8);

  var _super11 = _createSuper(Uint64);

  function Uint64() {
    (0, _classCallCheck2.default)(this, Uint64);
    return _super11.call(this, false, 64);
  }

  return Uint64;
}(Int);

exports.Uint64 = Uint64;
var Precision = {
  HALF: 16,
  SINGLE: 32,
  DOUBLE: 64
};
_Symbol$toStringTag2 = Symbol.toStringTag;

var Float = function (_DataType4) {
  (0, _inherits2.default)(Float, _DataType4);

  var _super12 = _createSuper(Float);

  function Float(precision) {
    var _this2;

    (0, _classCallCheck2.default)(this, Float);
    _this2 = _super12.call(this);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this2), "precision", void 0);
    _this2.precision = precision;
    return _this2;
  }

  (0, _createClass2.default)(Float, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.Float;
    }
  }, {
    key: _Symbol$toStringTag2,
    get: function get() {
      return 'Float';
    }
  }, {
    key: "toString",
    value: function toString() {
      return "Float".concat(this.precision);
    }
  }]);
  return Float;
}(DataType);

exports.Float = Float;

var Float16 = function (_Float) {
  (0, _inherits2.default)(Float16, _Float);

  var _super13 = _createSuper(Float16);

  function Float16() {
    (0, _classCallCheck2.default)(this, Float16);
    return _super13.call(this, Precision.HALF);
  }

  return Float16;
}(Float);

exports.Float16 = Float16;

var Float32 = function (_Float2) {
  (0, _inherits2.default)(Float32, _Float2);

  var _super14 = _createSuper(Float32);

  function Float32() {
    (0, _classCallCheck2.default)(this, Float32);
    return _super14.call(this, Precision.SINGLE);
  }

  return Float32;
}(Float);

exports.Float32 = Float32;

var Float64 = function (_Float3) {
  (0, _inherits2.default)(Float64, _Float3);

  var _super15 = _createSuper(Float64);

  function Float64() {
    (0, _classCallCheck2.default)(this, Float64);
    return _super15.call(this, Precision.DOUBLE);
  }

  return Float64;
}(Float);

exports.Float64 = Float64;

var Binary = function (_DataType5) {
  (0, _inherits2.default)(Binary, _DataType5);

  var _super16 = _createSuper(Binary);

  function Binary() {
    (0, _classCallCheck2.default)(this, Binary);
    return _super16.call(this);
  }

  (0, _createClass2.default)(Binary, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.Binary;
    }
  }, {
    key: "toString",
    value: function toString() {
      return 'Binary';
    }
  }, {
    key: Symbol.toStringTag,
    get: function get() {
      return 'Binary';
    }
  }]);
  return Binary;
}(DataType);

exports.Binary = Binary;

var Utf8 = function (_DataType6) {
  (0, _inherits2.default)(Utf8, _DataType6);

  var _super17 = _createSuper(Utf8);

  function Utf8() {
    (0, _classCallCheck2.default)(this, Utf8);
    return _super17.apply(this, arguments);
  }

  (0, _createClass2.default)(Utf8, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.Utf8;
    }
  }, {
    key: Symbol.toStringTag,
    get: function get() {
      return 'Utf8';
    }
  }, {
    key: "toString",
    value: function toString() {
      return 'Utf8';
    }
  }]);
  return Utf8;
}(DataType);

exports.Utf8 = Utf8;
var DateUnit = {
  DAY: 0,
  MILLISECOND: 1
};
_Symbol$toStringTag3 = Symbol.toStringTag;

var Date = function (_DataType7) {
  (0, _inherits2.default)(Date, _DataType7);

  var _super18 = _createSuper(Date);

  function Date(unit) {
    var _this3;

    (0, _classCallCheck2.default)(this, Date);
    _this3 = _super18.call(this);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this3), "unit", void 0);
    _this3.unit = unit;
    return _this3;
  }

  (0, _createClass2.default)(Date, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.Date;
    }
  }, {
    key: _Symbol$toStringTag3,
    get: function get() {
      return 'Date';
    }
  }, {
    key: "toString",
    value: function toString() {
      return "Date".concat((this.unit + 1) * 32, "<").concat(DateUnit[this.unit], ">");
    }
  }]);
  return Date;
}(DataType);

exports.Date = Date;

var DateDay = function (_Date) {
  (0, _inherits2.default)(DateDay, _Date);

  var _super19 = _createSuper(DateDay);

  function DateDay() {
    (0, _classCallCheck2.default)(this, DateDay);
    return _super19.call(this, DateUnit.DAY);
  }

  return DateDay;
}(Date);

exports.DateDay = DateDay;

var DateMillisecond = function (_Date2) {
  (0, _inherits2.default)(DateMillisecond, _Date2);

  var _super20 = _createSuper(DateMillisecond);

  function DateMillisecond() {
    (0, _classCallCheck2.default)(this, DateMillisecond);
    return _super20.call(this, DateUnit.MILLISECOND);
  }

  return DateMillisecond;
}(Date);

exports.DateMillisecond = DateMillisecond;
var TimeUnit = {
  SECOND: 1,
  MILLISECOND: 1e3,
  MICROSECOND: 1e6,
  NANOSECOND: 1e9
};
_Symbol$toStringTag4 = Symbol.toStringTag;

var Time = function (_DataType8) {
  (0, _inherits2.default)(Time, _DataType8);

  var _super21 = _createSuper(Time);

  function Time(unit, bitWidth) {
    var _this4;

    (0, _classCallCheck2.default)(this, Time);
    _this4 = _super21.call(this);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this4), "unit", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this4), "bitWidth", void 0);
    _this4.unit = unit;
    _this4.bitWidth = bitWidth;
    return _this4;
  }

  (0, _createClass2.default)(Time, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.Time;
    }
  }, {
    key: "toString",
    value: function toString() {
      return "Time".concat(this.bitWidth, "<").concat(TimeUnit[this.unit], ">");
    }
  }, {
    key: _Symbol$toStringTag4,
    get: function get() {
      return 'Time';
    }
  }]);
  return Time;
}(DataType);

exports.Time = Time;

var TimeSecond = function (_Time) {
  (0, _inherits2.default)(TimeSecond, _Time);

  var _super22 = _createSuper(TimeSecond);

  function TimeSecond() {
    (0, _classCallCheck2.default)(this, TimeSecond);
    return _super22.call(this, TimeUnit.SECOND, 32);
  }

  return TimeSecond;
}(Time);

exports.TimeSecond = TimeSecond;

var TimeMillisecond = function (_Time2) {
  (0, _inherits2.default)(TimeMillisecond, _Time2);

  var _super23 = _createSuper(TimeMillisecond);

  function TimeMillisecond() {
    (0, _classCallCheck2.default)(this, TimeMillisecond);
    return _super23.call(this, TimeUnit.MILLISECOND, 32);
  }

  return TimeMillisecond;
}(Time);

exports.TimeMillisecond = TimeMillisecond;
_Symbol$toStringTag5 = Symbol.toStringTag;

var Timestamp = function (_DataType9) {
  (0, _inherits2.default)(Timestamp, _DataType9);

  var _super24 = _createSuper(Timestamp);

  function Timestamp(unit) {
    var _this5;

    var timezone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    (0, _classCallCheck2.default)(this, Timestamp);
    _this5 = _super24.call(this);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this5), "unit", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this5), "timezone", void 0);
    _this5.unit = unit;
    _this5.timezone = timezone;
    return _this5;
  }

  (0, _createClass2.default)(Timestamp, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.Timestamp;
    }
  }, {
    key: _Symbol$toStringTag5,
    get: function get() {
      return 'Timestamp';
    }
  }, {
    key: "toString",
    value: function toString() {
      return "Timestamp<".concat(TimeUnit[this.unit]).concat(this.timezone ? ", ".concat(this.timezone) : '', ">");
    }
  }]);
  return Timestamp;
}(DataType);

exports.Timestamp = Timestamp;

var TimestampSecond = function (_Timestamp) {
  (0, _inherits2.default)(TimestampSecond, _Timestamp);

  var _super25 = _createSuper(TimestampSecond);

  function TimestampSecond() {
    var timezone = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    (0, _classCallCheck2.default)(this, TimestampSecond);
    return _super25.call(this, TimeUnit.SECOND, timezone);
  }

  return TimestampSecond;
}(Timestamp);

exports.TimestampSecond = TimestampSecond;

var TimestampMillisecond = function (_Timestamp2) {
  (0, _inherits2.default)(TimestampMillisecond, _Timestamp2);

  var _super26 = _createSuper(TimestampMillisecond);

  function TimestampMillisecond() {
    var timezone = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    (0, _classCallCheck2.default)(this, TimestampMillisecond);
    return _super26.call(this, TimeUnit.MILLISECOND, timezone);
  }

  return TimestampMillisecond;
}(Timestamp);

exports.TimestampMillisecond = TimestampMillisecond;

var TimestampMicrosecond = function (_Timestamp3) {
  (0, _inherits2.default)(TimestampMicrosecond, _Timestamp3);

  var _super27 = _createSuper(TimestampMicrosecond);

  function TimestampMicrosecond() {
    var timezone = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    (0, _classCallCheck2.default)(this, TimestampMicrosecond);
    return _super27.call(this, TimeUnit.MICROSECOND, timezone);
  }

  return TimestampMicrosecond;
}(Timestamp);

exports.TimestampMicrosecond = TimestampMicrosecond;

var TimestampNanosecond = function (_Timestamp4) {
  (0, _inherits2.default)(TimestampNanosecond, _Timestamp4);

  var _super28 = _createSuper(TimestampNanosecond);

  function TimestampNanosecond() {
    var timezone = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    (0, _classCallCheck2.default)(this, TimestampNanosecond);
    return _super28.call(this, TimeUnit.NANOSECOND, timezone);
  }

  return TimestampNanosecond;
}(Timestamp);

exports.TimestampNanosecond = TimestampNanosecond;
var IntervalUnit = {
  DAY_TIME: 0,
  YEAR_MONTH: 1
};
_Symbol$toStringTag6 = Symbol.toStringTag;

var Interval = function (_DataType10) {
  (0, _inherits2.default)(Interval, _DataType10);

  var _super29 = _createSuper(Interval);

  function Interval(unit) {
    var _this6;

    (0, _classCallCheck2.default)(this, Interval);
    _this6 = _super29.call(this);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this6), "unit", void 0);
    _this6.unit = unit;
    return _this6;
  }

  (0, _createClass2.default)(Interval, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.Interval;
    }
  }, {
    key: _Symbol$toStringTag6,
    get: function get() {
      return 'Interval';
    }
  }, {
    key: "toString",
    value: function toString() {
      return "Interval<".concat(IntervalUnit[this.unit], ">");
    }
  }]);
  return Interval;
}(DataType);

exports.Interval = Interval;

var IntervalDayTime = function (_Interval) {
  (0, _inherits2.default)(IntervalDayTime, _Interval);

  var _super30 = _createSuper(IntervalDayTime);

  function IntervalDayTime() {
    (0, _classCallCheck2.default)(this, IntervalDayTime);
    return _super30.call(this, IntervalUnit.DAY_TIME);
  }

  return IntervalDayTime;
}(Interval);

exports.IntervalDayTime = IntervalDayTime;

var IntervalYearMonth = function (_Interval2) {
  (0, _inherits2.default)(IntervalYearMonth, _Interval2);

  var _super31 = _createSuper(IntervalYearMonth);

  function IntervalYearMonth() {
    (0, _classCallCheck2.default)(this, IntervalYearMonth);
    return _super31.call(this, IntervalUnit.YEAR_MONTH);
  }

  return IntervalYearMonth;
}(Interval);

exports.IntervalYearMonth = IntervalYearMonth;
_Symbol$toStringTag7 = Symbol.toStringTag;

var FixedSizeList = function (_DataType11) {
  (0, _inherits2.default)(FixedSizeList, _DataType11);

  var _super32 = _createSuper(FixedSizeList);

  function FixedSizeList(listSize, child) {
    var _this7;

    (0, _classCallCheck2.default)(this, FixedSizeList);
    _this7 = _super32.call(this);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this7), "listSize", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this7), "children", void 0);
    _this7.listSize = listSize;
    _this7.children = [child];
    return _this7;
  }

  (0, _createClass2.default)(FixedSizeList, [{
    key: "typeId",
    get: function get() {
      return _enum.Type.FixedSizeList;
    }
  }, {
    key: "valueType",
    get: function get() {
      return this.children[0].type;
    }
  }, {
    key: "valueField",
    get: function get() {
      return this.children[0];
    }
  }, {
    key: _Symbol$toStringTag7,
    get: function get() {
      return 'FixedSizeList';
    }
  }, {
    key: "toString",
    value: function toString() {
      return "FixedSizeList[".concat(this.listSize, "]<").concat(this.valueType, ">");
    }
  }]);
  return FixedSizeList;
}(DataType);

exports.FixedSizeList = FixedSizeList;

},{"./enum":96,"@babel/runtime/helpers/assertThisInitialized":7,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/getPrototypeOf":16,"@babel/runtime/helpers/inherits":17,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/possibleConstructorReturn":25}],100:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Schema", {
  enumerable: true,
  get: function get() {
    return _schema.default;
  }
});
Object.defineProperty(exports, "Field", {
  enumerable: true,
  get: function get() {
    return _field.default;
  }
});
Object.defineProperty(exports, "Type", {
  enumerable: true,
  get: function get() {
    return _type.Type;
  }
});
Object.defineProperty(exports, "DataType", {
  enumerable: true,
  get: function get() {
    return _type.DataType;
  }
});
Object.defineProperty(exports, "Null", {
  enumerable: true,
  get: function get() {
    return _type.Null;
  }
});
Object.defineProperty(exports, "Bool", {
  enumerable: true,
  get: function get() {
    return _type.Bool;
  }
});
Object.defineProperty(exports, "Int", {
  enumerable: true,
  get: function get() {
    return _type.Int;
  }
});
Object.defineProperty(exports, "Int8", {
  enumerable: true,
  get: function get() {
    return _type.Int8;
  }
});
Object.defineProperty(exports, "Int16", {
  enumerable: true,
  get: function get() {
    return _type.Int16;
  }
});
Object.defineProperty(exports, "Int32", {
  enumerable: true,
  get: function get() {
    return _type.Int32;
  }
});
Object.defineProperty(exports, "Int64", {
  enumerable: true,
  get: function get() {
    return _type.Int64;
  }
});
Object.defineProperty(exports, "Uint8", {
  enumerable: true,
  get: function get() {
    return _type.Uint8;
  }
});
Object.defineProperty(exports, "Uint16", {
  enumerable: true,
  get: function get() {
    return _type.Uint16;
  }
});
Object.defineProperty(exports, "Uint32", {
  enumerable: true,
  get: function get() {
    return _type.Uint32;
  }
});
Object.defineProperty(exports, "Uint64", {
  enumerable: true,
  get: function get() {
    return _type.Uint64;
  }
});
Object.defineProperty(exports, "Float", {
  enumerable: true,
  get: function get() {
    return _type.Float;
  }
});
Object.defineProperty(exports, "Float16", {
  enumerable: true,
  get: function get() {
    return _type.Float16;
  }
});
Object.defineProperty(exports, "Float32", {
  enumerable: true,
  get: function get() {
    return _type.Float32;
  }
});
Object.defineProperty(exports, "Float64", {
  enumerable: true,
  get: function get() {
    return _type.Float64;
  }
});
Object.defineProperty(exports, "Binary", {
  enumerable: true,
  get: function get() {
    return _type.Binary;
  }
});
Object.defineProperty(exports, "Utf8", {
  enumerable: true,
  get: function get() {
    return _type.Utf8;
  }
});
Object.defineProperty(exports, "Date", {
  enumerable: true,
  get: function get() {
    return _type.Date;
  }
});
Object.defineProperty(exports, "DateDay", {
  enumerable: true,
  get: function get() {
    return _type.DateDay;
  }
});
Object.defineProperty(exports, "DateMillisecond", {
  enumerable: true,
  get: function get() {
    return _type.DateMillisecond;
  }
});
Object.defineProperty(exports, "Time", {
  enumerable: true,
  get: function get() {
    return _type.Time;
  }
});
Object.defineProperty(exports, "TimeSecond", {
  enumerable: true,
  get: function get() {
    return _type.TimeSecond;
  }
});
Object.defineProperty(exports, "TimeMillisecond", {
  enumerable: true,
  get: function get() {
    return _type.TimeMillisecond;
  }
});
Object.defineProperty(exports, "Timestamp", {
  enumerable: true,
  get: function get() {
    return _type.Timestamp;
  }
});
Object.defineProperty(exports, "TimestampSecond", {
  enumerable: true,
  get: function get() {
    return _type.TimestampSecond;
  }
});
Object.defineProperty(exports, "TimestampMillisecond", {
  enumerable: true,
  get: function get() {
    return _type.TimestampMillisecond;
  }
});
Object.defineProperty(exports, "TimestampMicrosecond", {
  enumerable: true,
  get: function get() {
    return _type.TimestampMicrosecond;
  }
});
Object.defineProperty(exports, "TimestampNanosecond", {
  enumerable: true,
  get: function get() {
    return _type.TimestampNanosecond;
  }
});
Object.defineProperty(exports, "Interval", {
  enumerable: true,
  get: function get() {
    return _type.Interval;
  }
});
Object.defineProperty(exports, "IntervalDayTime", {
  enumerable: true,
  get: function get() {
    return _type.IntervalDayTime;
  }
});
Object.defineProperty(exports, "IntervalYearMonth", {
  enumerable: true,
  get: function get() {
    return _type.IntervalYearMonth;
  }
});
Object.defineProperty(exports, "FixedSizeList", {
  enumerable: true,
  get: function get() {
    return _type.FixedSizeList;
  }
});

var _schema = _interopRequireDefault(require("./impl/schema"));

var _field = _interopRequireDefault(require("./impl/field"));

var _type = require("./impl/type");

},{"./impl/field":97,"./impl/schema":98,"./impl/type":99,"@babel/runtime/helpers/interopRequireDefault":18}],101:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var DEFAULT_ROW_COUNT = 100;

var RowTableBatchAggregator = function () {
  function RowTableBatchAggregator(schema, options) {
    (0, _classCallCheck2.default)(this, RowTableBatchAggregator);
    (0, _defineProperty2.default)(this, "schema", void 0);
    (0, _defineProperty2.default)(this, "options", void 0);
    (0, _defineProperty2.default)(this, "length", 0);
    (0, _defineProperty2.default)(this, "rows", null);
    (0, _defineProperty2.default)(this, "cursor", 0);
    (0, _defineProperty2.default)(this, "_headers", []);
    this.options = options;
    this.schema = schema;

    if (!Array.isArray(schema)) {
      this._headers = [];

      for (var key in schema) {
        this._headers[schema[key].index] = schema[key].name;
      }
    }
  }

  (0, _createClass2.default)(RowTableBatchAggregator, [{
    key: "rowCount",
    value: function rowCount() {
      return this.length;
    }
  }, {
    key: "addArrayRow",
    value: function addArrayRow(row, cursor) {
      if (Number.isFinite(cursor)) {
        this.cursor = cursor;
      }

      this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);
      this.rows[this.length] = row;
      this.length++;
    }
  }, {
    key: "addObjectRow",
    value: function addObjectRow(row, cursor) {
      if (Number.isFinite(cursor)) {
        this.cursor = cursor;
      }

      this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);
      this.rows[this.length] = row;
      this.length++;
    }
  }, {
    key: "getBatch",
    value: function getBatch() {
      var rows = this.rows;

      if (!rows) {
        return null;
      }

      rows = rows.slice(0, this.length);
      this.rows = null;
      var batch = {
        shape: this.options.shape,
        batchType: 'data',
        data: rows,
        length: this.length,
        schema: this.schema,
        cursor: this.cursor
      };
      return batch;
    }
  }]);
  return RowTableBatchAggregator;
}();

exports.default = RowTableBatchAggregator;

},{"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18}],102:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var DEFAULT_ROW_COUNT = 100;

var ColumnarTableBatchAggregator = function () {
  function ColumnarTableBatchAggregator(schema, options) {
    (0, _classCallCheck2.default)(this, ColumnarTableBatchAggregator);
    (0, _defineProperty2.default)(this, "schema", void 0);
    (0, _defineProperty2.default)(this, "length", 0);
    (0, _defineProperty2.default)(this, "allocated", 0);
    (0, _defineProperty2.default)(this, "columns", {});
    this.schema = schema;

    this._reallocateColumns();
  }

  (0, _createClass2.default)(ColumnarTableBatchAggregator, [{
    key: "rowCount",
    value: function rowCount() {
      return this.length;
    }
  }, {
    key: "addArrayRow",
    value: function addArrayRow(row) {
      this._reallocateColumns();

      var i = 0;

      for (var fieldName in this.columns) {
        this.columns[fieldName][this.length] = row[i++];
      }

      this.length++;
    }
  }, {
    key: "addObjectRow",
    value: function addObjectRow(row) {
      this._reallocateColumns();

      for (var fieldName in row) {
        this.columns[fieldName][this.length] = row[fieldName];
      }

      this.length++;
    }
  }, {
    key: "getBatch",
    value: function getBatch() {
      this._pruneColumns();

      var columns = Array.isArray(this.schema) ? this.columns : {};

      if (!Array.isArray(this.schema)) {
        for (var fieldName in this.schema) {
          var field = this.schema[fieldName];
          columns[field.name] = this.columns[field.index];
        }
      }

      this.columns = {};
      var batch = {
        shape: 'columnar-table',
        batchType: 'data',
        data: columns,
        schema: this.schema,
        length: this.length
      };
      return batch;
    }
  }, {
    key: "_reallocateColumns",
    value: function _reallocateColumns() {
      if (this.length < this.allocated) {
        return;
      }

      this.allocated = this.allocated > 0 ? this.allocated *= 2 : DEFAULT_ROW_COUNT;
      this.columns = {};

      for (var fieldName in this.schema) {
        var field = this.schema[fieldName];
        var ArrayType = field.type || Float32Array;
        var oldColumn = this.columns[field.index];

        if (oldColumn && ArrayBuffer.isView(oldColumn)) {
          var typedArray = new ArrayType(this.allocated);
          typedArray.set(oldColumn);
          this.columns[field.index] = typedArray;
        } else if (oldColumn) {
          oldColumn.length = this.allocated;
          this.columns[field.index] = oldColumn;
        } else {
          this.columns[field.index] = new ArrayType(this.allocated);
        }
      }
    }
  }, {
    key: "_pruneColumns",
    value: function _pruneColumns() {
      for (var _i = 0, _Object$entries = Object.entries(this.columns); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = (0, _slicedToArray2.default)(_Object$entries[_i], 2),
            _columnName = _Object$entries$_i[0],
            column = _Object$entries$_i[1];

        this.columns[_columnName] = column.slice(0, this.length);
      }
    }
  }]);
  return ColumnarTableBatchAggregator;
}();

exports.default = ColumnarTableBatchAggregator;

},{"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/slicedToArray":27}],103:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _rowUtils = require("../utils/row-utils");

var DEFAULT_ROW_COUNT = 100;

var RowTableBatchAggregator = function () {
  function RowTableBatchAggregator(schema, options) {
    (0, _classCallCheck2.default)(this, RowTableBatchAggregator);
    (0, _defineProperty2.default)(this, "schema", void 0);
    (0, _defineProperty2.default)(this, "options", void 0);
    (0, _defineProperty2.default)(this, "length", 0);
    (0, _defineProperty2.default)(this, "objectRows", null);
    (0, _defineProperty2.default)(this, "arrayRows", null);
    (0, _defineProperty2.default)(this, "cursor", 0);
    (0, _defineProperty2.default)(this, "_headers", []);
    this.options = options;
    this.schema = schema;

    if (!Array.isArray(schema)) {
      this._headers = [];

      for (var key in schema) {
        this._headers[schema[key].index] = schema[key].name;
      }
    }
  }

  (0, _createClass2.default)(RowTableBatchAggregator, [{
    key: "rowCount",
    value: function rowCount() {
      return this.length;
    }
  }, {
    key: "addArrayRow",
    value: function addArrayRow(row, cursor) {
      if (Number.isFinite(cursor)) {
        this.cursor = cursor;
      }

      switch (this.options.shape) {
        case 'object-row-table':
          var rowObject = (0, _rowUtils.convertToObjectRow)(row, this._headers);
          this.addObjectRow(rowObject, cursor);
          break;

        case 'array-row-table':
          this.arrayRows = this.arrayRows || new Array(DEFAULT_ROW_COUNT);
          this.arrayRows[this.length] = row;
          this.length++;
          break;
      }
    }
  }, {
    key: "addObjectRow",
    value: function addObjectRow(row, cursor) {
      if (Number.isFinite(cursor)) {
        this.cursor = cursor;
      }

      switch (this.options.shape) {
        case 'array-row-table':
          var rowArray = (0, _rowUtils.convertToArrayRow)(row, this._headers);
          this.addArrayRow(rowArray, cursor);
          break;

        case 'object-row-table':
          this.objectRows = this.objectRows || new Array(DEFAULT_ROW_COUNT);
          this.objectRows[this.length] = row;
          this.length++;
          break;
      }
    }
  }, {
    key: "getBatch",
    value: function getBatch() {
      var rows = this.arrayRows || this.objectRows;

      if (!rows) {
        return null;
      }

      rows = rows.slice(0, this.length);
      this.arrayRows = null;
      this.objectRows = null;
      return {
        shape: this.options.shape,
        batchType: 'data',
        data: rows,
        length: this.length,
        schema: this.schema,
        cursor: this.cursor
      };
    }
  }]);
  return RowTableBatchAggregator;
}();

exports.default = RowTableBatchAggregator;

},{"../utils/row-utils":107,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18}],104:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _baseTableBatchAggregator = _interopRequireDefault(require("./base-table-batch-aggregator"));

var _rowTableBatchAggregator = _interopRequireDefault(require("./row-table-batch-aggregator"));

var _columnarTableBatchAggregator = _interopRequireDefault(require("./columnar-table-batch-aggregator"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var DEFAULT_OPTIONS = {
  shape: 'array-row-table',
  batchSize: 'auto',
  batchDebounceMs: 0,
  limit: 0,
  _limitMB: 0
};
var ERR_MESSAGE = 'TableBatchBuilder';

var TableBatchBuilder = function () {
  function TableBatchBuilder(schema, options) {
    (0, _classCallCheck2.default)(this, TableBatchBuilder);
    (0, _defineProperty2.default)(this, "schema", void 0);
    (0, _defineProperty2.default)(this, "options", void 0);
    (0, _defineProperty2.default)(this, "aggregator", null);
    (0, _defineProperty2.default)(this, "batchCount", 0);
    (0, _defineProperty2.default)(this, "bytesUsed", 0);
    (0, _defineProperty2.default)(this, "isChunkComplete", false);
    (0, _defineProperty2.default)(this, "lastBatchEmittedMs", Date.now());
    (0, _defineProperty2.default)(this, "totalLength", 0);
    (0, _defineProperty2.default)(this, "totalBytes", 0);
    (0, _defineProperty2.default)(this, "rowBytes", 0);
    this.schema = schema;
    this.options = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS), options);
  }

  (0, _createClass2.default)(TableBatchBuilder, [{
    key: "limitReached",
    value: function limitReached() {
      var _this$options, _this$options2;

      if (Boolean((_this$options = this.options) === null || _this$options === void 0 ? void 0 : _this$options.limit) && this.totalLength >= this.options.limit) {
        return true;
      }

      if (Boolean((_this$options2 = this.options) === null || _this$options2 === void 0 ? void 0 : _this$options2._limitMB) && this.totalBytes / 1e6 >= this.options._limitMB) {
        return true;
      }

      return false;
    }
  }, {
    key: "addRow",
    value: function addRow(row) {
      if (this.limitReached()) {
        return;
      }

      this.totalLength++;
      this.rowBytes = this.rowBytes || this._estimateRowMB(row);
      this.totalBytes += this.rowBytes;

      if (Array.isArray(row)) {
        this.addArrayRow(row);
      } else {
        this.addObjectRow(row);
      }
    }
  }, {
    key: "addArrayRow",
    value: function addArrayRow(row) {
      if (!this.aggregator) {
        var TableBatchType = this._getTableBatchType();

        this.aggregator = new TableBatchType(this.schema, this.options);
      }

      this.aggregator.addArrayRow(row);
    }
  }, {
    key: "addObjectRow",
    value: function addObjectRow(row) {
      if (!this.aggregator) {
        var TableBatchType = this._getTableBatchType();

        this.aggregator = new TableBatchType(this.schema, this.options);
      }

      this.aggregator.addObjectRow(row);
    }
  }, {
    key: "chunkComplete",
    value: function chunkComplete(chunk) {
      if (chunk instanceof ArrayBuffer) {
        this.bytesUsed += chunk.byteLength;
      }

      if (typeof chunk === 'string') {
        this.bytesUsed += chunk.length;
      }

      this.isChunkComplete = true;
    }
  }, {
    key: "getFullBatch",
    value: function getFullBatch(options) {
      return this._isFull() ? this._getBatch(options) : null;
    }
  }, {
    key: "getFinalBatch",
    value: function getFinalBatch(options) {
      return this._getBatch(options);
    }
  }, {
    key: "_estimateRowMB",
    value: function _estimateRowMB(row) {
      return Array.isArray(row) ? row.length * 8 : Object.keys(row).length * 8;
    }
  }, {
    key: "_isFull",
    value: function _isFull() {
      if (!this.aggregator || this.aggregator.rowCount() === 0) {
        return false;
      }

      if (this.options.batchSize === 'auto') {
        if (!this.isChunkComplete) {
          return false;
        }
      } else if (this.options.batchSize > this.aggregator.rowCount()) {
        return false;
      }

      if (this.options.batchDebounceMs > Date.now() - this.lastBatchEmittedMs) {
        return false;
      }

      this.isChunkComplete = false;
      this.lastBatchEmittedMs = Date.now();
      return true;
    }
  }, {
    key: "_getBatch",
    value: function _getBatch(options) {
      if (!this.aggregator) {
        return null;
      }

      if (options !== null && options !== void 0 && options.bytesUsed) {
        this.bytesUsed = options.bytesUsed;
      }

      var normalizedBatch = this.aggregator.getBatch();
      normalizedBatch.count = this.batchCount;
      normalizedBatch.bytesUsed = this.bytesUsed;
      Object.assign(normalizedBatch, options);
      this.batchCount++;
      this.aggregator = null;
      return normalizedBatch;
    }
  }, {
    key: "_getTableBatchType",
    value: function _getTableBatchType() {
      switch (this.options.shape) {
        case 'row-table':
          return _baseTableBatchAggregator.default;

        case 'array-row-table':
        case 'object-row-table':
          return _rowTableBatchAggregator.default;

        case 'columnar-table':
          return _columnarTableBatchAggregator.default;

        case 'arrow-table':
          if (!TableBatchBuilder.ArrowBatch) {
            throw new Error(ERR_MESSAGE);
          }

          return TableBatchBuilder.ArrowBatch;

        default:
          throw new Error(ERR_MESSAGE);
      }
    }
  }]);
  return TableBatchBuilder;
}();

exports.default = TableBatchBuilder;
(0, _defineProperty2.default)(TableBatchBuilder, "ArrowBatch", void 0);

},{"./base-table-batch-aggregator":101,"./columnar-table-batch-aggregator":102,"./row-table-batch-aggregator":103,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18}],105:[function(require,module,exports){
arguments[4][81][0].apply(exports,arguments)
},{"dup":81}],106:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.takeAsync = takeAsync;
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));

var _Symbol$asyncIterator;

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var ArrayQueue = function (_Array) {
  (0, _inherits2.default)(ArrayQueue, _Array);

  var _super = _createSuper(ArrayQueue);

  function ArrayQueue() {
    (0, _classCallCheck2.default)(this, ArrayQueue);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(ArrayQueue, [{
    key: "enqueue",
    value: function enqueue(value) {
      return this.push(value);
    }
  }, {
    key: "dequeue",
    value: function dequeue() {
      return this.shift();
    }
  }]);
  return ArrayQueue;
}((0, _wrapNativeSuper2.default)(Array));

_Symbol$asyncIterator = Symbol.asyncIterator;

var AsyncQueue = function () {
  function AsyncQueue() {
    (0, _classCallCheck2.default)(this, AsyncQueue);
    (0, _defineProperty2.default)(this, "_values", void 0);
    (0, _defineProperty2.default)(this, "_settlers", void 0);
    (0, _defineProperty2.default)(this, "_closed", void 0);
    this._values = new ArrayQueue();
    this._settlers = new ArrayQueue();
    this._closed = false;
  }

  (0, _createClass2.default)(AsyncQueue, [{
    key: "close",
    value: function close() {
      while (this._settlers.length > 0) {
        this._settlers.dequeue().resolve({
          done: true
        });
      }

      this._closed = true;
    }
  }, {
    key: _Symbol$asyncIterator,
    value: function value() {
      return this;
    }
  }, {
    key: "enqueue",
    value: function enqueue(value) {
      if (this._closed) {
        throw new Error('Closed');
      }

      if (this._settlers.length > 0) {
        if (this._values.length > 0) {
          throw new Error('Illegal internal state');
        }

        var settler = this._settlers.dequeue();

        if (value instanceof Error) {
          settler.reject(value);
        } else {
          settler.resolve({
            value: value
          });
        }
      } else {
        this._values.enqueue(value);
      }
    }
  }, {
    key: "next",
    value: function next() {
      var _this = this;

      if (this._values.length > 0) {
        var value = this._values.dequeue();

        if (value instanceof Error) {
          return Promise.reject(value);
        }

        return Promise.resolve({
          value: value
        });
      }

      if (this._closed) {
        if (this._settlers.length > 0) {
          throw new Error('Illegal internal state');
        }

        return Promise.resolve({
          done: true
        });
      }

      return new Promise(function (resolve, reject) {
        _this._settlers.enqueue({
          resolve: resolve,
          reject: reject
        });
      });
    }
  }]);
  return AsyncQueue;
}();

exports.default = AsyncQueue;

function takeAsync(_x) {
  return _takeAsync.apply(this, arguments);
}

function _takeAsync() {
  _takeAsync = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(asyncIterable) {
    var count,
        result,
        iterator,
        _yield$iterator$next,
        value,
        done,
        _args = arguments;

    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            count = _args.length > 1 && _args[1] !== undefined ? _args[1] : Infinity;
            result = [];
            iterator = asyncIterable[Symbol.asyncIterator]();

          case 3:
            if (!(result.length < count)) {
              _context.next = 14;
              break;
            }

            _context.next = 6;
            return iterator.next();

          case 6:
            _yield$iterator$next = _context.sent;
            value = _yield$iterator$next.value;
            done = _yield$iterator$next.done;

            if (!done) {
              _context.next = 11;
              break;
            }

            return _context.abrupt("break", 14);

          case 11:
            result.push(value);
            _context.next = 3;
            break;

          case 14:
            return _context.abrupt("return", result);

          case 15:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _takeAsync.apply(this, arguments);
}

},{"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/getPrototypeOf":16,"@babel/runtime/helpers/inherits":17,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/possibleConstructorReturn":25,"@babel/runtime/helpers/wrapNativeSuper":32,"@babel/runtime/regenerator":33}],107:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertToObjectRow = convertToObjectRow;
exports.convertToArrayRow = convertToArrayRow;

function convertToObjectRow(arrayRow, headers) {
  if (!arrayRow) {
    throw new Error('null row');
  }

  if (!headers) {
    throw new Error('no headers');
  }

  var objectRow = {};

  for (var i = 0; i < headers.length; i++) {
    objectRow[headers[i]] = arrayRow[i];
  }

  return objectRow;
}

function convertToArrayRow(objectRow, headers) {
  if (!objectRow) {
    throw new Error('null row');
  }

  if (!headers) {
    throw new Error('no headers');
  }

  var arrayRow = new Array(headers.length);

  for (var i = 0; i < headers.length; i++) {
    arrayRow[i] = objectRow[headers[i]];
  }

  return arrayRow;
}

},{}],108:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function get() {
    return _assert.assert;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function get() {
    return _globals.isBrowser;
  }
});
Object.defineProperty(exports, "isWorker", {
  enumerable: true,
  get: function get() {
    return _globals.isWorker;
  }
});
Object.defineProperty(exports, "WorkerJob", {
  enumerable: true,
  get: function get() {
    return _workerJob.default;
  }
});
Object.defineProperty(exports, "WorkerThread", {
  enumerable: true,
  get: function get() {
    return _workerThread.default;
  }
});
Object.defineProperty(exports, "WorkerFarm", {
  enumerable: true,
  get: function get() {
    return _workerFarm.default;
  }
});
Object.defineProperty(exports, "WorkerPool", {
  enumerable: true,
  get: function get() {
    return _workerPool.default;
  }
});
Object.defineProperty(exports, "WorkerBody", {
  enumerable: true,
  get: function get() {
    return _workerBody.default;
  }
});
Object.defineProperty(exports, "processOnWorker", {
  enumerable: true,
  get: function get() {
    return _processOnWorker.processOnWorker;
  }
});
Object.defineProperty(exports, "canProcessOnWorker", {
  enumerable: true,
  get: function get() {
    return _processOnWorker.canProcessOnWorker;
  }
});
Object.defineProperty(exports, "createWorker", {
  enumerable: true,
  get: function get() {
    return _createWorker.createWorker;
  }
});
Object.defineProperty(exports, "getWorkerURL", {
  enumerable: true,
  get: function get() {
    return _getWorkerUrl.getWorkerURL;
  }
});
Object.defineProperty(exports, "validateWorkerVersion", {
  enumerable: true,
  get: function get() {
    return _validateWorkerVersion.validateWorkerVersion;
  }
});
Object.defineProperty(exports, "getTransferList", {
  enumerable: true,
  get: function get() {
    return _getTransferList.getTransferList;
  }
});
Object.defineProperty(exports, "getLibraryUrl", {
  enumerable: true,
  get: function get() {
    return _libraryUtils.getLibraryUrl;
  }
});
Object.defineProperty(exports, "loadLibrary", {
  enumerable: true,
  get: function get() {
    return _libraryUtils.loadLibrary;
  }
});
Object.defineProperty(exports, "AsyncQueue", {
  enumerable: true,
  get: function get() {
    return _asyncQueue.default;
  }
});
Object.defineProperty(exports, "ChildProcessProxy", {
  enumerable: true,
  get: function get() {
    return _childProcessProxy.default;
  }
});
exports.NullWorker = void 0;

var _version = require("./lib/env-utils/version");

var _assert = require("./lib/env-utils/assert");

var _globals = require("./lib/env-utils/globals");

var _workerJob = _interopRequireDefault(require("./lib/worker-farm/worker-job"));

var _workerThread = _interopRequireDefault(require("./lib/worker-farm/worker-thread"));

var _workerFarm = _interopRequireDefault(require("./lib/worker-farm/worker-farm"));

var _workerPool = _interopRequireDefault(require("./lib/worker-farm/worker-pool"));

var _workerBody = _interopRequireDefault(require("./lib/worker-farm/worker-body"));

var _processOnWorker = require("./lib/worker-api/process-on-worker");

var _createWorker = require("./lib/worker-api/create-worker");

var _getWorkerUrl = require("./lib/worker-api/get-worker-url");

var _validateWorkerVersion = require("./lib/worker-api/validate-worker-version");

var _getTransferList = require("./lib/worker-utils/get-transfer-list");

var _libraryUtils = require("./lib/library-utils/library-utils");

var _asyncQueue = _interopRequireDefault(require("./lib/async-queue/async-queue"));

var _childProcessProxy = _interopRequireDefault(require("./lib/process-utils/child-process-proxy"));

var NullWorker = {
  id: 'null',
  name: 'null',
  module: 'worker-utils',
  version: _version.VERSION,
  options: {
    null: {}
  }
};
exports.NullWorker = NullWorker;

},{"./lib/async-queue/async-queue":109,"./lib/env-utils/assert":110,"./lib/env-utils/globals":111,"./lib/env-utils/version":112,"./lib/library-utils/library-utils":113,"./lib/process-utils/child-process-proxy":130,"./lib/worker-api/create-worker":114,"./lib/worker-api/get-worker-url":115,"./lib/worker-api/process-on-worker":116,"./lib/worker-api/validate-worker-version":117,"./lib/worker-farm/worker-body":118,"./lib/worker-farm/worker-farm":119,"./lib/worker-farm/worker-job":120,"./lib/worker-farm/worker-pool":121,"./lib/worker-farm/worker-thread":122,"./lib/worker-utils/get-transfer-list":124,"@babel/runtime/helpers/interopRequireDefault":18}],109:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _Symbol$asyncIterator;

_Symbol$asyncIterator = Symbol.asyncIterator;

var AsyncQueue = function () {
  function AsyncQueue() {
    (0, _classCallCheck2.default)(this, AsyncQueue);
    (0, _defineProperty2.default)(this, "_values", void 0);
    (0, _defineProperty2.default)(this, "_settlers", void 0);
    (0, _defineProperty2.default)(this, "_closed", void 0);
    this._values = [];
    this._settlers = [];
    this._closed = false;
  }

  (0, _createClass2.default)(AsyncQueue, [{
    key: _Symbol$asyncIterator,
    value: function value() {
      return this;
    }
  }, {
    key: "push",
    value: function push(value) {
      return this.enqueue(value);
    }
  }, {
    key: "enqueue",
    value: function enqueue(value) {
      if (this._closed) {
        throw new Error('Closed');
      }

      if (this._settlers.length > 0) {
        if (this._values.length > 0) {
          throw new Error('Illegal internal state');
        }

        var settler = this._settlers.shift();

        if (value instanceof Error) {
          settler.reject(value);
        } else {
          settler.resolve({
            value: value
          });
        }
      } else {
        this._values.push(value);
      }
    }
  }, {
    key: "close",
    value: function close() {
      while (this._settlers.length > 0) {
        var settler = this._settlers.shift();

        settler.resolve({
          done: true
        });
      }

      this._closed = true;
    }
  }, {
    key: "next",
    value: function next() {
      var _this = this;

      if (this._values.length > 0) {
        var value = this._values.shift();

        if (value instanceof Error) {
          return Promise.reject(value);
        }

        return Promise.resolve({
          done: false,
          value: value
        });
      }

      if (this._closed) {
        if (this._settlers.length > 0) {
          throw new Error('Illegal internal state');
        }

        return Promise.resolve({
          done: true,
          value: undefined
        });
      }

      return new Promise(function (resolve, reject) {
        _this._settlers.push({
          resolve: resolve,
          reject: reject
        });
      });
    }
  }]);
  return AsyncQueue;
}();

exports.default = AsyncQueue;

},{"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18}],110:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assert = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'loaders.gl assertion failed.');
  }
}

},{}],111:[function(require,module,exports){
(function (process,global){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nodeVersion = exports.isMobile = exports.isWorker = exports.isBrowser = exports.document = exports.global = exports.window = exports.self = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};
var self_ = globals.self || globals.window || globals.global || {};
exports.self = self_;
var window_ = globals.window || globals.self || globals.global || {};
exports.window = window_;
var global_ = globals.global || globals.self || globals.window || {};
exports.global = global_;
var document_ = globals.document || {};
exports.document = document_;
var isBrowser = (typeof process === "undefined" ? "undefined" : (0, _typeof2.default)(process)) !== 'object' || String(process) !== '[object process]' || process.browser;
exports.isBrowser = isBrowser;
var isWorker = typeof importScripts === 'function';
exports.isWorker = isWorker;
var isMobile = typeof window !== 'undefined' && typeof window.orientation !== 'undefined';
exports.isMobile = isMobile;
var matches = typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);
var nodeVersion = matches && parseFloat(matches[1]) || 0;
exports.nodeVersion = nodeVersion;

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"_process":153}],112:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VERSION = void 0;
var DEFAULT_VERSION = 'beta';
var VERSION = typeof "3.0.9" !== 'undefined' ? "3.0.9" : DEFAULT_VERSION;
exports.VERSION = VERSION;

if (typeof "3.0.9" === 'undefined') {
  console.error('loaders.gl: The __VERSION__ variable is not injected using babel plugin. Latest unstable workers would be fetched from the CDN.');
}

},{}],113:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadLibrary = loadLibrary;
exports.getLibraryUrl = getLibraryUrl;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _globals = require("../env-utils/globals");

var node = _interopRequireWildcard(require("../node/require-utils.node"));

var _assert = require("../env-utils/assert");

var _version = require("../env-utils/version");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var LATEST = 'beta';
var VERSION = typeof "3.0.9" !== 'undefined' ? "3.0.9" : LATEST;
var loadLibraryPromises = {};

function loadLibrary(_x) {
  return _loadLibrary.apply(this, arguments);
}

function _loadLibrary() {
  _loadLibrary = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(libraryUrl) {
    var moduleName,
        options,
        _args = arguments;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            moduleName = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;
            options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};

            if (moduleName) {
              libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);
            }

            loadLibraryPromises[libraryUrl] = loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);
            _context.next = 6;
            return loadLibraryPromises[libraryUrl];

          case 6:
            return _context.abrupt("return", _context.sent);

          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _loadLibrary.apply(this, arguments);
}

function getLibraryUrl(library, moduleName, options) {
  if (library.startsWith('http')) {
    return library;
  }

  var modules = options.modules || {};

  if (modules[library]) {
    return modules[library];
  }

  if (!_globals.isBrowser) {
    return "modules/".concat(moduleName, "/dist/libs/").concat(library);
  }

  if (options.CDN) {
    (0, _assert.assert)(options.CDN.startsWith('http'));
    return "".concat(options.CDN, "/").concat(moduleName, "@").concat(VERSION, "/dist/libs/").concat(library);
  }

  if (_globals.isWorker) {
    return "../src/libs/".concat(library);
  }

  return "modules/".concat(moduleName, "/src/libs/").concat(library);
}

function loadLibraryFromFile(_x2) {
  return _loadLibraryFromFile.apply(this, arguments);
}

function _loadLibraryFromFile() {
  _loadLibraryFromFile = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(libraryUrl) {
    var _response, response, scriptSource;

    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!libraryUrl.endsWith('wasm')) {
              _context2.next = 7;
              break;
            }

            _context2.next = 3;
            return fetch(libraryUrl);

          case 3:
            _response = _context2.sent;
            _context2.next = 6;
            return _response.arrayBuffer();

          case 6:
            return _context2.abrupt("return", _context2.sent);

          case 7:
            if (_globals.isBrowser) {
              _context2.next = 14;
              break;
            }

            _context2.t0 = node.requireFromFile;

            if (!_context2.t0) {
              _context2.next = 13;
              break;
            }

            _context2.next = 12;
            return node.requireFromFile(libraryUrl);

          case 12:
            _context2.t0 = _context2.sent;

          case 13:
            return _context2.abrupt("return", _context2.t0);

          case 14:
            if (!_globals.isWorker) {
              _context2.next = 16;
              break;
            }

            return _context2.abrupt("return", importScripts(libraryUrl));

          case 16:
            _context2.next = 18;
            return fetch(libraryUrl);

          case 18:
            response = _context2.sent;
            _context2.next = 21;
            return response.text();

          case 21:
            scriptSource = _context2.sent;
            return _context2.abrupt("return", loadLibraryFromString(scriptSource, libraryUrl));

          case 23:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _loadLibraryFromFile.apply(this, arguments);
}

function loadLibraryFromString(scriptSource, id) {
  if (!_globals.isBrowser) {
    return node.requireFromString && node.requireFromString(scriptSource, id);
  }

  if (_globals.isWorker) {
    eval.call(_globals.global, scriptSource);
    return null;
  }

  var script = document.createElement('script');
  script.id = id;

  try {
    script.appendChild(document.createTextNode(scriptSource));
  } catch (e) {
    script.text = scriptSource;
  }

  document.body.appendChild(script);
  return null;
}

},{"../env-utils/assert":110,"../env-utils/globals":111,"../env-utils/version":112,"../node/require-utils.node":130,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"@babel/runtime/regenerator":33}],114:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createWorker = createWorker;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

var _asyncQueue = _interopRequireDefault(require("../async-queue/async-queue"));

var _workerBody = _interopRequireDefault(require("../worker-farm/worker-body"));

var requestId = 0;
var inputBatches;
var options;

function createWorker(process, processInBatches) {
  if (typeof self === 'undefined') {
    return;
  }

  var context = {
    process: processOnMainThread
  };

  _workerBody.default.onmessage = function () {
    var _ref = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(type, payload) {
      var result, resultIterator, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, batch, message;

      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.t0 = type;
              _context.next = _context.t0 === 'process' ? 4 : _context.t0 === 'process-in-batches' ? 11 : _context.t0 === 'input-batch' ? 51 : _context.t0 === 'input-done' ? 53 : 55;
              break;

            case 4:
              if (process) {
                _context.next = 6;
                break;
              }

              throw new Error('Worker does not support atomic processing');

            case 6:
              _context.next = 8;
              return process(payload.input, payload.options || {}, context);

            case 8:
              result = _context.sent;

              _workerBody.default.postMessage('done', {
                result: result
              });

              return _context.abrupt("break", 55);

            case 11:
              if (processInBatches) {
                _context.next = 13;
                break;
              }

              throw new Error('Worker does not support batched processing');

            case 13:
              inputBatches = new _asyncQueue.default();
              options = payload.options || {};
              resultIterator = processInBatches(inputBatches, options, context === null || context === void 0 ? void 0 : context.processInBatches);
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _context.prev = 18;
              _iterator = (0, _asyncIterator2.default)(resultIterator);

            case 20:
              _context.next = 22;
              return _iterator.next();

            case 22:
              _step = _context.sent;
              _iteratorNormalCompletion = _step.done;
              _context.next = 26;
              return _step.value;

            case 26:
              _value = _context.sent;

              if (_iteratorNormalCompletion) {
                _context.next = 33;
                break;
              }

              batch = _value;

              _workerBody.default.postMessage('output-batch', {
                result: batch
              });

            case 30:
              _iteratorNormalCompletion = true;
              _context.next = 20;
              break;

            case 33:
              _context.next = 39;
              break;

            case 35:
              _context.prev = 35;
              _context.t1 = _context["catch"](18);
              _didIteratorError = true;
              _iteratorError = _context.t1;

            case 39:
              _context.prev = 39;
              _context.prev = 40;

              if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
                _context.next = 44;
                break;
              }

              _context.next = 44;
              return _iterator.return();

            case 44:
              _context.prev = 44;

              if (!_didIteratorError) {
                _context.next = 47;
                break;
              }

              throw _iteratorError;

            case 47:
              return _context.finish(44);

            case 48:
              return _context.finish(39);

            case 49:
              _workerBody.default.postMessage('done', {});

              return _context.abrupt("break", 55);

            case 51:
              inputBatches.push(payload.input);
              return _context.abrupt("break", 55);

            case 53:
              inputBatches.close();
              return _context.abrupt("break", 55);

            case 55:
              _context.next = 61;
              break;

            case 57:
              _context.prev = 57;
              _context.t2 = _context["catch"](0);
              message = _context.t2 instanceof Error ? _context.t2.message : '';

              _workerBody.default.postMessage('error', {
                error: message
              });

            case 61:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[0, 57], [18, 35, 39, 49], [40,, 44, 48]]);
    }));

    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();
}

function processOnMainThread(arrayBuffer) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return new Promise(function (resolve, reject) {
    var id = requestId++;

    var onMessage = function onMessage(type, payload) {
      if (payload.id !== id) {
        return;
      }

      switch (type) {
        case 'done':
          _workerBody.default.removeEventListener(onMessage);

          resolve(payload.result);
          break;

        case 'error':
          _workerBody.default.removeEventListener(onMessage);

          reject(payload.error);
          break;

        default:
      }
    };

    _workerBody.default.addEventListener(onMessage);

    var payload = {
      id: id,
      input: arrayBuffer,
      options: options
    };

    _workerBody.default.postMessage('process', payload);
  });
}

},{"../async-queue/async-queue":109,"../worker-farm/worker-body":118,"@babel/runtime/helpers/asyncIterator":9,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],115:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getWorkerName = getWorkerName;
exports.getWorkerURL = getWorkerURL;

var _assert = require("../env-utils/assert");

var _version = require("../env-utils/version");

var NPM_TAG = 'latest';
var VERSION = typeof "3.0.9" !== 'undefined' ? "3.0.9" : NPM_TAG;

function getWorkerName(worker) {
  var warning = worker.version !== VERSION ? " (worker-utils@".concat(VERSION, ")") : '';
  return "".concat(worker.name, "@").concat(worker.version).concat(warning);
}

function getWorkerURL(worker) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var workerOptions = options[worker.id] || {};
  var workerFile = "".concat(worker.id, "-worker.js");
  var url = workerOptions.workerUrl;

  if (options._workerType === 'test') {
    url = "modules/".concat(worker.module, "/dist/").concat(workerFile);
  }

  if (!url) {
    var version = worker.version;

    if (version === 'latest') {
      version = NPM_TAG;
    }

    var versionTag = version ? "@".concat(version) : '';
    url = "https://unpkg.com/@loaders.gl/".concat(worker.module).concat(versionTag, "/dist/").concat(workerFile);
  }

  (0, _assert.assert)(url);
  return url;
}

},{"../env-utils/assert":110,"../env-utils/version":112}],116:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.canProcessOnWorker = canProcessOnWorker;
exports.processOnWorker = processOnWorker;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _workerFarm = _interopRequireDefault(require("../worker-farm/worker-farm"));

var _removeNontransferableOptions = require("../worker-utils/remove-nontransferable-options");

var _getWorkerUrl = require("./get-worker-url");

function canProcessOnWorker(worker, options) {
  if (!_workerFarm.default.isSupported()) {
    return false;
  }

  return worker.worker && (options === null || options === void 0 ? void 0 : options.worker);
}

function processOnWorker(_x, _x2) {
  return _processOnWorker.apply(this, arguments);
}

function _processOnWorker() {
  _processOnWorker = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(worker, data) {
    var options,
        context,
        name,
        url,
        workerFarm,
        workerPool,
        jobName,
        job,
        transferableOptions,
        result,
        _args = arguments;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
            context = _args.length > 3 && _args[3] !== undefined ? _args[3] : {};
            name = (0, _getWorkerUrl.getWorkerName)(worker);
            url = (0, _getWorkerUrl.getWorkerURL)(worker, options);
            workerFarm = _workerFarm.default.getWorkerFarm(options);
            workerPool = workerFarm.getWorkerPool({
              name: name,
              url: url
            });
            jobName = options.jobName || worker.name;
            _context.next = 9;
            return workerPool.startJob(jobName, onMessage.bind(null, context));

          case 9:
            job = _context.sent;
            transferableOptions = (0, _removeNontransferableOptions.removeNontransferableOptions)(options);
            job.postMessage('process', {
              input: data,
              options: transferableOptions
            });
            _context.next = 14;
            return job.result;

          case 14:
            result = _context.sent;
            return _context.abrupt("return", result.result);

          case 16:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _processOnWorker.apply(this, arguments);
}

function onMessage(_x3, _x4, _x5, _x6) {
  return _onMessage.apply(this, arguments);
}

function _onMessage() {
  _onMessage = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2(context, job, type, payload) {
    var id, input, options, result, message;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.t0 = type;
            _context2.next = _context2.t0 === 'done' ? 3 : _context2.t0 === 'error' ? 5 : _context2.t0 === 'process' ? 7 : 23;
            break;

          case 3:
            job.done(payload);
            return _context2.abrupt("break", 24);

          case 5:
            job.error(payload.error);
            return _context2.abrupt("break", 24);

          case 7:
            id = payload.id, input = payload.input, options = payload.options;
            _context2.prev = 8;

            if (context.process) {
              _context2.next = 12;
              break;
            }

            job.postMessage('error', {
              id: id,
              error: 'Worker not set up to process on main thread'
            });
            return _context2.abrupt("return");

          case 12:
            _context2.next = 14;
            return context.process(input, options);

          case 14:
            result = _context2.sent;
            job.postMessage('done', {
              id: id,
              result: result
            });
            _context2.next = 22;
            break;

          case 18:
            _context2.prev = 18;
            _context2.t1 = _context2["catch"](8);
            message = _context2.t1 instanceof Error ? _context2.t1.message : 'unknown error';
            job.postMessage('error', {
              id: id,
              error: message
            });

          case 22:
            return _context2.abrupt("break", 24);

          case 23:
            console.warn("process-on-worker: unknown message ".concat(type));

          case 24:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[8, 18]]);
  }));
  return _onMessage.apply(this, arguments);
}

},{"../worker-farm/worker-farm":119,"../worker-utils/remove-nontransferable-options":125,"./get-worker-url":115,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],117:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateWorkerVersion = validateWorkerVersion;

var _assert = require("../env-utils/assert");

var _version = require("../env-utils/version");

function validateWorkerVersion(worker) {
  var coreVersion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _version.VERSION;
  (0, _assert.assert)(worker, 'no worker provided');
  var workerVersion = worker.version;

  if (!coreVersion || !workerVersion) {
    return false;
  }

  return true;
}

function parseVersion(version) {
  var parts = version.split('.').map(Number);
  return {
    major: parts[0],
    minor: parts[1]
  };
}

},{"../env-utils/assert":110,"../env-utils/version":112}],118:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _getTransferList = require("../worker-utils/get-transfer-list");

var onMessageWrapperMap = new Map();

var WorkerBody = function () {
  function WorkerBody() {
    (0, _classCallCheck2.default)(this, WorkerBody);
  }

  (0, _createClass2.default)(WorkerBody, null, [{
    key: "onmessage",
    set: function set(onMessage) {
      self.onmessage = function (message) {
        if (!isKnownMessage(message)) {
          return;
        }

        var _message$data = message.data,
            type = _message$data.type,
            payload = _message$data.payload;
        onMessage(type, payload);
      };
    }
  }, {
    key: "addEventListener",
    value: function addEventListener(onMessage) {
      var onMessageWrapper = onMessageWrapperMap.get(onMessage);

      if (!onMessageWrapper) {
        onMessageWrapper = function onMessageWrapper(message) {
          if (!isKnownMessage(message)) {
            return;
          }

          var _message$data2 = message.data,
              type = _message$data2.type,
              payload = _message$data2.payload;
          onMessage(type, payload);
        };
      }

      self.addEventListener('message', onMessageWrapper);
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(onMessage) {
      var onMessageWrapper = onMessageWrapperMap.get(onMessage);
      onMessageWrapperMap.delete(onMessage);
      self.removeEventListener('message', onMessageWrapper);
    }
  }, {
    key: "postMessage",
    value: function postMessage(type, payload) {
      if (self) {
        var data = {
          source: 'loaders.gl',
          type: type,
          payload: payload
        };
        var transferList = (0, _getTransferList.getTransferList)(payload);
        self.postMessage(data, transferList);
      }
    }
  }]);
  return WorkerBody;
}();

exports.default = WorkerBody;

function isKnownMessage(message) {
  var type = message.type,
      data = message.data;
  return type === 'message' && data && typeof data.source === 'string' && data.source.startsWith('loaders.gl');
}

},{"../worker-utils/get-transfer-list":124,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/interopRequireDefault":18}],119:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _workerPool = _interopRequireDefault(require("./worker-pool"));

var _workerThread = _interopRequireDefault(require("./worker-thread"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var DEFAULT_PROPS = {
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  onDebug: function onDebug() {},
  reuseWorkers: true
};

var WorkerFarm = function () {
  function WorkerFarm(props) {
    (0, _classCallCheck2.default)(this, WorkerFarm);
    (0, _defineProperty2.default)(this, "props", void 0);
    (0, _defineProperty2.default)(this, "workerPools", new Map());
    this.props = _objectSpread({}, DEFAULT_PROPS);
    this.setProps(props);
    this.workerPools = new Map();
  }

  (0, _createClass2.default)(WorkerFarm, [{
    key: "destroy",
    value: function destroy() {
      var _iterator = _createForOfIteratorHelper(this.workerPools.values()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var workerPool = _step.value;
          workerPool.destroy();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      this.props = _objectSpread(_objectSpread({}, this.props), props);

      var _iterator2 = _createForOfIteratorHelper(this.workerPools.values()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var workerPool = _step2.value;
          workerPool.setProps(this._getWorkerPoolProps());
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }, {
    key: "getWorkerPool",
    value: function getWorkerPool(options) {
      var name = options.name,
          source = options.source,
          url = options.url;
      var workerPool = this.workerPools.get(name);

      if (!workerPool) {
        workerPool = new _workerPool.default({
          name: name,
          source: source,
          url: url
        });
        workerPool.setProps(this._getWorkerPoolProps());
        this.workerPools.set(name, workerPool);
      }

      return workerPool;
    }
  }, {
    key: "_getWorkerPoolProps",
    value: function _getWorkerPoolProps() {
      return {
        maxConcurrency: this.props.maxConcurrency,
        maxMobileConcurrency: this.props.maxMobileConcurrency,
        reuseWorkers: this.props.reuseWorkers,
        onDebug: this.props.onDebug
      };
    }
  }], [{
    key: "isSupported",
    value: function isSupported() {
      return _workerThread.default.isSupported();
    }
  }, {
    key: "getWorkerFarm",
    value: function getWorkerFarm() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      WorkerFarm._workerFarm = WorkerFarm._workerFarm || new WorkerFarm({});

      WorkerFarm._workerFarm.setProps(props);

      return WorkerFarm._workerFarm;
    }
  }]);
  return WorkerFarm;
}();

exports.default = WorkerFarm;
(0, _defineProperty2.default)(WorkerFarm, "_workerFarm", void 0);

},{"./worker-pool":121,"./worker-thread":122,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18}],120:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _assert = require("../env-utils/assert");

var WorkerJob = function () {
  function WorkerJob(jobName, workerThread) {
    var _this = this;

    (0, _classCallCheck2.default)(this, WorkerJob);
    (0, _defineProperty2.default)(this, "name", void 0);
    (0, _defineProperty2.default)(this, "workerThread", void 0);
    (0, _defineProperty2.default)(this, "isRunning", void 0);
    (0, _defineProperty2.default)(this, "result", void 0);
    (0, _defineProperty2.default)(this, "_resolve", void 0);
    (0, _defineProperty2.default)(this, "_reject", void 0);
    this.name = jobName;
    this.workerThread = workerThread;
    this.isRunning = true;

    this._resolve = function () {};

    this._reject = function () {};

    this.result = new Promise(function (resolve, reject) {
      _this._resolve = resolve;
      _this._reject = reject;
    });
  }

  (0, _createClass2.default)(WorkerJob, [{
    key: "postMessage",
    value: function postMessage(type, payload) {
      this.workerThread.postMessage({
        source: 'loaders.gl',
        type: type,
        payload: payload
      });
    }
  }, {
    key: "done",
    value: function done(value) {
      (0, _assert.assert)(this.isRunning);
      this.isRunning = false;

      this._resolve(value);
    }
  }, {
    key: "error",
    value: function error(_error) {
      (0, _assert.assert)(this.isRunning);
      this.isRunning = false;

      this._reject(_error);
    }
  }]);
  return WorkerJob;
}();

exports.default = WorkerJob;

},{"../env-utils/assert":110,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18}],121:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _globals = require("../env-utils/globals");

var _workerThread = _interopRequireDefault(require("./worker-thread"));

var _workerJob = _interopRequireDefault(require("./worker-job"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var WorkerPool = function () {
  function WorkerPool(props) {
    (0, _classCallCheck2.default)(this, WorkerPool);
    (0, _defineProperty2.default)(this, "name", 'unnamed');
    (0, _defineProperty2.default)(this, "source", void 0);
    (0, _defineProperty2.default)(this, "url", void 0);
    (0, _defineProperty2.default)(this, "maxConcurrency", 1);
    (0, _defineProperty2.default)(this, "maxMobileConcurrency", 1);
    (0, _defineProperty2.default)(this, "onDebug", function () {});
    (0, _defineProperty2.default)(this, "reuseWorkers", true);
    (0, _defineProperty2.default)(this, "props", {});
    (0, _defineProperty2.default)(this, "jobQueue", []);
    (0, _defineProperty2.default)(this, "idleQueue", []);
    (0, _defineProperty2.default)(this, "count", 0);
    (0, _defineProperty2.default)(this, "isDestroyed", false);
    this.source = props.source;
    this.url = props.url;
    this.setProps(props);
  }

  (0, _createClass2.default)(WorkerPool, [{
    key: "destroy",
    value: function destroy() {
      this.idleQueue.forEach(function (worker) {
        return worker.destroy();
      });
      this.isDestroyed = true;
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      this.props = _objectSpread(_objectSpread({}, this.props), props);

      if (props.name !== undefined) {
        this.name = props.name;
      }

      if (props.maxConcurrency !== undefined) {
        this.maxConcurrency = props.maxConcurrency;
      }

      if (props.maxMobileConcurrency !== undefined) {
        this.maxMobileConcurrency = props.maxMobileConcurrency;
      }

      if (props.reuseWorkers !== undefined) {
        this.reuseWorkers = props.reuseWorkers;
      }

      if (props.onDebug !== undefined) {
        this.onDebug = props.onDebug;
      }
    }
  }, {
    key: "startJob",
    value: function () {
      var _startJob = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee(name) {
        var _this = this;

        var onMessage,
            onError,
            startPromise,
            _args = arguments;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                onMessage = _args.length > 1 && _args[1] !== undefined ? _args[1] : function (job, type, data) {
                  return job.done(data);
                };
                onError = _args.length > 2 && _args[2] !== undefined ? _args[2] : function (job, error) {
                  return job.error(error);
                };
                startPromise = new Promise(function (onStart) {
                  _this.jobQueue.push({
                    name: name,
                    onMessage: onMessage,
                    onError: onError,
                    onStart: onStart
                  });

                  return _this;
                });

                this._startQueuedJob();

                _context.next = 6;
                return startPromise;

              case 6:
                return _context.abrupt("return", _context.sent);

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function startJob(_x) {
        return _startJob.apply(this, arguments);
      }

      return startJob;
    }()
  }, {
    key: "_startQueuedJob",
    value: function () {
      var _startQueuedJob2 = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2() {
        var workerThread, queuedJob, _job;

        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this.jobQueue.length) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return");

              case 2:
                workerThread = this._getAvailableWorker();

                if (workerThread) {
                  _context2.next = 5;
                  break;
                }

                return _context2.abrupt("return");

              case 5:
                queuedJob = this.jobQueue.shift();

                if (!queuedJob) {
                  _context2.next = 18;
                  break;
                }

                this.onDebug({
                  message: 'Starting job',
                  name: queuedJob.name,
                  workerThread: workerThread,
                  backlog: this.jobQueue.length
                });
                _job = new _workerJob.default(queuedJob.name, workerThread);

                workerThread.onMessage = function (data) {
                  return queuedJob.onMessage(_job, data.type, data.payload);
                };

                workerThread.onError = function (error) {
                  return queuedJob.onError(_job, error);
                };

                queuedJob.onStart(_job);
                _context2.prev = 12;
                _context2.next = 15;
                return _job.result;

              case 15:
                _context2.prev = 15;
                this.returnWorkerToQueue(workerThread);
                return _context2.finish(15);

              case 18:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[12,, 15, 18]]);
      }));

      function _startQueuedJob() {
        return _startQueuedJob2.apply(this, arguments);
      }

      return _startQueuedJob;
    }()
  }, {
    key: "returnWorkerToQueue",
    value: function returnWorkerToQueue(worker) {
      var shouldDestroyWorker = this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();

      if (shouldDestroyWorker) {
        worker.destroy();
        this.count--;
      } else {
        this.idleQueue.push(worker);
      }

      if (!this.isDestroyed) {
        this._startQueuedJob();
      }
    }
  }, {
    key: "_getAvailableWorker",
    value: function _getAvailableWorker() {
      if (this.idleQueue.length > 0) {
        return this.idleQueue.shift() || null;
      }

      if (this.count < this._getMaxConcurrency()) {
        this.count++;
        var name = "".concat(this.name.toLowerCase(), " (#").concat(this.count, " of ").concat(this.maxConcurrency, ")");
        return new _workerThread.default({
          name: name,
          source: this.source,
          url: this.url
        });
      }

      return null;
    }
  }, {
    key: "_getMaxConcurrency",
    value: function _getMaxConcurrency() {
      return _globals.isMobile ? this.maxMobileConcurrency : this.maxConcurrency;
    }
  }]);
  return WorkerPool;
}();

exports.default = WorkerPool;

},{"../env-utils/globals":111,"./worker-job":120,"./worker-thread":122,"@babel/runtime/helpers/asyncToGenerator":10,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/regenerator":33}],122:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _assert = require("../env-utils/assert");

var _getLoadableWorkerUrl = require("../worker-utils/get-loadable-worker-url");

var _getTransferList = require("../worker-utils/get-transfer-list");

var NOOP = function NOOP() {};

var WorkerThread = function () {
  function WorkerThread(props) {
    (0, _classCallCheck2.default)(this, WorkerThread);
    (0, _defineProperty2.default)(this, "name", void 0);
    (0, _defineProperty2.default)(this, "source", void 0);
    (0, _defineProperty2.default)(this, "url", void 0);
    (0, _defineProperty2.default)(this, "terminated", false);
    (0, _defineProperty2.default)(this, "worker", void 0);
    (0, _defineProperty2.default)(this, "onMessage", void 0);
    (0, _defineProperty2.default)(this, "onError", void 0);
    (0, _defineProperty2.default)(this, "_loadableURL", '');
    var name = props.name,
        source = props.source,
        url = props.url;
    (0, _assert.assert)(source || url);
    this.name = name;
    this.source = source;
    this.url = url;
    this.onMessage = NOOP;

    this.onError = function (error) {
      return console.log(error);
    };

    this.worker = this._createBrowserWorker();
  }

  (0, _createClass2.default)(WorkerThread, [{
    key: "destroy",
    value: function destroy() {
      this.onMessage = NOOP;
      this.onError = NOOP;
      this.worker.terminate();
      this.terminated = true;
    }
  }, {
    key: "isRunning",
    get: function get() {
      return Boolean(this.onMessage);
    }
  }, {
    key: "postMessage",
    value: function postMessage(data, transferList) {
      transferList = transferList || (0, _getTransferList.getTransferList)(data);
      this.worker.postMessage(data, transferList);
    }
  }, {
    key: "_getErrorFromErrorEvent",
    value: function _getErrorFromErrorEvent(event) {
      var message = 'Failed to load ';
      message += "worker ".concat(this.name, ". ");

      if (event.message) {
        message += "".concat(event.message, " in ");
      }

      if (event.lineno) {
        message += ":".concat(event.lineno, ":").concat(event.colno);
      }

      return new Error(message);
    }
  }, {
    key: "_createBrowserWorker",
    value: function _createBrowserWorker() {
      var _this = this;

      this._loadableURL = (0, _getLoadableWorkerUrl.getLoadableWorkerURL)({
        source: this.source,
        url: this.url
      });
      var worker = new Worker(this._loadableURL, {
        name: this.name
      });

      worker.onmessage = function (event) {
        if (!event.data) {
          _this.onError(new Error('No data received'));
        } else {
          _this.onMessage(event.data);
        }
      };

      worker.onerror = function (error) {
        _this.onError(_this._getErrorFromErrorEvent(error));

        _this.terminated = true;
      };

      worker.onmessageerror = function (event) {
        return console.error(event);
      };

      return worker;
    }
  }], [{
    key: "isSupported",
    value: function isSupported() {
      return typeof Worker !== 'undefined';
    }
  }]);
  return WorkerThread;
}();

exports.default = WorkerThread;

},{"../env-utils/assert":110,"../worker-utils/get-loadable-worker-url":123,"../worker-utils/get-transfer-list":124,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18}],123:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLoadableWorkerURL = getLoadableWorkerURL;

var _assert = require("../env-utils/assert");

var workerURLCache = new Map();

function getLoadableWorkerURL(props) {
  (0, _assert.assert)(props.source && !props.url || !props.source && props.url);
  var workerURL = workerURLCache.get(props.source || props.url);

  if (!workerURL) {
    if (props.url) {
      workerURL = getLoadableWorkerURLFromURL(props.url);
      workerURLCache.set(props.url, workerURL);
    }

    if (props.source) {
      workerURL = getLoadableWorkerURLFromSource(props.source);
      workerURLCache.set(props.source, workerURL);
    }
  }

  (0, _assert.assert)(workerURL);
  return workerURL;
}

function getLoadableWorkerURLFromURL(url) {
  if (!url.startsWith('http')) {
    return url;
  }

  var workerSource = buildScriptSource(url);
  return getLoadableWorkerURLFromSource(workerSource);
}

function getLoadableWorkerURLFromSource(workerSource) {
  var blob = new Blob([workerSource], {
    type: 'application/javascript'
  });
  return URL.createObjectURL(blob);
}

function buildScriptSource(workerUrl) {
  return "try {\n  importScripts('".concat(workerUrl, "');\n} catch (error) {\n  console.error(error);\n  throw error;\n}");
}

},{"../env-utils/assert":110}],124:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTransferList = getTransferList;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

function getTransferList(object) {
  var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var transfers = arguments.length > 2 ? arguments[2] : undefined;
  var transfersSet = transfers || new Set();

  if (!object) {} else if (isTransferable(object)) {
    transfersSet.add(object);
  } else if (isTransferable(object.buffer)) {
    transfersSet.add(object.buffer);
  } else if (ArrayBuffer.isView(object)) {} else if (recursive && (0, _typeof2.default)(object) === 'object') {
    for (var key in object) {
      getTransferList(object[key], recursive, transfersSet);
    }
  }

  return transfers === undefined ? Array.from(transfersSet) : [];
}

function isTransferable(object) {
  if (!object) {
    return false;
  }

  if (object instanceof ArrayBuffer) {
    return true;
  }

  if (typeof MessagePort !== 'undefined' && object instanceof MessagePort) {
    return true;
  }

  if (typeof ImageBitmap !== 'undefined' && object instanceof ImageBitmap) {
    return true;
  }

  if (typeof OffscreenCanvas !== 'undefined' && object instanceof OffscreenCanvas) {
    return true;
  }

  return false;
}

},{"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29}],125:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeNontransferableOptions = removeNontransferableOptions;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

function removeNontransferableOptions(object) {
  return JSON.parse(stringifyJSON(object));
}

function stringifyJSON(v) {
  var cache = new Set();
  return JSON.stringify(v, function (key, value) {
    if ((0, _typeof2.default)(value) === 'object' && value !== null) {
      if (cache.has(value)) {
        try {
          return JSON.parse(JSON.stringify(value));
        } catch (err) {
          return undefined;
        }
      }

      cache.add(value);
    }

    return value;
  });
}

},{"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29}],126:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Stats", {
  enumerable: true,
  get: function get() {
    return _stats.default;
  }
});
Object.defineProperty(exports, "Stat", {
  enumerable: true,
  get: function get() {
    return _stat.default;
  }
});
Object.defineProperty(exports, "_getHiResTimestamp", {
  enumerable: true,
  get: function get() {
    return _hiResTimestamp.default;
  }
});

var _stats = _interopRequireDefault(require("./lib/stats"));

var _stat = _interopRequireDefault(require("./lib/stat"));

var _hiResTimestamp = _interopRequireDefault(require("./utils/hi-res-timestamp"));

},{"./lib/stat":127,"./lib/stats":128,"./utils/hi-res-timestamp":129,"@babel/runtime/helpers/interopRequireDefault":18}],127:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _hiResTimestamp = _interopRequireDefault(require("../utils/hi-res-timestamp"));

var Stat = function () {
  function Stat(name, type) {
    (0, _classCallCheck2.default)(this, Stat);
    this.name = name;
    this.type = type;
    this.sampleSize = 1;
    this.reset();
  }

  (0, _createClass2.default)(Stat, [{
    key: "setSampleSize",
    value: function setSampleSize(samples) {
      this.sampleSize = samples;
      return this;
    }
  }, {
    key: "incrementCount",
    value: function incrementCount() {
      this.addCount(1);
      return this;
    }
  }, {
    key: "decrementCount",
    value: function decrementCount() {
      this.subtractCount(1);
      return this;
    }
  }, {
    key: "addCount",
    value: function addCount(value) {
      this._count += value;
      this._samples++;

      this._checkSampling();

      return this;
    }
  }, {
    key: "subtractCount",
    value: function subtractCount(value) {
      this._count -= value;
      this._samples++;

      this._checkSampling();

      return this;
    }
  }, {
    key: "addTime",
    value: function addTime(time) {
      this._time += time;
      this.lastTiming = time;
      this._samples++;

      this._checkSampling();

      return this;
    }
  }, {
    key: "timeStart",
    value: function timeStart() {
      this._startTime = (0, _hiResTimestamp.default)();
      this._timerPending = true;
      return this;
    }
  }, {
    key: "timeEnd",
    value: function timeEnd() {
      if (!this._timerPending) {
        return this;
      }

      this.addTime((0, _hiResTimestamp.default)() - this._startTime);
      this._timerPending = false;

      this._checkSampling();

      return this;
    }
  }, {
    key: "getSampleAverageCount",
    value: function getSampleAverageCount() {
      return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
    }
  }, {
    key: "getSampleAverageTime",
    value: function getSampleAverageTime() {
      return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
    }
  }, {
    key: "getSampleHz",
    value: function getSampleHz() {
      return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1000) : 0;
    }
  }, {
    key: "getAverageCount",
    value: function getAverageCount() {
      return this.samples > 0 ? this.count / this.samples : 0;
    }
  }, {
    key: "getAverageTime",
    value: function getAverageTime() {
      return this.samples > 0 ? this.time / this.samples : 0;
    }
  }, {
    key: "getHz",
    value: function getHz() {
      return this.time > 0 ? this.samples / (this.time / 1000) : 0;
    }
  }, {
    key: "reset",
    value: function reset() {
      this.time = 0;
      this.count = 0;
      this.samples = 0;
      this.lastTiming = 0;
      this.lastSampleTime = 0;
      this.lastSampleCount = 0;
      this._count = 0;
      this._time = 0;
      this._samples = 0;
      this._startTime = 0;
      this._timerPending = false;
      return this;
    }
  }, {
    key: "_checkSampling",
    value: function _checkSampling() {
      if (this._samples === this.sampleSize) {
        this.lastSampleTime = this._time;
        this.lastSampleCount = this._count;
        this.count += this._count;
        this.time += this._time;
        this.samples += this._samples;
        this._time = 0;
        this._count = 0;
        this._samples = 0;
      }
    }
  }]);
  return Stat;
}();

exports.default = Stat;

},{"../utils/hi-res-timestamp":129,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/interopRequireDefault":18}],128:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _stat = _interopRequireDefault(require("./stat"));

var Stats = function () {
  function Stats(_ref) {
    var id = _ref.id,
        stats = _ref.stats;
    (0, _classCallCheck2.default)(this, Stats);
    this.id = id;
    this.stats = {};

    this._initializeStats(stats);

    Object.seal(this);
  }

  (0, _createClass2.default)(Stats, [{
    key: "get",
    value: function get(name) {
      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'count';
      return this._getOrCreate({
        name: name,
        type: type
      });
    }
  }, {
    key: "size",
    get: function get() {
      return Object.keys(this.stats).length;
    }
  }, {
    key: "reset",
    value: function reset() {
      for (var key in this.stats) {
        this.stats[key].reset();
      }

      return this;
    }
  }, {
    key: "forEach",
    value: function forEach(fn) {
      for (var key in this.stats) {
        fn(this.stats[key]);
      }
    }
  }, {
    key: "getTable",
    value: function getTable() {
      var table = {};
      this.forEach(function (stat) {
        table[stat.name] = {
          time: stat.time || 0,
          count: stat.count || 0,
          average: stat.getAverageTime() || 0,
          hz: stat.getHz() || 0
        };
      });
      return table;
    }
  }, {
    key: "_initializeStats",
    value: function _initializeStats() {
      var _this = this;

      var stats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      stats.forEach(function (stat) {
        return _this._getOrCreate(stat);
      });
    }
  }, {
    key: "_getOrCreate",
    value: function _getOrCreate(stat) {
      if (!stat || !stat.name) {
        return null;
      }

      var name = stat.name,
          type = stat.type;

      if (!this.stats[name]) {
        if (stat instanceof _stat.default) {
          this.stats[name] = stat;
        } else {
          this.stats[name] = new _stat.default(name, type);
        }
      }

      return this.stats[name];
    }
  }]);
  return Stats;
}();

exports.default = Stats;

},{"./stat":127,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/interopRequireDefault":18}],129:[function(require,module,exports){
(function (process){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getHiResTimestamp;

function getHiResTimestamp() {
  var timestamp;

  if (typeof window !== 'undefined' && window.performance) {
    timestamp = window.performance.now();
  } else if (typeof process !== 'undefined' && process.hrtime) {
    var timeParts = process.hrtime();
    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }

  return timestamp;
}

}).call(this)}).call(this,require('_process'))

},{"_process":153}],130:[function(require,module,exports){

},{}],131:[function(require,module,exports){
module.exports = attributeToProperty

var transform = {
  'class': 'className',
  'for': 'htmlFor',
  'http-equiv': 'httpEquiv'
}

function attributeToProperty (h) {
  return function (tagName, attrs, children) {
    for (var attr in attrs) {
      if (attr in transform) {
        attrs[transform[attr]] = attrs[attr]
        delete attrs[attr]
      }
    }
    return h(tagName, attrs, children)
  }
}

},{}],132:[function(require,module,exports){
var attrToProp = require('hyperscript-attribute-to-property')

var VAR = 0, TEXT = 1, OPEN = 2, CLOSE = 3, ATTR = 4
var ATTR_KEY = 5, ATTR_KEY_W = 6
var ATTR_VALUE_W = 7, ATTR_VALUE = 8
var ATTR_VALUE_SQ = 9, ATTR_VALUE_DQ = 10
var ATTR_EQ = 11, ATTR_BREAK = 12
var COMMENT = 13

module.exports = function (h, opts) {
  if (!opts) opts = {}
  var concat = opts.concat || function (a, b) {
    return String(a) + String(b)
  }
  if (opts.attrToProp !== false) {
    h = attrToProp(h)
  }

  return function (strings) {
    var state = TEXT, reg = ''
    var arglen = arguments.length
    var parts = []

    for (var i = 0; i < strings.length; i++) {
      if (i < arglen - 1) {
        var arg = arguments[i+1]
        var p = parse(strings[i])
        var xstate = state
        if (xstate === ATTR_VALUE_DQ) xstate = ATTR_VALUE
        if (xstate === ATTR_VALUE_SQ) xstate = ATTR_VALUE
        if (xstate === ATTR_VALUE_W) xstate = ATTR_VALUE
        if (xstate === ATTR) xstate = ATTR_KEY
        if (xstate === OPEN) {
          if (reg === '/') {
            p.push([ OPEN, '/', arg ])
            reg = ''
          } else {
            p.push([ OPEN, arg ])
          }
        } else if (xstate === COMMENT && opts.comments) {
          reg += String(arg)
        } else if (xstate !== COMMENT) {
          p.push([ VAR, xstate, arg ])
        }
        parts.push.apply(parts, p)
      } else parts.push.apply(parts, parse(strings[i]))
    }

    var tree = [null,{},[]]
    var stack = [[tree,-1]]
    for (var i = 0; i < parts.length; i++) {
      var cur = stack[stack.length-1][0]
      var p = parts[i], s = p[0]
      if (s === OPEN && /^\//.test(p[1])) {
        var ix = stack[stack.length-1][1]
        if (stack.length > 1) {
          stack.pop()
          stack[stack.length-1][0][2][ix] = h(
            cur[0], cur[1], cur[2].length ? cur[2] : undefined
          )
        }
      } else if (s === OPEN) {
        var c = [p[1],{},[]]
        cur[2].push(c)
        stack.push([c,cur[2].length-1])
      } else if (s === ATTR_KEY || (s === VAR && p[1] === ATTR_KEY)) {
        var key = ''
        var copyKey
        for (; i < parts.length; i++) {
          if (parts[i][0] === ATTR_KEY) {
            key = concat(key, parts[i][1])
          } else if (parts[i][0] === VAR && parts[i][1] === ATTR_KEY) {
            if (typeof parts[i][2] === 'object' && !key) {
              for (copyKey in parts[i][2]) {
                if (parts[i][2].hasOwnProperty(copyKey) && !cur[1][copyKey]) {
                  cur[1][copyKey] = parts[i][2][copyKey]
                }
              }
            } else {
              key = concat(key, parts[i][2])
            }
          } else break
        }
        if (parts[i][0] === ATTR_EQ) i++
        var j = i
        for (; i < parts.length; i++) {
          if (parts[i][0] === ATTR_VALUE || parts[i][0] === ATTR_KEY) {
            if (!cur[1][key]) cur[1][key] = strfn(parts[i][1])
            else parts[i][1]==="" || (cur[1][key] = concat(cur[1][key], parts[i][1]));
          } else if (parts[i][0] === VAR
          && (parts[i][1] === ATTR_VALUE || parts[i][1] === ATTR_KEY)) {
            if (!cur[1][key]) cur[1][key] = strfn(parts[i][2])
            else parts[i][2]==="" || (cur[1][key] = concat(cur[1][key], parts[i][2]));
          } else {
            if (key.length && !cur[1][key] && i === j
            && (parts[i][0] === CLOSE || parts[i][0] === ATTR_BREAK)) {
              // https://html.spec.whatwg.org/multipage/infrastructure.html#boolean-attributes
              // empty string is falsy, not well behaved value in browser
              cur[1][key] = key.toLowerCase()
            }
            if (parts[i][0] === CLOSE) {
              i--
            }
            break
          }
        }
      } else if (s === ATTR_KEY) {
        cur[1][p[1]] = true
      } else if (s === VAR && p[1] === ATTR_KEY) {
        cur[1][p[2]] = true
      } else if (s === CLOSE) {
        if (selfClosing(cur[0]) && stack.length) {
          var ix = stack[stack.length-1][1]
          stack.pop()
          stack[stack.length-1][0][2][ix] = h(
            cur[0], cur[1], cur[2].length ? cur[2] : undefined
          )
        }
      } else if (s === VAR && p[1] === TEXT) {
        if (p[2] === undefined || p[2] === null) p[2] = ''
        else if (!p[2]) p[2] = concat('', p[2])
        if (Array.isArray(p[2][0])) {
          cur[2].push.apply(cur[2], p[2])
        } else {
          cur[2].push(p[2])
        }
      } else if (s === TEXT) {
        cur[2].push(p[1])
      } else if (s === ATTR_EQ || s === ATTR_BREAK) {
        // no-op
      } else {
        throw new Error('unhandled: ' + s)
      }
    }

    if (tree[2].length > 1 && /^\s*$/.test(tree[2][0])) {
      tree[2].shift()
    }

    if (tree[2].length > 2
    || (tree[2].length === 2 && /\S/.test(tree[2][1]))) {
      if (opts.createFragment) return opts.createFragment(tree[2])
      throw new Error(
        'multiple root elements must be wrapped in an enclosing tag'
      )
    }
    if (Array.isArray(tree[2][0]) && typeof tree[2][0][0] === 'string'
    && Array.isArray(tree[2][0][2])) {
      tree[2][0] = h(tree[2][0][0], tree[2][0][1], tree[2][0][2])
    }
    return tree[2][0]

    function parse (str) {
      var res = []
      if (state === ATTR_VALUE_W) state = ATTR
      for (var i = 0; i < str.length; i++) {
        var c = str.charAt(i)
        if (state === TEXT && c === '<') {
          if (reg.length) res.push([TEXT, reg])
          reg = ''
          state = OPEN
        } else if (c === '>' && !quot(state) && state !== COMMENT) {
          if (state === OPEN && reg.length) {
            res.push([OPEN,reg])
          } else if (state === ATTR_KEY) {
            res.push([ATTR_KEY,reg])
          } else if (state === ATTR_VALUE && reg.length) {
            res.push([ATTR_VALUE,reg])
          }
          res.push([CLOSE])
          reg = ''
          state = TEXT
        } else if (state === COMMENT && /-$/.test(reg) && c === '-') {
          if (opts.comments) {
            res.push([ATTR_VALUE,reg.substr(0, reg.length - 1)])
          }
          reg = ''
          state = TEXT
        } else if (state === OPEN && /^!--$/.test(reg)) {
          if (opts.comments) {
            res.push([OPEN, reg],[ATTR_KEY,'comment'],[ATTR_EQ])
          }
          reg = c
          state = COMMENT
        } else if (state === TEXT || state === COMMENT) {
          reg += c
        } else if (state === OPEN && c === '/' && reg.length) {
          // no-op, self closing tag without a space <br/>
        } else if (state === OPEN && /\s/.test(c)) {
          if (reg.length) {
            res.push([OPEN, reg])
          }
          reg = ''
          state = ATTR
        } else if (state === OPEN) {
          reg += c
        } else if (state === ATTR && /[^\s"'=/]/.test(c)) {
          state = ATTR_KEY
          reg = c
        } else if (state === ATTR && /\s/.test(c)) {
          if (reg.length) res.push([ATTR_KEY,reg])
          res.push([ATTR_BREAK])
        } else if (state === ATTR_KEY && /\s/.test(c)) {
          res.push([ATTR_KEY,reg])
          reg = ''
          state = ATTR_KEY_W
        } else if (state === ATTR_KEY && c === '=') {
          res.push([ATTR_KEY,reg],[ATTR_EQ])
          reg = ''
          state = ATTR_VALUE_W
        } else if (state === ATTR_KEY) {
          reg += c
        } else if ((state === ATTR_KEY_W || state === ATTR) && c === '=') {
          res.push([ATTR_EQ])
          state = ATTR_VALUE_W
        } else if ((state === ATTR_KEY_W || state === ATTR) && !/\s/.test(c)) {
          res.push([ATTR_BREAK])
          if (/[\w-]/.test(c)) {
            reg += c
            state = ATTR_KEY
          } else state = ATTR
        } else if (state === ATTR_VALUE_W && c === '"') {
          state = ATTR_VALUE_DQ
        } else if (state === ATTR_VALUE_W && c === "'") {
          state = ATTR_VALUE_SQ
        } else if (state === ATTR_VALUE_DQ && c === '"') {
          res.push([ATTR_VALUE,reg],[ATTR_BREAK])
          reg = ''
          state = ATTR
        } else if (state === ATTR_VALUE_SQ && c === "'") {
          res.push([ATTR_VALUE,reg],[ATTR_BREAK])
          reg = ''
          state = ATTR
        } else if (state === ATTR_VALUE_W && !/\s/.test(c)) {
          state = ATTR_VALUE
          i--
        } else if (state === ATTR_VALUE && /\s/.test(c)) {
          res.push([ATTR_VALUE,reg],[ATTR_BREAK])
          reg = ''
          state = ATTR
        } else if (state === ATTR_VALUE || state === ATTR_VALUE_SQ
        || state === ATTR_VALUE_DQ) {
          reg += c
        }
      }
      if (state === TEXT && reg.length) {
        res.push([TEXT,reg])
        reg = ''
      } else if (state === ATTR_VALUE && reg.length) {
        res.push([ATTR_VALUE,reg])
        reg = ''
      } else if (state === ATTR_VALUE_DQ && reg.length) {
        res.push([ATTR_VALUE,reg])
        reg = ''
      } else if (state === ATTR_VALUE_SQ && reg.length) {
        res.push([ATTR_VALUE,reg])
        reg = ''
      } else if (state === ATTR_KEY) {
        res.push([ATTR_KEY,reg])
        reg = ''
      }
      return res
    }
  }

  function strfn (x) {
    if (typeof x === 'function') return x
    else if (typeof x === 'string') return x
    else if (x && typeof x === 'object') return x
    else if (x === null || x === undefined) return x
    else return concat('', x)
  }
}

function quot (state) {
  return state === ATTR_VALUE_SQ || state === ATTR_VALUE_DQ
}

var closeRE = RegExp('^(' + [
  'area', 'base', 'basefont', 'bgsound', 'br', 'col', 'command', 'embed',
  'frame', 'hr', 'img', 'input', 'isindex', 'keygen', 'link', 'meta', 'param',
  'source', 'track', 'wbr', '!--',
  // SVG TAGS
  'animate', 'animateTransform', 'circle', 'cursor', 'desc', 'ellipse',
  'feBlend', 'feColorMatrix', 'feComposite',
  'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap',
  'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR',
  'feGaussianBlur', 'feImage', 'feMergeNode', 'feMorphology',
  'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile',
  'feTurbulence', 'font-face-format', 'font-face-name', 'font-face-uri',
  'glyph', 'glyphRef', 'hkern', 'image', 'line', 'missing-glyph', 'mpath',
  'path', 'polygon', 'polyline', 'rect', 'set', 'stop', 'tref', 'use', 'view',
  'vkern'
].join('|') + ')(?:[\.#][a-zA-Z0-9\u007F-\uFFFF_:-]+)*$')
function selfClosing (tag) { return closeRE.test(tag) }

},{"hyperscript-attribute-to-property":131}],133:[function(require,module,exports){
'use strict'

var trailingNewlineRegex = /\n[\s]+$/
var leadingNewlineRegex = /^\n[\s]+/
var trailingSpaceRegex = /[\s]+$/
var leadingSpaceRegex = /^[\s]+/
var multiSpaceRegex = /[\n\s]+/g

var TEXT_TAGS = [
  'a', 'abbr', 'b', 'bdi', 'bdo', 'br', 'cite', 'data', 'dfn', 'em', 'i',
  'kbd', 'mark', 'q', 'rp', 'rt', 'rtc', 'ruby', 's', 'amp', 'small', 'span',
  'strong', 'sub', 'sup', 'time', 'u', 'var', 'wbr'
]

var VERBATIM_TAGS = [
  'code', 'pre', 'textarea'
]

module.exports = function appendChild (el, childs) {
  if (!Array.isArray(childs)) return

  var nodeName = el.nodeName.toLowerCase()

  var hadText = false
  var value, leader

  for (var i = 0, len = childs.length; i < len; i++) {
    var node = childs[i]
    if (Array.isArray(node)) {
      appendChild(el, node)
      continue
    }

    if (typeof node === 'number' ||
      typeof node === 'boolean' ||
      typeof node === 'function' ||
      node instanceof Date ||
      node instanceof RegExp) {
      node = node.toString()
    }

    var lastChild = el.childNodes[el.childNodes.length - 1]

    // Iterate over text nodes
    if (typeof node === 'string') {
      hadText = true

      // If we already had text, append to the existing text
      if (lastChild && lastChild.nodeName === '#text') {
        lastChild.nodeValue += node

      // We didn't have a text node yet, create one
      } else {
        node = el.ownerDocument.createTextNode(node)
        el.appendChild(node)
        lastChild = node
      }

      // If this is the last of the child nodes, make sure we close it out
      // right
      if (i === len - 1) {
        hadText = false
        // Trim the child text nodes if the current node isn't a
        // node where whitespace matters.
        if (TEXT_TAGS.indexOf(nodeName) === -1 &&
          VERBATIM_TAGS.indexOf(nodeName) === -1) {
          value = lastChild.nodeValue
            .replace(leadingNewlineRegex, '')
            .replace(trailingSpaceRegex, '')
            .replace(trailingNewlineRegex, '')
            .replace(multiSpaceRegex, ' ')
          if (value === '') {
            el.removeChild(lastChild)
          } else {
            lastChild.nodeValue = value
          }
        } else if (VERBATIM_TAGS.indexOf(nodeName) === -1) {
          // The very first node in the list should not have leading
          // whitespace. Sibling text nodes should have whitespace if there
          // was any.
          leader = i === 0 ? '' : ' '
          value = lastChild.nodeValue
            .replace(leadingNewlineRegex, leader)
            .replace(leadingSpaceRegex, ' ')
            .replace(trailingSpaceRegex, '')
            .replace(trailingNewlineRegex, '')
            .replace(multiSpaceRegex, ' ')
          lastChild.nodeValue = value
        }
      }

    // Iterate over DOM nodes
    } else if (node && node.nodeType) {
      // If the last node was a text node, make sure it is properly closed out
      if (hadText) {
        hadText = false

        // Trim the child text nodes if the current node isn't a
        // text node or a code node
        if (TEXT_TAGS.indexOf(nodeName) === -1 &&
          VERBATIM_TAGS.indexOf(nodeName) === -1) {
          value = lastChild.nodeValue
            .replace(leadingNewlineRegex, '')
            .replace(trailingNewlineRegex, ' ')
            .replace(multiSpaceRegex, ' ')

          // Remove empty text nodes, append otherwise
          if (value === '') {
            el.removeChild(lastChild)
          } else {
            lastChild.nodeValue = value
          }
        // Trim the child nodes but preserve the appropriate whitespace
        } else if (VERBATIM_TAGS.indexOf(nodeName) === -1) {
          value = lastChild.nodeValue
            .replace(leadingSpaceRegex, ' ')
            .replace(leadingNewlineRegex, '')
            .replace(trailingNewlineRegex, ' ')
            .replace(multiSpaceRegex, ' ')
          lastChild.nodeValue = value
        }
      }

      // Store the last nodename
      var _nodeName = node.nodeName
      if (_nodeName) nodeName = _nodeName.toLowerCase()

      // Append the node to the DOM
      el.appendChild(node)
    }
  }
}

},{}],134:[function(require,module,exports){
'use strict'

module.exports = [
  'async', 'autofocus', 'autoplay', 'checked', 'controls', 'default',
  'defaultchecked', 'defer', 'disabled', 'formnovalidate', 'hidden',
  'ismap', 'loop', 'multiple', 'muted', 'novalidate', 'open', 'playsinline',
  'readonly', 'required', 'reversed', 'selected'
]

},{}],135:[function(require,module,exports){
module.exports = require('./dom')(document)

},{"./dom":137}],136:[function(require,module,exports){
'use strict'

module.exports = [
  'indeterminate'
]

},{}],137:[function(require,module,exports){
'use strict'

var hyperx = require('hyperx')
var appendChild = require('./append-child')
var SVG_TAGS = require('./svg-tags')
var BOOL_PROPS = require('./bool-props')
// Props that need to be set directly rather than with el.setAttribute()
var DIRECT_PROPS = require('./direct-props')

var SVGNS = 'http://www.w3.org/2000/svg'
var XLINKNS = 'http://www.w3.org/1999/xlink'

var COMMENT_TAG = '!--'

module.exports = function (document) {
  function nanoHtmlCreateElement (tag, props, children) {
    var el

    // If an svg tag, it needs a namespace
    if (SVG_TAGS.indexOf(tag) !== -1) {
      props.namespace = SVGNS
    }

    // If we are using a namespace
    var ns = false
    if (props.namespace) {
      ns = props.namespace
      delete props.namespace
    }

    // If we are extending a builtin element
    var isCustomElement = false
    if (props.is) {
      isCustomElement = props.is
      delete props.is
    }

    // Create the element
    if (ns) {
      if (isCustomElement) {
        el = document.createElementNS(ns, tag, { is: isCustomElement })
      } else {
        el = document.createElementNS(ns, tag)
      }
    } else if (tag === COMMENT_TAG) {
      return document.createComment(props.comment)
    } else if (isCustomElement) {
      el = document.createElement(tag, { is: isCustomElement })
    } else {
      el = document.createElement(tag)
    }

    // Create the properties
    for (var p in props) {
      if (props.hasOwnProperty(p)) {
        var key = p.toLowerCase()
        var val = props[p]
        // Normalize className
        if (key === 'classname') {
          key = 'class'
          p = 'class'
        }
        // The for attribute gets transformed to htmlFor, but we just set as for
        if (p === 'htmlFor') {
          p = 'for'
        }
        // If a property is boolean, set itself to the key
        if (BOOL_PROPS.indexOf(key) !== -1) {
          if (String(val) === 'true') val = key
          else if (String(val) === 'false') continue
        }
        // If a property prefers being set directly vs setAttribute
        if (key.slice(0, 2) === 'on' || DIRECT_PROPS.indexOf(key) !== -1) {
          el[p] = val
        } else {
          if (ns) {
            if (p === 'xlink:href') {
              el.setAttributeNS(XLINKNS, p, val)
            } else if (/^xmlns($|:)/i.test(p)) {
              // skip xmlns definitions
            } else {
              el.setAttributeNS(null, p, val)
            }
          } else {
            el.setAttribute(p, val)
          }
        }
      }
    }

    appendChild(el, children)
    return el
  }

  function createFragment (nodes) {
    var fragment = document.createDocumentFragment()
    for (var i = 0; i < nodes.length; i++) {
      if (nodes[i] == null) continue
      if (Array.isArray(nodes[i])) {
        fragment.appendChild(createFragment(nodes[i]))
      } else {
        if (typeof nodes[i] === 'string') nodes[i] = document.createTextNode(nodes[i])
        fragment.appendChild(nodes[i])
      }
    }
    return fragment
  }

  var exports = hyperx(nanoHtmlCreateElement, {
    comments: true,
    createFragment: createFragment
  })
  exports.default = exports
  exports.createComment = nanoHtmlCreateElement
  return exports
}

},{"./append-child":133,"./bool-props":134,"./direct-props":136,"./svg-tags":138,"hyperx":132}],138:[function(require,module,exports){
'use strict'

module.exports = [
  'svg', 'altGlyph', 'altGlyphDef', 'altGlyphItem', 'animate', 'animateColor',
  'animateMotion', 'animateTransform', 'circle', 'clipPath', 'color-profile',
  'cursor', 'defs', 'desc', 'ellipse', 'feBlend', 'feColorMatrix',
  'feComponentTransfer', 'feComposite', 'feConvolveMatrix',
  'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood',
  'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage',
  'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight',
  'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence', 'filter',
  'font', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src',
  'font-face-uri', 'foreignObject', 'g', 'glyph', 'glyphRef', 'hkern', 'image',
  'line', 'linearGradient', 'marker', 'mask', 'metadata', 'missing-glyph',
  'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect',
  'set', 'stop', 'switch', 'symbol', 'text', 'textPath', 'title', 'tref',
  'tspan', 'use', 'view', 'vkern'
]

},{}],139:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isMobile = isMobile;
exports.default = getBrowser;

var _globals = require("./globals");

var _isBrowser = _interopRequireDefault(require("./is-browser"));

var _isElectron = _interopRequireDefault(require("./is-electron"));

function isMobile() {
  return typeof _globals.window.orientation !== 'undefined';
}

function getBrowser(mockUserAgent) {
  if (!mockUserAgent && !(0, _isBrowser.default)()) {
    return 'Node';
  }

  if ((0, _isElectron.default)(mockUserAgent)) {
    return 'Electron';
  }

  var navigator_ = typeof navigator !== 'undefined' ? navigator : {};
  var userAgent = mockUserAgent || navigator_.userAgent || '';

  if (userAgent.indexOf('Edge') > -1) {
    return 'Edge';
  }

  var isMSIE = userAgent.indexOf('MSIE ') !== -1;
  var isTrident = userAgent.indexOf('Trident/') !== -1;

  if (isMSIE || isTrident) {
    return 'IE';
  }

  if (_globals.window.chrome) {
    return 'Chrome';
  }

  if (_globals.window.safari) {
    return 'Safari';
  }

  if (_globals.window.mozInnerScreenX) {
    return 'Firefox';
  }

  return 'Unknown';
}

},{"./globals":140,"./is-browser":141,"./is-electron":142,"@babel/runtime/helpers/interopRequireDefault":18}],140:[function(require,module,exports){
(function (process,global){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.console = exports.process = exports.document = exports.global = exports.window = exports.self = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document,
  process: (typeof process === "undefined" ? "undefined" : (0, _typeof2.default)(process)) === 'object' && process
};
var self_ = globals.self || globals.window || globals.global;
exports.self = self_;
var window_ = globals.window || globals.self || globals.global;
exports.window = window_;
var global_ = globals.global || globals.self || globals.window;
exports.global = global_;
var document_ = globals.document || {};
exports.document = document_;
var process_ = globals.process || {};
exports.process = process_;
var console_ = console;
exports.console = console_;

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"_process":153}],141:[function(require,module,exports){
(function (process){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isBrowser;
exports.isBrowserMainThread = isBrowserMainThread;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _isElectron = _interopRequireDefault(require("./is-electron"));

function isBrowser() {
  var isNode = (typeof process === "undefined" ? "undefined" : (0, _typeof2.default)(process)) === 'object' && String(process) === '[object process]' && !process.browser;
  return !isNode || (0, _isElectron.default)();
}

function isBrowserMainThread() {
  return isBrowser() && typeof document !== 'undefined';
}

}).call(this)}).call(this,require('_process'))

},{"./is-electron":142,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"_process":153}],142:[function(require,module,exports){
(function (process){(function (){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isElectron;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

function isElectron(mockUserAgent) {
  if (typeof window !== 'undefined' && (0, _typeof2.default)(window.process) === 'object' && window.process.type === 'renderer') {
    return true;
  }

  if (typeof process !== 'undefined' && (0, _typeof2.default)(process.versions) === 'object' && Boolean(process.versions.electron)) {
    return true;
  }

  var realUserAgent = (typeof navigator === "undefined" ? "undefined" : (0, _typeof2.default)(navigator)) === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent;
  var userAgent = mockUserAgent || realUserAgent;

  if (userAgent && userAgent.indexOf('Electron') >= 0) {
    return true;
  }

  return false;
}

}).call(this)}).call(this,require('_process'))

},{"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"_process":153}],143:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Log", {
  enumerable: true,
  get: function get() {
    return _log.default;
  }
});
Object.defineProperty(exports, "VERSION", {
  enumerable: true,
  get: function get() {
    return _globals.VERSION;
  }
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function get() {
    return _globals2.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function get() {
    return _globals2.window;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function get() {
    return _globals2.global;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function get() {
    return _globals2.document;
  }
});
Object.defineProperty(exports, "process", {
  enumerable: true,
  get: function get() {
    return _globals2.process;
  }
});
Object.defineProperty(exports, "console", {
  enumerable: true,
  get: function get() {
    return _globals2.console;
  }
});
Object.defineProperty(exports, "isBrowser", {
  enumerable: true,
  get: function get() {
    return _isBrowser.default;
  }
});
Object.defineProperty(exports, "isBrowserMainThread", {
  enumerable: true,
  get: function get() {
    return _isBrowser.isBrowserMainThread;
  }
});
Object.defineProperty(exports, "getBrowser", {
  enumerable: true,
  get: function get() {
    return _getBrowser.default;
  }
});
Object.defineProperty(exports, "isMobile", {
  enumerable: true,
  get: function get() {
    return _getBrowser.isMobile;
  }
});
Object.defineProperty(exports, "isElectron", {
  enumerable: true,
  get: function get() {
    return _isElectron.default;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function get() {
    return _assert.default;
  }
});
Object.defineProperty(exports, "COLOR", {
  enumerable: true,
  get: function get() {
    return _color.COLOR;
  }
});
Object.defineProperty(exports, "addColor", {
  enumerable: true,
  get: function get() {
    return _color.addColor;
  }
});
Object.defineProperty(exports, "leftPad", {
  enumerable: true,
  get: function get() {
    return _formatters.leftPad;
  }
});
Object.defineProperty(exports, "rightPad", {
  enumerable: true,
  get: function get() {
    return _formatters.rightPad;
  }
});
Object.defineProperty(exports, "autobind", {
  enumerable: true,
  get: function get() {
    return _autobind.autobind;
  }
});
Object.defineProperty(exports, "LocalStorage", {
  enumerable: true,
  get: function get() {
    return _localStorage.default;
  }
});
Object.defineProperty(exports, "getHiResTimestamp", {
  enumerable: true,
  get: function get() {
    return _hiResTimestamp.default;
  }
});
Object.defineProperty(exports, "Stats", {
  enumerable: true,
  get: function get() {
    return _stats.Stats;
  }
});
Object.defineProperty(exports, "Stat", {
  enumerable: true,
  get: function get() {
    return _stats.Stat;
  }
});
exports.default = void 0;

require("./init");

var _log = _interopRequireDefault(require("./lib/log"));

var _globals = require("./utils/globals");

var _globals2 = require("./env/globals");

var _isBrowser = _interopRequireWildcard(require("./env/is-browser"));

var _getBrowser = _interopRequireWildcard(require("./env/get-browser"));

var _isElectron = _interopRequireDefault(require("./env/is-electron"));

var _assert = _interopRequireDefault(require("./utils/assert"));

var _color = require("./utils/color");

var _formatters = require("./utils/formatters");

var _autobind = require("./utils/autobind");

var _localStorage = _interopRequireDefault(require("./utils/local-storage"));

var _hiResTimestamp = _interopRequireDefault(require("./utils/hi-res-timestamp"));

var _stats = require("@probe.gl/stats");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var _default = new _log.default({
  id: 'probe.gl'
});

exports.default = _default;

},{"./env/get-browser":139,"./env/globals":140,"./env/is-browser":141,"./env/is-electron":142,"./init":144,"./lib/log":145,"./utils/assert":146,"./utils/autobind":147,"./utils/color":148,"./utils/formatters":149,"./utils/globals":150,"./utils/hi-res-timestamp":151,"./utils/local-storage":152,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/typeof":29,"@probe.gl/stats":126}],144:[function(require,module,exports){
"use strict";

var _globals = require("./utils/globals");

_globals.global.probe = {};

},{"./utils/globals":150}],145:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalizeArguments = normalizeArguments;
exports.default = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _globals = require("../utils/globals");

var _localStorage = _interopRequireDefault(require("../utils/local-storage"));

var _formatters = require("../utils/formatters");

var _color = require("../utils/color");

var _autobind = require("../utils/autobind");

var _assert2 = _interopRequireDefault(require("../utils/assert"));

var _hiResTimestamp = _interopRequireDefault(require("../utils/hi-res-timestamp"));

var originalConsole = {
  debug: _globals.isBrowser ? console.debug || console.log : console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
};
var DEFAULT_SETTINGS = {
  enabled: true,
  level: 0
};

function noop() {}

var cache = {};
var ONCE = {
  once: true
};

function getTableHeader(table) {
  for (var key in table) {
    for (var title in table[key]) {
      return title || 'untitled';
    }
  }

  return 'empty';
}

var Log = function () {
  function Log() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      id: ''
    },
        id = _ref.id;

    (0, _classCallCheck2.default)(this, Log);
    this.id = id;
    this.VERSION = _globals.VERSION;
    this._startTs = (0, _hiResTimestamp.default)();
    this._deltaTs = (0, _hiResTimestamp.default)();
    this.LOG_THROTTLE_TIMEOUT = 0;
    this._storage = new _localStorage.default("__probe-".concat(this.id, "__"), DEFAULT_SETTINGS);
    this.userData = {};
    this.timeStamp("".concat(this.id, " started"));
    (0, _autobind.autobind)(this);
    Object.seal(this);
  }

  (0, _createClass2.default)(Log, [{
    key: "level",
    get: function get() {
      return this.getLevel();
    },
    set: function set(newLevel) {
      this.setLevel(newLevel);
    }
  }, {
    key: "isEnabled",
    value: function isEnabled() {
      return this._storage.config.enabled;
    }
  }, {
    key: "getLevel",
    value: function getLevel() {
      return this._storage.config.level;
    }
  }, {
    key: "getTotal",
    value: function getTotal() {
      return Number(((0, _hiResTimestamp.default)() - this._startTs).toPrecision(10));
    }
  }, {
    key: "getDelta",
    value: function getDelta() {
      return Number(((0, _hiResTimestamp.default)() - this._deltaTs).toPrecision(10));
    }
  }, {
    key: "priority",
    get: function get() {
      return this.level;
    },
    set: function set(newPriority) {
      this.level = newPriority;
    }
  }, {
    key: "getPriority",
    value: function getPriority() {
      return this.level;
    }
  }, {
    key: "enable",
    value: function enable() {
      var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this._storage.updateConfiguration({
        enabled: enabled
      });

      return this;
    }
  }, {
    key: "setLevel",
    value: function setLevel(level) {
      this._storage.updateConfiguration({
        level: level
      });

      return this;
    }
  }, {
    key: "assert",
    value: function assert(condition, message) {
      (0, _assert2.default)(condition, message);
    }
  }, {
    key: "warn",
    value: function warn(message) {
      return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);
    }
  }, {
    key: "error",
    value: function error(message) {
      return this._getLogFunction(0, message, originalConsole.error, arguments);
    }
  }, {
    key: "deprecated",
    value: function deprecated(oldUsage, newUsage) {
      return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
    }
  }, {
    key: "removed",
    value: function removed(oldUsage, newUsage) {
      return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
    }
  }, {
    key: "probe",
    value: function probe(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {
        time: true,
        once: true
      });
    }
  }, {
    key: "log",
    value: function log(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);
    }
  }, {
    key: "info",
    value: function info(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.info, arguments);
    }
  }, {
    key: "once",
    value: function once(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole.debug || originalConsole.info, arguments, ONCE);
    }
  }, {
    key: "table",
    value: function table(logLevel, _table, columns) {
      if (_table) {
        return this._getLogFunction(logLevel, _table, console.table || noop, columns && [columns], {
          tag: getTableHeader(_table)
        });
      }

      return noop;
    }
  }, {
    key: "image",
    value: function image(_ref2) {
      var logLevel = _ref2.logLevel,
          priority = _ref2.priority,
          _image = _ref2.image,
          _ref2$message = _ref2.message,
          message = _ref2$message === void 0 ? '' : _ref2$message,
          _ref2$scale = _ref2.scale,
          scale = _ref2$scale === void 0 ? 1 : _ref2$scale;

      if (!this._shouldLog(logLevel || priority)) {
        return noop;
      }

      return _globals.isBrowser ? logImageInBrowser({
        image: _image,
        message: message,
        scale: scale
      }) : logImageInNode({
        image: _image,
        message: message,
        scale: scale
      });
    }
  }, {
    key: "settings",
    value: function settings() {
      if (console.table) {
        console.table(this._storage.config);
      } else {
        console.log(this._storage.config);
      }
    }
  }, {
    key: "get",
    value: function get(setting) {
      return this._storage.config[setting];
    }
  }, {
    key: "set",
    value: function set(setting, value) {
      this._storage.updateConfiguration((0, _defineProperty2.default)({}, setting, value));
    }
  }, {
    key: "time",
    value: function time(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
    }
  }, {
    key: "timeEnd",
    value: function timeEnd(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
    }
  }, {
    key: "timeStamp",
    value: function timeStamp(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.timeStamp || noop);
    }
  }, {
    key: "group",
    value: function group(logLevel, message) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
        collapsed: false
      };
      opts = normalizeArguments({
        logLevel: logLevel,
        message: message,
        opts: opts
      });
      var _opts = opts,
          collapsed = _opts.collapsed;
      opts.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
      return this._getLogFunction(opts);
    }
  }, {
    key: "groupCollapsed",
    value: function groupCollapsed(logLevel, message) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return this.group(logLevel, message, Object.assign({}, opts, {
        collapsed: true
      }));
    }
  }, {
    key: "groupEnd",
    value: function groupEnd(logLevel) {
      return this._getLogFunction(logLevel, '', console.groupEnd || noop);
    }
  }, {
    key: "withGroup",
    value: function withGroup(logLevel, message, func) {
      this.group(logLevel, message)();

      try {
        func();
      } finally {
        this.groupEnd(logLevel)();
      }
    }
  }, {
    key: "trace",
    value: function trace() {
      if (console.trace) {
        console.trace();
      }
    }
  }, {
    key: "_shouldLog",
    value: function _shouldLog(logLevel) {
      return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
    }
  }, {
    key: "_getLogFunction",
    value: function _getLogFunction(logLevel, message, method) {
      var args = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
      var opts = arguments.length > 4 ? arguments[4] : undefined;

      if (this._shouldLog(logLevel)) {
        var _method;

        opts = normalizeArguments({
          logLevel: logLevel,
          message: message,
          args: args,
          opts: opts
        });
        method = method || opts.method;
        (0, _assert2.default)(method);
        opts.total = this.getTotal();
        opts.delta = this.getDelta();
        this._deltaTs = (0, _hiResTimestamp.default)();
        var tag = opts.tag || opts.message;

        if (opts.once) {
          if (!cache[tag]) {
            cache[tag] = (0, _hiResTimestamp.default)();
          } else {
            return noop;
          }
        }

        message = decorateMessage(this.id, opts.message, opts);
        return (_method = method).bind.apply(_method, [console, message].concat((0, _toConsumableArray2.default)(opts.args)));
      }

      return noop;
    }
  }]);
  return Log;
}();

exports.default = Log;
Log.VERSION = _globals.VERSION;

function normalizeLogLevel(logLevel) {
  if (!logLevel) {
    return 0;
  }

  var resolvedLevel;

  switch ((0, _typeof2.default)(logLevel)) {
    case 'number':
      resolvedLevel = logLevel;
      break;

    case 'object':
      resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
      break;

    default:
      return 0;
  }

  (0, _assert2.default)(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
  return resolvedLevel;
}

function normalizeArguments(opts) {
  var logLevel = opts.logLevel,
      message = opts.message;
  opts.logLevel = normalizeLogLevel(logLevel);
  var args = opts.args ? Array.from(opts.args) : [];

  while (args.length && args.shift() !== message) {}

  opts.args = args;

  switch ((0, _typeof2.default)(logLevel)) {
    case 'string':
    case 'function':
      if (message !== undefined) {
        args.unshift(message);
      }

      opts.message = logLevel;
      break;

    case 'object':
      Object.assign(opts, logLevel);
      break;

    default:
  }

  if (typeof opts.message === 'function') {
    opts.message = opts.message();
  }

  var messageType = (0, _typeof2.default)(opts.message);
  (0, _assert2.default)(messageType === 'string' || messageType === 'object');
  return Object.assign(opts, opts.opts);
}

function decorateMessage(id, message, opts) {
  if (typeof message === 'string') {
    var time = opts.time ? (0, _formatters.leftPad)((0, _formatters.formatTime)(opts.total)) : '';
    message = opts.time ? "".concat(id, ": ").concat(time, "  ").concat(message) : "".concat(id, ": ").concat(message);
    message = (0, _color.addColor)(message, opts.color, opts.background);
  }

  return message;
}

function logImageInNode(_ref3) {
  var image = _ref3.image,
      _ref3$message = _ref3.message,
      message = _ref3$message === void 0 ? '' : _ref3$message,
      _ref3$scale = _ref3.scale,
      scale = _ref3$scale === void 0 ? 1 : _ref3$scale;
  var asciify = null;

  try {
    asciify = module.require('asciify-image');
  } catch (error) {}

  if (asciify) {
    return function () {
      return asciify(image, {
        fit: 'box',
        width: "".concat(Math.round(80 * scale), "%")
      }).then(function (data) {
        return console.log(data);
      });
    };
  }

  return noop;
}

function logImageInBrowser(_ref4) {
  var image = _ref4.image,
      _ref4$message = _ref4.message,
      message = _ref4$message === void 0 ? '' : _ref4$message,
      _ref4$scale = _ref4.scale,
      scale = _ref4$scale === void 0 ? 1 : _ref4$scale;

  if (typeof image === 'string') {
    var img = new Image();

    img.onload = function () {
      var _console;

      var args = (0, _formatters.formatImage)(img, message, scale);

      (_console = console).log.apply(_console, (0, _toConsumableArray2.default)(args));
    };

    img.src = image;
    return noop;
  }

  var element = image.nodeName || '';

  if (element.toLowerCase() === 'img') {
    var _console2;

    (_console2 = console).log.apply(_console2, (0, _toConsumableArray2.default)((0, _formatters.formatImage)(image, message, scale)));

    return noop;
  }

  if (element.toLowerCase() === 'canvas') {
    var _img = new Image();

    _img.onload = function () {
      var _console3;

      return (_console3 = console).log.apply(_console3, (0, _toConsumableArray2.default)((0, _formatters.formatImage)(_img, message, scale)));
    };

    _img.src = image.toDataURL();
    return noop;
  }

  return noop;
}

},{"../utils/assert":146,"../utils/autobind":147,"../utils/color":148,"../utils/formatters":149,"../utils/globals":150,"../utils/hi-res-timestamp":151,"../utils/local-storage":152,"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/defineProperty":15,"@babel/runtime/helpers/interopRequireDefault":18,"@babel/runtime/helpers/toConsumableArray":28,"@babel/runtime/helpers/typeof":29}],146:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assert;

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'Assertion failed');
  }
}

},{}],147:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.autobind = autobind;

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function autobind(obj) {
  var predefined = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['constructor'];
  var proto = Object.getPrototypeOf(obj);
  var propNames = Object.getOwnPropertyNames(proto);

  var _iterator = _createForOfIteratorHelper(propNames),
      _step;

  try {
    var _loop = function _loop() {
      var key = _step.value;

      if (typeof obj[key] === 'function') {
        if (!predefined.find(function (name) {
          return key === name;
        })) {
          obj[key] = obj[key].bind(obj);
        }
      }
    };

    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      _loop();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}

},{}],148:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addColor = addColor;
exports.COLOR = void 0;

var _globals = require("./globals");

var COLOR = {
  BLACK: 30,
  RED: 31,
  GREEN: 32,
  YELLOW: 33,
  BLUE: 34,
  MAGENTA: 35,
  CYAN: 36,
  WHITE: 37,
  BRIGHT_BLACK: 90,
  BRIGHT_RED: 91,
  BRIGHT_GREEN: 92,
  BRIGHT_YELLOW: 93,
  BRIGHT_BLUE: 94,
  BRIGHT_MAGENTA: 95,
  BRIGHT_CYAN: 96,
  BRIGHT_WHITE: 97
};
exports.COLOR = COLOR;

function getColor(color) {
  return typeof color === 'string' ? COLOR[color.toUpperCase()] || COLOR.WHITE : color;
}

function addColor(string, color, background) {
  if (!_globals.isBrowser && typeof string === 'string') {
    if (color) {
      color = getColor(color);
      string = "\x1B[".concat(color, "m").concat(string, "\x1B[39m");
    }

    if (background) {
      color = getColor(background);
      string = "\x1B[".concat(background + 10, "m").concat(string, "\x1B[49m");
    }
  }

  return string;
}

},{"./globals":150}],149:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatTime = formatTime;
exports.leftPad = leftPad;
exports.rightPad = rightPad;
exports.formatValue = formatValue;
exports.formatImage = formatImage;

function formatTime(ms) {
  var formatted;

  if (ms < 10) {
    formatted = "".concat(ms.toFixed(2), "ms");
  } else if (ms < 100) {
    formatted = "".concat(ms.toFixed(1), "ms");
  } else if (ms < 1000) {
    formatted = "".concat(ms.toFixed(0), "ms");
  } else {
    formatted = "".concat((ms / 1000).toFixed(2), "s");
  }

  return formatted;
}

function leftPad(string) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  var padLength = Math.max(length - string.length, 0);
  return "".concat(' '.repeat(padLength)).concat(string);
}

function rightPad(string) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  var padLength = Math.max(length - string.length, 0);
  return "".concat(string).concat(' '.repeat(padLength));
}

function formatValue(v) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var EPSILON = 1e-16;
  var _opts$isInteger = opts.isInteger,
      isInteger = _opts$isInteger === void 0 ? false : _opts$isInteger;

  if (Array.isArray(v) || ArrayBuffer.isView(v)) {
    return formatArrayValue(v, opts);
  }

  if (!Number.isFinite(v)) {
    return String(v);
  }

  if (Math.abs(v) < EPSILON) {
    return isInteger ? '0' : '0.';
  }

  if (isInteger) {
    return v.toFixed(0);
  }

  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {
    return v.toFixed(0);
  }

  var string = v.toPrecision(2);
  var decimal = string.indexOf('.0');
  return decimal === string.length - 2 ? string.slice(0, -1) : string;
}

function formatArrayValue(v, opts) {
  var _opts$maxElts = opts.maxElts,
      maxElts = _opts$maxElts === void 0 ? 16 : _opts$maxElts,
      _opts$size = opts.size,
      size = _opts$size === void 0 ? 1 : _opts$size;
  var string = '[';

  for (var i = 0; i < v.length && i < maxElts; ++i) {
    if (i > 0) {
      string += ",".concat(i % size === 0 ? ' ' : '');
    }

    string += formatValue(v[i], opts);
  }

  var terminator = v.length > maxElts ? '...' : ']';
  return "".concat(string).concat(terminator);
}

function formatImage(image, message, scale) {
  var maxWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 600;
  var imageUrl = image.src.replace(/\(/g, '%28').replace(/\)/g, '%29');

  if (image.width > maxWidth) {
    scale = Math.min(scale, maxWidth / image.width);
  }

  var width = image.width * scale;
  var height = image.height * scale;
  var style = ['font-size:1px;', "padding:".concat(Math.floor(height / 2), "px ").concat(Math.floor(width / 2), "px;"), "line-height:".concat(height, "px;"), "background:url(".concat(imageUrl, ");"), "background-size:".concat(width, "px ").concat(height, "px;"), 'color:transparent;'].join('');
  return ["".concat(message, " %c+"), style];
}

},{}],150:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "self", {
  enumerable: true,
  get: function get() {
    return _globals.self;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function get() {
    return _globals.window;
  }
});
Object.defineProperty(exports, "global", {
  enumerable: true,
  get: function get() {
    return _globals.global;
  }
});
Object.defineProperty(exports, "document", {
  enumerable: true,
  get: function get() {
    return _globals.document;
  }
});
Object.defineProperty(exports, "process", {
  enumerable: true,
  get: function get() {
    return _globals.process;
  }
});
Object.defineProperty(exports, "console", {
  enumerable: true,
  get: function get() {
    return _globals.console;
  }
});
exports.isBrowser = exports.VERSION = void 0;

var _isBrowser = _interopRequireDefault(require("../env/is-browser"));

var _globals = require("../env/globals");

var VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'untranspiled source';
exports.VERSION = VERSION;
var isBrowser = (0, _isBrowser.default)();
exports.isBrowser = isBrowser;

},{"../env/globals":140,"../env/is-browser":141,"@babel/runtime/helpers/interopRequireDefault":18}],151:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getHiResTimestamp;

var _globals = require("./globals");

function getHiResTimestamp() {
  var timestamp;

  if (_globals.isBrowser && _globals.window.performance) {
    timestamp = _globals.window.performance.now();
  } else if (_globals.process.hrtime) {
    var timeParts = _globals.process.hrtime();

    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }

  return timestamp;
}

},{"./globals":150}],152:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function getStorage(type) {
  try {
    var storage = window[type];
    var x = '__storage_test__';
    storage.setItem(x, x);
    storage.removeItem(x);
    return storage;
  } catch (e) {
    return null;
  }
}

var LocalStorage = function () {
  function LocalStorage(id, defaultSettings) {
    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'sessionStorage';
    (0, _classCallCheck2.default)(this, LocalStorage);
    this.storage = getStorage(type);
    this.id = id;
    this.config = {};
    Object.assign(this.config, defaultSettings);

    this._loadConfiguration();
  }

  (0, _createClass2.default)(LocalStorage, [{
    key: "getConfiguration",
    value: function getConfiguration() {
      return this.config;
    }
  }, {
    key: "setConfiguration",
    value: function setConfiguration(configuration) {
      this.config = {};
      return this.updateConfiguration(configuration);
    }
  }, {
    key: "updateConfiguration",
    value: function updateConfiguration(configuration) {
      Object.assign(this.config, configuration);

      if (this.storage) {
        var serialized = JSON.stringify(this.config);
        this.storage.setItem(this.id, serialized);
      }

      return this;
    }
  }, {
    key: "_loadConfiguration",
    value: function _loadConfiguration() {
      var configuration = {};

      if (this.storage) {
        var serializedConfiguration = this.storage.getItem(this.id);
        configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
      }

      Object.assign(this.config, configuration);
      return this;
    }
  }]);
  return LocalStorage;
}();

exports.default = LocalStorage;

},{"@babel/runtime/helpers/classCallCheck":12,"@babel/runtime/helpers/createClass":14,"@babel/runtime/helpers/interopRequireDefault":18}],153:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],154:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  define(Gp, "constructor", GeneratorFunctionPrototype);
  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  define(Gp, iteratorSymbol, function() {
    return this;
  });

  define(Gp, "toString", function() {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  typeof module === "object" ? module.exports : {}
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJleGFtcGxlLWRhdGEtbG9hZGluZy9zY3JpcHQuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9Bc3luY0dlbmVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL0F3YWl0VmFsdWUuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRoSG9sZXMuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jR2VuZXJhdG9yRGVsZWdhdGUuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY0l0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2F3YWl0QXN5bmNHZW5lcmF0b3IuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NvbnN0cnVjdC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXNOYXRpdmVGdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVSZXN0LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVTcHJlYWQuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2V0UHJvdG90eXBlT2YuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3dyYXBBc3luY0dlbmVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3dyYXBOYXRpdmVTdXBlci5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvaXRlcmF0b3JzL21ha2UtaXRlcmF0b3IvbWFrZS1hcnJheS1idWZmZXItaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9pdGVyYXRvcnMvbWFrZS1pdGVyYXRvci9tYWtlLWJsb2ItaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9pdGVyYXRvcnMvbWFrZS1pdGVyYXRvci9tYWtlLWl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvaXRlcmF0b3JzL21ha2UtaXRlcmF0b3IvbWFrZS1zdHJlYW0taXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9pdGVyYXRvcnMvbWFrZS1pdGVyYXRvci9tYWtlLXN0cmluZy1pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2l0ZXJhdG9ycy9tYWtlLXN0cmVhbS9tYWtlLWRvbS1zdHJlYW0uanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9pdGVyYXRvcnMvbWFrZS1zdHJlYW0vbWFrZS1zdHJlYW0uanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9qYXZhc2NyaXB0LXV0aWxzL2lzLXR5cGUuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9saWIvYXBpL2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2xpYi9hcGkvbG9hZC1pbi1iYXRjaGVzLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvbGliL2FwaS9sb2FkLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvbGliL2FwaS9wYXJzZS1pbi1iYXRjaGVzLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvbGliL2FwaS9wYXJzZS1zeW5jLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvbGliL2FwaS9wYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2xpYi9hcGkvcmVnaXN0ZXItbG9hZGVycy5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2xpYi9hcGkvc2F2ZS5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2xpYi9hcGkvc2VsZWN0LWxvYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2xpYi9hcGkvc2V0LWxvYWRlci1vcHRpb25zLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvbGliL2ZldGNoL2ZldGNoLWZpbGUuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9saWIvZmV0Y2gvcmVhZC1hcnJheS1idWZmZXIuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9saWIvZmV0Y2gvcmVhZC1maWxlLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvbGliL2ZldGNoL3dyaXRlLWZpbGUuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9saWIvZmlsZXN5c3RlbXMvYnJvd3Nlci1maWxlc3lzdGVtLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvbGliL2xvYWRlci11dGlscy9nZXQtZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2xpYi9sb2FkZXItdXRpbHMvbG9hZGVyLWNvbnRleHQuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9saWIvbG9hZGVyLXV0aWxzL2xvZ2dlcnMuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9saWIvbG9hZGVyLXV0aWxzL25vcm1hbGl6ZS1sb2FkZXIuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvY29yZS9kaXN0L2VzNS9saWIvbG9hZGVyLXV0aWxzL29wdGlvbi1kZWZhdWx0cy5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2xpYi9sb2FkZXItdXRpbHMvb3B0aW9uLXV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvbGliL3Byb2dyZXNzL2ZldGNoLXByb2dyZXNzLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2NvcmUvZGlzdC9lczUvbGliL3V0aWxzL21pbWUtdHlwZS11dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2xpYi91dGlscy9yZXNvdXJjZS11dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L2xpYi91dGlscy9yZXNwb25zZS11dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jb3JlL2Rpc3QvZXM1L251bGwtbG9hZGVyLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2Nzdi9kaXN0L2VzNS9jc3YtbG9hZGVyLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2Nzdi9kaXN0L2VzNS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9jc3YvZGlzdC9lczUvbGliL2FzeW5jLWl0ZXJhdG9yLXN0cmVhbWVyLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2Nzdi9kaXN0L2VzNS9saWJzL3BhcGFwYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9lczUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzL2Rpc3QvZXM1L2pzb24tbG9hZGVyLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscy9kaXN0L2VzNS9saWIvYmluYXJ5LXV0aWxzL2FycmF5LWJ1ZmZlci11dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9lczUvbGliL2JpbmFyeS11dGlscy9iaW5hcnktY29weS11dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9lczUvbGliL2JpbmFyeS11dGlscy9idWZmZXItdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzL2Rpc3QvZXM1L2xpYi9iaW5hcnktdXRpbHMvZW5jb2RlLXV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscy9kaXN0L2VzNS9saWIvYmluYXJ5LXV0aWxzL2dldC1maXJzdC1jaGFyYWN0ZXJzLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscy9kaXN0L2VzNS9saWIvYmluYXJ5LXV0aWxzL21lbW9yeS1jb3B5LXV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscy9kaXN0L2VzNS9saWIvZW52LXV0aWxzL2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9lczUvbGliL2Vudi11dGlscy9nbG9iYWxzLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscy9kaXN0L2VzNS9saWIvaXRlcmF0b3JzL2FzeW5jLWl0ZXJhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9lczUvbGliL2l0ZXJhdG9ycy90ZXh0LWl0ZXJhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9lczUvbGliL3BhcnNlci11dGlscy9wYXJzZS1qc29uLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscy9kaXN0L2VzNS9saWIvcGF0aC11dGlscy9maWxlLWFsaWFzZXMuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzL2Rpc3QvZXM1L2xpYi9wYXRoLXV0aWxzL3BhdGguanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzL2Rpc3QvZXM1L2xpYi9yZXF1ZXN0LXV0aWxzL3JlcXVlc3Qtc2NoZWR1bGVyLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL2xvYWRlci11dGlscy9kaXN0L2VzNS9saWIvd29ya2VyLWxvYWRlci11dGlscy9jcmVhdGUtbG9hZGVyLXdvcmtlci5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9sb2FkZXItdXRpbHMvZGlzdC9lczUvbGliL3dvcmtlci1sb2FkZXItdXRpbHMvcGFyc2Utd2l0aC13b3JrZXIuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvc2NoZW1hL2Rpc3QvZXM1L2NhdGVnb3J5L21lc2gvbWVzaC11dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9zY2hlbWEvZGlzdC9lczUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvc2NoZW1hL2Rpc3QvZXM1L2xpYi9zY2hlbWEtdXRpbHMvZGVkdWNlLXRhYmxlLXNjaGVtYS5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9zY2hlbWEvZGlzdC9lczUvbGliL3NjaGVtYS11dGlscy9nZXQtdHlwZS1pbmZvLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3NjaGVtYS9kaXN0L2VzNS9saWIvc2NoZW1hLXV0aWxzL3R5cGUtdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvc2NoZW1hL2Rpc3QvZXM1L2xpYi9zY2hlbWEvaW1wbC9lbnVtLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3NjaGVtYS9kaXN0L2VzNS9saWIvc2NoZW1hL2ltcGwvZmllbGQuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvc2NoZW1hL2Rpc3QvZXM1L2xpYi9zY2hlbWEvaW1wbC9zY2hlbWEuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvc2NoZW1hL2Rpc3QvZXM1L2xpYi9zY2hlbWEvaW1wbC90eXBlLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3NjaGVtYS9kaXN0L2VzNS9saWIvc2NoZW1hL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3NjaGVtYS9kaXN0L2VzNS9saWIvdGFibGUvYmFzZS10YWJsZS1iYXRjaC1hZ2dyZWdhdG9yLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3NjaGVtYS9kaXN0L2VzNS9saWIvdGFibGUvY29sdW1uYXItdGFibGUtYmF0Y2gtYWdncmVnYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9zY2hlbWEvZGlzdC9lczUvbGliL3RhYmxlL3Jvdy10YWJsZS1iYXRjaC1hZ2dyZWdhdG9yLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3NjaGVtYS9kaXN0L2VzNS9saWIvdGFibGUvdGFibGUtYmF0Y2gtYnVpbGRlci5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC9zY2hlbWEvZGlzdC9lczUvbGliL3V0aWxzL2FzeW5jLXF1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3NjaGVtYS9kaXN0L2VzNS9saWIvdXRpbHMvcm93LXV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2VzNS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9lczUvbGliL2FzeW5jLXF1ZXVlL2FzeW5jLXF1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2VzNS9saWIvZW52LXV0aWxzL2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9lczUvbGliL2Vudi11dGlscy9nbG9iYWxzLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2VzNS9saWIvZW52LXV0aWxzL3ZlcnNpb24uanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvd29ya2VyLXV0aWxzL2Rpc3QvZXM1L2xpYi9saWJyYXJ5LXV0aWxzL2xpYnJhcnktdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvd29ya2VyLXV0aWxzL2Rpc3QvZXM1L2xpYi93b3JrZXItYXBpL2NyZWF0ZS13b3JrZXIuanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvd29ya2VyLXV0aWxzL2Rpc3QvZXM1L2xpYi93b3JrZXItYXBpL2dldC13b3JrZXItdXJsLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2VzNS9saWIvd29ya2VyLWFwaS9wcm9jZXNzLW9uLXdvcmtlci5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9lczUvbGliL3dvcmtlci1hcGkvdmFsaWRhdGUtd29ya2VyLXZlcnNpb24uanMiLCJub2RlX21vZHVsZXMvQGxvYWRlcnMuZ2wvd29ya2VyLXV0aWxzL2Rpc3QvZXM1L2xpYi93b3JrZXItZmFybS93b3JrZXItYm9keS5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9lczUvbGliL3dvcmtlci1mYXJtL3dvcmtlci1mYXJtLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2VzNS9saWIvd29ya2VyLWZhcm0vd29ya2VyLWpvYi5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9lczUvbGliL3dvcmtlci1mYXJtL3dvcmtlci1wb29sLmpzIiwibm9kZV9tb2R1bGVzL0Bsb2FkZXJzLmdsL3dvcmtlci11dGlscy9kaXN0L2VzNS9saWIvd29ya2VyLWZhcm0vd29ya2VyLXRocmVhZC5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9lczUvbGliL3dvcmtlci11dGlscy9nZXQtbG9hZGFibGUtd29ya2VyLXVybC5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9lczUvbGliL3dvcmtlci11dGlscy9nZXQtdHJhbnNmZXItbGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9AbG9hZGVycy5nbC93b3JrZXItdXRpbHMvZGlzdC9lczUvbGliL3dvcmtlci11dGlscy9yZW1vdmUtbm9udHJhbnNmZXJhYmxlLW9wdGlvbnMuanMiLCJub2RlX21vZHVsZXMvQHByb2JlLmdsL3N0YXRzL2Rpc3QvZXM1L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0Bwcm9iZS5nbC9zdGF0cy9kaXN0L2VzNS9saWIvc3RhdC5qcyIsIm5vZGVfbW9kdWxlcy9AcHJvYmUuZ2wvc3RhdHMvZGlzdC9lczUvbGliL3N0YXRzLmpzIiwibm9kZV9tb2R1bGVzL0Bwcm9iZS5nbC9zdGF0cy9kaXN0L2VzNS91dGlscy9oaS1yZXMtdGltZXN0YW1wLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9oeXBlcnNjcmlwdC1hdHRyaWJ1dGUtdG8tcHJvcGVydHkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaHlwZXJ4L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL25hbm9odG1sL2xpYi9hcHBlbmQtY2hpbGQuanMiLCJub2RlX21vZHVsZXMvbmFub2h0bWwvbGliL2Jvb2wtcHJvcHMuanMiLCJub2RlX21vZHVsZXMvbmFub2h0bWwvbGliL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvbmFub2h0bWwvbGliL2RpcmVjdC1wcm9wcy5qcyIsIm5vZGVfbW9kdWxlcy9uYW5vaHRtbC9saWIvZG9tLmpzIiwibm9kZV9tb2R1bGVzL25hbm9odG1sL2xpYi9zdmctdGFncy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9iZS5nbC9kaXN0L2VzNS9lbnYvZ2V0LWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHJvYmUuZ2wvZGlzdC9lczUvZW52L2dsb2JhbHMuanMiLCJub2RlX21vZHVsZXMvcHJvYmUuZ2wvZGlzdC9lczUvZW52L2lzLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHJvYmUuZ2wvZGlzdC9lczUvZW52L2lzLWVsZWN0cm9uLmpzIiwibm9kZV9tb2R1bGVzL3Byb2JlLmdsL2Rpc3QvZXM1L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb2JlLmdsL2Rpc3QvZXM1L2luaXQuanMiLCJub2RlX21vZHVsZXMvcHJvYmUuZ2wvZGlzdC9lczUvbGliL2xvZy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9iZS5nbC9kaXN0L2VzNS91dGlscy9hc3NlcnQuanMiLCJub2RlX21vZHVsZXMvcHJvYmUuZ2wvZGlzdC9lczUvdXRpbHMvYXV0b2JpbmQuanMiLCJub2RlX21vZHVsZXMvcHJvYmUuZ2wvZGlzdC9lczUvdXRpbHMvY29sb3IuanMiLCJub2RlX21vZHVsZXMvcHJvYmUuZ2wvZGlzdC9lczUvdXRpbHMvZm9ybWF0dGVycy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9iZS5nbC9kaXN0L2VzNS91dGlscy9nbG9iYWxzLmpzIiwibm9kZV9tb2R1bGVzL3Byb2JlLmdsL2Rpc3QvZXM1L3V0aWxzL2hpLXJlcy10aW1lc3RhbXAuanMiLCJub2RlX21vZHVsZXMvcHJvYmUuZ2wvZGlzdC9lczUvdXRpbHMvbG9jYWwtc3RvcmFnZS5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUNnQkE7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7OztBQWxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBMkIsSUFBM0I7QUFBQSxJQUFPLE1BQVAsU0FBTyxNQUFQO0FBQUEsSUFBZSxRQUFmLFNBQWUsUUFBZixDLENBQ0E7O0FBS0EsSUFBSSxHQUFKO0FBQ0EsSUFBSSxTQUFKO0FBQ0EsSUFBSSxPQUFPLEdBQUcsVUFBZDtBQUVBLElBQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyxRQUFQLENBQWdCLElBQWhCLENBQXFCLE9BQXJCLENBQTZCLHdCQUE3QixFQUF1RCxFQUF2RCxDQUFoQjtBQUVBLElBQU0sV0FBVywyQkFBakI7QUFFQSxJQUFNLFdBQVcsMkJBQWpCLEMsQ0FFQTs7QUFDQSxJQUFNLFFBQVEsR0FBRyxDQUFDO0FBQ2hCLEVBQUEsS0FBSyxFQUFFLFdBRFM7QUFDSTtBQUNwQixFQUFBLEVBQUUsRUFBRSxXQUZZO0FBRUE7QUFDaEIsRUFBQSxHQUFHLEVBQUUsV0FIVztBQUloQixFQUFBLFVBQVUsRUFBRTtBQUpJLENBQUQsRUFLZDtBQUNELEVBQUEsS0FBSyxFQUFFLFFBRE47QUFFRCxFQUFBLEVBQUUsRUFBRSxRQUZIO0FBR0QsRUFBQSxHQUFHLEVBQUUsUUFISjtBQUlELEVBQUEsVUFBVSxFQUFFO0FBSlgsQ0FMYyxFQVdoQjtBQUNDLEVBQUEsS0FBSyxFQUFFLFNBRFI7QUFFQyxFQUFBLEVBQUUsRUFBRSxTQUZMO0FBR0MsRUFBQSxHQUFHLEVBQUUsU0FITjtBQUlDLEVBQUEsVUFBVSxFQUFFO0FBSmIsQ0FYZ0IsQ0FBakI7QUFtQkEsSUFBTSxRQUFRLEdBQUcsQ0FBQztBQUNoQixFQUFBLEtBQUssRUFBRSxrQkFEUztBQUVoQixFQUFBLEVBQUUsRUFBRSxVQUZZO0FBR2hCLEVBQUEsR0FBRyxFQUFFLEVBSFc7QUFJaEIsRUFBQSxTQUFTLEVBQUUsWUFKSztBQUtoQixFQUFBLE9BQU8sRUFBRSxZQUxPO0FBTWhCLEVBQUEsUUFBUSxFQUFFLENBQUMsWUFBRCxFQUFlLFdBQWYsRUFBNEIsY0FBNUI7QUFOTSxDQUFELENBQWpCO0FBU0EsUUFBUSxDQUFDLE9BQVQsQ0FBaUIsVUFBQyxPQUFELEVBQVUsQ0FBVixFQUFnQjtBQUMvQixNQUFNLEdBQUcsYUFBTSxPQUFOLFNBQWdCLFdBQWhCLFNBQThCLE9BQU8sQ0FBQyxHQUF0QyxxQkFBVDtBQUNBLEVBQUEsT0FBTyxDQUFDLEtBQVIsR0FBZ0IsQ0FBRSxHQUFGLENBQWhCO0FBQ0EsRUFBQSxPQUFPLENBQUMsUUFBUixHQUFtQixLQUFuQjtBQUNBLEVBQUEsT0FBTyxDQUFDLFFBQVIsR0FBbUIsSUFBSSxLQUFKLENBQVUsT0FBTyxDQUFDLFVBQWxCLEVBQThCLElBQTlCLENBQW1DLENBQW5DLEVBQXNDLEdBQXRDLENBQTBDLFVBQUMsQ0FBRCxFQUFJLENBQUo7QUFBQSxXQUFVLElBQUksQ0FBQyxNQUFMLEVBQVY7QUFBQSxHQUExQyxDQUFuQjtBQUNELENBTEQ7QUFPQSxJQUFNLFFBQVEsR0FBRyxHQUFqQjtBQUNBLElBQUksZ0JBQWdCLEdBQUcsQ0FBdkI7QUFDQSxjQUFjLENBQUMsV0FBRCxDQUFkLEMsQ0FDQTs7QUFFQSxPQUFPLENBQUMsR0FBUixDQUFZLFVBQVosRUFBd0IsUUFBeEIsRUFBa0MsU0FBbEM7QUFFQSxJQUFNLE1BQU0sT0FBRyxvQkFBSCw2SUFBWjs7QUFDQSxJQUFNLFlBQVksR0FBRyxTQUFmLFlBQWU7QUFBQSxNQUFDLElBQUQsdUVBQVEsSUFBUjtBQUFBLDJGQUEwRixJQUExRjtBQUFBLENBQXJCOztBQUNBLElBQU0sTUFBTSxHQUFHLFFBQVEsQ0FBQyxhQUFULENBQXVCLEtBQXZCLENBQWY7QUFFQSxJQUFNLFNBQVMsT0FBRyxvQkFBSCwwTUFDcUIsVUFBQyxDQUFELEVBQU87QUFBRSxFQUFBLGNBQWMsQ0FBQyxDQUFDLENBQUMsTUFBRixDQUFTLEtBQVYsQ0FBZDtBQUErQixDQUQ3RCxFQUVaLFFBQVEsQ0FBQyxHQUFULENBQWEsVUFBQyxPQUFEO0FBQUEsYUFBYSxvQkFBYixrSEFBbUMsT0FBTyxDQUFDLEVBQTNDLEVBQWtELE9BQU8sQ0FBQyxFQUFSLEtBQWUsU0FBUyxDQUFDLEVBQXpCLEdBQTRCLFVBQTVCLEdBQXVDLEVBQXpGLEVBQStGLE9BQU8sQ0FBQyxLQUF2RztBQUFBLENBQWIsQ0FGWSxDQUFmO0FBS0EsTUFBTSxDQUFDLFdBQVAsQ0FBbUIsU0FBbkI7QUFDQSxNQUFNLENBQUMsV0FBUCxDQUFtQixNQUFuQixFLENBR0E7QUFDQTtBQUNBO0FBQ0E7O1NBQ2UsTzs7Ozs7cUVBQWY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0UsWUFBQSxnQkFBZ0I7QUFDaEIsZ0JBQUcsZ0JBQWdCLEdBQUcsUUFBdEIsRUFBZ0MsZ0JBQWdCLEdBQUcsQ0FBbkI7QUFDMUIsWUFBQSxDQUhSLEdBR1ksSUFBSSxJQUFKLEVBSFo7QUFJRSxZQUFBLENBQUMsQ0FBQyxPQUFGLENBQVUsQ0FBQyxRQUFELEdBQVksZ0JBQXRCO0FBQ00sWUFBQSxPQUxSLEdBS2tCLENBQUMsQ0FBQyxrQkFBRixDQUFxQixPQUFyQixDQUxsQixFQUtnRDs7QUFDOUMsWUFBQSxNQUFNLENBQUMsU0FBUCxHQUFtQixZQUFZLENBQUMsT0FBRCxDQUEvQjtBQU5GO0FBQUEsbUJBT3dCLDBCQUFRLE9BQVIsU0FBa0IsV0FBbEIsU0FBZ0MsT0FBaEMsY0FBMkMsU0FBUyxDQUFDLEVBQXJELDZCQUEwRSxPQUExRSxXQUF5RixjQUF6RixDQVB4Qjs7QUFBQTtBQU9RLFlBQUEsT0FQUjtBQVFFO0FBQ0EsWUFBQSxTQUFTLENBQUMsUUFBVixHQUFzQixTQUFTLENBQUMsUUFBVixDQUFtQixHQUFuQixDQUF1QixVQUFDLENBQUQsRUFBSSxDQUFKO0FBQUEscUJBQVUsT0FBTyxDQUFDLENBQUQsQ0FBUCxDQUFXLFFBQXJCO0FBQUEsYUFBdkIsQ0FBdEIsQ0FURixDQVVBO0FBQ0E7O0FBQ0UsWUFBQSxNQUFNOztBQVpSO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEc7Ozs7QUFjQSxPQUFPOztBQUVQLFNBQVMsY0FBVCxDQUF5QixFQUF6QixFQUE2QjtBQUMzQixFQUFBLFFBQVEsQ0FBQyxPQUFULENBQWlCLFVBQUMsT0FBRCxFQUFhO0FBQzVCLFFBQUcsT0FBTyxDQUFDLEVBQVIsS0FBZSxFQUFsQixFQUFzQjtBQUNwQixNQUFBLE9BQU8sQ0FBQyxPQUFSLEdBQWtCLElBQWxCO0FBQ0EsTUFBQSxTQUFTLEdBQUcsT0FBWjtBQUNELEtBSEQsTUFHTztBQUNMLE1BQUEsT0FBTyxDQUFDLE9BQVIsR0FBa0IsS0FBbEI7QUFDRDtBQUNGLEdBUEQ7QUFRRDs7QUFFRCxTQUFTLE1BQVQsR0FBbUI7QUFDakI7QUFDQSxNQUFNLE1BQU0sR0FBRyxRQUFRLENBQUMsR0FBVCxDQUFhLFVBQUMsT0FBRDtBQUFBLFdBQWEsSUFBSSxRQUFKLENBQWE7QUFDcEQ7QUFDQSxNQUFBLEVBQUUsRUFBRSxPQUFPLENBQUMsRUFGd0M7QUFHcEQsTUFBQSxJQUFJLEVBQUUsT0FBTyxDQUFDLEtBSHNDO0FBSXBELE1BQUEsUUFBUSxFQUFFLE9BQU8sQ0FBQyxPQUprQztBQUtwRCxNQUFBLFlBQVksRUFBRSxzQkFBQyxHQUFELEVBQVM7QUFDckI7QUFDQSxZQUFNLENBQUMsR0FBRyxPQUFPLENBQUMsUUFBUixDQUFpQixHQUFHLENBQUMsRUFBckIsQ0FBVjtBQUNELGVBQU8sQ0FBQyxDQUFDLEdBQUcsR0FBTCxFQUFVLENBQUMsR0FBRyxHQUFkLEVBQW1CLENBQUMsR0FBRyxHQUF2QixDQUFQLENBSHNCLENBSXRCO0FBQ0EsT0FWbUQ7QUFXcEQsTUFBQSxZQUFZLEVBQUUsQ0FYc0M7QUFZdEQsTUFBQSxXQUFXLEVBQUU7QUFDWCxRQUFBLFlBQVksRUFBRTtBQURILE9BWnlDO0FBZXRELE1BQUEsY0FBYyxFQUFFO0FBQ2Q7QUFDQSxRQUFBLFlBQVksRUFBRSxDQUFDLGdCQUFEO0FBRkEsT0Fmc0M7QUFtQnRELE1BQUEsT0FBTyxFQUFFLE9BQU8sQ0FBQyxPQW5CcUM7QUFvQnRELE1BQUEsa0JBQWtCLEVBQUUsQ0FwQmtDO0FBcUJ0RCxNQUFBLE9BQU8sRUFBRSxFQXJCNkM7QUFzQnRELE1BQUEsT0FBTyxFQUFFO0FBdEI2QyxLQUFiLENBQWI7QUFBQSxHQUFiLENBQWY7QUF5QkEsRUFBQSxHQUFHLENBQUMsUUFBSixDQUFhO0FBQUMsSUFBQSxNQUFNLEVBQUU7QUFBVCxHQUFiO0FBQ0Q7O0FBQ0QsR0FBRyxHQUFHLElBQUksTUFBSixDQUFXO0FBRWYsRUFBQSxnQkFBZ0IsRUFBRTtBQUNoQjtBQUNBLElBQUEsUUFBUSxFQUFFLGlCQUZNO0FBR2hCLElBQUEsU0FBUyxFQUFFLGdCQUhLO0FBSWhCO0FBQ0Q7QUFDQztBQUNBLElBQUEsSUFBSSxFQUFFLENBUFU7QUFRaEIsSUFBQSxPQUFPLEVBQUUsRUFSTztBQVNoQixJQUFBLEtBQUssRUFBRSxFQVRTO0FBVWhCLElBQUEsT0FBTyxFQUFFO0FBVk8sR0FGSDtBQWNmLEVBQUEsVUFBVSxFQUFFLElBZEc7QUFlZixFQUFBLFVBQVUsRUFBRSwwQkFBZ0I7QUFBQSxRQUFiLE1BQWEsUUFBYixNQUFhOztBQUMxQixRQUFHLE1BQUgsRUFBVztBQUNULE1BQUEsT0FBTyxDQUFDLEdBQVIsQ0FBWSxNQUFaO0FBRUEsdUJBQVUsTUFBTSxDQUFDLFVBQVAsQ0FBa0IsR0FBNUIsdUJBQTRDLFNBQVMsQ0FBQyxRQUFWLENBQW1CLE1BQU0sQ0FBQyxFQUExQixDQUE1QztBQUNEOztBQUNELFdBQU8sSUFBUDtBQUNELEdBdEJjLENBdUJmOztBQXZCZSxDQUFYLENBQU47QUEwQkEsV0FBVyxDQUFDLFlBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRixFQUFBLE9BQU8sR0FSVyxDQVNqQjtBQUNBLENBVlUsRUFVUixJQVZRLENBQVg7QUFhQSxRQUFRLENBQUMsSUFBVCxDQUFjLFdBQWQsQ0FBMEIsTUFBMUIsRSxDQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcllBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlrQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3YzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9QQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JCQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiLypcbiogVG8gZG86XG4qIC0gaG93IHRvIHVwZGF0ZSB0b29sdGlwIHdoZW4gZGF0ZSBpcyB1cGRhdGVkPyBcbiogLSBkZWZpbml0aW9uIGZpbGUgZm9yIGRhdGFzZXRzXG4qIC0gbWFrZSBkYXRhc2V0IGZpbGVzIHRoYXQgb25seSBjb250YWluIHZhbHVlcywgbm90IGdlb2lkXG4qIC0gaW1wbGVtZW50IHN0YXJ0IGRhdGUgYW5kIGVuZCBkYXRlXG4qIC0gYWRkIHNhbXBsZSBkYXRhIGZvciB0aW1lc2VyaWVzXG4qIC0gbG9hZGluZyBzcGlubmVyIHdoaWxlIGRhdGEgaXMgbG9hZGluZ1xuKiAtIHNob3cgc2VsZWN0ZWQgZWxlbWVudHMgYXMgc2VwYXJhdGUgYXJyYXlcbiogXG4qIGFzc3VtcHRpb25zOiBnZW8gaWQgaW4gdGlsZXNldCByZWZlcnMgdG8gZGF0YSBvcmRlciAoPylcbiogYXJlIHRoZXJlIGRhdGFzZXRzIHRoYXQgb25seSBleGlzdCBhdCBjZXJ0YWluIGdlb2xldmVscz9cbiogaHR0cHM6Ly9kZWNrLmdsL2RvY3MvYXBpLXJlZmVyZW5jZS9nZW8tbGF5ZXJzL212dC1sYXllclxuKi9cbmNvbnN0IHtEZWNrR0wsIE1WVExheWVyfSA9IGRlY2s7XG4vL2ltcG9ydCB7IGNzdiB9IGZyb20gJ2QzJ1xuaW1wb3J0IHtsb2FkfSBmcm9tICdAbG9hZGVycy5nbC9jb3JlJztcbmltcG9ydCB7Q1NWTG9hZGVyfSBmcm9tICdAbG9hZGVycy5nbC9jc3YnO1xuaW1wb3J0IGh0bWwgZnJvbSAnbmFub2h0bWwnXG5cbmxldCB2aXpcbmxldCBnZW9SZWdpb25cbmxldCBkYXRhc2V0ID0gJ21vYmlsaXR5J1xuXG5jb25zdCBiYXNlVVJMID0gd2luZG93LmxvY2F0aW9uLmhyZWYucmVwbGFjZSgnL2V4YW1wbGUtZGF0YS1sb2FkaW5nLycsICcnKVxuXG5jb25zdCBkYXRhc2V0UGF0aCA9IGAvc2FtcGxlLWRhdGEvZGF0YXNldHMvYFxuXG5jb25zdCB0aWxlc2V0UGF0aCA9IGAvc2FtcGxlLWRhdGEvdGlsZXNldHMvYFxuXG4vLyBzZXRzIG9mIHZlY3RvciB0aWxlc2V0cyByZXByZXNlbnRpbmcgZGlmZmVyZW50IGdlby1yZWdpb25zXG5jb25zdCB0aWxlc2V0cyA9IFt7XG4gIGxhYmVsOiAnZ2VtZWluZGVuJywgLy8gXG4gIGlkOiAnZ2VtZWluZGVuJywvLyBcbiAgdXJsOiAnZ2VtZWluZGVuJyxcbiAgbnVtRW50cmllczogMTE0MzEsXG59LCB7XG4gIGxhYmVsOiAna3JlaXNlJyxcbiAgaWQ6ICdrcmVpc2UnLFxuICB1cmw6ICdrcmVpc2UnLFxuICBudW1FbnRyaWVzOiA0MzJcbn0sXG4ge1xuICBsYWJlbDogJ2xhZW5kZXInLFxuICBpZDogJ2xhZW5kZXInLFxuICB1cmw6ICdsYWVuZGVyJyxcbiAgbnVtRW50cmllczogMzRcbn1cbl1cblxuY29uc3QgZGF0YXNldHMgPSBbe1xuICBsYWJlbDogJ01vYmlsaXR5IGJ5IERhdGUnLFxuICBpZDogJ21vYmlsaXR5JyxcbiAgdXJsOiAnJyxcbiAgc3RhcnREYXRlOiAnMjAyMS0wNS0yMycsXG4gIGVuZERhdGU6ICcyMDIxLTA4LTMwJyxcbiAgdGlsZXNldHM6IFsnbGFlbmRlcmdlbycsICdrcmVpc2VnZW8nLCAnZ2VtZWluZGVuZ2VvJ11cbn1dXG5cbnRpbGVzZXRzLmZvckVhY2goKHRpbGVzZXQsIGkpID0+IHtcbiAgY29uc3QgVVJMID0gYCR7YmFzZVVSTH0ke3RpbGVzZXRQYXRofSR7dGlsZXNldC51cmx9L3t6fS97eH0ve3l9LnBiZmBcbiAgdGlsZXNldC50aWxlcyA9IFsgVVJMIF1cbiAgdGlsZXNldC52aXNpYmlsZSA9IGZhbHNlXG4gIHRpbGVzZXQubW9iaWxpdHkgPSBuZXcgQXJyYXkodGlsZXNldC5udW1FbnRyaWVzKS5maWxsKDApLm1hcCgoXywgaSkgPT4gTWF0aC5yYW5kb20oKSlcbn0pXG5cbmNvbnN0IG51bURhdGVzID0gMTAwXG5sZXQgY3VycmVudERhdGVJbmRleCA9IDBcbnNlbGVjdEdlb0xldmVsKCdnZW1laW5kZW4nKVxuLy9nZW9SZWdpb24gPSB0aWxlc2V0c1swXVxuXG5jb25zb2xlLmxvZygnYmFzZSB1cmwnLCB0aWxlc2V0cywgZ2VvUmVnaW9uKVxuXG5jb25zdCBmb290ZXIgPSBodG1sYDxkaXYgc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTtib3R0b206MHB4O3JpZ2h0OjBweDt3aWR0aDoxMDAlXCI+PC9kaXY+YFxuY29uc3QgZ2VuZXJhdGVEYXRlID0gKGRhdGUgPSAnaGknKSA9PiBgPGRpdiBzdHlsZT1cImZvbnQtc2l6ZTo0cmVtO2NvbG9yOndoaXRlO2JhY2tncm91bmQ6cmdiYSgwLCAwLCAwLCAwLjQpXCI+JHtkYXRlfTwvZGl2PmBcbmNvbnN0IGRhdGVFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG5cbmNvbnN0IGdlb1NlbGVjdCA9IGh0bWxgPGxhYmVsIGZvcj1cImdlb2xldmVsXCI+U2VsZWN0IG1hcCBnZW8gbGV2ZWw8L2xhYmVsPlxuPHNlbGVjdCBsYWJlbD1cImdlb2xldmVsXCIgb25jaGFuZ2U9JHsoZSkgPT4geyBzZWxlY3RHZW9MZXZlbChlLnRhcmdldC52YWx1ZSl9fSBpZD1cImdlb2xldmVsXCI+XG4gJHt0aWxlc2V0cy5tYXAoKHRpbGVzZXQpID0+IGh0bWxgPG9wdGlvbiB2YWx1ZT1cIiR7dGlsZXNldC5pZH1cIiAke3RpbGVzZXQuaWQgPT09IGdlb1JlZ2lvbi5pZD8nc2VsZWN0ZWQnOicnfT4ke3RpbGVzZXQubGFiZWx9PC9vcHRpb24+YCl9XG48L3NlbGVjdD5gXG5cbmZvb3Rlci5hcHBlbmRDaGlsZChnZW9TZWxlY3QpXG5mb290ZXIuYXBwZW5kQ2hpbGQoZGF0ZUVsKVxuXG5cbi8vIG9wdGltaXphdGlvbnMgZm9yIHRoaXM6IGxvYWQgZGlyZWN0bHkgYXMgYW4gYXJyYXkgYW5kIGRvIG5vdCBwYXJzZSBpbnRvIG9iamVjdHNcbi8vIHN0b3JlIGFscmVhZHkgbG9hZGVkIGRhdGEgaW4gc29tZSB3YXkgYW5kIG9ubHkgbG9hZCBuZXcgZGF0YSBhcyBuZWNlc3Nhcnlcbi8vIHJlYWQgbW9yZSBhYm91dCBkZWNrZ2wgLyB3ZWJnbCBwZXJmb3JtYW5jZVxuLy8gc2hvdyBsb2FkaW5nIGFuaW1hdGlvbiB3aGlsZSBsb2FkaW5nXG5hc3luYyBmdW5jdGlvbiBnZXREYXRhKCkge1xuICBjdXJyZW50RGF0ZUluZGV4KytcbiAgaWYoY3VycmVudERhdGVJbmRleCA+IG51bURhdGVzKSBjdXJyZW50RGF0ZUluZGV4ID0gMFxuICBjb25zdCBkID0gbmV3IERhdGUoKVxuICBkLnNldERhdGUoLW51bURhdGVzICsgY3VycmVudERhdGVJbmRleClcbiAgY29uc3QgZGF0ZVN0ciA9IGQudG9Mb2NhbGVEYXRlU3RyaW5nKCdlbi1DQScpIC8vZGF0ZS5mb3JtYXQoZCwgJ1lZWVktTU0tREQnKVxuICBkYXRlRWwuaW5uZXJIVE1MID0gZ2VuZXJhdGVEYXRlKGRhdGVTdHIpXG4gIGNvbnN0IG5ld0RhdGEgPSBhd2FpdCBsb2FkKGAke2Jhc2VVUkx9JHtkYXRhc2V0UGF0aH0ke2RhdGFzZXR9LyR7Z2VvUmVnaW9uLmlkfS92YWx1ZXMtYnktZGF0ZS8ke2RhdGVTdHJ9LmNzdmAsIENTVkxvYWRlcik7XG4gIC8vIGNvbnNvbGUubG9nKCdsb2FkZWQnLCBuZXdEYXRhLCBnZW9SZWdpb24pXG4gIGdlb1JlZ2lvbi5tb2JpbGl0eSA9ICBnZW9SZWdpb24ubW9iaWxpdHkubWFwKChfLCBpKSA9PiBuZXdEYXRhW2ldLm1vYmlsaXR5KVxuLy9nZW1laW5kZW46IG5ldyBBcnJheSgxMTQzMSkuZmlsbCgwKS5tYXAoKF8sIGkpID0+IE1hdGgucmFuZG9tKCkpLFxuLy9rcmVpc2U6IG5ldyBBcnJheSg0MzIpLmZpbGwoMCkubWFwKChfLCBpKSA9PiBNYXRoLnJhbmRvbSgpKVxuICByZW5kZXIoKVxufVxuZ2V0RGF0YSgpXG5cbmZ1bmN0aW9uIHNlbGVjdEdlb0xldmVsIChpZCkge1xuICB0aWxlc2V0cy5mb3JFYWNoKCh0aWxlc2V0KSA9PiB7XG4gICAgaWYodGlsZXNldC5pZCA9PT0gaWQpIHtcbiAgICAgIHRpbGVzZXQudmlzaWJsZSA9IHRydWVcbiAgICAgIGdlb1JlZ2lvbiA9IHRpbGVzZXRcbiAgICB9IGVsc2Uge1xuICAgICAgdGlsZXNldC52aXNpYmxlID0gZmFsc2VcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gIC8vIGNvbnNvbGUubG9nKHRpbGVzZXRzLCAndGlsZXNldHMnKVxuICBjb25zdCBsYXllcnMgPSB0aWxlc2V0cy5tYXAoKHRpbGVzZXQpID0+IG5ldyBNVlRMYXllcih7XG4gICAgLy8gaWQ6IHRpbGVzZXQuaWQsXG4gICAgaWQ6IHRpbGVzZXQuaWQsXG4gICAgZGF0YTogdGlsZXNldC50aWxlcyxcbiAgICBwaWNrYWJsZTogdGlsZXNldC52aXNpYmxlLFxuICAgIGdldEZpbGxDb2xvcjogKG9iaikgPT4ge1xuICAgICAgLy9jb25zb2xlLmxvZygnZ2V0dGluZyBtb2JpbGl0eSBhdCcsIG9iai5pZCwgdGlsZXNldC5tb2JpbGl0eSlcbiAgICAgIGNvbnN0IGogPSB0aWxlc2V0Lm1vYmlsaXR5W29iai5pZF1cbiAgICAgcmV0dXJuIFtqICogMjU1LCBqICogMjU1LCBqICogMjU1XVxuICAgICAvL3JldHVybiBbTWF0aC5yYW5kb20oKSAqIDI1NSwgTWF0aC5yYW5kb20oKSAqIDI1NSwgTWF0aC5yYW5kb20oKSAqIDI1NV1cbiAgICB9LCBcbiAgICBnZXRMaW5lV2lkdGg6IDQsXG4gIHRyYW5zaXRpb25zOiB7XG4gICAgZ2V0RmlsbENvbG9yOiAxMDAsXG4gIH0sXG4gIHVwZGF0ZVRyaWdnZXJzOiB7XG4gICAgLy8gaWYgY3VycmVudERhdGVJbmRleCBjaGFuZ2VzLCByZWNvbXB1dGUgZ2V0RmlsbENvbG9yIGZvciBlYWNoIHBvaW50XG4gICAgZ2V0RmlsbENvbG9yOiBbY3VycmVudERhdGVJbmRleF1cbiAgfSxcbiAgdmlzaWJsZTogdGlsZXNldC52aXNpYmxlLFxuICBsaW5lV2lkdGhNaW5QaXhlbHM6IDAsXG4gIG1heFpvb206IDEzLFxuICBtaW5ab29tOiAwLFxufSkpXG5cbiAgdml6LnNldFByb3BzKHtsYXllcnM6IGxheWVyc30pXG59XG52aXogPSBuZXcgRGVja0dMKHtcbiAgXG4gIGluaXRpYWxWaWV3U3RhdGU6IHtcbiAgICAvLyBsb25naXR1ZGU6IC0xMjIuNCxcbiAgICBsYXRpdHVkZTogNTEuNjY0MDM3ODE2NTgxMjEsXG4gICAgbG9uZ2l0dWRlOiAxMC42NDYwOTUyNzU4Nzg5LFxuICAgIC8vIGxhdGl0dWRlOiAzNy43NCxcbiAgIC8vIGxvbmdpdHVkZTogMTMuNzY1ODY5LFxuICAgIC8vMTMuNzY1ODY5LDU0LjExNzM4MlxuICAgIHpvb206IDYsXG4gICAgbWF4Wm9vbTogMjAsXG4gICAgcGl0Y2g6IDMwLFxuICAgIGJlYXJpbmc6IDBcbiAgfSxcbiAgY29udHJvbGxlcjogdHJ1ZSxcbiAgZ2V0VG9vbHRpcDogKHsgb2JqZWN0IH0pID0+IHsgXG4gICAgaWYob2JqZWN0KSB7XG4gICAgICBjb25zb2xlLmxvZyhvYmplY3QpXG5cbiAgICAgIHJldHVybiBgJHtvYmplY3QucHJvcGVydGllcy5HRU59IG1vYmlsaXR5ICR7Z2VvUmVnaW9uLm1vYmlsaXR5W29iamVjdC5pZF19YFxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIC8vbGF5ZXJzOiBbbGF5ZXJdXG59KTtcbiAgXG5zZXRJbnRlcnZhbCgoKSA9PiB7XG4vLyAgY29uc29sZS5sb2coc2hvdWxkVXBkYXRlKVxuLy8gZmFrZURhdGEubGFlbmRlciA9IGZha2VEYXRhLmxhZW5kZXIubWFwKChfLCBpKSA9PiBNYXRoLnJhbmRvbSgpKVxuLy8gZmFrZURhdGEua3JlaXNlID0gZmFrZURhdGEua3JlaXNlLm1hcCgoXywgaSkgPT4gTWF0aC5yYW5kb20oKSlcbi8vZmFrZURhdGFbZ2VvUmVnaW9uXSA9IGZha2VEYXRhW2dlb1JlZ2lvbl0ubWFwKChfLCBpKSA9PiBNYXRoLnJhbmRvbSgpKVxuLy9nZW1laW5kZW46IG5ldyBBcnJheSgxMTQzMSkuZmlsbCgwKS5tYXAoKF8sIGkpID0+IE1hdGgucmFuZG9tKCkpLFxuLy9rcmVpc2U6IG5ldyBBcnJheSg0MzIpLmZpbGwoMCkubWFwKChfLCBpKSA9PiBNYXRoLnJhbmRvbSgpKVxuICAvL3JlbmRlcigpXG5nZXREYXRhKClcbiAvLyBzaG91bGRVcGRhdGUgKytcbn0sIDIwMDApXG5cblxuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb290ZXIpXG5cbi8vICAgY29uc3QgdGlsZVVSTCA9IGAke3dpbmRvdy5sb2NhdGlvbi5vcmlnaW59L2dlbWVpbmRlbi16Ny11bmNvbXByZXNzZWQve3p9L3t4fS97eX0ucGJmYFxuXG4vLyBjb25zdCBEQVRBID0gW1xuLy8gICAgIHRpbGVVUkxcbi8vICAgICAvLydodHRwczovL3RpbGVzLWEuYmFzZW1hcHMuY2FydG9jZG4uY29tL3ZlY3RvcnRpbGVzL2NhcnRvLnN0cmVldHMvdjEve3p9L3t4fS97eX0ubXZ0J1xuLy8gICBdXG5cbi8vIGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4vLyBjb25zdCBnZW1laW5kZW4gPSBuZXcgTVZUTGF5ZXIoe1xuLy8gICBpZDogJ2dlbWVpbmRlbmdlbycsXG4vLyAgIGRhdGE6IERBVEEsXG4vLyAgIHBpY2thYmxlOiB0cnVlLFxuLy8gICBnZXRGaWxsQ29sb3I6ICgpID0+IHtcbi8vICAgIC8vIGNvbnNvbGUubG9nKHNob3VsZFVwZGF0ZSlcbi8vICAgIHJldHVybiBbTWF0aC5yYW5kb20oKSAqIDI1NSwgTWF0aC5yYW5kb20oKSAqIDI1NSwgTWF0aC5yYW5kb20oKSAqIDI1NV1cbi8vICAgfSxcbi8vICAgZ2V0TGluZUNvbG9yOiAoKSA9PiBbTWF0aC5yYW5kb20oKSAqIDI1NSwgTWF0aC5yYW5kb20oKSAqIDI1NSwgTWF0aC5yYW5kb20oKSAqIDI1NV0sXG4vLyAgIGdldExpbmVXaWR0aDogNCxcbi8vICAgdHJhbnNpdGlvbnM6IHtcbi8vICAgICBnZXRGaWxsQ29sb3I6IDEwMCxcbi8vICAgfSxcbi8vICAgdXBkYXRlVHJpZ2dlcnM6IHtcbi8vICAgICAvLyBpZiBzaG93TGlicmFyaWVzIGNoYW5nZXMsIHJlY29tcHV0ZSBnZXRGaWxsQ29sb3IgZm9yIGVhY2ggcG9pbnRcbi8vICAgICBnZXRGaWxsQ29sb3I6IFtzaG91bGRVcGRhdGVdXG4vLyAgIH0sXG4vLyAgIGxpbmVXaWR0aE1pblBpeGVsczogMSxcbiAgXG4vLyAgIC8qIHByb3BzIGZyb20gTVZUTGF5ZXIgY2xhc3MgKi9cbiAgXG4vLyAgIC8vIGJpbmFyeTogZmFsc2UsXG4vLyAgIC8vIGhpZ2hsaWdodGVkRmVhdHVyZUlkOiBudWxsLFxuLy8gICAvLyBsb2FkZXJzOiAsXG4vLyAgIC8vIHVuaXF1ZUlkUHJvcGVydHk6ICcnLFxuICBcbi8vICAgLyogcHJvcHMgaW5oZXJpdGVkIGZyb20gVGlsZUxheWVyIGNsYXNzICovXG4gIFxuLy8gICAvLyBleHRlbnQ6IG51bGwsXG4vLyAgIC8vIGdldFRpbGVEYXRhOiBudWxsLFxuLy8gICAvLyBtYXhDYWNoZUJ5dGVTaXplOiBudWxsLFxuLy8gICAvLyBtYXhDYWNoZVNpemU6IG51bGwsXG4vLyAgIC8vIG1heFJlcXVlc3RzOiA2LFxuLy8gICBtYXhab29tOiAxMyxcbi8vICAgbWluWm9vbTogNyxcbi8vICAgLy8gb25UaWxlRXJyb3I6IG51bGwsXG4vLyAgIC8vIG9uVGlsZUxvYWQ6IG51bGwsXG4vLyAgIC8vIG9uVGlsZVVubG9hZDogbnVsbCxcbi8vICAgLy8gb25WaWV3cG9ydExvYWQ6IG51bGwsXG4vLyAgIC8vIHJlZmluZW1lbnRTdHJhdGVneTogJ2Jlc3QtYXZhaWxhYmxlJyxcbi8vICAgLy8gcmVuZGVyU3ViTGF5ZXJzOiBudWxsLFxuLy8gICAvLyB0aWxlU2l6ZTogNTEyLFxuLy8gICAvLyB6UmFuZ2U6IG51bGwsXG4gIFxuLy8gICAvKiBwcm9wcyBpbmhlcml0ZWQgZnJvbSBMYXllciBjbGFzcyAqL1xuICBcbi8vICAgLy8gYXV0b0hpZ2hsaWdodDogZmFsc2UsXG4vLyAgIC8vIGNvb3JkaW5hdGVPcmlnaW46IFswLCAwLCAwXSxcbi8vICAgLy8gY29vcmRpbmF0ZVN5c3RlbTogQ09PUkRJTkFURV9TWVNURU0uTE5HTEFULFxuLy8gICAvLyBoaWdobGlnaHRDb2xvcjogWzAsIDAsIDEyOCwgMTI4XSxcbi8vICAgLy8gbW9kZWxNYXRyaXg6IG51bGwsXG4vLyAgIC8vIG9wYWNpdHk6IDEsXG4vLyAgIC8vIHBpY2thYmxlOiBmYWxzZSxcbi8vICAgLy8gdmlzaWJsZTogdHJ1ZSxcbi8vICAgLy8gd3JhcExvbmdpdHVkZTogZmFsc2UsXG4vLyB9KTsiLCJ2YXIgQXdhaXRWYWx1ZSA9IHJlcXVpcmUoXCIuL0F3YWl0VmFsdWUuanNcIik7XG5cbmZ1bmN0aW9uIEFzeW5jR2VuZXJhdG9yKGdlbikge1xuICB2YXIgZnJvbnQsIGJhY2s7XG5cbiAgZnVuY3Rpb24gc2VuZChrZXksIGFyZykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIGFyZzogYXJnLFxuICAgICAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgICAgICByZWplY3Q6IHJlamVjdCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcblxuICAgICAgaWYgKGJhY2spIHtcbiAgICAgICAgYmFjayA9IGJhY2submV4dCA9IHJlcXVlc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcm9udCA9IGJhY2sgPSByZXF1ZXN0O1xuICAgICAgICByZXN1bWUoa2V5LCBhcmcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzdW1lKGtleSwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciByZXN1bHQgPSBnZW5ba2V5XShhcmcpO1xuICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgdmFyIHdyYXBwZWRBd2FpdCA9IHZhbHVlIGluc3RhbmNlb2YgQXdhaXRWYWx1ZTtcbiAgICAgIFByb21pc2UucmVzb2x2ZSh3cmFwcGVkQXdhaXQgPyB2YWx1ZS53cmFwcGVkIDogdmFsdWUpLnRoZW4oZnVuY3Rpb24gKGFyZykge1xuICAgICAgICBpZiAod3JhcHBlZEF3YWl0KSB7XG4gICAgICAgICAgcmVzdW1lKGtleSA9PT0gXCJyZXR1cm5cIiA/IFwicmV0dXJuXCIgOiBcIm5leHRcIiwgYXJnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZXR0bGUocmVzdWx0LmRvbmUgPyBcInJldHVyblwiIDogXCJub3JtYWxcIiwgYXJnKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgcmVzdW1lKFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc2V0dGxlKFwidGhyb3dcIiwgZXJyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXR0bGUodHlwZSwgdmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJyZXR1cm5cIjpcbiAgICAgICAgZnJvbnQucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwidGhyb3dcIjpcbiAgICAgICAgZnJvbnQucmVqZWN0KHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGZyb250LnJlc29sdmUoe1xuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZnJvbnQgPSBmcm9udC5uZXh0O1xuXG4gICAgaWYgKGZyb250KSB7XG4gICAgICByZXN1bWUoZnJvbnQua2V5LCBmcm9udC5hcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYWNrID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9pbnZva2UgPSBzZW5kO1xuXG4gIGlmICh0eXBlb2YgZ2VuW1wicmV0dXJuXCJdICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aGlzW1wicmV0dXJuXCJdID0gdW5kZWZpbmVkO1xuICB9XG59XG5cbkFzeW5jR2VuZXJhdG9yLnByb3RvdHlwZVt0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIl0gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcblxuQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiB0aGlzLl9pbnZva2UoXCJuZXh0XCIsIGFyZyk7XG59O1xuXG5Bc3luY0dlbmVyYXRvci5wcm90b3R5cGVbXCJ0aHJvd1wiXSA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIHRoaXMuX2ludm9rZShcInRocm93XCIsIGFyZyk7XG59O1xuXG5Bc3luY0dlbmVyYXRvci5wcm90b3R5cGVbXCJyZXR1cm5cIl0gPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiB0aGlzLl9pbnZva2UoXCJyZXR1cm5cIiwgYXJnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXN5bmNHZW5lcmF0b3I7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX0F3YWl0VmFsdWUodmFsdWUpIHtcbiAgdGhpcy53cmFwcGVkID0gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX0F3YWl0VmFsdWU7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheUxpa2VUb0FycmF5O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRoSG9sZXM7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5LmpzXCIpO1xuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aG91dEhvbGVzO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZDtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfYXN5bmNHZW5lcmF0b3JEZWxlZ2F0ZShpbm5lciwgYXdhaXRXcmFwKSB7XG4gIHZhciBpdGVyID0ge30sXG4gICAgICB3YWl0aW5nID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gcHVtcChrZXksIHZhbHVlKSB7XG4gICAgd2FpdGluZyA9IHRydWU7XG4gICAgdmFsdWUgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgcmVzb2x2ZShpbm5lcltrZXldKHZhbHVlKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgdmFsdWU6IGF3YWl0V3JhcCh2YWx1ZSlcbiAgICB9O1xuICB9XG5cbiAgO1xuXG4gIGl0ZXJbdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCJdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIGl0ZXIubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh3YWl0aW5nKSB7XG4gICAgICB3YWl0aW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHB1bXAoXCJuZXh0XCIsIHZhbHVlKTtcbiAgfTtcblxuICBpZiAodHlwZW9mIGlubmVyW1widGhyb3dcIl0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGl0ZXJbXCJ0aHJvd1wiXSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHdhaXRpbmcpIHtcbiAgICAgICAgd2FpdGluZyA9IGZhbHNlO1xuICAgICAgICB0aHJvdyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHB1bXAoXCJ0aHJvd1wiLCB2YWx1ZSk7XG4gICAgfTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5uZXJbXCJyZXR1cm5cIl0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGl0ZXJbXCJyZXR1cm5cIl0gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh3YWl0aW5nKSB7XG4gICAgICAgIHdhaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHVtcChcInJldHVyblwiLCB2YWx1ZSk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBpdGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3luY0dlbmVyYXRvckRlbGVnYXRlO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9hc3luY0l0ZXJhdG9yKGl0ZXJhYmxlKSB7XG4gIHZhciBtZXRob2Q7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBpZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IpIG1ldGhvZCA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXTtcbiAgICBpZiAobWV0aG9kID09IG51bGwgJiYgU3ltYm9sLml0ZXJhdG9yKSBtZXRob2QgPSBpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdO1xuICB9XG5cbiAgaWYgKG1ldGhvZCA9PSBudWxsKSBtZXRob2QgPSBpdGVyYWJsZVtcIkBAYXN5bmNJdGVyYXRvclwiXTtcbiAgaWYgKG1ldGhvZCA9PSBudWxsKSBtZXRob2QgPSBpdGVyYWJsZVtcIkBAaXRlcmF0b3JcIl07XG4gIGlmIChtZXRob2QgPT0gbnVsbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBpcyBub3QgYXN5bmMgaXRlcmFibGVcIik7XG4gIHJldHVybiBtZXRob2QuY2FsbChpdGVyYWJsZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FzeW5jSXRlcmF0b3I7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlamVjdChlcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGluZm8uZG9uZSkge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICB9XG5cbiAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FzeW5jVG9HZW5lcmF0b3I7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwidmFyIEF3YWl0VmFsdWUgPSByZXF1aXJlKFwiLi9Bd2FpdFZhbHVlLmpzXCIpO1xuXG5mdW5jdGlvbiBfYXdhaXRBc3luY0dlbmVyYXRvcih2YWx1ZSkge1xuICByZXR1cm4gbmV3IEF3YWl0VmFsdWUodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hd2FpdEFzeW5jR2VuZXJhdG9yO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mLmpzXCIpO1xuXG52YXIgaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gcmVxdWlyZShcIi4vaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0LmpzXCIpO1xuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgaWYgKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7XG4gICAgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgdmFyIGEgPSBbbnVsbF07XG4gICAgICBhLnB1c2guYXBwbHkoYSwgYXJncyk7XG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgIGlmIChDbGFzcykgc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NvbnN0cnVjdDtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NyZWF0ZUNsYXNzO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZpbmVQcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZjtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZi5qc1wiKTtcblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbmhlcml0cztcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgIFwiZGVmYXVsdFwiOiBvYmpcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7XG4gIHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2lzTmF0aXZlRnVuY3Rpb247XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdDtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTtcblxuICBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcblxuICB2YXIgX3MsIF9lO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheUxpbWl0O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlUmVzdDtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVNwcmVhZDtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKVtcImRlZmF1bHRcIl07XG5cbnZhciBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQgPSByZXF1aXJlKFwiLi9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanNcIik7XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gIH1cblxuICByZXR1cm4gYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2Y7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwidmFyIGFycmF5V2l0aEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRoSG9sZXMuanNcIik7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXlMaW1pdCA9IHJlcXVpcmUoXCIuL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzXCIpO1xuXG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qc1wiKTtcblxudmFyIG5vbkl0ZXJhYmxlUmVzdCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlUmVzdC5qc1wiKTtcblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc2xpY2VkVG9BcnJheTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgYXJyYXlXaXRob3V0SG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhvdXRIb2xlcy5qc1wiKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2l0ZXJhYmxlVG9BcnJheS5qc1wiKTtcblxudmFyIHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanNcIik7XG5cbnZhciBub25JdGVyYWJsZVNwcmVhZCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlU3ByZWFkLmpzXCIpO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdG9Db25zdW1hYmxlQXJyYXk7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsInZhciBhcnJheUxpa2VUb0FycmF5ID0gcmVxdWlyZShcIi4vYXJyYXlMaWtlVG9BcnJheS5qc1wiKTtcblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXk7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwidmFyIEFzeW5jR2VuZXJhdG9yID0gcmVxdWlyZShcIi4vQXN5bmNHZW5lcmF0b3IuanNcIik7XG5cbmZ1bmN0aW9uIF93cmFwQXN5bmNHZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IEFzeW5jR2VuZXJhdG9yKGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF93cmFwQXN5bmNHZW5lcmF0b3I7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwidmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vZ2V0UHJvdG90eXBlT2YuanNcIik7XG5cbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mLmpzXCIpO1xuXG52YXIgaXNOYXRpdmVGdW5jdGlvbiA9IHJlcXVpcmUoXCIuL2lzTmF0aXZlRnVuY3Rpb24uanNcIik7XG5cbnZhciBjb25zdHJ1Y3QgPSByZXF1aXJlKFwiLi9jb25zdHJ1Y3QuanNcIik7XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDtcblxuICBtb2R1bGUuZXhwb3J0cyA9IF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgaWYgKENsYXNzID09PSBudWxsIHx8ICFpc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzO1xuXG4gICAgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpO1xuXG4gICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXcmFwcGVyKCkge1xuICAgICAgcmV0dXJuIGNvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBnZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuXG4gICAgV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IFdyYXBwZXIsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4gIHJldHVybiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfd3JhcE5hdGl2ZVN1cGVyO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWVcIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmZXRjaEZpbGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ZldGNoRmlsZS5mZXRjaEZpbGU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVhZEFycmF5QnVmZmVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9yZWFkQXJyYXlCdWZmZXIucmVhZEFycmF5QnVmZmVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlYWRGaWxlU3luY1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfcmVhZEZpbGUucmVhZEZpbGVTeW5jO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIndyaXRlRmlsZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfd3JpdGVGaWxlLndyaXRlRmlsZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ3cml0ZUZpbGVTeW5jXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF93cml0ZUZpbGUud3JpdGVGaWxlU3luYztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzZXRMb2FkZXJPcHRpb25zXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zZXRMb2FkZXJPcHRpb25zLnNldExvYWRlck9wdGlvbnM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVnaXN0ZXJMb2FkZXJzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9yZWdpc3RlckxvYWRlcnMucmVnaXN0ZXJMb2FkZXJzO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl91bnJlZ2lzdGVyTG9hZGVyc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfcmVnaXN0ZXJMb2FkZXJzLl91bnJlZ2lzdGVyTG9hZGVycztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzZWxlY3RMb2FkZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NlbGVjdExvYWRlci5zZWxlY3RMb2FkZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2VsZWN0TG9hZGVyU3luY1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2VsZWN0TG9hZGVyLnNlbGVjdExvYWRlclN5bmM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3BhcnNlLnBhcnNlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlU3luY1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfcGFyc2VTeW5jLnBhcnNlU3luYztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZUluQmF0Y2hlc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfcGFyc2VJbkJhdGNoZXMucGFyc2VJbkJhdGNoZXM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibG9hZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbG9hZC5sb2FkO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxvYWRJbkJhdGNoZXNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2xvYWRJbkJhdGNoZXMubG9hZEluQmF0Y2hlcztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2VuY29kZS5lbmNvZGU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlU3luY1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZW5jb2RlLmVuY29kZVN5bmM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlSW5CYXRjaGVzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9lbmNvZGUuZW5jb2RlSW5CYXRjaGVzO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZVRleHRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2VuY29kZS5lbmNvZGVUZXh0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZVVSTHRvVVJMXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9lbmNvZGUuZW5jb2RlVVJMdG9VUkw7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2F2ZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2F2ZS5zYXZlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNhdmVTeW5jXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zYXZlLnNhdmVTeW5jO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNldFBhdGhQcmVmaXhcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2xvYWRlclV0aWxzLnNldFBhdGhQcmVmaXg7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0UGF0aFByZWZpeFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbG9hZGVyVXRpbHMuZ2V0UGF0aFByZWZpeDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZXNvbHZlUGF0aFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbG9hZGVyVXRpbHMucmVzb2x2ZVBhdGg7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFNjaGVkdWxlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbG9hZGVyVXRpbHMuUmVxdWVzdFNjaGVkdWxlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJKU09OTG9hZGVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9sb2FkZXJVdGlscy5KU09OTG9hZGVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzQnJvd3NlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbG9hZGVyVXRpbHMuaXNCcm93c2VyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzV29ya2VyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9sb2FkZXJVdGlscy5pc1dvcmtlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzZWxmXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9sb2FkZXJVdGlscy5zZWxmO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIndpbmRvd1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbG9hZGVyVXRpbHMud2luZG93O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdsb2JhbFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbG9hZGVyVXRpbHMuZ2xvYmFsO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRvY3VtZW50XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9sb2FkZXJVdGlscy5kb2N1bWVudDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhc3NlcnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2xvYWRlclV0aWxzLmFzc2VydDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmb3JFYWNoXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9sb2FkZXJVdGlscy5mb3JFYWNoO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzQXN5bmNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2xvYWRlclV0aWxzLmNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzQXN5bmM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWFrZVRleHREZWNvZGVySXRlcmF0b3JcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2xvYWRlclV0aWxzLm1ha2VUZXh0RGVjb2Rlckl0ZXJhdG9yO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1ha2VUZXh0RW5jb2Rlckl0ZXJhdG9yXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9sb2FkZXJVdGlscy5tYWtlVGV4dEVuY29kZXJJdGVyYXRvcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYWtlTGluZUl0ZXJhdG9yXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9sb2FkZXJVdGlscy5tYWtlTGluZUl0ZXJhdG9yO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1ha2VOdW1iZXJlZExpbmVJdGVyYXRvclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbG9hZGVyVXRpbHMubWFrZU51bWJlcmVkTGluZUl0ZXJhdG9yO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1ha2VJdGVyYXRvclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbWFrZUl0ZXJhdG9yLm1ha2VJdGVyYXRvcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYWtlU3RyZWFtXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9tYWtlU3RyZWFtLm1ha2VTdHJlYW07XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWFrZURPTVN0cmVhbVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbWFrZURvbVN0cmVhbS5tYWtlRE9NU3RyZWFtO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1ha2VOb2RlU3RyZWFtXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9tYWtlTm9kZVN0cmVhbS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk51bGxXb3JrZXJMb2FkZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX251bGxMb2FkZXIuTnVsbFdvcmtlckxvYWRlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOdWxsTG9hZGVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9udWxsTG9hZGVyLk51bGxMb2FkZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX2ZldGNoUHJvZ3Jlc3NcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ZldGNoUHJvZ3Jlc3MuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfQnJvd3NlckZpbGVTeXN0ZW1cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2Jyb3dzZXJGaWxlc3lzdGVtLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNQdXJlT2JqZWN0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pc1R5cGUuaXNQdXJlT2JqZWN0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzUHJvbWlzZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaXNUeXBlLmlzUHJvbWlzZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0l0ZXJhYmxlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pc1R5cGUuaXNJdGVyYWJsZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0FzeW5jSXRlcmFibGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2lzVHlwZS5pc0FzeW5jSXRlcmFibGU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNJdGVyYXRvclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaXNUeXBlLmlzSXRlcmF0b3I7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNSZXNwb25zZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaXNUeXBlLmlzUmVzcG9uc2U7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNSZWFkYWJsZVN0cmVhbVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaXNUeXBlLmlzUmVhZGFibGVTdHJlYW07XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNXcml0YWJsZVN0cmVhbVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaXNUeXBlLmlzV3JpdGFibGVTdHJlYW07XG4gIH1cbn0pO1xuXG52YXIgX2ZldGNoRmlsZSA9IHJlcXVpcmUoXCIuL2xpYi9mZXRjaC9mZXRjaC1maWxlXCIpO1xuXG52YXIgX3JlYWRBcnJheUJ1ZmZlciA9IHJlcXVpcmUoXCIuL2xpYi9mZXRjaC9yZWFkLWFycmF5LWJ1ZmZlclwiKTtcblxudmFyIF9yZWFkRmlsZSA9IHJlcXVpcmUoXCIuL2xpYi9mZXRjaC9yZWFkLWZpbGVcIik7XG5cbnZhciBfd3JpdGVGaWxlID0gcmVxdWlyZShcIi4vbGliL2ZldGNoL3dyaXRlLWZpbGVcIik7XG5cbnZhciBfc2V0TG9hZGVyT3B0aW9ucyA9IHJlcXVpcmUoXCIuL2xpYi9hcGkvc2V0LWxvYWRlci1vcHRpb25zXCIpO1xuXG52YXIgX3JlZ2lzdGVyTG9hZGVycyA9IHJlcXVpcmUoXCIuL2xpYi9hcGkvcmVnaXN0ZXItbG9hZGVyc1wiKTtcblxudmFyIF9zZWxlY3RMb2FkZXIgPSByZXF1aXJlKFwiLi9saWIvYXBpL3NlbGVjdC1sb2FkZXJcIik7XG5cbnZhciBfcGFyc2UgPSByZXF1aXJlKFwiLi9saWIvYXBpL3BhcnNlXCIpO1xuXG52YXIgX3BhcnNlU3luYyA9IHJlcXVpcmUoXCIuL2xpYi9hcGkvcGFyc2Utc3luY1wiKTtcblxudmFyIF9wYXJzZUluQmF0Y2hlcyA9IHJlcXVpcmUoXCIuL2xpYi9hcGkvcGFyc2UtaW4tYmF0Y2hlc1wiKTtcblxudmFyIF9sb2FkID0gcmVxdWlyZShcIi4vbGliL2FwaS9sb2FkXCIpO1xuXG52YXIgX2xvYWRJbkJhdGNoZXMgPSByZXF1aXJlKFwiLi9saWIvYXBpL2xvYWQtaW4tYmF0Y2hlc1wiKTtcblxudmFyIF9lbmNvZGUgPSByZXF1aXJlKFwiLi9saWIvYXBpL2VuY29kZVwiKTtcblxudmFyIF9zYXZlID0gcmVxdWlyZShcIi4vbGliL2FwaS9zYXZlXCIpO1xuXG52YXIgX2xvYWRlclV0aWxzID0gcmVxdWlyZShcIkBsb2FkZXJzLmdsL2xvYWRlci11dGlsc1wiKTtcblxudmFyIF9tYWtlSXRlcmF0b3IgPSByZXF1aXJlKFwiLi9pdGVyYXRvcnMvbWFrZS1pdGVyYXRvci9tYWtlLWl0ZXJhdG9yXCIpO1xuXG52YXIgX21ha2VTdHJlYW0gPSByZXF1aXJlKFwiLi9pdGVyYXRvcnMvbWFrZS1zdHJlYW0vbWFrZS1zdHJlYW1cIik7XG5cbnZhciBfbWFrZURvbVN0cmVhbSA9IHJlcXVpcmUoXCIuL2l0ZXJhdG9ycy9tYWtlLXN0cmVhbS9tYWtlLWRvbS1zdHJlYW1cIik7XG5cbnZhciBfbWFrZU5vZGVTdHJlYW0gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2l0ZXJhdG9ycy9tYWtlLXN0cmVhbS9tYWtlLW5vZGUtc3RyZWFtXCIpKTtcblxudmFyIF9udWxsTG9hZGVyID0gcmVxdWlyZShcIi4vbnVsbC1sb2FkZXJcIik7XG5cbnZhciBfZmV0Y2hQcm9ncmVzcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL3Byb2dyZXNzL2ZldGNoLXByb2dyZXNzXCIpKTtcblxudmFyIF9icm93c2VyRmlsZXN5c3RlbSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2ZpbGVzeXN0ZW1zL2Jyb3dzZXItZmlsZXN5c3RlbVwiKSk7XG5cbnZhciBfaXNUeXBlID0gcmVxdWlyZShcIi4vamF2YXNjcmlwdC11dGlscy9pcy10eXBlXCIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5tYWtlQXJyYXlCdWZmZXJJdGVyYXRvciA9IG1ha2VBcnJheUJ1ZmZlckl0ZXJhdG9yO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX21hcmtlZCA9IF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsobWFrZUFycmF5QnVmZmVySXRlcmF0b3IpO1xuXG52YXIgREVGQVVMVF9DSFVOS19TSVpFID0gMjU2ICogMTAyNDtcblxuZnVuY3Rpb24gbWFrZUFycmF5QnVmZmVySXRlcmF0b3IoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIG9wdGlvbnMsXG4gICAgICBfb3B0aW9ucyRjaHVua1NpemUsXG4gICAgICBjaHVua1NpemUsXG4gICAgICBieXRlT2Zmc2V0LFxuICAgICAgY2h1bmtCeXRlTGVuZ3RoLFxuICAgICAgY2h1bmssXG4gICAgICBzb3VyY2VBcnJheSxcbiAgICAgIGNodW5rQXJyYXksXG4gICAgICBfYXJncyA9IGFyZ3VtZW50cztcblxuICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBtYWtlQXJyYXlCdWZmZXJJdGVyYXRvciQoX2NvbnRleHQpIHtcbiAgICB3aGlsZSAoMSkge1xuICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgb3B0aW9ucyA9IF9hcmdzLmxlbmd0aCA+IDEgJiYgX2FyZ3NbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzWzFdIDoge307XG4gICAgICAgICAgX29wdGlvbnMkY2h1bmtTaXplID0gb3B0aW9ucy5jaHVua1NpemUsIGNodW5rU2l6ZSA9IF9vcHRpb25zJGNodW5rU2l6ZSA9PT0gdm9pZCAwID8gREVGQVVMVF9DSFVOS19TSVpFIDogX29wdGlvbnMkY2h1bmtTaXplO1xuICAgICAgICAgIGJ5dGVPZmZzZXQgPSAwO1xuXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBpZiAoIShieXRlT2Zmc2V0IDwgYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCkpIHtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNodW5rQnl0ZUxlbmd0aCA9IE1hdGgubWluKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGggLSBieXRlT2Zmc2V0LCBjaHVua1NpemUpO1xuICAgICAgICAgIGNodW5rID0gbmV3IEFycmF5QnVmZmVyKGNodW5rQnl0ZUxlbmd0aCk7XG4gICAgICAgICAgc291cmNlQXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlciwgYnl0ZU9mZnNldCwgY2h1bmtCeXRlTGVuZ3RoKTtcbiAgICAgICAgICBjaHVua0FycmF5ID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmspO1xuICAgICAgICAgIGNodW5rQXJyYXkuc2V0KHNvdXJjZUFycmF5KTtcbiAgICAgICAgICBieXRlT2Zmc2V0ICs9IGNodW5rQnl0ZUxlbmd0aDtcbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTI7XG4gICAgICAgICAgcmV0dXJuIGNodW5rO1xuXG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCBfbWFya2VkKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ha2UtYXJyYXktYnVmZmVyLWl0ZXJhdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubWFrZUJsb2JJdGVyYXRvciA9IG1ha2VCbG9iSXRlcmF0b3I7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXdhaXRBc3luY0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2F3YWl0QXN5bmNHZW5lcmF0b3JcIikpO1xuXG52YXIgX3dyYXBBc3luY0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3dyYXBBc3luY0dlbmVyYXRvclwiKSk7XG5cbnZhciBERUZBVUxUX0NIVU5LX1NJWkUgPSAxMDI0ICogMTAyNDtcblxuZnVuY3Rpb24gbWFrZUJsb2JJdGVyYXRvcihfeCwgX3gyKSB7XG4gIHJldHVybiBfbWFrZUJsb2JJdGVyYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfbWFrZUJsb2JJdGVyYXRvcigpIHtcbiAgX21ha2VCbG9iSXRlcmF0b3IgPSAoMCwgX3dyYXBBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKGJsb2IsIG9wdGlvbnMpIHtcbiAgICB2YXIgY2h1bmtTaXplLCBvZmZzZXQsIGVuZCwgY2h1bms7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjaHVua1NpemUgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNodW5rU2l6ZSkgfHwgREVGQVVMVF9DSFVOS19TSVpFO1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGlmICghKG9mZnNldCA8IGJsb2Iuc2l6ZSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZW5kID0gb2Zmc2V0ICsgY2h1bmtTaXplO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9hd2FpdEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShibG9iLnNsaWNlKG9mZnNldCwgZW5kKS5hcnJheUJ1ZmZlcigpKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIGNodW5rID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIG9mZnNldCA9IGVuZDtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMDtcbiAgICAgICAgICAgIHJldHVybiBjaHVuaztcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9tYWtlQmxvYkl0ZXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWtlLWJsb2ItaXRlcmF0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm1ha2VJdGVyYXRvciA9IG1ha2VJdGVyYXRvcjtcblxudmFyIF9tYWtlU3RyaW5nSXRlcmF0b3IgPSByZXF1aXJlKFwiLi9tYWtlLXN0cmluZy1pdGVyYXRvclwiKTtcblxudmFyIF9tYWtlQXJyYXlCdWZmZXJJdGVyYXRvciA9IHJlcXVpcmUoXCIuL21ha2UtYXJyYXktYnVmZmVyLWl0ZXJhdG9yXCIpO1xuXG52YXIgX21ha2VCbG9iSXRlcmF0b3IgPSByZXF1aXJlKFwiLi9tYWtlLWJsb2ItaXRlcmF0b3JcIik7XG5cbnZhciBfbWFrZVN0cmVhbUl0ZXJhdG9yID0gcmVxdWlyZShcIi4vbWFrZS1zdHJlYW0taXRlcmF0b3JcIik7XG5cbnZhciBfaXNUeXBlID0gcmVxdWlyZShcIi4uLy4uL2phdmFzY3JpcHQtdXRpbHMvaXMtdHlwZVwiKTtcblxuZnVuY3Rpb24gbWFrZUl0ZXJhdG9yKGRhdGEsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiAoMCwgX21ha2VTdHJpbmdJdGVyYXRvci5tYWtlU3RyaW5nSXRlcmF0b3IpKGRhdGEsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiAoMCwgX21ha2VBcnJheUJ1ZmZlckl0ZXJhdG9yLm1ha2VBcnJheUJ1ZmZlckl0ZXJhdG9yKShkYXRhLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmICgoMCwgX2lzVHlwZS5pc0Jsb2IpKGRhdGEpKSB7XG4gICAgcmV0dXJuICgwLCBfbWFrZUJsb2JJdGVyYXRvci5tYWtlQmxvYkl0ZXJhdG9yKShkYXRhLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmICgoMCwgX2lzVHlwZS5pc1JlYWRhYmxlU3RyZWFtKShkYXRhKSkge1xuICAgIHJldHVybiAoMCwgX21ha2VTdHJlYW1JdGVyYXRvci5tYWtlU3RyZWFtSXRlcmF0b3IpKGRhdGEsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKCgwLCBfaXNUeXBlLmlzUmVzcG9uc2UpKGRhdGEpKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gZGF0YTtcbiAgICByZXR1cm4gKDAsIF9tYWtlU3RyZWFtSXRlcmF0b3IubWFrZVN0cmVhbUl0ZXJhdG9yKShyZXNwb25zZS5ib2R5LCBvcHRpb25zKTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignbWFrZUl0ZXJhdG9yJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWtlLWl0ZXJhdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubWFrZVN0cmVhbUl0ZXJhdG9yID0gbWFrZVN0cmVhbUl0ZXJhdG9yO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jSXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY0l0ZXJhdG9yXCIpKTtcblxudmFyIF9hd2FpdEFzeW5jR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXdhaXRBc3luY0dlbmVyYXRvclwiKSk7XG5cbnZhciBfd3JhcEFzeW5jR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvd3JhcEFzeW5jR2VuZXJhdG9yXCIpKTtcblxudmFyIF9sb2FkZXJVdGlscyA9IHJlcXVpcmUoXCJAbG9hZGVycy5nbC9sb2FkZXItdXRpbHNcIik7XG5cbmZ1bmN0aW9uIG1ha2VTdHJlYW1JdGVyYXRvcihzdHJlYW0sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9sb2FkZXJVdGlscy5pc0Jyb3dzZXIgPyBtYWtlQnJvd3NlclN0cmVhbUl0ZXJhdG9yKHN0cmVhbSwgb3B0aW9ucykgOiBtYWtlTm9kZVN0cmVhbUl0ZXJhdG9yKHN0cmVhbSwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIG1ha2VCcm93c2VyU3RyZWFtSXRlcmF0b3IoX3gsIF94Mikge1xuICByZXR1cm4gX21ha2VCcm93c2VyU3RyZWFtSXRlcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX21ha2VCcm93c2VyU3RyZWFtSXRlcmF0b3IoKSB7XG4gIF9tYWtlQnJvd3NlclN0cmVhbUl0ZXJhdG9yID0gKDAsIF93cmFwQXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZShzdHJlYW0sIG9wdGlvbnMpIHtcbiAgICB2YXIgcmVhZGVyLCBuZXh0QmF0Y2hQcm9taXNlLCBjdXJyZW50QmF0Y2hQcm9taXNlLCBfeWllbGQkX2F3YWl0QXN5bmNHZW4sIGRvbmUsIHZhbHVlO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGlmICghdHJ1ZSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50QmF0Y2hQcm9taXNlID0gbmV4dEJhdGNoUHJvbWlzZSB8fCByZWFkZXIucmVhZCgpO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgJiYgb3B0aW9ucy5fc3RyZWFtUmVhZEFoZWFkKSB7XG4gICAgICAgICAgICAgIG5leHRCYXRjaFByb21pc2UgPSByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2F3YWl0QXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKGN1cnJlbnRCYXRjaFByb21pc2UpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgX3lpZWxkJF9hd2FpdEFzeW5jR2VuID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIGRvbmUgPSBfeWllbGQkX2F3YWl0QXN5bmNHZW4uZG9uZTtcbiAgICAgICAgICAgIHZhbHVlID0gX3lpZWxkJF9hd2FpdEFzeW5jR2VuLnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9sb2FkZXJVdGlscy50b0FycmF5QnVmZmVyKSh2YWx1ZSk7XG5cbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjE7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTg7XG4gICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMSk7XG4gICAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcblxuICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbMSwgMThdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9tYWtlQnJvd3NlclN0cmVhbUl0ZXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIG1ha2VOb2RlU3RyZWFtSXRlcmF0b3IoX3gzLCBfeDQpIHtcbiAgcmV0dXJuIF9tYWtlTm9kZVN0cmVhbUl0ZXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9tYWtlTm9kZVN0cmVhbUl0ZXJhdG9yKCkge1xuICBfbWFrZU5vZGVTdHJlYW1JdGVyYXRvciA9ICgwLCBfd3JhcEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKHN0cmVhbSwgb3B0aW9ucykge1xuICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uLCBfZGlkSXRlcmF0b3JFcnJvciwgX2l0ZXJhdG9yRXJyb3IsIF9pdGVyYXRvciwgX3N0ZXAsIF92YWx1ZSwgY2h1bms7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDI7XG4gICAgICAgICAgICBfaXRlcmF0b3IgPSAoMCwgX2FzeW5jSXRlcmF0b3IyLmRlZmF1bHQpKHN0cmVhbSk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDY7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9hd2FpdEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShfaXRlcmF0b3IubmV4dCgpKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIF9zdGVwID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gX3N0ZXAuZG9uZTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTA7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9hd2FpdEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShfc3RlcC52YWx1ZSk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgX3ZhbHVlID0gX2NvbnRleHQyLnNlbnQ7XG5cbiAgICAgICAgICAgIGlmIChfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaHVuayA9IF92YWx1ZTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTU7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9sb2FkZXJVdGlscy50b0FycmF5QnVmZmVyKShjaHVuayk7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI0O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAyMDtcbiAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IF9jb250ZXh0MltcImNhdGNoXCJdKDIpO1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBfY29udGV4dDIudDA7XG5cbiAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAyNDtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMjU7XG5cbiAgICAgICAgICAgIGlmICghKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9hd2FpdEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShfaXRlcmF0b3IucmV0dXJuKCkpO1xuXG4gICAgICAgICAgY2FzZSAyOTpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMjk7XG5cbiAgICAgICAgICAgIGlmICghX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAzMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuXG4gICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuZmluaXNoKDI5KTtcblxuICAgICAgICAgIGNhc2UgMzM6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmZpbmlzaCgyNCk7XG5cbiAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIsIG51bGwsIFtbMiwgMjAsIDI0LCAzNF0sIFsyNSwsIDI5LCAzM11dKTtcbiAgfSkpO1xuICByZXR1cm4gX21ha2VOb2RlU3RyZWFtSXRlcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ha2Utc3RyZWFtLWl0ZXJhdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubWFrZVN0cmluZ0l0ZXJhdG9yID0gbWFrZVN0cmluZ0l0ZXJhdG9yO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX21hcmtlZCA9IF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsobWFrZVN0cmluZ0l0ZXJhdG9yKTtcblxudmFyIERFRkFVTFRfQ0hVTktfU0laRSA9IDI1NiAqIDEwMjQ7XG5cbmZ1bmN0aW9uIG1ha2VTdHJpbmdJdGVyYXRvcihzdHJpbmcsIG9wdGlvbnMpIHtcbiAgdmFyIGNodW5rU2l6ZSwgb2Zmc2V0LCB0ZXh0RW5jb2RlciwgY2h1bmtMZW5ndGgsIGNodW5rO1xuICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBtYWtlU3RyaW5nSXRlcmF0b3IkKF9jb250ZXh0KSB7XG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGNodW5rU2l6ZSA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2h1bmtTaXplKSB8fCBERUZBVUxUX0NIVU5LX1NJWkU7XG4gICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBpZiAoIShvZmZzZXQgPCBzdHJpbmcubGVuZ3RoKSkge1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDExO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2h1bmtMZW5ndGggPSBNYXRoLm1pbihzdHJpbmcubGVuZ3RoIC0gb2Zmc2V0LCBjaHVua1NpemUpO1xuICAgICAgICAgIGNodW5rID0gc3RyaW5nLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgY2h1bmtMZW5ndGgpO1xuICAgICAgICAgIG9mZnNldCArPSBjaHVua0xlbmd0aDtcbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gOTtcbiAgICAgICAgICByZXR1cm4gdGV4dEVuY29kZXIuZW5jb2RlKGNodW5rKTtcblxuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCBfbWFya2VkKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ha2Utc3RyaW5nLWl0ZXJhdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubWFrZURPTVN0cmVhbSA9IG1ha2VET01TdHJlYW07XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gbWFrZURPTVN0cmVhbShzb3VyY2UsIG9wdGlvbnMpIHtcbiAgdmFyIGl0ZXJhdG9yID0gc291cmNlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA/IHNvdXJjZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSA6IHNvdXJjZVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHR5cGU6ICdieXRlcycsXG4gICAgcHVsbDogZnVuY3Rpb24gcHVsbChjb250cm9sbGVyKSB7XG4gICAgICByZXR1cm4gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgIHZhciBfeWllbGQkaXRlcmF0b3IkbmV4dCwgZG9uZSwgdmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDA7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yLm5leHQoKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgX3lpZWxkJGl0ZXJhdG9yJG5leHQgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICAgIGRvbmUgPSBfeWllbGQkaXRlcmF0b3IkbmV4dC5kb25lO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gX3lpZWxkJGl0ZXJhdG9yJG5leHQudmFsdWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUobmV3IFVpbnQ4QXJyYXkodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA5O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKF9jb250ZXh0LnQwKTtcblxuICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbMCwgOV1dKTtcbiAgICAgIH0pKSgpO1xuICAgIH0sXG4gICAgY2FuY2VsOiBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICByZXR1cm4gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgICB2YXIgX2l0ZXJhdG9yJHJldHVybjtcblxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvciA9PT0gbnVsbCB8fCBpdGVyYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9pdGVyYXRvciRyZXR1cm4gPSBpdGVyYXRvci5yZXR1cm4pID09PSBudWxsIHx8IF9pdGVyYXRvciRyZXR1cm4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9pdGVyYXRvciRyZXR1cm4uY2FsbChpdGVyYXRvcik7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMik7XG4gICAgICB9KSkoKTtcbiAgICB9XG4gIH0sIF9vYmplY3RTcHJlYWQoe1xuICAgIGhpZ2hXYXRlck1hcms6IE1hdGgucG93KDIsIDI0KVxuICB9LCBvcHRpb25zKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWtlLWRvbS1zdHJlYW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5tYWtlU3RyZWFtID0gbWFrZVN0cmVhbTtcblxudmFyIF9sb2FkZXJVdGlscyA9IHJlcXVpcmUoXCJAbG9hZGVycy5nbC9sb2FkZXItdXRpbHNcIik7XG5cbnZhciBfbWFrZURvbVN0cmVhbSA9IHJlcXVpcmUoXCIuL21ha2UtZG9tLXN0cmVhbVwiKTtcblxudmFyIF9tYWtlTm9kZVN0cmVhbSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbWFrZS1ub2RlLXN0cmVhbVwiKSk7XG5cbmZ1bmN0aW9uIG1ha2VTdHJlYW0oZGF0YSwgb3B0aW9ucykge1xuICByZXR1cm4gX2xvYWRlclV0aWxzLmlzQnJvd3NlciA/ICgwLCBfbWFrZURvbVN0cmVhbS5tYWtlRE9NU3RyZWFtKShkYXRhLCBvcHRpb25zKSA6ICgwLCBfbWFrZU5vZGVTdHJlYW0uZGVmYXVsdCkoZGF0YSwgb3B0aW9ucyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWtlLXN0cmVhbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmlzV3JpdGFibGVTdHJlYW0gPSBleHBvcnRzLmlzUmVhZGFibGVTdHJlYW0gPSBleHBvcnRzLmlzUmVhZGFibGVOb2RlU3RyZWFtID0gZXhwb3J0cy5pc1dyaXRhYmxlTm9kZVN0cmVhbSA9IGV4cG9ydHMuaXNCdWZmZXIgPSBleHBvcnRzLmlzUmVhZGFibGVET01TdHJlYW0gPSBleHBvcnRzLmlzV3JpdGFibGVET01TdHJlYW0gPSBleHBvcnRzLmlzQmxvYiA9IGV4cG9ydHMuaXNGaWxlID0gZXhwb3J0cy5pc1Jlc3BvbnNlID0gZXhwb3J0cy5pc0l0ZXJhdG9yID0gZXhwb3J0cy5pc0FzeW5jSXRlcmFibGUgPSBleHBvcnRzLmlzSXRlcmFibGUgPSBleHBvcnRzLmlzUHJvbWlzZSA9IGV4cG9ydHMuaXNQdXJlT2JqZWN0ID0gZXhwb3J0cy5pc09iamVjdCA9IHZvaWQgMDtcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG52YXIgaXNCb29sZWFuID0gZnVuY3Rpb24gaXNCb29sZWFuKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnYm9vbGVhbic7XG59O1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24oeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG59O1xuXG52YXIgaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdCh4KSB7XG4gIHJldHVybiB4ICE9PSBudWxsICYmICgwLCBfdHlwZW9mMi5kZWZhdWx0KSh4KSA9PT0gJ29iamVjdCc7XG59O1xuXG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbnZhciBpc1B1cmVPYmplY3QgPSBmdW5jdGlvbiBpc1B1cmVPYmplY3QoeCkge1xuICByZXR1cm4gaXNPYmplY3QoeCkgJiYgeC5jb25zdHJ1Y3RvciA9PT0ge30uY29uc3RydWN0b3I7XG59O1xuXG5leHBvcnRzLmlzUHVyZU9iamVjdCA9IGlzUHVyZU9iamVjdDtcblxudmFyIGlzUHJvbWlzZSA9IGZ1bmN0aW9uIGlzUHJvbWlzZSh4KSB7XG4gIHJldHVybiBpc09iamVjdCh4KSAmJiBpc0Z1bmN0aW9uKHgudGhlbik7XG59O1xuXG5leHBvcnRzLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTtcblxudmFyIGlzSXRlcmFibGUgPSBmdW5jdGlvbiBpc0l0ZXJhYmxlKHgpIHtcbiAgcmV0dXJuIHggJiYgdHlwZW9mIHhbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cbmV4cG9ydHMuaXNJdGVyYWJsZSA9IGlzSXRlcmFibGU7XG5cbnZhciBpc0FzeW5jSXRlcmFibGUgPSBmdW5jdGlvbiBpc0FzeW5jSXRlcmFibGUoeCkge1xuICByZXR1cm4geCAmJiB0eXBlb2YgeFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG59O1xuXG5leHBvcnRzLmlzQXN5bmNJdGVyYWJsZSA9IGlzQXN5bmNJdGVyYWJsZTtcblxudmFyIGlzSXRlcmF0b3IgPSBmdW5jdGlvbiBpc0l0ZXJhdG9yKHgpIHtcbiAgcmV0dXJuIHggJiYgaXNGdW5jdGlvbih4Lm5leHQpO1xufTtcblxuZXhwb3J0cy5pc0l0ZXJhdG9yID0gaXNJdGVyYXRvcjtcblxudmFyIGlzUmVzcG9uc2UgPSBmdW5jdGlvbiBpc1Jlc3BvbnNlKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiBSZXNwb25zZSAhPT0gJ3VuZGVmaW5lZCcgJiYgeCBpbnN0YW5jZW9mIFJlc3BvbnNlIHx8IHggJiYgeC5hcnJheUJ1ZmZlciAmJiB4LnRleHQgJiYgeC5qc29uO1xufTtcblxuZXhwb3J0cy5pc1Jlc3BvbnNlID0gaXNSZXNwb25zZTtcblxudmFyIGlzRmlsZSA9IGZ1bmN0aW9uIGlzRmlsZSh4KSB7XG4gIHJldHVybiB0eXBlb2YgRmlsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgeCBpbnN0YW5jZW9mIEZpbGU7XG59O1xuXG5leHBvcnRzLmlzRmlsZSA9IGlzRmlsZTtcblxudmFyIGlzQmxvYiA9IGZ1bmN0aW9uIGlzQmxvYih4KSB7XG4gIHJldHVybiB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgeCBpbnN0YW5jZW9mIEJsb2I7XG59O1xuXG5leHBvcnRzLmlzQmxvYiA9IGlzQmxvYjtcblxudmFyIGlzV3JpdGFibGVET01TdHJlYW0gPSBmdW5jdGlvbiBpc1dyaXRhYmxlRE9NU3RyZWFtKHgpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHgpICYmIGlzRnVuY3Rpb24oeC5hYm9ydCkgJiYgaXNGdW5jdGlvbih4LmdldFdyaXRlcik7XG59O1xuXG5leHBvcnRzLmlzV3JpdGFibGVET01TdHJlYW0gPSBpc1dyaXRhYmxlRE9NU3RyZWFtO1xuXG52YXIgaXNSZWFkYWJsZURPTVN0cmVhbSA9IGZ1bmN0aW9uIGlzUmVhZGFibGVET01TdHJlYW0oeCkge1xuICByZXR1cm4gdHlwZW9mIFJlYWRhYmxlU3RyZWFtICE9PSAndW5kZWZpbmVkJyAmJiB4IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0gfHwgaXNPYmplY3QoeCkgJiYgaXNGdW5jdGlvbih4LnRlZSkgJiYgaXNGdW5jdGlvbih4LmNhbmNlbCkgJiYgaXNGdW5jdGlvbih4LmdldFJlYWRlcik7XG59O1xuXG5leHBvcnRzLmlzUmVhZGFibGVET01TdHJlYW0gPSBpc1JlYWRhYmxlRE9NU3RyZWFtO1xuXG52YXIgaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlcih4KSB7XG4gIHJldHVybiB4ICYmICgwLCBfdHlwZW9mMi5kZWZhdWx0KSh4KSA9PT0gJ29iamVjdCcgJiYgeC5pc0J1ZmZlcjtcbn07XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSBpc0J1ZmZlcjtcblxudmFyIGlzV3JpdGFibGVOb2RlU3RyZWFtID0gZnVuY3Rpb24gaXNXcml0YWJsZU5vZGVTdHJlYW0oeCkge1xuICByZXR1cm4gaXNPYmplY3QoeCkgJiYgaXNGdW5jdGlvbih4LmVuZCkgJiYgaXNGdW5jdGlvbih4LndyaXRlKSAmJiBpc0Jvb2xlYW4oeC53cml0YWJsZSk7XG59O1xuXG5leHBvcnRzLmlzV3JpdGFibGVOb2RlU3RyZWFtID0gaXNXcml0YWJsZU5vZGVTdHJlYW07XG5cbnZhciBpc1JlYWRhYmxlTm9kZVN0cmVhbSA9IGZ1bmN0aW9uIGlzUmVhZGFibGVOb2RlU3RyZWFtKHgpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHgpICYmIGlzRnVuY3Rpb24oeC5yZWFkKSAmJiBpc0Z1bmN0aW9uKHgucGlwZSkgJiYgaXNCb29sZWFuKHgucmVhZGFibGUpO1xufTtcblxuZXhwb3J0cy5pc1JlYWRhYmxlTm9kZVN0cmVhbSA9IGlzUmVhZGFibGVOb2RlU3RyZWFtO1xuXG52YXIgaXNSZWFkYWJsZVN0cmVhbSA9IGZ1bmN0aW9uIGlzUmVhZGFibGVTdHJlYW0oeCkge1xuICByZXR1cm4gaXNSZWFkYWJsZURPTVN0cmVhbSh4KSB8fCBpc1JlYWRhYmxlTm9kZVN0cmVhbSh4KTtcbn07XG5cbmV4cG9ydHMuaXNSZWFkYWJsZVN0cmVhbSA9IGlzUmVhZGFibGVTdHJlYW07XG5cbnZhciBpc1dyaXRhYmxlU3RyZWFtID0gZnVuY3Rpb24gaXNXcml0YWJsZVN0cmVhbSh4KSB7XG4gIHJldHVybiBpc1dyaXRhYmxlRE9NU3RyZWFtKHgpIHx8IGlzV3JpdGFibGVOb2RlU3RyZWFtKHgpO1xufTtcblxuZXhwb3J0cy5pc1dyaXRhYmxlU3RyZWFtID0gaXNXcml0YWJsZVN0cmVhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLXR5cGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5leHBvcnRzLmVuY29kZVN5bmMgPSBlbmNvZGVTeW5jO1xuZXhwb3J0cy5lbmNvZGVUZXh0ID0gZW5jb2RlVGV4dDtcbmV4cG9ydHMuZW5jb2RlSW5CYXRjaGVzID0gZW5jb2RlSW5CYXRjaGVzO1xuZXhwb3J0cy5lbmNvZGVVUkx0b1VSTCA9IGVuY29kZVVSTHRvVVJMO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY0l0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNJdGVyYXRvclwiKSk7XG5cbnZhciBfbG9hZGVyVXRpbHMgPSByZXF1aXJlKFwiQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzXCIpO1xuXG52YXIgX3dyaXRlRmlsZSA9IHJlcXVpcmUoXCIuLi9mZXRjaC93cml0ZS1maWxlXCIpO1xuXG52YXIgX2ZldGNoRmlsZSA9IHJlcXVpcmUoXCIuLi9mZXRjaC9mZXRjaC1maWxlXCIpO1xuXG5mdW5jdGlvbiBlbmNvZGUoX3gsIF94MiwgX3gzKSB7XG4gIHJldHVybiBfZW5jb2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9lbmNvZGUoKSB7XG4gIF9lbmNvZGUgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZShkYXRhLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICB2YXIgYmF0Y2hlcywgY2h1bmtzLCBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uLCBfZGlkSXRlcmF0b3JFcnJvciwgX2l0ZXJhdG9yRXJyb3IsIF9pdGVyYXRvciwgX3N0ZXAsIF92YWx1ZSwgYmF0Y2gsIHRtcElucHV0RmlsZW5hbWUsIHRtcE91dHB1dEZpbGVuYW1lLCBvdXRwdXRGaWxlbmFtZSwgcmVzcG9uc2U7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghd3JpdGVyLmVuY29kZSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlci5lbmNvZGUoZGF0YSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0LnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgaWYgKCF3cml0ZXIuZW5jb2RlU3luYykge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgd3JpdGVyLmVuY29kZVN5bmMoZGF0YSwgb3B0aW9ucykpO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgaWYgKCF3cml0ZXIuZW5jb2RlVGV4dCkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dC50MCA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEwO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlci5lbmNvZGVUZXh0KGRhdGEsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIF9jb250ZXh0LnQxID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQudDAuZW5jb2RlLmNhbGwoX2NvbnRleHQudDAsIF9jb250ZXh0LnQxKSk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgaWYgKCF3cml0ZXIuZW5jb2RlSW5CYXRjaGVzKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0OTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJhdGNoZXMgPSBlbmNvZGVJbkJhdGNoZXMoZGF0YSwgd3JpdGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNodW5rcyA9IFtdO1xuICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDE3O1xuICAgICAgICAgICAgX2l0ZXJhdG9yID0gKDAsIF9hc3luY0l0ZXJhdG9yMi5kZWZhdWx0KShiYXRjaGVzKTtcblxuICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjE7XG4gICAgICAgICAgICByZXR1cm4gX2l0ZXJhdG9yLm5leHQoKTtcblxuICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICBfc3RlcCA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gX3N0ZXAuZG9uZTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyNTtcbiAgICAgICAgICAgIHJldHVybiBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgICBfdmFsdWUgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgICBpZiAoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbikge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMzI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBiYXRjaCA9IF92YWx1ZTtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKGJhdGNoKTtcblxuICAgICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxOTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzODtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAzNDtcbiAgICAgICAgICAgIF9jb250ZXh0LnQyID0gX2NvbnRleHRbXCJjYXRjaFwiXSgxNyk7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IF9jb250ZXh0LnQyO1xuXG4gICAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAzODtcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAzOTtcblxuICAgICAgICAgICAgaWYgKCEoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDM7XG4gICAgICAgICAgICByZXR1cm4gX2l0ZXJhdG9yLnJldHVybigpO1xuXG4gICAgICAgICAgY2FzZSA0MzpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA0MztcblxuICAgICAgICAgICAgaWYgKCFfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcblxuICAgICAgICAgIGNhc2UgNDY6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDQzKTtcblxuICAgICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDM4KTtcblxuICAgICAgICAgIGNhc2UgNDg6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIF9sb2FkZXJVdGlscy5jb25jYXRlbmF0ZUFycmF5QnVmZmVycy5hcHBseSh2b2lkIDAsIGNodW5rcykpO1xuXG4gICAgICAgICAgY2FzZSA0OTpcbiAgICAgICAgICAgIGlmICghKCFfbG9hZGVyVXRpbHMuaXNCcm93c2VyICYmIHdyaXRlci5lbmNvZGVVUkx0b1VSTCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDYxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG1wSW5wdXRGaWxlbmFtZSA9IGdldFRlbXBvcmFyeUZpbGVuYW1lKCdpbnB1dCcpO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDUzO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfd3JpdGVGaWxlLndyaXRlRmlsZSkodG1wSW5wdXRGaWxlbmFtZSwgZGF0YSk7XG5cbiAgICAgICAgICBjYXNlIDUzOlxuICAgICAgICAgICAgdG1wT3V0cHV0RmlsZW5hbWUgPSBnZXRUZW1wb3JhcnlGaWxlbmFtZSgnb3V0cHV0Jyk7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTY7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlVVJMdG9VUkwodG1wSW5wdXRGaWxlbmFtZSwgdG1wT3V0cHV0RmlsZW5hbWUsIHdyaXRlciwgb3B0aW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDU2OlxuICAgICAgICAgICAgb3V0cHV0RmlsZW5hbWUgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDU5O1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfZmV0Y2hGaWxlLmZldGNoRmlsZSkob3V0cHV0RmlsZW5hbWUpO1xuXG4gICAgICAgICAgY2FzZSA1OTpcbiAgICAgICAgICAgIHJlc3BvbnNlID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKSk7XG5cbiAgICAgICAgICBjYXNlIDYxOlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcml0ZXIgY291bGQgbm90IGVuY29kZSBkYXRhJyk7XG5cbiAgICAgICAgICBjYXNlIDYyOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlLCBudWxsLCBbWzE3LCAzNCwgMzgsIDQ4XSwgWzM5LCwgNDMsIDQ3XV0pO1xuICB9KSk7XG4gIHJldHVybiBfZW5jb2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGVuY29kZVN5bmMoZGF0YSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gIGlmICh3cml0ZXIuZW5jb2RlU3luYykge1xuICAgIHJldHVybiB3cml0ZXIuZW5jb2RlU3luYyhkYXRhLCBvcHRpb25zKTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignV3JpdGVyIGNvdWxkIG5vdCBzeW5jaHJvbm91c2x5IGVuY29kZSBkYXRhJyk7XG59XG5cbmZ1bmN0aW9uIGVuY29kZVRleHQoX3g0LCBfeDUsIF94Nikge1xuICByZXR1cm4gX2VuY29kZVRleHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2VuY29kZVRleHQoKSB7XG4gIF9lbmNvZGVUZXh0ID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGRhdGEsIHdyaXRlciwgb3B0aW9ucykge1xuICAgIHZhciBhcnJheUJ1ZmZlcjtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoISh3cml0ZXIudGV4dCAmJiB3cml0ZXIuZW5jb2RlVGV4dCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlci5lbmNvZGVUZXh0KGRhdGEsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQyLnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgaWYgKCEod3JpdGVyLnRleHQgJiYgKHdyaXRlci5lbmNvZGUgfHwgd3JpdGVyLmVuY29kZUluQmF0Y2hlcykpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNztcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGUoZGF0YSwgd3JpdGVyLCBvcHRpb25zKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGFycmF5QnVmZmVyID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYXJyYXlCdWZmZXIpKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV3JpdGVyIGNvdWxkIG5vdCBlbmNvZGUgZGF0YSBhcyB0ZXh0Jyk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIpO1xuICB9KSk7XG4gIHJldHVybiBfZW5jb2RlVGV4dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVJbkJhdGNoZXMoZGF0YSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gIGlmICh3cml0ZXIuZW5jb2RlSW5CYXRjaGVzKSB7XG4gICAgdmFyIGRhdGFJdGVyYXRvciA9IGdldEl0ZXJhdG9yKGRhdGEpO1xuICAgIHJldHVybiB3cml0ZXIuZW5jb2RlSW5CYXRjaGVzKGRhdGFJdGVyYXRvciwgb3B0aW9ucyk7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1dyaXRlciBjb3VsZCBub3QgZW5jb2RlIGRhdGEgaW4gYmF0Y2hlcycpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVVUkx0b1VSTChfeDcsIF94OCwgX3g5LCBfeDEwKSB7XG4gIHJldHVybiBfZW5jb2RlVVJMdG9VUkwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2VuY29kZVVSTHRvVVJMKCkge1xuICBfZW5jb2RlVVJMdG9VUkwgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoaW5wdXRVcmwsIG91dHB1dFVybCwgd3JpdGVyLCBvcHRpb25zKSB7XG4gICAgdmFyIG91dHB1dEZpbGVuYW1lO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlucHV0VXJsID0gKDAsIF9sb2FkZXJVdGlscy5yZXNvbHZlUGF0aCkoaW5wdXRVcmwpO1xuICAgICAgICAgICAgb3V0cHV0VXJsID0gKDAsIF9sb2FkZXJVdGlscy5yZXNvbHZlUGF0aCkob3V0cHV0VXJsKTtcblxuICAgICAgICAgICAgaWYgKCEoX2xvYWRlclV0aWxzLmlzQnJvd3NlciB8fCAhd3JpdGVyLmVuY29kZVVSTHRvVVJMKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNjtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXIuZW5jb2RlVVJMdG9VUkwoaW5wdXRVcmwsIG91dHB1dFVybCwgb3B0aW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBvdXRwdXRGaWxlbmFtZSA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgb3V0cHV0RmlsZW5hbWUpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTMpO1xuICB9KSk7XG4gIHJldHVybiBfZW5jb2RlVVJMdG9VUkwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0SXRlcmF0b3IoZGF0YSkge1xuICB2YXIgZGF0YUl0ZXJhdG9yID0gW3tcbiAgICB0YWJsZTogZGF0YSxcbiAgICBzdGFydDogMCxcbiAgICBlbmQ6IGRhdGEubGVuZ3RoXG4gIH1dO1xuICByZXR1cm4gZGF0YUl0ZXJhdG9yO1xufVxuXG5mdW5jdGlvbiBnZXRUZW1wb3JhcnlGaWxlbmFtZShmaWxlbmFtZSkge1xuICByZXR1cm4gXCIvdG1wL1wiLmNvbmNhdChmaWxlbmFtZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbmNvZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5sb2FkSW5CYXRjaGVzID0gbG9hZEluQmF0Y2hlcztcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfbm9ybWFsaXplTG9hZGVyID0gcmVxdWlyZShcIi4uL2xvYWRlci11dGlscy9ub3JtYWxpemUtbG9hZGVyXCIpO1xuXG52YXIgX29wdGlvblV0aWxzID0gcmVxdWlyZShcIi4uL2xvYWRlci11dGlscy9vcHRpb24tdXRpbHNcIik7XG5cbnZhciBfcGFyc2VJbkJhdGNoZXMgPSByZXF1aXJlKFwiLi9wYXJzZS1pbi1iYXRjaGVzXCIpO1xuXG5mdW5jdGlvbiBsb2FkSW5CYXRjaGVzKGZpbGVzLCBsb2FkZXJzLCBvcHRpb25zLCBjb250ZXh0KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsb2FkZXJzKSAmJiAhKDAsIF9ub3JtYWxpemVMb2FkZXIuaXNMb2FkZXJPYmplY3QpKGxvYWRlcnMpKSB7XG4gICAgY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICBvcHRpb25zID0gbG9hZGVycztcbiAgICBsb2FkZXJzID0gbnVsbDtcbiAgfVxuXG4gIHZhciBmZXRjaCA9ICgwLCBfb3B0aW9uVXRpbHMuZ2V0RmV0Y2hGdW5jdGlvbikob3B0aW9ucyB8fCB7fSk7XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGZpbGVzKSkge1xuICAgIHJldHVybiBsb2FkT25lRmlsZUluQmF0Y2hlcyhmaWxlcywgbG9hZGVycywgb3B0aW9ucywgZmV0Y2gpO1xuICB9XG5cbiAgdmFyIHByb21pc2VzID0gZmlsZXMubWFwKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgcmV0dXJuIGxvYWRPbmVGaWxlSW5CYXRjaGVzKGZpbGUsIGxvYWRlcnMsIG9wdGlvbnMsIGZldGNoKTtcbiAgfSk7XG4gIHJldHVybiBwcm9taXNlcztcbn1cblxuZnVuY3Rpb24gbG9hZE9uZUZpbGVJbkJhdGNoZXMoX3gsIF94MiwgX3gzLCBfeDQpIHtcbiAgcmV0dXJuIF9sb2FkT25lRmlsZUluQmF0Y2hlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfbG9hZE9uZUZpbGVJbkJhdGNoZXMoKSB7XG4gIF9sb2FkT25lRmlsZUluQmF0Y2hlcyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKGZpbGUsIGxvYWRlcnMsIG9wdGlvbnMsIGZldGNoKSB7XG4gICAgdmFyIHVybCwgcmVzcG9uc2U7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoISh0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdXJsID0gZmlsZTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoKHVybCk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXNwb25zZSA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgIHJldHVybiAoMCwgX3BhcnNlSW5CYXRjaGVzLnBhcnNlSW5CYXRjaGVzKShyZXNwb25zZSwgbG9hZGVycywgb3B0aW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0LnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEwO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfcGFyc2VJbkJhdGNoZXMucGFyc2VJbkJhdGNoZXMpKGZpbGUsIGxvYWRlcnMsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlKTtcbiAgfSkpO1xuICByZXR1cm4gX2xvYWRPbmVGaWxlSW5CYXRjaGVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkLWluLWJhdGNoZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfaXNUeXBlID0gcmVxdWlyZShcIi4uLy4uL2phdmFzY3JpcHQtdXRpbHMvaXMtdHlwZVwiKTtcblxudmFyIF9ub3JtYWxpemVMb2FkZXIgPSByZXF1aXJlKFwiLi4vbG9hZGVyLXV0aWxzL25vcm1hbGl6ZS1sb2FkZXJcIik7XG5cbnZhciBfb3B0aW9uVXRpbHMgPSByZXF1aXJlKFwiLi4vbG9hZGVyLXV0aWxzL29wdGlvbi11dGlsc1wiKTtcblxudmFyIF9wYXJzZSA9IHJlcXVpcmUoXCIuL3BhcnNlXCIpO1xuXG5mdW5jdGlvbiBsb2FkKF94LCBfeDIsIF94MywgX3g0KSB7XG4gIHJldHVybiBfbG9hZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfbG9hZCgpIHtcbiAgX2xvYWQgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZSh1cmwsIGxvYWRlcnMsIG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgICB2YXIgZmV0Y2gsIGRhdGE7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobG9hZGVycykgJiYgISgwLCBfbm9ybWFsaXplTG9hZGVyLmlzTG9hZGVyT2JqZWN0KShsb2FkZXJzKSkge1xuICAgICAgICAgICAgICBjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICBvcHRpb25zID0gbG9hZGVycztcbiAgICAgICAgICAgICAgbG9hZGVycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmV0Y2ggPSAoMCwgX29wdGlvblV0aWxzLmdldEZldGNoRnVuY3Rpb24pKG9wdGlvbnMpO1xuICAgICAgICAgICAgZGF0YSA9IHVybDtcblxuICAgICAgICAgICAgaWYgKCEodHlwZW9mIHVybCA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2godXJsKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgaWYgKCEoMCwgX2lzVHlwZS5pc0Jsb2IpKHVybCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDExO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEwO1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoKHVybCk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgZGF0YSA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEzO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfcGFyc2UucGFyc2UpKGRhdGEsIGxvYWRlcnMsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlKTtcbiAgfSkpO1xuICByZXR1cm4gX2xvYWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5wYXJzZUluQmF0Y2hlcyA9IHBhcnNlSW5CYXRjaGVzO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX3R5cGVvZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX3dyYXBBc3luY0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3dyYXBBc3luY0dlbmVyYXRvclwiKSk7XG5cbnZhciBfYXdhaXRBc3luY0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2F3YWl0QXN5bmNHZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jSXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY0l0ZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY0dlbmVyYXRvckRlbGVnYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNHZW5lcmF0b3JEZWxlZ2F0ZVwiKSk7XG5cbnZhciBfbG9hZGVyVXRpbHMgPSByZXF1aXJlKFwiQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzXCIpO1xuXG52YXIgX25vcm1hbGl6ZUxvYWRlciA9IHJlcXVpcmUoXCIuLi9sb2FkZXItdXRpbHMvbm9ybWFsaXplLWxvYWRlclwiKTtcblxudmFyIF9vcHRpb25VdGlscyA9IHJlcXVpcmUoXCIuLi9sb2FkZXItdXRpbHMvb3B0aW9uLXV0aWxzXCIpO1xuXG52YXIgX2xvYWRlckNvbnRleHQgPSByZXF1aXJlKFwiLi4vbG9hZGVyLXV0aWxzL2xvYWRlci1jb250ZXh0XCIpO1xuXG52YXIgX2dldERhdGEgPSByZXF1aXJlKFwiLi4vbG9hZGVyLXV0aWxzL2dldC1kYXRhXCIpO1xuXG52YXIgX3Jlc291cmNlVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMvcmVzb3VyY2UtdXRpbHNcIik7XG5cbnZhciBfc2VsZWN0TG9hZGVyID0gcmVxdWlyZShcIi4vc2VsZWN0LWxvYWRlclwiKTtcblxudmFyIF9wYXJzZSA9IHJlcXVpcmUoXCIuL3BhcnNlXCIpO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gcGFyc2VJbkJhdGNoZXMoX3gyLCBfeDMsIF94NCwgX3g1KSB7XG4gIHJldHVybiBfcGFyc2VJbkJhdGNoZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3BhcnNlSW5CYXRjaGVzKCkge1xuICBfcGFyc2VJbkJhdGNoZXMgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoZGF0YSwgbG9hZGVycywgb3B0aW9ucywgY29udGV4dCkge1xuICAgIHZhciBfZ2V0UmVzb3VyY2VVcmxBbmRUeXAsIHVybCwgbG9hZGVyO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgKDAsIF9sb2FkZXJVdGlscy5hc3NlcnQpKCFjb250ZXh0IHx8ICgwLCBfdHlwZW9mMi5kZWZhdWx0KShjb250ZXh0KSA9PT0gJ29iamVjdCcpO1xuXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobG9hZGVycykgJiYgISgwLCBfbm9ybWFsaXplTG9hZGVyLmlzTG9hZGVyT2JqZWN0KShsb2FkZXJzKSkge1xuICAgICAgICAgICAgICBjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICBvcHRpb25zID0gbG9hZGVycztcbiAgICAgICAgICAgICAgbG9hZGVycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA0O1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBkYXRhID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIF9nZXRSZXNvdXJjZVVybEFuZFR5cCA9ICgwLCBfcmVzb3VyY2VVdGlscy5nZXRSZXNvdXJjZVVybEFuZFR5cGUpKGRhdGEpLCB1cmwgPSBfZ2V0UmVzb3VyY2VVcmxBbmRUeXAudXJsO1xuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA5O1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfc2VsZWN0TG9hZGVyLnNlbGVjdExvYWRlcikoZGF0YSwgbG9hZGVycywgb3B0aW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBsb2FkZXIgPSBfY29udGV4dDMuc2VudDtcblxuICAgICAgICAgICAgaWYgKGxvYWRlcikge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDEyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgbnVsbCk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgb3B0aW9ucyA9ICgwLCBfb3B0aW9uVXRpbHMubm9ybWFsaXplT3B0aW9ucykob3B0aW9ucywgbG9hZGVyLCBsb2FkZXJzLCB1cmwpO1xuICAgICAgICAgICAgY29udGV4dCA9ICgwLCBfbG9hZGVyQ29udGV4dC5nZXRMb2FkZXJDb250ZXh0KSh7XG4gICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICBwYXJzZUluQmF0Y2hlczogcGFyc2VJbkJhdGNoZXMsXG4gICAgICAgICAgICAgIHBhcnNlOiBfcGFyc2UucGFyc2UsXG4gICAgICAgICAgICAgIGxvYWRlcnM6IGxvYWRlcnNcbiAgICAgICAgICAgIH0sIG9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxNjtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVdpdGhMb2FkZXJJbkJhdGNoZXMobG9hZGVyLCBkYXRhLCBvcHRpb25zLCBjb250ZXh0KTtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDMuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIpO1xuICB9KSk7XG4gIHJldHVybiBfcGFyc2VJbkJhdGNoZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VXaXRoTG9hZGVySW5CYXRjaGVzKGxvYWRlciwgZGF0YSwgb3B0aW9ucywgY29udGV4dCkge1xuICB2YXIgb3V0cHV0SXRlcmF0b3IsIG1ldGFkYXRhQmF0Y2gsIG1ha2VNZXRhZGF0YUJhdGNoSXRlcmF0b3IsIF9tYWtlTWV0YWRhdGFCYXRjaEl0ZXJhdG9yO1xuXG4gIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC5hc3luYyhmdW5jdGlvbiBwYXJzZVdpdGhMb2FkZXJJbkJhdGNoZXMkKF9jb250ZXh0KSB7XG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIF9tYWtlTWV0YWRhdGFCYXRjaEl0ZXJhdG9yID0gZnVuY3Rpb24gX21ha2VNZXRhZGF0YUJhdGNoSXRlMigpIHtcbiAgICAgICAgICAgIF9tYWtlTWV0YWRhdGFCYXRjaEl0ZXJhdG9yID0gKDAsIF93cmFwQXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZShpdGVyYXRvcikge1xuICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dDIpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhQmF0Y2g7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuZGVsZWdhdGVZaWVsZCgoMCwgX2FzeW5jR2VuZXJhdG9yRGVsZWdhdGUyLmRlZmF1bHQpKCgwLCBfYXN5bmNJdGVyYXRvcjIuZGVmYXVsdCkoaXRlcmF0b3IpLCBfYXdhaXRBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCksIFwidDBcIiwgMyk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCBfY2FsbGVlKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBfbWFrZU1ldGFkYXRhQmF0Y2hJdGVyYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBtYWtlTWV0YWRhdGFCYXRjaEl0ZXJhdG9yID0gZnVuY3Rpb24gX21ha2VNZXRhZGF0YUJhdGNoSXRlKF94KSB7XG4gICAgICAgICAgICByZXR1cm4gX21ha2VNZXRhZGF0YUJhdGNoSXRlcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XG4gICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LmF3cmFwKHBhcnNlVG9PdXRwdXRJdGVyYXRvcihsb2FkZXIsIGRhdGEsIG9wdGlvbnMsIGNvbnRleHQpKTtcblxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgb3V0cHV0SXRlcmF0b3IgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnMubWV0YWRhdGEpIHtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBvdXRwdXRJdGVyYXRvcik7XG5cbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIG1ldGFkYXRhQmF0Y2ggPSB7XG4gICAgICAgICAgICBiYXRjaFR5cGU6ICdtZXRhZGF0YScsXG4gICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICBfbG9hZGVyOiBsb2FkZXIsXG4gICAgICAgICAgICAgIF9jb250ZXh0OiBjb250ZXh0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICBieXRlc1VzZWQ6IDBcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbWFrZU1ldGFkYXRhQmF0Y2hJdGVyYXRvcihvdXRwdXRJdGVyYXRvcikpO1xuXG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCBudWxsLCBudWxsLCBudWxsLCBQcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUb091dHB1dEl0ZXJhdG9yKF94NiwgX3g3LCBfeDgsIF94OSkge1xuICByZXR1cm4gX3BhcnNlVG9PdXRwdXRJdGVyYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfcGFyc2VUb091dHB1dEl0ZXJhdG9yKCkge1xuICBfcGFyc2VUb091dHB1dEl0ZXJhdG9yID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KGxvYWRlciwgZGF0YSwgb3B0aW9ucywgY29udGV4dCkge1xuICAgIHZhciBpbnB1dEl0ZXJhdG9yLCB0cmFuc2Zvcm1lZEl0ZXJhdG9yLCBwYXJzZUNodW5rSW5CYXRjaGVzLCBfcGFyc2VDaHVua0luQmF0Y2hlcztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDUpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9wYXJzZUNodW5rSW5CYXRjaGVzID0gZnVuY3Rpb24gX3BhcnNlQ2h1bmtJbkJhdGNoZXMzKCkge1xuICAgICAgICAgICAgICBfcGFyc2VDaHVua0luQmF0Y2hlcyA9ICgwLCBfd3JhcEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcnJheUJ1ZmZlciwgcGFyc2VkRGF0YSwgYmF0Y2g7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0NCkge1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfYXdhaXRBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoKDAsIF9sb2FkZXJVdGlscy5jb25jYXRlbmF0ZUFycmF5QnVmZmVyc0FzeW5jKSh0cmFuc2Zvcm1lZEl0ZXJhdG9yKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheUJ1ZmZlciA9IF9jb250ZXh0NC5zZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfYXdhaXRBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoKDAsIF9wYXJzZS5wYXJzZSkoYXJyYXlCdWZmZXIsIGxvYWRlciwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IGxvYWRlci5taW1lVHlwZXNbMF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBjb250ZXh0KSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRhID0gX2NvbnRleHQ0LnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXRjaCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IGxvYWRlci5taW1lVHlwZXNbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlOiBBcnJheS5pc0FycmF5KHBhcnNlZERhdGEpID8gJ3Jvdy10YWJsZScgOiAndW5rbm93bicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJhdGNoVHlwZTogJ2RhdGEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBwYXJzZWREYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IEFycmF5LmlzQXJyYXkocGFyc2VkRGF0YSkgPyBwYXJzZWREYXRhLmxlbmd0aCA6IDFcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmF0Y2g7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBfY2FsbGVlMyk7XG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9wYXJzZUNodW5rSW5CYXRjaGVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBwYXJzZUNodW5rSW5CYXRjaGVzID0gZnVuY3Rpb24gX3BhcnNlQ2h1bmtJbkJhdGNoZXMyKCkge1xuICAgICAgICAgICAgICByZXR1cm4gX3BhcnNlQ2h1bmtJbkJhdGNoZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2dldERhdGEuZ2V0QXN5bmNJdGVyYWJsZUZyb21EYXRhKShkYXRhLCBvcHRpb25zKTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGlucHV0SXRlcmF0b3IgPSBfY29udGV4dDUuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNztcbiAgICAgICAgICAgIHJldHVybiBhcHBseUlucHV0VHJhbnNmb3JtcyhpbnB1dEl0ZXJhdG9yLCAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYW5zZm9ybXMpIHx8IFtdKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkSXRlcmF0b3IgPSBfY29udGV4dDUuc2VudDtcblxuICAgICAgICAgICAgaWYgKCFsb2FkZXIucGFyc2VJbkJhdGNoZXMpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIGxvYWRlci5wYXJzZUluQmF0Y2hlcyh0cmFuc2Zvcm1lZEl0ZXJhdG9yLCBvcHRpb25zLCBjb250ZXh0KSk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgcGFyc2VDaHVua0luQmF0Y2hlcygpKTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNCk7XG4gIH0pKTtcbiAgcmV0dXJuIF9wYXJzZVRvT3V0cHV0SXRlcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlJbnB1dFRyYW5zZm9ybXMoX3gxMCkge1xuICByZXR1cm4gX2FwcGx5SW5wdXRUcmFuc2Zvcm1zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9hcHBseUlucHV0VHJhbnNmb3JtcygpIHtcbiAgX2FwcGx5SW5wdXRUcmFuc2Zvcm1zID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KGlucHV0SXRlcmF0b3IpIHtcbiAgICB2YXIgdHJhbnNmb3JtcyxcbiAgICAgICAgaXRlcmF0b3JDaGFpbixcbiAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbixcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IsXG4gICAgICAgIF9pdGVyYXRvckVycm9yLFxuICAgICAgICBfaXRlcmF0b3IsXG4gICAgICAgIF9zdGVwLFxuICAgICAgICBfdmFsdWUsXG4gICAgICAgIHRyYW5zZm9ybUJhdGNoZXMsXG4gICAgICAgIF9hcmdzNiA9IGFyZ3VtZW50cztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDYpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHRyYW5zZm9ybXMgPSBfYXJnczYubGVuZ3RoID4gMSAmJiBfYXJnczZbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzNlsxXSA6IFtdO1xuICAgICAgICAgICAgaXRlcmF0b3JDaGFpbiA9IGlucHV0SXRlcmF0b3I7XG4gICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICBfY29udGV4dDYucHJldiA9IDQ7XG4gICAgICAgICAgICBfaXRlcmF0b3IgPSAoMCwgX2FzeW5jSXRlcmF0b3IyLmRlZmF1bHQpKHRyYW5zZm9ybXMpO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA4O1xuICAgICAgICAgICAgcmV0dXJuIF9pdGVyYXRvci5uZXh0KCk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBfc3RlcCA9IF9jb250ZXh0Ni5zZW50O1xuICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IF9zdGVwLmRvbmU7XG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDEyO1xuICAgICAgICAgICAgcmV0dXJuIF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIF92YWx1ZSA9IF9jb250ZXh0Ni5zZW50O1xuXG4gICAgICAgICAgICBpZiAoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbikge1xuICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDE5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJhbnNmb3JtQmF0Y2hlcyA9IF92YWx1ZTtcbiAgICAgICAgICAgIGl0ZXJhdG9yQ2hhaW4gPSB0cmFuc2Zvcm1CYXRjaGVzKGl0ZXJhdG9yQ2hhaW4pO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA2O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAyNTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgIF9jb250ZXh0Ni5wcmV2ID0gMjE7XG4gICAgICAgICAgICBfY29udGV4dDYudDAgPSBfY29udGV4dDZbXCJjYXRjaFwiXSg0KTtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gX2NvbnRleHQ2LnQwO1xuXG4gICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgIF9jb250ZXh0Ni5wcmV2ID0gMjU7XG4gICAgICAgICAgICBfY29udGV4dDYucHJldiA9IDI2O1xuXG4gICAgICAgICAgICBpZiAoISghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMzA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDMwO1xuICAgICAgICAgICAgcmV0dXJuIF9pdGVyYXRvci5yZXR1cm4oKTtcblxuICAgICAgICAgIGNhc2UgMzA6XG4gICAgICAgICAgICBfY29udGV4dDYucHJldiA9IDMwO1xuXG4gICAgICAgICAgICBpZiAoIV9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMzM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcblxuICAgICAgICAgIGNhc2UgMzM6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmZpbmlzaCgzMCk7XG5cbiAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5maW5pc2goMjUpO1xuXG4gICAgICAgICAgY2FzZSAzNTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIGl0ZXJhdG9yQ2hhaW4pO1xuXG4gICAgICAgICAgY2FzZSAzNjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU1LCBudWxsLCBbWzQsIDIxLCAyNSwgMzVdLCBbMjYsLCAzMCwgMzRdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9hcHBseUlucHV0VHJhbnNmb3Jtcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2UtaW4tYmF0Y2hlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnBhcnNlU3luYyA9IHBhcnNlU3luYztcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG52YXIgX2xvYWRlclV0aWxzID0gcmVxdWlyZShcIkBsb2FkZXJzLmdsL2xvYWRlci11dGlsc1wiKTtcblxudmFyIF9zZWxlY3RMb2FkZXIgPSByZXF1aXJlKFwiLi9zZWxlY3QtbG9hZGVyXCIpO1xuXG52YXIgX25vcm1hbGl6ZUxvYWRlciA9IHJlcXVpcmUoXCIuLi9sb2FkZXItdXRpbHMvbm9ybWFsaXplLWxvYWRlclwiKTtcblxudmFyIF9vcHRpb25VdGlscyA9IHJlcXVpcmUoXCIuLi9sb2FkZXItdXRpbHMvb3B0aW9uLXV0aWxzXCIpO1xuXG52YXIgX2dldERhdGEgPSByZXF1aXJlKFwiLi4vbG9hZGVyLXV0aWxzL2dldC1kYXRhXCIpO1xuXG52YXIgX2xvYWRlckNvbnRleHQgPSByZXF1aXJlKFwiLi4vbG9hZGVyLXV0aWxzL2xvYWRlci1jb250ZXh0XCIpO1xuXG52YXIgX3Jlc291cmNlVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMvcmVzb3VyY2UtdXRpbHNcIik7XG5cbmZ1bmN0aW9uIHBhcnNlU3luYyhkYXRhLCBsb2FkZXJzLCBvcHRpb25zLCBjb250ZXh0KSB7XG4gICgwLCBfbG9hZGVyVXRpbHMuYXNzZXJ0KSghY29udGV4dCB8fCAoMCwgX3R5cGVvZjIuZGVmYXVsdCkoY29udGV4dCkgPT09ICdvYmplY3QnKTtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkobG9hZGVycykgJiYgISgwLCBfbm9ybWFsaXplTG9hZGVyLmlzTG9hZGVyT2JqZWN0KShsb2FkZXJzKSkge1xuICAgIGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgb3B0aW9ucyA9IGxvYWRlcnM7XG4gICAgbG9hZGVycyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZWRMb2FkZXJzID0gbG9hZGVycztcbiAgdmFyIGNhbmRpZGF0ZUxvYWRlcnMgPSAoMCwgX2xvYWRlckNvbnRleHQuZ2V0TG9hZGVyc0Zyb21Db250ZXh0KSh0eXBlZExvYWRlcnMsIGNvbnRleHQpO1xuICB2YXIgbG9hZGVyID0gKDAsIF9zZWxlY3RMb2FkZXIuc2VsZWN0TG9hZGVyU3luYykoZGF0YSwgY2FuZGlkYXRlTG9hZGVycywgb3B0aW9ucyk7XG5cbiAgaWYgKCFsb2FkZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG9wdGlvbnMgPSAoMCwgX29wdGlvblV0aWxzLm5vcm1hbGl6ZU9wdGlvbnMpKG9wdGlvbnMsIGxvYWRlciwgY2FuZGlkYXRlTG9hZGVycyk7XG5cbiAgdmFyIF9nZXRSZXNvdXJjZVVybEFuZFR5cCA9ICgwLCBfcmVzb3VyY2VVdGlscy5nZXRSZXNvdXJjZVVybEFuZFR5cGUpKGRhdGEpLFxuICAgICAgdXJsID0gX2dldFJlc291cmNlVXJsQW5kVHlwLnVybDtcblxuICB2YXIgcGFyc2UgPSBmdW5jdGlvbiBwYXJzZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnNlU3luYyBjYWxsZWQgcGFyc2UnKTtcbiAgfTtcblxuICBjb250ZXh0ID0gKDAsIF9sb2FkZXJDb250ZXh0LmdldExvYWRlckNvbnRleHQpKHtcbiAgICB1cmw6IHVybCxcbiAgICBwYXJzZVN5bmM6IHBhcnNlU3luYyxcbiAgICBwYXJzZTogcGFyc2UsXG4gICAgbG9hZGVyczogbG9hZGVyc1xuICB9LCBvcHRpb25zKTtcbiAgcmV0dXJuIHBhcnNlV2l0aExvYWRlclN5bmMobG9hZGVyLCBkYXRhLCBvcHRpb25zLCBjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VXaXRoTG9hZGVyU3luYyhsb2FkZXIsIGRhdGEsIG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgZGF0YSA9ICgwLCBfZ2V0RGF0YS5nZXRBcnJheUJ1ZmZlck9yU3RyaW5nRnJvbURhdGFTeW5jKShkYXRhLCBsb2FkZXIsIG9wdGlvbnMpO1xuXG4gIGlmIChsb2FkZXIucGFyc2VUZXh0U3luYyAmJiB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbG9hZGVyLnBhcnNlVGV4dFN5bmMoZGF0YSwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAobG9hZGVyLnBhcnNlU3luYyAmJiBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gbG9hZGVyLnBhcnNlU3luYyhkYXRhLCBvcHRpb25zLCBjb250ZXh0KTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcIlwiLmNvbmNhdChsb2FkZXIubmFtZSwgXCIgbG9hZGVyOiAncGFyc2VTeW5jJyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgbG9hZGVyLCB1c2UgJ3BhcnNlJyBpbnN0ZWFkLiBcIikuY29uY2F0KGNvbnRleHQudXJsIHx8ICcnKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZS1zeW5jLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF93b3JrZXJVdGlscyA9IHJlcXVpcmUoXCJAbG9hZGVycy5nbC93b3JrZXItdXRpbHNcIik7XG5cbnZhciBfbG9hZGVyVXRpbHMgPSByZXF1aXJlKFwiQGxvYWRlcnMuZ2wvbG9hZGVyLXV0aWxzXCIpO1xuXG52YXIgX25vcm1hbGl6ZUxvYWRlciA9IHJlcXVpcmUoXCIuLi9sb2FkZXItdXRpbHMvbm9ybWFsaXplLWxvYWRlclwiKTtcblxudmFyIF9vcHRpb25VdGlscyA9IHJlcXVpcmUoXCIuLi9sb2FkZXItdXRpbHMvb3B0aW9uLXV0aWxzXCIpO1xuXG52YXIgX2dldERhdGEgPSByZXF1aXJlKFwiLi4vbG9hZGVyLXV0aWxzL2dldC1kYXRhXCIpO1xuXG52YXIgX2xvYWRlckNvbnRleHQgPSByZXF1aXJlKFwiLi4vbG9hZGVyLXV0aWxzL2xvYWRlci1jb250ZXh0XCIpO1xuXG52YXIgX3Jlc291cmNlVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMvcmVzb3VyY2UtdXRpbHNcIik7XG5cbnZhciBfc2VsZWN0TG9hZGVyID0gcmVxdWlyZShcIi4vc2VsZWN0LWxvYWRlclwiKTtcblxuZnVuY3Rpb24gcGFyc2UoX3gsIF94MiwgX3gzLCBfeDQpIHtcbiAgcmV0dXJuIF9wYXJzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfcGFyc2UoKSB7XG4gIF9wYXJzZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKGRhdGEsIGxvYWRlcnMsIG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgICB2YXIgX2dldFJlc291cmNlVXJsQW5kVHlwLCB1cmwsIHR5cGVkTG9hZGVycywgY2FuZGlkYXRlTG9hZGVycywgbG9hZGVyO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAoMCwgX3dvcmtlclV0aWxzLmFzc2VydCkoIWNvbnRleHQgfHwgKDAsIF90eXBlb2YyLmRlZmF1bHQpKGNvbnRleHQpID09PSAnb2JqZWN0Jyk7XG5cbiAgICAgICAgICAgIGlmIChsb2FkZXJzICYmICFBcnJheS5pc0FycmF5KGxvYWRlcnMpICYmICEoMCwgX25vcm1hbGl6ZUxvYWRlci5pc0xvYWRlck9iamVjdCkobG9hZGVycykpIHtcbiAgICAgICAgICAgICAgY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgb3B0aW9ucyA9IGxvYWRlcnM7XG4gICAgICAgICAgICAgIGxvYWRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBkYXRhID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgX2dldFJlc291cmNlVXJsQW5kVHlwID0gKDAsIF9yZXNvdXJjZVV0aWxzLmdldFJlc291cmNlVXJsQW5kVHlwZSkoZGF0YSksIHVybCA9IF9nZXRSZXNvdXJjZVVybEFuZFR5cC51cmw7XG4gICAgICAgICAgICB0eXBlZExvYWRlcnMgPSBsb2FkZXJzO1xuICAgICAgICAgICAgY2FuZGlkYXRlTG9hZGVycyA9ICgwLCBfbG9hZGVyQ29udGV4dC5nZXRMb2FkZXJzRnJvbUNvbnRleHQpKHR5cGVkTG9hZGVycywgY29udGV4dCk7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9zZWxlY3RMb2FkZXIuc2VsZWN0TG9hZGVyKShkYXRhLCBjYW5kaWRhdGVMb2FkZXJzLCBvcHRpb25zKTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBsb2FkZXIgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbnVsbCk7XG5cbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgb3B0aW9ucyA9ICgwLCBfb3B0aW9uVXRpbHMubm9ybWFsaXplT3B0aW9ucykob3B0aW9ucywgbG9hZGVyLCBjYW5kaWRhdGVMb2FkZXJzLCB1cmwpO1xuICAgICAgICAgICAgY29udGV4dCA9ICgwLCBfbG9hZGVyQ29udGV4dC5nZXRMb2FkZXJDb250ZXh0KSh7XG4gICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICBwYXJzZTogcGFyc2UsXG4gICAgICAgICAgICAgIGxvYWRlcnM6IGNhbmRpZGF0ZUxvYWRlcnNcbiAgICAgICAgICAgIH0sIG9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE4O1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlV2l0aExvYWRlcihsb2FkZXIsIGRhdGEsIG9wdGlvbnMsIGNvbnRleHQpO1xuXG4gICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlKTtcbiAgfSkpO1xuICByZXR1cm4gX3BhcnNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2l0aExvYWRlcihfeDUsIF94NiwgX3g3LCBfeDgpIHtcbiAgcmV0dXJuIF9wYXJzZVdpdGhMb2FkZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3BhcnNlV2l0aExvYWRlcigpIHtcbiAgX3BhcnNlV2l0aExvYWRlciA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMihsb2FkZXIsIGRhdGEsIG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAoMCwgX3dvcmtlclV0aWxzLnZhbGlkYXRlV29ya2VyVmVyc2lvbikobG9hZGVyKTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2dldERhdGEuZ2V0QXJyYXlCdWZmZXJPclN0cmluZ0Zyb21EYXRhKShkYXRhLCBsb2FkZXIsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgZGF0YSA9IF9jb250ZXh0Mi5zZW50O1xuXG4gICAgICAgICAgICBpZiAoIShsb2FkZXIucGFyc2VUZXh0U3luYyAmJiB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YVR5cGUgPSAndGV4dCc7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBsb2FkZXIucGFyc2VUZXh0U3luYyhkYXRhLCBvcHRpb25zLCBjb250ZXh0LCBsb2FkZXIpKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGlmICghKDAsIF9sb2FkZXJVdGlscy5jYW5QYXJzZVdpdGhXb3JrZXIpKGxvYWRlciwgb3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTA7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9sb2FkZXJVdGlscy5wYXJzZVdpdGhXb3JrZXIpKGxvYWRlciwgZGF0YSwgb3B0aW9ucywgY29udGV4dCwgcGFyc2UpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0Mi5zZW50KTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBpZiAoIShsb2FkZXIucGFyc2VUZXh0ICYmIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTQ7XG4gICAgICAgICAgICByZXR1cm4gbG9hZGVyLnBhcnNlVGV4dChkYXRhLCBvcHRpb25zLCBjb250ZXh0LCBsb2FkZXIpO1xuXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0Mi5zZW50KTtcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICBpZiAoIWxvYWRlci5wYXJzZSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxODtcbiAgICAgICAgICAgIHJldHVybiBsb2FkZXIucGFyc2UoZGF0YSwgb3B0aW9ucywgY29udGV4dCwgbG9hZGVyKTtcblxuICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDIuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgKDAsIF93b3JrZXJVdGlscy5hc3NlcnQpKCFsb2FkZXIucGFyc2VTeW5jKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiLmNvbmNhdChsb2FkZXIuaWQsIFwiIGxvYWRlciAtIG5vIHBhcnNlciBmb3VuZCBhbmQgd29ya2VyIGlzIGRpc2FibGVkXCIpKTtcblxuICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMik7XG4gIH0pKTtcbiAgcmV0dXJuIF9wYXJzZVdpdGhMb2FkZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5yZWdpc3RlckxvYWRlcnMgPSByZWdpc3RlckxvYWRlcnM7XG5leHBvcnRzLmdldFJlZ2lzdGVyZWRMb2FkZXJzID0gZ2V0UmVnaXN0ZXJlZExvYWRlcnM7XG5leHBvcnRzLl91bnJlZ2lzdGVyTG9hZGVycyA9IF91bnJlZ2lzdGVyTG9hZGVycztcblxudmFyIF9ub3JtYWxpemVMb2FkZXIgPSByZXF1aXJlKFwiLi4vbG9hZGVyLXV0aWxzL25vcm1hbGl6ZS1sb2FkZXJcIik7XG5cbnZhciBfb3B0aW9uVXRpbHMgPSByZXF1aXJlKFwiLi4vbG9hZGVyLXV0aWxzL29wdGlvbi11dGlsc1wiKTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG52YXIgZ2V0R2xvYmFsTG9hZGVyUmVnaXN0cnkgPSBmdW5jdGlvbiBnZXRHbG9iYWxMb2FkZXJSZWdpc3RyeSgpIHtcbiAgdmFyIHN0YXRlID0gKDAsIF9vcHRpb25VdGlscy5nZXRHbG9iYWxMb2FkZXJTdGF0ZSkoKTtcbiAgc3RhdGUubG9hZGVyUmVnaXN0cnkgPSBzdGF0ZS5sb2FkZXJSZWdpc3RyeSB8fCBbXTtcbiAgcmV0dXJuIHN0YXRlLmxvYWRlclJlZ2lzdHJ5O1xufTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJMb2FkZXJzKGxvYWRlcnMpIHtcbiAgdmFyIGxvYWRlclJlZ2lzdHJ5ID0gZ2V0R2xvYmFsTG9hZGVyUmVnaXN0cnkoKTtcbiAgbG9hZGVycyA9IEFycmF5LmlzQXJyYXkobG9hZGVycykgPyBsb2FkZXJzIDogW2xvYWRlcnNdO1xuXG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihsb2FkZXJzKSxcbiAgICAgIF9zdGVwO1xuXG4gIHRyeSB7XG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICB2YXIgbG9hZGVyID0gX3N0ZXAudmFsdWU7XG4gICAgICB2YXIgbm9ybWFsaXplZExvYWRlciA9ICgwLCBfbm9ybWFsaXplTG9hZGVyLm5vcm1hbGl6ZUxvYWRlcikobG9hZGVyKTtcblxuICAgICAgaWYgKCFsb2FkZXJSZWdpc3RyeS5maW5kKGZ1bmN0aW9uIChyZWdpc3RlcmVkTG9hZGVyKSB7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVkTG9hZGVyID09PSByZWdpc3RlcmVkTG9hZGVyO1xuICAgICAgfSkpIHtcbiAgICAgICAgbG9hZGVyUmVnaXN0cnkudW5zaGlmdChub3JtYWxpemVkTG9hZGVyKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIF9sb29wKCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvci5mKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmVnaXN0ZXJlZExvYWRlcnMoKSB7XG4gIHJldHVybiBnZXRHbG9iYWxMb2FkZXJSZWdpc3RyeSgpO1xufVxuXG5mdW5jdGlvbiBfdW5yZWdpc3RlckxvYWRlcnMoKSB7XG4gIHZhciBzdGF0ZSA9ICgwLCBfb3B0aW9uVXRpbHMuZ2V0R2xvYmFsTG9hZGVyU3RhdGUpKCk7XG4gIHN0YXRlLmxvYWRlclJlZ2lzdHJ5ID0gW107XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWdpc3Rlci1sb2FkZXJzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLnNhdmVTeW5jID0gc2F2ZVN5bmM7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2VuY29kZSA9IHJlcXVpcmUoXCIuL2VuY29kZVwiKTtcblxudmFyIF93cml0ZUZpbGUgPSByZXF1aXJlKFwiLi4vZmV0Y2gvd3JpdGUtZmlsZVwiKTtcblxuZnVuY3Rpb24gc2F2ZShfeCwgX3gyLCBfeDMsIF94NCkge1xuICByZXR1cm4gX3NhdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3NhdmUoKSB7XG4gIF9zYXZlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoZGF0YSwgdXJsLCB3cml0ZXIsIG9wdGlvbnMpIHtcbiAgICB2YXIgZW5jb2RlZERhdGE7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2VuY29kZS5lbmNvZGUpKGRhdGEsIHdyaXRlciwgb3B0aW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBlbmNvZGVkRGF0YSA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX3dyaXRlRmlsZS53cml0ZUZpbGUpKHVybCwgZW5jb2RlZERhdGEpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dC5zZW50KTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9zYXZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHNhdmVTeW5jKGRhdGEsIHVybCwgd3JpdGVyLCBvcHRpb25zKSB7XG4gIHZhciBlbmNvZGVkRGF0YSA9ICgwLCBfZW5jb2RlLmVuY29kZVN5bmMpKGRhdGEsIHdyaXRlciwgb3B0aW9ucyk7XG4gIHJldHVybiAoMCwgX3dyaXRlRmlsZS53cml0ZUZpbGVTeW5jKSh1cmwsIGVuY29kZWREYXRhKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNhdmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5zZWxlY3RMb2FkZXIgPSBzZWxlY3RMb2FkZXI7XG5leHBvcnRzLnNlbGVjdExvYWRlclN5bmMgPSBzZWxlY3RMb2FkZXJTeW5jO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX3R5cGVvZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKSk7XG5cbnZhciBfdG9Db25zdW1hYmxlQXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheVwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2xvYWRlclV0aWxzID0gcmVxdWlyZShcIkBsb2FkZXJzLmdsL2xvYWRlci11dGlsc1wiKTtcblxudmFyIF9ub3JtYWxpemVMb2FkZXIgPSByZXF1aXJlKFwiLi4vbG9hZGVyLXV0aWxzL25vcm1hbGl6ZS1sb2FkZXJcIik7XG5cbnZhciBfcmVzb3VyY2VVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy9yZXNvdXJjZS11dGlsc1wiKTtcblxudmFyIF9yZWdpc3RlckxvYWRlcnMgPSByZXF1aXJlKFwiLi9yZWdpc3Rlci1sb2FkZXJzXCIpO1xuXG52YXIgX2lzVHlwZSA9IHJlcXVpcmUoXCIuLi8uLi9qYXZhc2NyaXB0LXV0aWxzL2lzLXR5cGVcIik7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbnZhciBFWFRfUEFUVEVSTiA9IC9cXC4oW14uXSspJC87XG5cbmZ1bmN0aW9uIHNlbGVjdExvYWRlcihfeCkge1xuICByZXR1cm4gX3NlbGVjdExvYWRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfc2VsZWN0TG9hZGVyKCkge1xuICBfc2VsZWN0TG9hZGVyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoZGF0YSkge1xuICAgIHZhciBsb2FkZXJzLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBsb2FkZXIsXG4gICAgICAgIF9hcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgbG9hZGVycyA9IF9hcmdzLmxlbmd0aCA+IDEgJiYgX2FyZ3NbMV0gIT09IHVuZGVmaW5lZCA/IF9hcmdzWzFdIDogW107XG4gICAgICAgICAgICBvcHRpb25zID0gX2FyZ3MubGVuZ3RoID4gMiA/IF9hcmdzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29udGV4dCA9IF9hcmdzLmxlbmd0aCA+IDMgPyBfYXJnc1szXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgaWYgKHZhbGlkSFRUUFJlc3BvbnNlKGRhdGEpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA1O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBudWxsKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGxvYWRlciA9IHNlbGVjdExvYWRlclN5bmMoZGF0YSwgbG9hZGVycywgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgICAgICAgbm90aHJvdzogdHJ1ZVxuICAgICAgICAgICAgfSksIGNvbnRleHQpO1xuXG4gICAgICAgICAgICBpZiAoIWxvYWRlcikge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbG9hZGVyKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIGlmICghKDAsIF9pc1R5cGUuaXNCbG9iKShkYXRhKSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5zbGljZSgwLCAxMCkuYXJyYXlCdWZmZXIoKTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBkYXRhID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIGxvYWRlciA9IHNlbGVjdExvYWRlclN5bmMoZGF0YSwgbG9hZGVycywgb3B0aW9ucywgY29udGV4dCk7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgaWYgKCEoIWxvYWRlciAmJiAhKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwICYmIG9wdGlvbnMubm90aHJvdykpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihnZXROb1ZhbGlkTG9hZGVyTWVzc2FnZShkYXRhKSk7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBsb2FkZXIpO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9zZWxlY3RMb2FkZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0TG9hZGVyU3luYyhkYXRhKSB7XG4gIHZhciBsb2FkZXJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyA/IGFyZ3VtZW50c1szXSA6IHVuZGVmaW5lZDtcblxuICBpZiAoIXZhbGlkSFRUUFJlc3BvbnNlKGRhdGEpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAobG9hZGVycyAmJiAhQXJyYXkuaXNBcnJheShsb2FkZXJzKSkge1xuICAgIHJldHVybiAoMCwgX25vcm1hbGl6ZUxvYWRlci5ub3JtYWxpemVMb2FkZXIpKGxvYWRlcnMpO1xuICB9XG5cbiAgdmFyIGNhbmRpZGF0ZUxvYWRlcnMgPSBbXTtcblxuICBpZiAobG9hZGVycykge1xuICAgIGNhbmRpZGF0ZUxvYWRlcnMgPSBjYW5kaWRhdGVMb2FkZXJzLmNvbmNhdChsb2FkZXJzKTtcbiAgfVxuXG4gIGlmICghKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwICYmIG9wdGlvbnMuaWdub3JlUmVnaXN0ZXJlZExvYWRlcnMpKSB7XG4gICAgdmFyIF9jYW5kaWRhdGVMb2FkZXJzO1xuXG4gICAgKF9jYW5kaWRhdGVMb2FkZXJzID0gY2FuZGlkYXRlTG9hZGVycykucHVzaC5hcHBseShfY2FuZGlkYXRlTG9hZGVycywgKDAsIF90b0NvbnN1bWFibGVBcnJheTIuZGVmYXVsdCkoKDAsIF9yZWdpc3RlckxvYWRlcnMuZ2V0UmVnaXN0ZXJlZExvYWRlcnMpKCkpKTtcbiAgfVxuXG4gIG5vcm1hbGl6ZUxvYWRlcnMoY2FuZGlkYXRlTG9hZGVycyk7XG4gIHZhciBsb2FkZXIgPSBzZWxlY3RMb2FkZXJJbnRlcm5hbChkYXRhLCBjYW5kaWRhdGVMb2FkZXJzLCBvcHRpb25zLCBjb250ZXh0KTtcblxuICBpZiAoIWxvYWRlciAmJiAhKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwICYmIG9wdGlvbnMubm90aHJvdykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0Tm9WYWxpZExvYWRlck1lc3NhZ2UoZGF0YSkpO1xuICB9XG5cbiAgcmV0dXJuIGxvYWRlcjtcbn1cblxuZnVuY3Rpb24gc2VsZWN0TG9hZGVySW50ZXJuYWwoZGF0YSwgbG9hZGVycywgb3B0aW9ucywgY29udGV4dCkge1xuICB2YXIgX2dldFJlc291cmNlVXJsQW5kVHlwID0gKDAsIF9yZXNvdXJjZVV0aWxzLmdldFJlc291cmNlVXJsQW5kVHlwZSkoZGF0YSksXG4gICAgICB1cmwgPSBfZ2V0UmVzb3VyY2VVcmxBbmRUeXAudXJsLFxuICAgICAgdHlwZSA9IF9nZXRSZXNvdXJjZVVybEFuZFR5cC50eXBlO1xuXG4gIHZhciB0ZXN0VXJsID0gdXJsIHx8IChjb250ZXh0ID09PSBudWxsIHx8IGNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRleHQudXJsKTtcbiAgdmFyIGxvYWRlciA9IG51bGw7XG5cbiAgaWYgKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwICYmIG9wdGlvbnMubWltZVR5cGUpIHtcbiAgICBsb2FkZXIgPSBmaW5kTG9hZGVyQnlNSU1FVHlwZShsb2FkZXJzLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWltZVR5cGUpO1xuICB9XG5cbiAgbG9hZGVyID0gbG9hZGVyIHx8IGZpbmRMb2FkZXJCeVVybChsb2FkZXJzLCB0ZXN0VXJsKTtcbiAgbG9hZGVyID0gbG9hZGVyIHx8IGZpbmRMb2FkZXJCeU1JTUVUeXBlKGxvYWRlcnMsIHR5cGUpO1xuICBsb2FkZXIgPSBsb2FkZXIgfHwgZmluZExvYWRlckJ5SW5pdGlhbEJ5dGVzKGxvYWRlcnMsIGRhdGEpO1xuICBsb2FkZXIgPSBsb2FkZXIgfHwgZmluZExvYWRlckJ5TUlNRVR5cGUobG9hZGVycywgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZhbGxiYWNrTWltZVR5cGUpO1xuICByZXR1cm4gbG9hZGVyO1xufVxuXG5mdW5jdGlvbiB2YWxpZEhUVFBSZXNwb25zZShkYXRhKSB7XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICBpZiAoZGF0YS5zdGF0dXMgPT09IDIwNCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXROb1ZhbGlkTG9hZGVyTWVzc2FnZShkYXRhKSB7XG4gIHZhciBfZ2V0UmVzb3VyY2VVcmxBbmRUeXAyID0gKDAsIF9yZXNvdXJjZVV0aWxzLmdldFJlc291cmNlVXJsQW5kVHlwZSkoZGF0YSksXG4gICAgICB1cmwgPSBfZ2V0UmVzb3VyY2VVcmxBbmRUeXAyLnVybCxcbiAgICAgIHR5cGUgPSBfZ2V0UmVzb3VyY2VVcmxBbmRUeXAyLnR5cGU7XG5cbiAgdmFyIG1lc3NhZ2UgPSAnTm8gdmFsaWQgbG9hZGVyIGZvdW5kJztcblxuICBpZiAoZGF0YSkge1xuICAgIG1lc3NhZ2UgKz0gXCIgZGF0YTogXFxcIlwiLmNvbmNhdChnZXRGaXJzdENoYXJhY3RlcnMoZGF0YSksIFwiXFxcIiwgY29udGVudFR5cGU6IFxcXCJcIikuY29uY2F0KHR5cGUsIFwiXFxcIlwiKTtcbiAgfVxuXG4gIGlmICh1cmwpIHtcbiAgICBtZXNzYWdlICs9IFwiIHVybDogXCIuY29uY2F0KHVybCk7XG4gIH1cblxuICByZXR1cm4gbWVzc2FnZTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplTG9hZGVycyhsb2FkZXJzKSB7XG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihsb2FkZXJzKSxcbiAgICAgIF9zdGVwO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBsb2FkZXIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICgwLCBfbm9ybWFsaXplTG9hZGVyLm5vcm1hbGl6ZUxvYWRlcikobG9hZGVyKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kTG9hZGVyQnlVcmwobG9hZGVycywgdXJsKSB7XG4gIHZhciBtYXRjaCA9IHVybCAmJiBFWFRfUEFUVEVSTi5leGVjKHVybCk7XG4gIHZhciBleHRlbnNpb24gPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgcmV0dXJuIGV4dGVuc2lvbiA/IGZpbmRMb2FkZXJCeUV4dGVuc2lvbihsb2FkZXJzLCBleHRlbnNpb24pIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZmluZExvYWRlckJ5RXh0ZW5zaW9uKGxvYWRlcnMsIGV4dGVuc2lvbikge1xuICBleHRlbnNpb24gPSBleHRlbnNpb24udG9Mb3dlckNhc2UoKTtcblxuICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGxvYWRlcnMpLFxuICAgICAgX3N0ZXAyO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBsb2FkZXIgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobG9hZGVyLmV4dGVuc2lvbnMpLFxuICAgICAgICAgIF9zdGVwMztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgbG9hZGVyRXh0ZW5zaW9uID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICAgICAgaWYgKGxvYWRlckV4dGVuc2lvbi50b0xvd2VyQ2FzZSgpID09PSBleHRlbnNpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBsb2FkZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IzLmYoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjIuZigpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGZpbmRMb2FkZXJCeU1JTUVUeXBlKGxvYWRlcnMsIG1pbWVUeXBlKSB7XG4gIHZhciBfaXRlcmF0b3I0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobG9hZGVycyksXG4gICAgICBfc3RlcDQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykge1xuICAgICAgdmFyIGxvYWRlciA9IF9zdGVwNC52YWx1ZTtcblxuICAgICAgaWYgKGxvYWRlci5taW1lVHlwZXMgJiYgbG9hZGVyLm1pbWVUeXBlcy5pbmNsdWRlcyhtaW1lVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGxvYWRlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1pbWVUeXBlID09PSBcImFwcGxpY2F0aW9uL3guXCIuY29uY2F0KGxvYWRlci5pZCkpIHtcbiAgICAgICAgcmV0dXJuIGxvYWRlcjtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjQuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjQuZigpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGZpbmRMb2FkZXJCeUluaXRpYWxCeXRlcyhsb2FkZXJzLCBkYXRhKSB7XG4gIGlmICghZGF0YSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIF9pdGVyYXRvcjUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihsb2FkZXJzKSxcbiAgICAgIF9zdGVwNTtcblxuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yNS5zKCk7ICEoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgbG9hZGVyID0gX3N0ZXA1LnZhbHVlO1xuXG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0ZXN0RGF0YUFnYWluc3RUZXh0KGRhdGEsIGxvYWRlcikpIHtcbiAgICAgICAgICByZXR1cm4gbG9hZGVyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgICAgICBpZiAodGVzdERhdGFBZ2FpbnN0QmluYXJ5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGxvYWRlcikpIHtcbiAgICAgICAgICByZXR1cm4gbG9hZGVyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICB2YXIgYnl0ZU9mZnNldCA9IDA7XG5cbiAgICAgICAgaWYgKHRlc3REYXRhQWdhaW5zdEJpbmFyeShkYXRhLCBieXRlT2Zmc2V0LCBsb2FkZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIGxvYWRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yNS5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yNS5mKCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gdGVzdERhdGFBZ2FpbnN0VGV4dChkYXRhLCBsb2FkZXIpIHtcbiAgaWYgKGxvYWRlci50ZXN0VGV4dCkge1xuICAgIHJldHVybiBsb2FkZXIudGVzdFRleHQoZGF0YSk7XG4gIH1cblxuICB2YXIgdGVzdHMgPSBBcnJheS5pc0FycmF5KGxvYWRlci50ZXN0cykgPyBsb2FkZXIudGVzdHMgOiBbbG9hZGVyLnRlc3RzXTtcbiAgcmV0dXJuIHRlc3RzLnNvbWUoZnVuY3Rpb24gKHRlc3QpIHtcbiAgICByZXR1cm4gZGF0YS5zdGFydHNXaXRoKHRlc3QpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdGVzdERhdGFBZ2FpbnN0QmluYXJ5KGRhdGEsIGJ5dGVPZmZzZXQsIGxvYWRlcikge1xuICB2YXIgdGVzdHMgPSBBcnJheS5pc0FycmF5KGxvYWRlci50ZXN0cykgPyBsb2FkZXIudGVzdHMgOiBbbG9hZGVyLnRlc3RzXTtcbiAgcmV0dXJuIHRlc3RzLnNvbWUoZnVuY3Rpb24gKHRlc3QpIHtcbiAgICByZXR1cm4gdGVzdEJpbmFyeShkYXRhLCBieXRlT2Zmc2V0LCBsb2FkZXIsIHRlc3QpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdGVzdEJpbmFyeShkYXRhLCBieXRlT2Zmc2V0LCBsb2FkZXIsIHRlc3QpIHtcbiAgaWYgKHRlc3QgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiAoMCwgX2xvYWRlclV0aWxzLmNvbXBhcmVBcnJheUJ1ZmZlcnMpKHRlc3QsIGRhdGEsIHRlc3QuYnl0ZUxlbmd0aCk7XG4gIH1cblxuICBzd2l0Y2ggKCgwLCBfdHlwZW9mMi5kZWZhdWx0KSh0ZXN0KSkge1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIHJldHVybiB0ZXN0KGRhdGEsIGxvYWRlcik7XG5cbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgdmFyIG1hZ2ljID0gZ2V0TWFnaWNTdHJpbmcoZGF0YSwgYnl0ZU9mZnNldCwgdGVzdC5sZW5ndGgpO1xuICAgICAgcmV0dXJuIHRlc3QgPT09IG1hZ2ljO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRGaXJzdENoYXJhY3RlcnMoZGF0YSkge1xuICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiA1O1xuXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGF0YS5zbGljZSgwLCBsZW5ndGgpO1xuICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgIHJldHVybiBnZXRNYWdpY1N0cmluZyhkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHZhciBieXRlT2Zmc2V0ID0gMDtcbiAgICByZXR1cm4gZ2V0TWFnaWNTdHJpbmcoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0TWFnaWNTdHJpbmcoYXJyYXlCdWZmZXIsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyBsZW5ndGgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpO1xuICB2YXIgbWFnaWMgPSAnJztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgbWFnaWMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhVmlldy5nZXRVaW50OChieXRlT2Zmc2V0ICsgaSkpO1xuICB9XG5cbiAgcmV0dXJuIG1hZ2ljO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VsZWN0LWxvYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc2V0TG9hZGVyT3B0aW9ucyA9IHNldExvYWRlck9wdGlvbnM7XG5cbnZhciBfb3B0aW9uVXRpbHMgPSByZXF1aXJlKFwiLi4vbG9hZGVyLXV0aWxzL29wdGlvbi11dGlsc1wiKTtcblxuZnVuY3Rpb24gc2V0TG9hZGVyT3B0aW9ucyhvcHRpb25zKSB7XG4gICgwLCBfb3B0aW9uVXRpbHMuc2V0R2xvYmFsT3B0aW9ucykob3B0aW9ucyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXQtbG9hZGVyLW9wdGlvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5mZXRjaEZpbGUgPSBmZXRjaEZpbGU7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2xvYWRlclV0aWxzID0gcmVxdWlyZShcIkBsb2FkZXJzLmdsL2xvYWRlci11dGlsc1wiKTtcblxudmFyIF9yZXNwb25zZVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzL3Jlc3BvbnNlLXV0aWxzXCIpO1xuXG5mdW5jdGlvbiBmZXRjaEZpbGUoX3gsIF94Mikge1xuICByZXR1cm4gX2ZldGNoRmlsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZmV0Y2hGaWxlKCkge1xuICBfZmV0Y2hGaWxlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUodXJsLCBvcHRpb25zKSB7XG4gICAgdmFyIGZldGNoT3B0aW9ucztcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghKHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVybCA9ICgwLCBfbG9hZGVyVXRpbHMucmVzb2x2ZVBhdGgpKHVybCk7XG4gICAgICAgICAgICBmZXRjaE9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgJiYgb3B0aW9ucy5mZXRjaCAmJiB0eXBlb2YgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mZXRjaCkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgZmV0Y2hPcHRpb25zID0gb3B0aW9ucy5mZXRjaDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2godXJsLCBmZXRjaE9wdGlvbnMpO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dC5zZW50KTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA5O1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfcmVzcG9uc2VVdGlscy5tYWtlUmVzcG9uc2UpKHVybCk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0LnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9mZXRjaEZpbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoLWZpbGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5yZWFkQXJyYXlCdWZmZXIgPSByZWFkQXJyYXlCdWZmZXI7XG5leHBvcnRzLnJlYWRCbG9iID0gcmVhZEJsb2I7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2xvYWRlclV0aWxzID0gcmVxdWlyZShcIkBsb2FkZXJzLmdsL2xvYWRlci11dGlsc1wiKTtcblxuZnVuY3Rpb24gcmVhZEFycmF5QnVmZmVyKF94LCBfeDIsIF94Mykge1xuICByZXR1cm4gX3JlYWRBcnJheUJ1ZmZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfcmVhZEFycmF5QnVmZmVyKCkge1xuICBfcmVhZEFycmF5QnVmZmVyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoZmlsZSwgc3RhcnQsIGxlbmd0aCkge1xuICAgIHZhciBzbGljZTtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghKHR5cGVvZiBmaWxlID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiBfbG9hZGVyVXRpbHMuZnMuX3JlYWRUb0FycmF5QnVmZmVyKGZpbGUsIHN0YXJ0LCBsZW5ndGgpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dC5zZW50KTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGlmICghKGZpbGUgaW5zdGFuY2VvZiBCbG9iKSkge1xuICAgICAgICAgICAgICBmaWxlID0gbmV3IEJsb2IoW2ZpbGVdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2xpY2UgPSBmaWxlLnNsaWNlKHN0YXJ0LCBzdGFydCArIGxlbmd0aCk7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gODtcbiAgICAgICAgICAgIHJldHVybiByZWFkQmxvYihzbGljZSk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0LnNlbnQpO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlKTtcbiAgfSkpO1xuICByZXR1cm4gX3JlYWRBcnJheUJ1ZmZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiByZWFkQmxvYihfeDQpIHtcbiAgcmV0dXJuIF9yZWFkQmxvYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfcmVhZEJsb2IoKSB7XG4gIF9yZWFkQmxvYiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMihibG9iKSB7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgdmFyIGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG4gICAgICAgICAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9ldmVudCR0YXJnZXQ7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShldmVudCA9PT0gbnVsbCB8fCBldmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9ldmVudCR0YXJnZXQgPSBldmVudC50YXJnZXQpID09PSBudWxsIHx8IF9ldmVudCR0YXJnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ldmVudCR0YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBmaWxlUmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBmaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDIuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMik7XG4gIH0pKTtcbiAgcmV0dXJuIF9yZWFkQmxvYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhZC1hcnJheS1idWZmZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnJlYWRGaWxlU3luYyA9IHJlYWRGaWxlU3luYztcblxudmFyIF9sb2FkZXJVdGlscyA9IHJlcXVpcmUoXCJAbG9hZGVycy5nbC9sb2FkZXItdXRpbHNcIik7XG5cbmZ1bmN0aW9uIHJlYWRGaWxlU3luYyh1cmwpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB1cmwgPSAoMCwgX2xvYWRlclV0aWxzLnJlc29sdmVQYXRoKSh1cmwpO1xuXG4gIGlmICghX2xvYWRlclV0aWxzLmlzQnJvd3Nlcikge1xuICAgIHZhciBidWZmZXIgPSBfbG9hZGVyVXRpbHMuZnMucmVhZEZpbGVTeW5jKHVybCwgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gdHlwZW9mIGJ1ZmZlciAhPT0gJ3N0cmluZycgPyAoMCwgX2xvYWRlclV0aWxzLnRvQXJyYXlCdWZmZXIpKGJ1ZmZlcikgOiBidWZmZXI7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMubm90aHJvdykge1xuICAgICgwLCBfbG9hZGVyVXRpbHMuYXNzZXJ0KShmYWxzZSk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWQtZmlsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLndyaXRlRmlsZSA9IHdyaXRlRmlsZTtcbmV4cG9ydHMud3JpdGVGaWxlU3luYyA9IHdyaXRlRmlsZVN5bmM7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2xvYWRlclV0aWxzID0gcmVxdWlyZShcIkBsb2FkZXJzLmdsL2xvYWRlci11dGlsc1wiKTtcblxuZnVuY3Rpb24gd3JpdGVGaWxlKF94LCBfeDIsIF94Mykge1xuICByZXR1cm4gX3dyaXRlRmlsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfd3JpdGVGaWxlKCkge1xuICBfd3JpdGVGaWxlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoZmlsZVBhdGgsIGFycmF5QnVmZmVyT3JTdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGZpbGVQYXRoID0gKDAsIF9sb2FkZXJVdGlscy5yZXNvbHZlUGF0aCkoZmlsZVBhdGgpO1xuXG4gICAgICAgICAgICBpZiAoX2xvYWRlclV0aWxzLmlzQnJvd3Nlcikge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgcmV0dXJuIF9sb2FkZXJVdGlscy5mcy53cml0ZUZpbGUoZmlsZVBhdGgsICgwLCBfbG9hZGVyVXRpbHMudG9CdWZmZXIpKGFycmF5QnVmZmVyT3JTdHJpbmcpLCB7XG4gICAgICAgICAgICAgIGZsYWc6ICd3J1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAoMCwgX2xvYWRlclV0aWxzLmFzc2VydCkoZmFsc2UpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlKTtcbiAgfSkpO1xuICByZXR1cm4gX3dyaXRlRmlsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiB3cml0ZUZpbGVTeW5jKGZpbGVQYXRoLCBhcnJheUJ1ZmZlck9yU3RyaW5nLCBvcHRpb25zKSB7XG4gIGZpbGVQYXRoID0gKDAsIF9sb2FkZXJVdGlscy5yZXNvbHZlUGF0aCkoZmlsZVBhdGgpO1xuXG4gIGlmICghX2xvYWRlclV0aWxzLmlzQnJvd3Nlcikge1xuICAgIF9sb2FkZXJVdGlscy5mcy53cml0ZUZpbGVTeW5jKGZpbGVQYXRoLCAoMCwgX2xvYWRlclV0aWxzLnRvQnVmZmVyKShhcnJheUJ1ZmZlck9yU3RyaW5nKSwge1xuICAgICAgZmxhZzogJ3cnXG4gICAgfSk7XG4gIH1cblxuICAoMCwgX2xvYWRlclV0aWxzLmFzc2VydCkoZmFsc2UpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d3JpdGUtZmlsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgQnJvd3NlckZpbGVTeXN0ZW0gPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJyb3dzZXJGaWxlU3lzdGVtKGZpbGVzLCBvcHRpb25zKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgQnJvd3NlckZpbGVTeXN0ZW0pO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiX2ZldGNoXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJmaWxlc1wiLCB7fSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJsb3dlckNhc2VGaWxlc1wiLCB7fSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJ1c2VkRmlsZXNcIiwge30pO1xuICAgIHRoaXMuX2ZldGNoID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mZXRjaCkgfHwgZmV0Y2g7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZmlsZSA9IGZpbGVzW2ldO1xuICAgICAgdGhpcy5maWxlc1tmaWxlLm5hbWVdID0gZmlsZTtcbiAgICAgIHRoaXMubG93ZXJDYXNlRmlsZXNbZmlsZS5uYW1lLnRvTG93ZXJDYXNlKCldID0gZmlsZTtcbiAgICAgIHRoaXMudXNlZEZpbGVzW2ZpbGUubmFtZV0gPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmZldGNoID0gdGhpcy5mZXRjaC5iaW5kKHRoaXMpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoQnJvd3NlckZpbGVTeXN0ZW0sIFt7XG4gICAga2V5OiBcImZldGNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZmV0Y2ggPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZShwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBmaWxlLCBoZWFkZXJzLCByYW5nZSwgYnl0ZXMsIHN0YXJ0LCBlbmQsIGRhdGEsIF9yZXNwb25zZSwgcmVzcG9uc2U7XG5cbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgaWYgKCFwYXRoLmluY2x1ZGVzKCc6Ly8nKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMuX2ZldGNoKHBhdGgsIG9wdGlvbnMpKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgZmlsZSA9IHRoaXMuZmlsZXNbcGF0aF07XG5cbiAgICAgICAgICAgICAgICBpZiAoZmlsZSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG5ldyBSZXNwb25zZShwYXRoLCB7XG4gICAgICAgICAgICAgICAgICBzdGF0dXM6IDQwMCxcbiAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6ICdOT1QgRk9VTkQnXG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBoZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIHJhbmdlID0gaGVhZGVycy5nZXQoJ1JhbmdlJyk7XG4gICAgICAgICAgICAgICAgYnl0ZXMgPSByYW5nZSAmJiAvYnl0ZXM9KCQxKS0oJDIpLy5leGVjKHJhbmdlKTtcblxuICAgICAgICAgICAgICAgIGlmICghYnl0ZXMpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gcGFyc2VJbnQoYnl0ZXNbMV0pO1xuICAgICAgICAgICAgICAgIGVuZCA9IHBhcnNlSW50KGJ5dGVzWzJdKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGUuc2xpY2Uoc3RhcnQsIGVuZCkuYXJyYXlCdWZmZXIoKTtcblxuICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgIGRhdGEgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICAgIF9yZXNwb25zZSA9IG5ldyBSZXNwb25zZShkYXRhKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3Jlc3BvbnNlLCAndXJsJywge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IHBhdGhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIF9yZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IG5ldyBSZXNwb25zZShmaWxlKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzcG9uc2UsICd1cmwnLCB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogcGF0aFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGZldGNoKF94LCBfeDIpIHtcbiAgICAgICAgcmV0dXJuIF9mZXRjaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmV0Y2g7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwicmVhZGRpclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlYWRkaXIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoZGlybmFtZSkge1xuICAgICAgICB2YXIgZmlsZXMsIHBhdGg7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBmaWxlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yIChwYXRoIGluIHRoaXMuZmlsZXMpIHtcbiAgICAgICAgICAgICAgICAgIGZpbGVzLnB1c2gocGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgZmlsZXMpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiByZWFkZGlyKF94Mykge1xuICAgICAgICByZXR1cm4gX3JlYWRkaXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlYWRkaXI7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwic3RhdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3N0YXQgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMocGF0aCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgZmlsZTtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGZpbGUgPSB0aGlzLmZpbGVzW3BhdGhdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwYXRoKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgICAgc2l6ZTogZmlsZS5zaXplXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMywgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHN0YXQoX3g0LCBfeDUpIHtcbiAgICAgICAgcmV0dXJuIF9zdGF0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGF0O1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcInVubGlua1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3VubGluayA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlNChwYXRoKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5maWxlc1twYXRoXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5sb3dlckNhc2VGaWxlc1twYXRoXTtcbiAgICAgICAgICAgICAgICB0aGlzLnVzZWRGaWxlc1twYXRoXSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNCwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHVubGluayhfeDYpIHtcbiAgICAgICAgcmV0dXJuIF91bmxpbmsuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVubGluaztcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJvcGVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfb3BlbiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlNShwYXRobmFtZSwgZmxhZ3MsIG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMuZmlsZXNbcGF0aG5hbWVdKTtcblxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU1LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gb3BlbihfeDcsIF94OCwgX3g5KSB7XG4gICAgICAgIHJldHVybiBfb3Blbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3BlbjtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJyZWFkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVhZCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlNihmZCwgYnVmZmVyKSB7XG4gICAgICAgIHZhciBvZmZzZXQsXG4gICAgICAgICAgICBsZW5ndGgsXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICBzdGFydFBvc2l0aW9uLFxuICAgICAgICAgICAgYXJyYXlCdWZmZXIsXG4gICAgICAgICAgICBfYXJnczYgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWU2JChfY29udGV4dDYpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDYucHJldiA9IF9jb250ZXh0Ni5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBfYXJnczYubGVuZ3RoID4gMiAmJiBfYXJnczZbMl0gIT09IHVuZGVmaW5lZCA/IF9hcmdzNlsyXSA6IDA7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gX2FyZ3M2Lmxlbmd0aCA+IDMgJiYgX2FyZ3M2WzNdICE9PSB1bmRlZmluZWQgPyBfYXJnczZbM10gOiBidWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IF9hcmdzNi5sZW5ndGggPiA0ICYmIF9hcmdzNls0XSAhPT0gdW5kZWZpbmVkID8gX2FyZ3M2WzRdIDogbnVsbDtcbiAgICAgICAgICAgICAgICBmaWxlID0gZmQ7XG4gICAgICAgICAgICAgICAgc3RhcnRQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA3O1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlLnNsaWNlKHN0YXJ0UG9zaXRpb24sIHN0YXJ0UG9zaXRpb24gKyBsZW5ndGgpLmFycmF5QnVmZmVyKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIGFycmF5QnVmZmVyID0gX2NvbnRleHQ2LnNlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgICAgYnl0ZXNSZWFkOiBsZW5ndGgsXG4gICAgICAgICAgICAgICAgICBidWZmZXI6IGFycmF5QnVmZmVyXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNik7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlYWQoX3gxMCwgX3gxMSkge1xuICAgICAgICByZXR1cm4gX3JlYWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlYWQ7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9jbG9zZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlNyhmZCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlNyQoX2NvbnRleHQ3KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU3KTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gY2xvc2UoX3gxMikge1xuICAgICAgICByZXR1cm4gX2Nsb3NlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbG9zZTtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJfZ2V0RmlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RmlsZShwYXRoLCB1c2VkKSB7XG4gICAgICB2YXIgZmlsZSA9IHRoaXMuZmlsZXNbcGF0aF0gfHwgdGhpcy5sb3dlckNhc2VGaWxlc1twYXRoXTtcblxuICAgICAgaWYgKGZpbGUgJiYgdXNlZCkge1xuICAgICAgICB0aGlzLnVzZWRGaWxlc1twYXRoXSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmaWxlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQnJvd3NlckZpbGVTeXN0ZW07XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEJyb3dzZXJGaWxlU3lzdGVtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3Nlci1maWxlc3lzdGVtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0QXJyYXlCdWZmZXJPclN0cmluZ0Zyb21EYXRhU3luYyA9IGdldEFycmF5QnVmZmVyT3JTdHJpbmdGcm9tRGF0YVN5bmM7XG5leHBvcnRzLmdldEFycmF5QnVmZmVyT3JTdHJpbmdGcm9tRGF0YSA9IGdldEFycmF5QnVmZmVyT3JTdHJpbmdGcm9tRGF0YTtcbmV4cG9ydHMuZ2V0QXN5bmNJdGVyYWJsZUZyb21EYXRhID0gZ2V0QXN5bmNJdGVyYWJsZUZyb21EYXRhO1xuZXhwb3J0cy5nZXRSZWFkYWJsZVN0cmVhbSA9IGdldFJlYWRhYmxlU3RyZWFtO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9sb2FkZXJVdGlscyA9IHJlcXVpcmUoXCJAbG9hZGVycy5nbC9sb2FkZXItdXRpbHNcIik7XG5cbnZhciBfaXNUeXBlID0gcmVxdWlyZShcIi4uLy4uL2phdmFzY3JpcHQtdXRpbHMvaXMtdHlwZVwiKTtcblxudmFyIF9tYWtlSXRlcmF0b3IgPSByZXF1aXJlKFwiLi4vLi4vaXRlcmF0b3JzL21ha2UtaXRlcmF0b3IvbWFrZS1pdGVyYXRvclwiKTtcblxudmFyIF9yZXNwb25zZVV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzL3Jlc3BvbnNlLXV0aWxzXCIpO1xuXG52YXIgRVJSX0RBVEEgPSAnQ2Fubm90IGNvbnZlcnQgc3VwcGxpZWQgZGF0YSB0eXBlJztcblxuZnVuY3Rpb24gZ2V0QXJyYXlCdWZmZXJPclN0cmluZ0Zyb21EYXRhU3luYyhkYXRhLCBsb2FkZXIsIG9wdGlvbnMpIHtcbiAgaWYgKGxvYWRlci50ZXh0ICYmIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgaWYgKCgwLCBfaXNUeXBlLmlzQnVmZmVyKShkYXRhKSkge1xuICAgIGRhdGEgPSBkYXRhLmJ1ZmZlcjtcbiAgfVxuXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgYXJyYXlCdWZmZXIgPSBkYXRhO1xuXG4gICAgaWYgKGxvYWRlci50ZXh0ICYmICFsb2FkZXIuYmluYXJ5KSB7XG4gICAgICB2YXIgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnKTtcbiAgICAgIHJldHVybiB0ZXh0RGVjb2Rlci5kZWNvZGUoYXJyYXlCdWZmZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheUJ1ZmZlcjtcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICBpZiAobG9hZGVyLnRleHQgJiYgIWxvYWRlci5iaW5hcnkpIHtcbiAgICAgIHZhciBfdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnKTtcblxuICAgICAgcmV0dXJuIF90ZXh0RGVjb2Rlci5kZWNvZGUoZGF0YSk7XG4gICAgfVxuXG4gICAgdmFyIF9hcnJheUJ1ZmZlciA9IGRhdGEuYnVmZmVyO1xuICAgIHZhciBieXRlTGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoIHx8IGRhdGEubGVuZ3RoO1xuXG4gICAgaWYgKGRhdGEuYnl0ZU9mZnNldCAhPT0gMCB8fCBieXRlTGVuZ3RoICE9PSBfYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgX2FycmF5QnVmZmVyID0gX2FycmF5QnVmZmVyLnNsaWNlKGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5ieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnJheUJ1ZmZlcjtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihFUlJfREFUQSk7XG59XG5cbmZ1bmN0aW9uIGdldEFycmF5QnVmZmVyT3JTdHJpbmdGcm9tRGF0YShfeCwgX3gyLCBfeDMpIHtcbiAgcmV0dXJuIF9nZXRBcnJheUJ1ZmZlck9yU3RyaW5nRnJvbURhdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEFycmF5QnVmZmVyT3JTdHJpbmdGcm9tRGF0YSgpIHtcbiAgX2dldEFycmF5QnVmZmVyT3JTdHJpbmdGcm9tRGF0YSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKGRhdGEsIGxvYWRlciwgb3B0aW9ucykge1xuICAgIHZhciBpc0FycmF5QnVmZmVyLCByZXNwb25zZTtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlzQXJyYXlCdWZmZXIgPSBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpO1xuXG4gICAgICAgICAgICBpZiAoISh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgfHwgaXNBcnJheUJ1ZmZlcikpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgZ2V0QXJyYXlCdWZmZXJPclN0cmluZ0Zyb21EYXRhU3luYyhkYXRhLCBsb2FkZXIsIG9wdGlvbnMpKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGlmICghKDAsIF9pc1R5cGUuaXNCbG9iKShkYXRhKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDY7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9yZXNwb25zZVV0aWxzLm1ha2VSZXNwb25zZSkoZGF0YSk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBkYXRhID0gX2NvbnRleHQzLnNlbnQ7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBpZiAoISgwLCBfaXNUeXBlLmlzUmVzcG9uc2UpKGRhdGEpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXNwb25zZSA9IGRhdGE7XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDExO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfcmVzcG9uc2VVdGlscy5jaGVja1Jlc3BvbnNlKShyZXNwb25zZSk7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgaWYgKCFsb2FkZXIuYmluYXJ5KSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDE0O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG5cbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgX2NvbnRleHQzLnQwID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDIwO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxOTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG5cbiAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgX2NvbnRleHQzLnQwID0gX2NvbnRleHQzLnNlbnQ7XG5cbiAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQzLnQwKTtcblxuICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICBpZiAoKDAsIF9pc1R5cGUuaXNSZWFkYWJsZVN0cmVhbSkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgZGF0YSA9ICgwLCBfbWFrZUl0ZXJhdG9yLm1ha2VJdGVyYXRvcikoZGF0YSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghKCgwLCBfaXNUeXBlLmlzSXRlcmFibGUpKGRhdGEpIHx8ICgwLCBfaXNUeXBlLmlzQXN5bmNJdGVyYWJsZSkoZGF0YSkpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCAoMCwgX2xvYWRlclV0aWxzLmNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzQXN5bmMpKGRhdGEpKTtcblxuICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJSX0RBVEEpO1xuXG4gICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0QXJyYXlCdWZmZXJPclN0cmluZ0Zyb21EYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldEFzeW5jSXRlcmFibGVGcm9tRGF0YShfeDQsIF94NSkge1xuICByZXR1cm4gX2dldEFzeW5jSXRlcmFibGVGcm9tRGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfZ2V0QXN5bmNJdGVyYWJsZUZyb21EYXRhKCkge1xuICBfZ2V0QXN5bmNJdGVyYWJsZUZyb21EYXRhID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGRhdGEsIG9wdGlvbnMpIHtcbiAgICB2YXIgcmVzcG9uc2UsIGJvZHk7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0NCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCEoMCwgX2lzVHlwZS5pc0l0ZXJhdG9yKShkYXRhKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCBkYXRhKTtcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGlmICghKDAsIF9pc1R5cGUuaXNSZXNwb25zZSkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3BvbnNlID0gZGF0YTtcbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gNjtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX3Jlc3BvbnNlVXRpbHMuY2hlY2tSZXNwb25zZSkocmVzcG9uc2UpO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA4O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmJvZHk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBib2R5ID0gX2NvbnRleHQ0LnNlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCAoMCwgX21ha2VJdGVyYXRvci5tYWtlSXRlcmF0b3IpKGJvZHksIG9wdGlvbnMpKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBpZiAoISgoMCwgX2lzVHlwZS5pc0Jsb2IpKGRhdGEpIHx8ICgwLCBfaXNUeXBlLmlzUmVhZGFibGVTdHJlYW0pKGRhdGEpKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDEyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgKDAsIF9tYWtlSXRlcmF0b3IubWFrZUl0ZXJhdG9yKShkYXRhLCBvcHRpb25zKSk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgaWYgKCEoMCwgX2lzVHlwZS5pc0FzeW5jSXRlcmFibGUpKGRhdGEpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCBkYXRhW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpKTtcblxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCBnZXRJdGVyYWJsZUZyb21EYXRhKGRhdGEpKTtcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMik7XG4gIH0pKTtcbiAgcmV0dXJuIF9nZXRBc3luY0l0ZXJhYmxlRnJvbURhdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVhZGFibGVTdHJlYW0oX3g2KSB7XG4gIHJldHVybiBfZ2V0UmVhZGFibGVTdHJlYW0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFJlYWRhYmxlU3RyZWFtKCkge1xuICBfZ2V0UmVhZGFibGVTdHJlYW0gPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoZGF0YSkge1xuICAgIHZhciByZXNwb25zZTtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQ1KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoISgwLCBfaXNUeXBlLmlzUmVhZGFibGVTdHJlYW0pKGRhdGEpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIGRhdGEpO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgaWYgKCEoMCwgX2lzVHlwZS5pc1Jlc3BvbnNlKShkYXRhKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCBkYXRhLmJvZHkpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA2O1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfcmVzcG9uc2VVdGlscy5tYWtlUmVzcG9uc2UpKGRhdGEpO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcmVzcG9uc2UgPSBfY29udGV4dDUuc2VudDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIHJlc3BvbnNlLmJvZHkpO1xuXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTMpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0UmVhZGFibGVTdHJlYW0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0SXRlcmFibGVGcm9tRGF0YShkYXRhKSB7XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBvbmVDaHVuaygpIHtcbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIG9uZUNodW5rJChfY29udGV4dCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgb25lQ2h1bmspO1xuICAgIH0pKCk7XG4gIH1cblxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gb25lQ2h1bmsoKSB7XG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBvbmVDaHVuayQoX2NvbnRleHQyKSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBvbmVDaHVuayk7XG4gICAgfSkoKTtcbiAgfVxuXG4gIGlmICgoMCwgX2lzVHlwZS5pc0l0ZXJhdG9yKShkYXRhKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgaWYgKCgwLCBfaXNUeXBlLmlzSXRlcmFibGUpKGRhdGEpKSB7XG4gICAgcmV0dXJuIGRhdGFbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKEVSUl9EQVRBKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1kYXRhLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0TG9hZGVyQ29udGV4dCA9IGdldExvYWRlckNvbnRleHQ7XG5leHBvcnRzLmdldExvYWRlcnNGcm9tQ29udGV4dCA9IGdldExvYWRlcnNGcm9tQ29udGV4dDtcblxudmFyIF90b0NvbnN1bWFibGVBcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5XCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9vcHRpb25VdGlscyA9IHJlcXVpcmUoXCIuL29wdGlvbi11dGlsc1wiKTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGdldExvYWRlckNvbnRleHQoY29udGV4dCwgb3B0aW9ucykge1xuICB2YXIgcHJldmlvdXNDb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuXG4gIGlmIChwcmV2aW91c0NvbnRleHQpIHtcbiAgICByZXR1cm4gcHJldmlvdXNDb250ZXh0O1xuICB9XG5cbiAgdmFyIHJlc29sdmVkQ29udGV4dCA9IF9vYmplY3RTcHJlYWQoe1xuICAgIGZldGNoOiAoMCwgX29wdGlvblV0aWxzLmdldEZldGNoRnVuY3Rpb24pKG9wdGlvbnMsIGNvbnRleHQpXG4gIH0sIGNvbnRleHQpO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShyZXNvbHZlZENvbnRleHQubG9hZGVycykpIHtcbiAgICByZXNvbHZlZENvbnRleHQubG9hZGVycyA9IG51bGw7XG4gIH1cblxuICByZXR1cm4gcmVzb2x2ZWRDb250ZXh0O1xufVxuXG5mdW5jdGlvbiBnZXRMb2FkZXJzRnJvbUNvbnRleHQobG9hZGVycywgY29udGV4dCkge1xuICBpZiAoIWNvbnRleHQgJiYgbG9hZGVycyAmJiAhQXJyYXkuaXNBcnJheShsb2FkZXJzKSkge1xuICAgIHJldHVybiBsb2FkZXJzO1xuICB9XG5cbiAgdmFyIGNhbmRpZGF0ZUxvYWRlcnM7XG5cbiAgaWYgKGxvYWRlcnMpIHtcbiAgICBjYW5kaWRhdGVMb2FkZXJzID0gQXJyYXkuaXNBcnJheShsb2FkZXJzKSA/IGxvYWRlcnMgOiBbbG9hZGVyc107XG4gIH1cblxuICBpZiAoY29udGV4dCAmJiBjb250ZXh0LmxvYWRlcnMpIHtcbiAgICB2YXIgY29udGV4dExvYWRlcnMgPSBBcnJheS5pc0FycmF5KGNvbnRleHQubG9hZGVycykgPyBjb250ZXh0LmxvYWRlcnMgOiBbY29udGV4dC5sb2FkZXJzXTtcbiAgICBjYW5kaWRhdGVMb2FkZXJzID0gY2FuZGlkYXRlTG9hZGVycyA/IFtdLmNvbmNhdCgoMCwgX3RvQ29uc3VtYWJsZUFycmF5Mi5kZWZhdWx0KShjYW5kaWRhdGVMb2FkZXJzKSwgKDAsIF90b0NvbnN1bWFibGVBcnJheTIuZGVmYXVsdCkoY29udGV4dExvYWRlcnMpKSA6IGNvbnRleHRMb2FkZXJzO1xuICB9XG5cbiAgcmV0dXJuIGNhbmRpZGF0ZUxvYWRlcnMgJiYgY2FuZGlkYXRlTG9hZGVycy5sZW5ndGggPyBjYW5kaWRhdGVMb2FkZXJzIDogbnVsbDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWRlci1jb250ZXh0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQ29uc29sZUxvZyA9IGV4cG9ydHMuTnVsbExvZyA9IGV4cG9ydHMucHJvYmVMb2cgPSB2b2lkIDA7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfcHJvYmUgPSByZXF1aXJlKFwicHJvYmUuZ2xcIik7XG5cbnZhciBwcm9iZUxvZyA9IG5ldyBfcHJvYmUuTG9nKHtcbiAgaWQ6ICdsb2FkZXJzLmdsJ1xufSk7XG5leHBvcnRzLnByb2JlTG9nID0gcHJvYmVMb2c7XG5cbnZhciBOdWxsTG9nID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBOdWxsTG9nKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIE51bGxMb2cpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoTnVsbExvZywgW3tcbiAgICBrZXk6IFwibG9nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvZygpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7fTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5mb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmZvKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHt9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3YXJuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdhcm4oKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge307XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVycm9yKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHt9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTnVsbExvZztcbn0oKTtcblxuZXhwb3J0cy5OdWxsTG9nID0gTnVsbExvZztcblxudmFyIENvbnNvbGVMb2cgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbnNvbGVMb2coKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgQ29uc29sZUxvZyk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJjb25zb2xlXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5jb25zb2xlID0gY29uc29sZTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKENvbnNvbGVMb2csIFt7XG4gICAga2V5OiBcImxvZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2coKSB7XG4gICAgICB2YXIgX3RoaXMkY29uc29sZSRsb2c7XG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKF90aGlzJGNvbnNvbGUkbG9nID0gdGhpcy5jb25zb2xlLmxvZykuYmluZC5hcHBseShfdGhpcyRjb25zb2xlJGxvZywgW3RoaXMuY29uc29sZV0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5mb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmZvKCkge1xuICAgICAgdmFyIF90aGlzJGNvbnNvbGUkaW5mbztcblxuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChfdGhpcyRjb25zb2xlJGluZm8gPSB0aGlzLmNvbnNvbGUuaW5mbykuYmluZC5hcHBseShfdGhpcyRjb25zb2xlJGluZm8sIFt0aGlzLmNvbnNvbGVdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndhcm5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2FybigpIHtcbiAgICAgIHZhciBfdGhpcyRjb25zb2xlJHdhcm47XG5cbiAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICBhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoX3RoaXMkY29uc29sZSR3YXJuID0gdGhpcy5jb25zb2xlLndhcm4pLmJpbmQuYXBwbHkoX3RoaXMkY29uc29sZSR3YXJuLCBbdGhpcy5jb25zb2xlXS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcnJvcigpIHtcbiAgICAgIHZhciBfdGhpcyRjb25zb2xlJGVycm9yO1xuXG4gICAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKF90aGlzJGNvbnNvbGUkZXJyb3IgPSB0aGlzLmNvbnNvbGUuZXJyb3IpLmJpbmQuYXBwbHkoX3RoaXMkY29uc29sZSRlcnJvciwgW3RoaXMuY29uc29sZV0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENvbnNvbGVMb2c7XG59KCk7XG5cbmV4cG9ydHMuQ29uc29sZUxvZyA9IENvbnNvbGVMb2c7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dnZXJzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuaXNMb2FkZXJPYmplY3QgPSBpc0xvYWRlck9iamVjdDtcbmV4cG9ydHMubm9ybWFsaXplTG9hZGVyID0gbm9ybWFsaXplTG9hZGVyO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX2xvYWRlclV0aWxzID0gcmVxdWlyZShcIkBsb2FkZXJzLmdsL2xvYWRlci11dGlsc1wiKTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGlzTG9hZGVyT2JqZWN0KGxvYWRlcikge1xuICB2YXIgX2xvYWRlcjtcblxuICBpZiAoIWxvYWRlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGxvYWRlcikpIHtcbiAgICBsb2FkZXIgPSBsb2FkZXJbMF07XG4gIH1cblxuICB2YXIgaGFzRXh0ZW5zaW9ucyA9IEFycmF5LmlzQXJyYXkoKF9sb2FkZXIgPSBsb2FkZXIpID09PSBudWxsIHx8IF9sb2FkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sb2FkZXIuZXh0ZW5zaW9ucyk7XG4gIHJldHVybiBoYXNFeHRlbnNpb25zO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVMb2FkZXIobG9hZGVyKSB7XG4gIHZhciBfbG9hZGVyMiwgX2xvYWRlcjM7XG5cbiAgKDAsIF9sb2FkZXJVdGlscy5hc3NlcnQpKGxvYWRlciwgJ251bGwgbG9hZGVyJyk7XG4gICgwLCBfbG9hZGVyVXRpbHMuYXNzZXJ0KShpc0xvYWRlck9iamVjdChsb2FkZXIpLCAnaW52YWxpZCBsb2FkZXInKTtcbiAgdmFyIG9wdGlvbnM7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobG9hZGVyKSkge1xuICAgIG9wdGlvbnMgPSBsb2FkZXJbMV07XG4gICAgbG9hZGVyID0gbG9hZGVyWzBdO1xuICAgIGxvYWRlciA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbG9hZGVyKSwge30sIHtcbiAgICAgIG9wdGlvbnM6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbG9hZGVyLm9wdGlvbnMpLCBvcHRpb25zKVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKChfbG9hZGVyMiA9IGxvYWRlcikgIT09IG51bGwgJiYgX2xvYWRlcjIgIT09IHZvaWQgMCAmJiBfbG9hZGVyMi5wYXJzZVRleHRTeW5jIHx8IChfbG9hZGVyMyA9IGxvYWRlcikgIT09IG51bGwgJiYgX2xvYWRlcjMgIT09IHZvaWQgMCAmJiBfbG9hZGVyMy5wYXJzZVRleHQpIHtcbiAgICBsb2FkZXIudGV4dCA9IHRydWU7XG4gIH1cblxuICBpZiAoIWxvYWRlci50ZXh0KSB7XG4gICAgbG9hZGVyLmJpbmFyeSA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gbG9hZGVyO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9ybWFsaXplLWxvYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuUkVNT1ZFRF9MT0FERVJfT1BUSU9OUyA9IGV4cG9ydHMuREVGQVVMVF9MT0FERVJfT1BUSU9OUyA9IHZvaWQgMDtcblxudmFyIF9sb2dnZXJzID0gcmVxdWlyZShcIi4vbG9nZ2Vyc1wiKTtcblxudmFyIERFRkFVTFRfTE9BREVSX09QVElPTlMgPSB7XG4gIGZldGNoOiBudWxsLFxuICBtaW1lVHlwZTogdW5kZWZpbmVkLFxuICBub3Rocm93OiBmYWxzZSxcbiAgbG9nOiBuZXcgX2xvZ2dlcnMuQ29uc29sZUxvZygpLFxuICBDRE46ICdodHRwczovL3VucGtnLmNvbS9AbG9hZGVycy5nbCcsXG4gIHdvcmtlcjogdHJ1ZSxcbiAgbWF4Q29uY3VycmVuY3k6IDMsXG4gIG1heE1vYmlsZUNvbmN1cnJlbmN5OiAxLFxuICByZXVzZVdvcmtlcnM6IHRydWUsXG4gIF93b3JrZXJUeXBlOiAnJyxcbiAgbGltaXQ6IDAsXG4gIF9saW1pdE1COiAwLFxuICBiYXRjaFNpemU6ICdhdXRvJyxcbiAgYmF0Y2hEZWJvdW5jZU1zOiAwLFxuICBtZXRhZGF0YTogZmFsc2UsXG4gIHRyYW5zZm9ybXM6IFtdXG59O1xuZXhwb3J0cy5ERUZBVUxUX0xPQURFUl9PUFRJT05TID0gREVGQVVMVF9MT0FERVJfT1BUSU9OUztcbnZhciBSRU1PVkVEX0xPQURFUl9PUFRJT05TID0ge1xuICB0aHJvd3M6ICdub3Rocm93JyxcbiAgZGF0YVR5cGU6ICcobm8gbG9uZ2VyIHVzZWQpJyxcbiAgdXJpOiAnYmFzZVVyaScsXG4gIG1ldGhvZDogJ2ZldGNoLm1ldGhvZCcsXG4gIGhlYWRlcnM6ICdmZXRjaC5oZWFkZXJzJyxcbiAgYm9keTogJ2ZldGNoLmJvZHknLFxuICBtb2RlOiAnZmV0Y2gubW9kZScsXG4gIGNyZWRlbnRpYWxzOiAnZmV0Y2guY3JlZGVudGlhbHMnLFxuICBjYWNoZTogJ2ZldGNoLmNhY2hlJyxcbiAgcmVkaXJlY3Q6ICdmZXRjaC5yZWRpcmVjdCcsXG4gIHJlZmVycmVyOiAnZmV0Y2gucmVmZXJyZXInLFxuICByZWZlcnJlclBvbGljeTogJ2ZldGNoLnJlZmVycmVyUG9saWN5JyxcbiAgaW50ZWdyaXR5OiAnZmV0Y2guaW50ZWdyaXR5JyxcbiAga2VlcGFsaXZlOiAnZmV0Y2gua2VlcGFsaXZlJyxcbiAgc2lnbmFsOiAnZmV0Y2guc2lnbmFsJ1xufTtcbmV4cG9ydHMuUkVNT1ZFRF9MT0FERVJfT1BUSU9OUyA9IFJFTU9WRURfTE9BREVSX09QVElPTlM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcHRpb24tZGVmYXVsdHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXRHbG9iYWxMb2FkZXJTdGF0ZSA9IGdldEdsb2JhbExvYWRlclN0YXRlO1xuZXhwb3J0cy5zZXRHbG9iYWxPcHRpb25zID0gc2V0R2xvYmFsT3B0aW9ucztcbmV4cG9ydHMubm9ybWFsaXplT3B0aW9ucyA9IG5vcm1hbGl6ZU9wdGlvbnM7XG5leHBvcnRzLmdldEZldGNoRnVuY3Rpb24gPSBnZXRGZXRjaEZ1bmN0aW9uO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX2xvYWRlclV0aWxzID0gcmVxdWlyZShcIkBsb2FkZXJzLmdsL2xvYWRlci11dGlsc1wiKTtcblxudmFyIF9pc1R5cGUgPSByZXF1aXJlKFwiLi4vLi4vamF2YXNjcmlwdC11dGlscy9pcy10eXBlXCIpO1xuXG52YXIgX2ZldGNoRmlsZSA9IHJlcXVpcmUoXCIuLi9mZXRjaC9mZXRjaC1maWxlXCIpO1xuXG52YXIgX2xvZ2dlcnMgPSByZXF1aXJlKFwiLi9sb2dnZXJzXCIpO1xuXG52YXIgX29wdGlvbkRlZmF1bHRzID0gcmVxdWlyZShcIi4vb3B0aW9uLWRlZmF1bHRzXCIpO1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBnZXRHbG9iYWxMb2FkZXJTdGF0ZSgpIHtcbiAgX2xvYWRlclV0aWxzLmdsb2JhbC5sb2FkZXJzID0gX2xvYWRlclV0aWxzLmdsb2JhbC5sb2FkZXJzIHx8IHt9O1xuICB2YXIgbG9hZGVycyA9IF9sb2FkZXJVdGlscy5nbG9iYWwubG9hZGVycztcbiAgbG9hZGVycy5fc3RhdGUgPSBsb2FkZXJzLl9zdGF0ZSB8fCB7fTtcbiAgcmV0dXJuIGxvYWRlcnMuX3N0YXRlO1xufVxuXG52YXIgZ2V0R2xvYmFsTG9hZGVyT3B0aW9ucyA9IGZ1bmN0aW9uIGdldEdsb2JhbExvYWRlck9wdGlvbnMoKSB7XG4gIHZhciBzdGF0ZSA9IGdldEdsb2JhbExvYWRlclN0YXRlKCk7XG4gIHN0YXRlLmdsb2JhbE9wdGlvbnMgPSBzdGF0ZS5nbG9iYWxPcHRpb25zIHx8IF9vYmplY3RTcHJlYWQoe30sIF9vcHRpb25EZWZhdWx0cy5ERUZBVUxUX0xPQURFUl9PUFRJT05TKTtcbiAgcmV0dXJuIHN0YXRlLmdsb2JhbE9wdGlvbnM7XG59O1xuXG5mdW5jdGlvbiBzZXRHbG9iYWxPcHRpb25zKG9wdGlvbnMpIHtcbiAgdmFyIHN0YXRlID0gZ2V0R2xvYmFsTG9hZGVyU3RhdGUoKTtcbiAgdmFyIGdsb2JhbE9wdGlvbnMgPSBnZXRHbG9iYWxMb2FkZXJPcHRpb25zKCk7XG4gIHN0YXRlLmdsb2JhbE9wdGlvbnMgPSBub3JtYWxpemVPcHRpb25zSW50ZXJuYWwoZ2xvYmFsT3B0aW9ucywgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU9wdGlvbnMob3B0aW9ucywgbG9hZGVyLCBsb2FkZXJzLCB1cmwpIHtcbiAgbG9hZGVycyA9IGxvYWRlcnMgfHwgW107XG4gIGxvYWRlcnMgPSBBcnJheS5pc0FycmF5KGxvYWRlcnMpID8gbG9hZGVycyA6IFtsb2FkZXJzXTtcbiAgdmFsaWRhdGVPcHRpb25zKG9wdGlvbnMsIGxvYWRlcnMpO1xuICByZXR1cm4gbm9ybWFsaXplT3B0aW9uc0ludGVybmFsKGxvYWRlciwgb3B0aW9ucywgdXJsKTtcbn1cblxuZnVuY3Rpb24gZ2V0RmV0Y2hGdW5jdGlvbihvcHRpb25zLCBjb250ZXh0KSB7XG4gIHZhciBnbG9iYWxPcHRpb25zID0gZ2V0R2xvYmFsTG9hZGVyT3B0aW9ucygpO1xuICB2YXIgZmV0Y2hPcHRpb25zID0gb3B0aW9ucyB8fCBnbG9iYWxPcHRpb25zO1xuXG4gIGlmICh0eXBlb2YgZmV0Y2hPcHRpb25zLmZldGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZldGNoT3B0aW9ucy5mZXRjaDtcbiAgfVxuXG4gIGlmICgoMCwgX2lzVHlwZS5pc09iamVjdCkoZmV0Y2hPcHRpb25zLmZldGNoKSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodXJsKSB7XG4gICAgICByZXR1cm4gKDAsIF9mZXRjaEZpbGUuZmV0Y2hGaWxlKSh1cmwsIGZldGNoT3B0aW9ucyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChjb250ZXh0ICE9PSBudWxsICYmIGNvbnRleHQgIT09IHZvaWQgMCAmJiBjb250ZXh0LmZldGNoKSB7XG4gICAgcmV0dXJuIGNvbnRleHQgPT09IG51bGwgfHwgY29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGV4dC5mZXRjaDtcbiAgfVxuXG4gIHJldHVybiBfZmV0Y2hGaWxlLmZldGNoRmlsZTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25zKG9wdGlvbnMsIGxvYWRlcnMpIHtcbiAgdmFsaWRhdGVPcHRpb25zT2JqZWN0KG9wdGlvbnMsIG51bGwsIF9vcHRpb25EZWZhdWx0cy5ERUZBVUxUX0xPQURFUl9PUFRJT05TLCBfb3B0aW9uRGVmYXVsdHMuUkVNT1ZFRF9MT0FERVJfT1BUSU9OUywgbG9hZGVycyk7XG5cbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGxvYWRlcnMpLFxuICAgICAgX3N0ZXA7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgdmFyIGxvYWRlciA9IF9zdGVwLnZhbHVlO1xuICAgICAgdmFyIGlkT3B0aW9ucyA9IG9wdGlvbnMgJiYgb3B0aW9uc1tsb2FkZXIuaWRdIHx8IHt9O1xuICAgICAgdmFyIGxvYWRlck9wdGlvbnMgPSBsb2FkZXIub3B0aW9ucyAmJiBsb2FkZXIub3B0aW9uc1tsb2FkZXIuaWRdIHx8IHt9O1xuICAgICAgdmFyIGRlcHJlY2F0ZWRPcHRpb25zID0gbG9hZGVyLmRlcHJlY2F0ZWRPcHRpb25zICYmIGxvYWRlci5kZXByZWNhdGVkT3B0aW9uc1tsb2FkZXIuaWRdIHx8IHt9O1xuICAgICAgdmFsaWRhdGVPcHRpb25zT2JqZWN0KGlkT3B0aW9ucywgbG9hZGVyLmlkLCBsb2FkZXJPcHRpb25zLCBkZXByZWNhdGVkT3B0aW9ucywgbG9hZGVycyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvci5mKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25zT2JqZWN0KG9wdGlvbnMsIGlkLCBkZWZhdWx0T3B0aW9ucywgZGVwcmVjYXRlZE9wdGlvbnMsIGxvYWRlcnMpIHtcbiAgdmFyIGxvYWRlck5hbWUgPSBpZCB8fCAnVG9wIGxldmVsJztcbiAgdmFyIHByZWZpeCA9IGlkID8gXCJcIi5jb25jYXQoaWQsIFwiLlwiKSA6ICcnO1xuXG4gIGZvciAodmFyIF9rZXkgaW4gb3B0aW9ucykge1xuICAgIHZhciBpc1N1Yk9wdGlvbnMgPSAhaWQgJiYgKDAsIF9pc1R5cGUuaXNPYmplY3QpKG9wdGlvbnNbX2tleV0pO1xuICAgIHZhciBpc0Jhc2VVcmlPcHRpb24gPSBfa2V5ID09PSAnYmFzZVVyaScgJiYgIWlkO1xuICAgIHZhciBpc1dvcmtlclVybE9wdGlvbiA9IF9rZXkgPT09ICd3b3JrZXJVcmwnICYmIGlkO1xuXG4gICAgaWYgKCEoX2tleSBpbiBkZWZhdWx0T3B0aW9ucykgJiYgIWlzQmFzZVVyaU9wdGlvbiAmJiAhaXNXb3JrZXJVcmxPcHRpb24pIHtcbiAgICAgIGlmIChfa2V5IGluIGRlcHJlY2F0ZWRPcHRpb25zKSB7XG4gICAgICAgIF9sb2dnZXJzLnByb2JlTG9nLndhcm4oXCJcIi5jb25jYXQobG9hZGVyTmFtZSwgXCIgbG9hZGVyIG9wdGlvbiAnXCIpLmNvbmNhdChwcmVmaXgpLmNvbmNhdChfa2V5LCBcIicgbm8gbG9uZ2VyIHN1cHBvcnRlZCwgdXNlICdcIikuY29uY2F0KGRlcHJlY2F0ZWRPcHRpb25zW19rZXldLCBcIidcIikpKCk7XG4gICAgICB9IGVsc2UgaWYgKCFpc1N1Yk9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHN1Z2dlc3Rpb24gPSBmaW5kU2ltaWxhck9wdGlvbihfa2V5LCBsb2FkZXJzKTtcblxuICAgICAgICBfbG9nZ2Vycy5wcm9iZUxvZy53YXJuKFwiXCIuY29uY2F0KGxvYWRlck5hbWUsIFwiIGxvYWRlciBvcHRpb24gJ1wiKS5jb25jYXQocHJlZml4KS5jb25jYXQoX2tleSwgXCInIG5vdCByZWNvZ25pemVkLiBcIikuY29uY2F0KHN1Z2dlc3Rpb24pKSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kU2ltaWxhck9wdGlvbihvcHRpb25LZXksIGxvYWRlcnMpIHtcbiAgdmFyIGxvd2VyQ2FzZU9wdGlvbktleSA9IG9wdGlvbktleS50b0xvd2VyQ2FzZSgpO1xuICB2YXIgYmVzdFN1Z2dlc3Rpb24gPSAnJztcblxuICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGxvYWRlcnMpLFxuICAgICAgX3N0ZXAyO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBsb2FkZXIgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgIGZvciAodmFyIF9rZXkyIGluIGxvYWRlci5vcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25LZXkgPT09IF9rZXkyKSB7XG4gICAgICAgICAgcmV0dXJuIFwiRGlkIHlvdSBtZWFuICdcIi5jb25jYXQobG9hZGVyLmlkLCBcIi5cIikuY29uY2F0KF9rZXkyLCBcIic/XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvd2VyQ2FzZUtleSA9IF9rZXkyLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgdmFyIGlzUGFydGlhbE1hdGNoID0gbG93ZXJDYXNlT3B0aW9uS2V5LnN0YXJ0c1dpdGgobG93ZXJDYXNlS2V5KSB8fCBsb3dlckNhc2VLZXkuc3RhcnRzV2l0aChsb3dlckNhc2VPcHRpb25LZXkpO1xuXG4gICAgICAgIGlmIChpc1BhcnRpYWxNYXRjaCkge1xuICAgICAgICAgIGJlc3RTdWdnZXN0aW9uID0gYmVzdFN1Z2dlc3Rpb24gfHwgXCJEaWQgeW91IG1lYW4gJ1wiLmNvbmNhdChsb2FkZXIuaWQsIFwiLlwiKS5jb25jYXQoX2tleTIsIFwiJz9cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjIuZigpO1xuICB9XG5cbiAgcmV0dXJuIGJlc3RTdWdnZXN0aW9uO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVPcHRpb25zSW50ZXJuYWwobG9hZGVyLCBvcHRpb25zLCB1cmwpIHtcbiAgdmFyIGxvYWRlckRlZmF1bHRPcHRpb25zID0gbG9hZGVyLm9wdGlvbnMgfHwge307XG5cbiAgdmFyIG1lcmdlZE9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkKHt9LCBsb2FkZXJEZWZhdWx0T3B0aW9ucyk7XG5cbiAgYWRkVXJsT3B0aW9ucyhtZXJnZWRPcHRpb25zLCB1cmwpO1xuXG4gIGlmIChtZXJnZWRPcHRpb25zLmxvZyA9PT0gbnVsbCkge1xuICAgIG1lcmdlZE9wdGlvbnMubG9nID0gbmV3IF9sb2dnZXJzLk51bGxMb2coKTtcbiAgfVxuXG4gIG1lcmdlTmVzdGVkRmllbGRzKG1lcmdlZE9wdGlvbnMsIGdldEdsb2JhbExvYWRlck9wdGlvbnMoKSk7XG4gIG1lcmdlTmVzdGVkRmllbGRzKG1lcmdlZE9wdGlvbnMsIG9wdGlvbnMpO1xuICByZXR1cm4gbWVyZ2VkT3B0aW9ucztcbn1cblxuZnVuY3Rpb24gbWVyZ2VOZXN0ZWRGaWVsZHMobWVyZ2VkT3B0aW9ucywgb3B0aW9ucykge1xuICBmb3IgKHZhciBfa2V5MyBpbiBvcHRpb25zKSB7XG4gICAgaWYgKF9rZXkzIGluIG9wdGlvbnMpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG9wdGlvbnNbX2tleTNdO1xuXG4gICAgICBpZiAoKDAsIF9pc1R5cGUuaXNQdXJlT2JqZWN0KSh2YWx1ZSkgJiYgKDAsIF9pc1R5cGUuaXNQdXJlT2JqZWN0KShtZXJnZWRPcHRpb25zW19rZXkzXSkpIHtcbiAgICAgICAgbWVyZ2VkT3B0aW9uc1tfa2V5M10gPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG1lcmdlZE9wdGlvbnNbX2tleTNdKSwgb3B0aW9uc1tfa2V5M10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVyZ2VkT3B0aW9uc1tfa2V5M10gPSBvcHRpb25zW19rZXkzXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkVXJsT3B0aW9ucyhvcHRpb25zLCB1cmwpIHtcbiAgaWYgKHVybCAmJiAhKCdiYXNlVXJpJyBpbiBvcHRpb25zKSkge1xuICAgIG9wdGlvbnMuYmFzZVVyaSA9IHVybDtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3B0aW9uLXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZldGNoUHJvZ3Jlc3M7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG5mdW5jdGlvbiBmZXRjaFByb2dyZXNzKF94LCBfeDIpIHtcbiAgcmV0dXJuIF9mZXRjaFByb2dyZXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9mZXRjaFByb2dyZXNzKCkge1xuICBfZmV0Y2hQcm9ncmVzcyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMihyZXNwb25zZSwgb25Qcm9ncmVzcykge1xuICAgIHZhciBvbkRvbmUsXG4gICAgICAgIG9uRXJyb3IsXG4gICAgICAgIGJvZHksXG4gICAgICAgIGNvbnRlbnRMZW5ndGgsXG4gICAgICAgIHRvdGFsQnl0ZXMsXG4gICAgICAgIHByb2dyZXNzU3RyZWFtLFxuICAgICAgICBfYXJnczIgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgb25Eb25lID0gX2FyZ3MyLmxlbmd0aCA+IDIgJiYgX2FyZ3MyWzJdICE9PSB1bmRlZmluZWQgPyBfYXJnczJbMl0gOiBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgIG9uRXJyb3IgPSBfYXJnczIubGVuZ3RoID4gMyAmJiBfYXJnczJbM10gIT09IHVuZGVmaW5lZCA/IF9hcmdzMlszXSA6IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA0O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmVzcG9uc2UgPSBfY29udGV4dDIuc2VudDtcblxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHJlc3BvbnNlKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGJvZHkgPSByZXNwb25zZS5ib2R5O1xuXG4gICAgICAgICAgICBpZiAoYm9keSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzcG9uc2UpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIGNvbnRlbnRMZW5ndGggPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC1sZW5ndGgnKSB8fCAwO1xuICAgICAgICAgICAgdG90YWxCeXRlcyA9IGNvbnRlbnRMZW5ndGggJiYgcGFyc2VJbnQoY29udGVudExlbmd0aCk7XG5cbiAgICAgICAgICAgIGlmIChjb250ZW50TGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzcG9uc2UpO1xuXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIGlmICghKHR5cGVvZiBSZWFkYWJsZVN0cmVhbSA9PT0gJ3VuZGVmaW5lZCcgfHwgIWJvZHkuZ2V0UmVhZGVyKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE2O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzcG9uc2UpO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIHByb2dyZXNzU3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVhZGVyO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlciA9IGJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZChjb250cm9sbGVyLCByZWFkZXIsIDAsIHRvdGFsQnl0ZXMsIG9uUHJvZ3Jlc3MsIG9uRG9uZSwgb25FcnJvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUpO1xuICAgICAgICAgICAgICAgIH0pKSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIG5ldyBSZXNwb25zZShwcm9ncmVzc1N0cmVhbSkpO1xuXG4gICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyKTtcbiAgfSkpO1xuICByZXR1cm4gX2ZldGNoUHJvZ3Jlc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gcmVhZChfeDMsIF94NCwgX3g1LCBfeDYsIF94NywgX3g4LCBfeDkpIHtcbiAgcmV0dXJuIF9yZWFkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9yZWFkKCkge1xuICBfcmVhZCA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhjb250cm9sbGVyLCByZWFkZXIsIGxvYWRlZEJ5dGVzLCB0b3RhbEJ5dGVzLCBvblByb2dyZXNzLCBvbkRvbmUsIG9uRXJyb3IpIHtcbiAgICB2YXIgX3lpZWxkJHJlYWRlciRyZWFkLCBkb25lLCB2YWx1ZSwgcGVyY2VudDtcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMDtcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZCgpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgX3lpZWxkJHJlYWRlciRyZWFkID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICBkb25lID0gX3lpZWxkJHJlYWRlciRyZWFkLmRvbmU7XG4gICAgICAgICAgICB2YWx1ZSA9IF95aWVsZCRyZWFkZXIkcmVhZC52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvbkRvbmUoKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIGxvYWRlZEJ5dGVzICs9IHZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBwZXJjZW50ID0gTWF0aC5yb3VuZChsb2FkZWRCeXRlcyAvIHRvdGFsQnl0ZXMgKiAxMDApO1xuICAgICAgICAgICAgb25Qcm9ncmVzcyhwZXJjZW50LCB7XG4gICAgICAgICAgICAgIGxvYWRlZEJ5dGVzOiBsb2FkZWRCeXRlcyxcbiAgICAgICAgICAgICAgdG90YWxCeXRlczogdG90YWxCeXRlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxNjtcbiAgICAgICAgICAgIHJldHVybiByZWFkKGNvbnRyb2xsZXIsIHJlYWRlciwgbG9hZGVkQnl0ZXMsIHRvdGFsQnl0ZXMsIG9uUHJvZ3Jlc3MsIG9uRG9uZSwgb25FcnJvcik7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAyMjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMTg7XG4gICAgICAgICAgICBfY29udGV4dDMudDAgPSBfY29udGV4dDNbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoX2NvbnRleHQzLnQwKTtcbiAgICAgICAgICAgIG9uRXJyb3IoX2NvbnRleHQzLnQwKTtcblxuICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMywgbnVsbCwgW1swLCAxOF1dKTtcbiAgfSkpO1xuICByZXR1cm4gX3JlYWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoLXByb2dyZXNzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5wYXJzZU1JTUVUeXBlID0gcGFyc2VNSU1FVHlwZTtcbmV4cG9ydHMucGFyc2VNSU1FVHlwZUZyb21VUkwgPSBwYXJzZU1JTUVUeXBlRnJvbVVSTDtcbnZhciBEQVRBX1VSTF9QQVRURVJOID0gL15kYXRhOihbLVxcdy5dK1xcL1stXFx3LitdKykoO3wsKS87XG52YXIgTUlNRV9UWVBFX1BBVFRFUk4gPSAvXihbLVxcdy5dK1xcL1stXFx3LitdKykvO1xuXG5mdW5jdGlvbiBwYXJzZU1JTUVUeXBlKG1pbWVTdHJpbmcpIHtcbiAgdmFyIG1hdGNoZXMgPSBNSU1FX1RZUEVfUEFUVEVSTi5leGVjKG1pbWVTdHJpbmcpO1xuXG4gIGlmIChtYXRjaGVzKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNbMV07XG4gIH1cblxuICByZXR1cm4gbWltZVN0cmluZztcbn1cblxuZnVuY3Rpb24gcGFyc2VNSU1FVHlwZUZyb21VUkwodXJsKSB7XG4gIHZhciBtYXRjaGVzID0gREFUQV9VUkxfUEFUVEVSTi5leGVjKHVybCk7XG5cbiAgaWYgKG1hdGNoZXMpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1sxXTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pbWUtdHlwZS11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0UmVzb3VyY2VVcmxBbmRUeXBlID0gZ2V0UmVzb3VyY2VVcmxBbmRUeXBlO1xuZXhwb3J0cy5nZXRSZXNvdXJjZUNvbnRlbnRMZW5ndGggPSBnZXRSZXNvdXJjZUNvbnRlbnRMZW5ndGg7XG5cbnZhciBfaXNUeXBlID0gcmVxdWlyZShcIi4uLy4uL2phdmFzY3JpcHQtdXRpbHMvaXMtdHlwZVwiKTtcblxudmFyIF9taW1lVHlwZVV0aWxzID0gcmVxdWlyZShcIi4vbWltZS10eXBlLXV0aWxzXCIpO1xuXG52YXIgUVVFUllfU1RSSU5HX1BBVFRFUk4gPSAvXFw/LiovO1xuXG5mdW5jdGlvbiBnZXRSZXNvdXJjZVVybEFuZFR5cGUocmVzb3VyY2UpIHtcbiAgaWYgKCgwLCBfaXNUeXBlLmlzUmVzcG9uc2UpKHJlc291cmNlKSkge1xuICAgIHZhciB1cmwgPSBzdHJpcFF1ZXJ5U3RyaW5nKHJlc291cmNlLnVybCB8fCAnJyk7XG4gICAgdmFyIGNvbnRlbnRUeXBlSGVhZGVyID0gcmVzb3VyY2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpIHx8ICcnO1xuICAgIHJldHVybiB7XG4gICAgICB1cmw6IHVybCxcbiAgICAgIHR5cGU6ICgwLCBfbWltZVR5cGVVdGlscy5wYXJzZU1JTUVUeXBlKShjb250ZW50VHlwZUhlYWRlcikgfHwgKDAsIF9taW1lVHlwZVV0aWxzLnBhcnNlTUlNRVR5cGVGcm9tVVJMKSh1cmwpXG4gICAgfTtcbiAgfVxuXG4gIGlmICgoMCwgX2lzVHlwZS5pc0Jsb2IpKHJlc291cmNlKSkge1xuICAgIHJldHVybiB7XG4gICAgICB1cmw6IHN0cmlwUXVlcnlTdHJpbmcocmVzb3VyY2UubmFtZSB8fCAnJyksXG4gICAgICB0eXBlOiByZXNvdXJjZS50eXBlIHx8ICcnXG4gICAgfTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcmVzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVybDogc3RyaXBRdWVyeVN0cmluZyhyZXNvdXJjZSksXG4gICAgICB0eXBlOiAoMCwgX21pbWVUeXBlVXRpbHMucGFyc2VNSU1FVHlwZUZyb21VUkwpKHJlc291cmNlKVxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHVybDogJycsXG4gICAgdHlwZTogJydcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVzb3VyY2VDb250ZW50TGVuZ3RoKHJlc291cmNlKSB7XG4gIGlmICgoMCwgX2lzVHlwZS5pc1Jlc3BvbnNlKShyZXNvdXJjZSkpIHtcbiAgICByZXR1cm4gcmVzb3VyY2UuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXSB8fCAtMTtcbiAgfVxuXG4gIGlmICgoMCwgX2lzVHlwZS5pc0Jsb2IpKHJlc291cmNlKSkge1xuICAgIHJldHVybiByZXNvdXJjZS5zaXplO1xuICB9XG5cbiAgaWYgKHR5cGVvZiByZXNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcmVzb3VyY2UubGVuZ3RoO1xuICB9XG5cbiAgaWYgKHJlc291cmNlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gcmVzb3VyY2UuYnl0ZUxlbmd0aDtcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcocmVzb3VyY2UpKSB7XG4gICAgcmV0dXJuIHJlc291cmNlLmJ5dGVMZW5ndGg7XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIHN0cmlwUXVlcnlTdHJpbmcodXJsKSB7XG4gIHJldHVybiB1cmwucmVwbGFjZShRVUVSWV9TVFJJTkdfUEFUVEVSTiwgJycpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb3VyY2UtdXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5tYWtlUmVzcG9uc2UgPSBtYWtlUmVzcG9uc2U7XG5leHBvcnRzLmNoZWNrUmVzcG9uc2UgPSBjaGVja1Jlc3BvbnNlO1xuZXhwb3J0cy5jaGVja1Jlc3BvbnNlU3luYyA9IGNoZWNrUmVzcG9uc2VTeW5jO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9pc1R5cGUgPSByZXF1aXJlKFwiLi4vLi4vamF2YXNjcmlwdC11dGlscy9pcy10eXBlXCIpO1xuXG52YXIgX3Jlc291cmNlVXRpbHMgPSByZXF1aXJlKFwiLi9yZXNvdXJjZS11dGlsc1wiKTtcblxuZnVuY3Rpb24gbWFrZVJlc3BvbnNlKF94KSB7XG4gIHJldHVybiBfbWFrZVJlc3BvbnNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9tYWtlUmVzcG9uc2UoKSB7XG4gIF9tYWtlUmVzcG9uc2UgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZShyZXNvdXJjZSkge1xuICAgIHZhciBoZWFkZXJzLCBjb250ZW50TGVuZ3RoLCBfZ2V0UmVzb3VyY2VVcmxBbmRUeXAsIHVybCwgdHlwZSwgaW5pdGlhbERhdGFVcmwsIHJlc3BvbnNlO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoISgwLCBfaXNUeXBlLmlzUmVzcG9uc2UpKHJlc291cmNlKSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzb3VyY2UpO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgY29udGVudExlbmd0aCA9ICgwLCBfcmVzb3VyY2VVdGlscy5nZXRSZXNvdXJjZUNvbnRlbnRMZW5ndGgpKHJlc291cmNlKTtcblxuICAgICAgICAgICAgaWYgKGNvbnRlbnRMZW5ndGggPj0gMCkge1xuICAgICAgICAgICAgICBoZWFkZXJzWydjb250ZW50LWxlbmd0aCddID0gU3RyaW5nKGNvbnRlbnRMZW5ndGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfZ2V0UmVzb3VyY2VVcmxBbmRUeXAgPSAoMCwgX3Jlc291cmNlVXRpbHMuZ2V0UmVzb3VyY2VVcmxBbmRUeXBlKShyZXNvdXJjZSksIHVybCA9IF9nZXRSZXNvdXJjZVVybEFuZFR5cC51cmwsIHR5cGUgPSBfZ2V0UmVzb3VyY2VVcmxBbmRUeXAudHlwZTtcblxuICAgICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgICAgaGVhZGVyc1snY29udGVudC10eXBlJ10gPSB0eXBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gOTtcbiAgICAgICAgICAgIHJldHVybiBnZXRJbml0aWFsRGF0YVVybChyZXNvdXJjZSk7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBpbml0aWFsRGF0YVVybCA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgIGlmIChpbml0aWFsRGF0YVVybCkge1xuICAgICAgICAgICAgICBoZWFkZXJzWyd4LWZpcnN0LWJ5dGVzJ10gPSBpbml0aWFsRGF0YVVybDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgcmVzb3VyY2UgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocmVzb3VyY2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXNwb25zZSA9IG5ldyBSZXNwb25zZShyZXNvdXJjZSwge1xuICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNwb25zZSwgJ3VybCcsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHVybFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHJlc3BvbnNlKTtcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUpO1xuICB9KSk7XG4gIHJldHVybiBfbWFrZVJlc3BvbnNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrUmVzcG9uc2UoX3gyKSB7XG4gIHJldHVybiBfY2hlY2tSZXNwb25zZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfY2hlY2tSZXNwb25zZSgpIHtcbiAgX2NoZWNrUmVzcG9uc2UgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIocmVzcG9uc2UpIHtcbiAgICB2YXIgbWVzc2FnZTtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA1O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIGdldFJlc3BvbnNlRXJyb3IocmVzcG9uc2UpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgbWVzc2FnZSA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIpO1xuICB9KSk7XG4gIHJldHVybiBfY2hlY2tSZXNwb25zZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBjaGVja1Jlc3BvbnNlU3luYyhyZXNwb25zZSkge1xuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBcIlwiLmNvbmNhdChyZXNwb25zZS5zdGF0dXMsIFwiIFwiKS5jb25jYXQocmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UubGVuZ3RoID4gNjAgPyBcIlwiLmNvbmNhdChtZXNzYWdlLnNsaWNlKDYwKSwgXCIuLi5cIikgOiBtZXNzYWdlO1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSZXNwb25zZUVycm9yKF94Mykge1xuICByZXR1cm4gX2dldFJlc3BvbnNlRXJyb3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldFJlc3BvbnNlRXJyb3IoKSB7XG4gIF9nZXRSZXNwb25zZUVycm9yID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKHJlc3BvbnNlKSB7XG4gICAgdmFyIG1lc3NhZ2UsIGNvbnRlbnRUeXBlLCB0ZXh0O1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkZhaWxlZCB0byBmZXRjaCByZXNvdXJjZSBcIi5jb25jYXQocmVzcG9uc2UudXJsLCBcIiAoXCIpLmNvbmNhdChyZXNwb25zZS5zdGF0dXMsIFwiKTogXCIpO1xuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAxO1xuICAgICAgICAgICAgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJyk7XG4gICAgICAgICAgICB0ZXh0ID0gcmVzcG9uc2Uuc3RhdHVzVGV4dDtcblxuICAgICAgICAgICAgaWYgKCFjb250ZW50VHlwZS5pbmNsdWRlcygnYXBwbGljYXRpb24vanNvbicpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDMudDAgPSB0ZXh0O1xuICAgICAgICAgICAgX2NvbnRleHQzLnQxID0gXCIgXCI7XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgX2NvbnRleHQzLnQyID0gX2NvbnRleHQzLnNlbnQ7XG4gICAgICAgICAgICB0ZXh0ID0gX2NvbnRleHQzLnQwICs9IF9jb250ZXh0My50MS5jb25jYXQuY2FsbChfY29udGV4dDMudDEsIF9jb250ZXh0My50Mik7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgbWVzc2FnZSArPSB0ZXh0O1xuICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UubGVuZ3RoID4gNjAgPyBcIlwiLmNvbmNhdChtZXNzYWdlLnNsaWNlKDYwKSwgXCIuLi5cIikgOiBtZXNzYWdlO1xuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxNztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMTU7XG4gICAgICAgICAgICBfY29udGV4dDMudDMgPSBfY29udGV4dDNbXCJjYXRjaFwiXSgxKTtcblxuICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBtZXNzYWdlKTtcblxuICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMywgbnVsbCwgW1sxLCAxNV1dKTtcbiAgfSkpO1xuICByZXR1cm4gX2dldFJlc3BvbnNlRXJyb3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5pdGlhbERhdGFVcmwoX3g0KSB7XG4gIHJldHVybiBfZ2V0SW5pdGlhbERhdGFVcmwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2dldEluaXRpYWxEYXRhVXJsKCkge1xuICBfZ2V0SW5pdGlhbERhdGFVcmwgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQocmVzb3VyY2UpIHtcbiAgICB2YXIgSU5JVElBTF9EQVRBX0xFTkdUSCwgYmxvYlNsaWNlLCBzbGljZSwgYmFzZTY0O1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIElOSVRJQUxfREFUQV9MRU5HVEggPSA1O1xuXG4gICAgICAgICAgICBpZiAoISh0eXBlb2YgcmVzb3VyY2UgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCBcImRhdGE6LFwiLmNvbmNhdChyZXNvdXJjZS5zbGljZSgwLCBJTklUSUFMX0RBVEFfTEVOR1RIKSkpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgaWYgKCEocmVzb3VyY2UgaW5zdGFuY2VvZiBCbG9iKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBibG9iU2xpY2UgPSByZXNvdXJjZS5zbGljZSgwLCA1KTtcbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gNztcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICAgICAgICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9ldmVudCR0YXJnZXQ7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShldmVudCA9PT0gbnVsbCB8fCBldmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9ldmVudCR0YXJnZXQgPSBldmVudC50YXJnZXQpID09PSBudWxsIHx8IF9ldmVudCR0YXJnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ldmVudCR0YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChibG9iU2xpY2UpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDQuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBpZiAoIShyZXNvdXJjZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDEyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2xpY2UgPSByZXNvdXJjZS5zbGljZSgwLCBJTklUSUFMX0RBVEFfTEVOR1RIKTtcbiAgICAgICAgICAgIGJhc2U2NCA9IGFycmF5QnVmZmVyVG9CYXNlNjQoc2xpY2UpO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgXCJkYXRhOmJhc2U2NCxcIi5jb25jYXQoYmFzZTY0KSk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgbnVsbCk7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTQpO1xuICB9KSk7XG4gIHJldHVybiBfZ2V0SW5pdGlhbERhdGFVcmwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gYXJyYXlCdWZmZXJUb0Jhc2U2NChidWZmZXIpIHtcbiAgdmFyIGJpbmFyeSA9ICcnO1xuICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMuYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgYmluYXJ5ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICB9XG5cbiAgcmV0dXJuIGJ0b2EoYmluYXJ5KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc3BvbnNlLXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuTnVsbExvYWRlciA9IGV4cG9ydHMuTnVsbFdvcmtlckxvYWRlciA9IHZvaWQgMDtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfYXdhaXRBc3luY0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2F3YWl0QXN5bmNHZW5lcmF0b3JcIikpO1xuXG52YXIgX3dyYXBBc3luY0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3dyYXBBc3luY0dlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNJdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jSXRlcmF0b3JcIikpO1xuXG52YXIgVkVSU0lPTiA9IHR5cGVvZiBcIjMuMC45XCIgIT09ICd1bmRlZmluZWQnID8gXCIzLjAuOVwiIDogJ2xhdGVzdCc7XG52YXIgTnVsbFdvcmtlckxvYWRlciA9IHtcbiAgbmFtZTogJ051bGwgbG9hZGVyJyxcbiAgaWQ6ICdudWxsJyxcbiAgbW9kdWxlOiAnY29yZScsXG4gIHZlcnNpb246IFZFUlNJT04sXG4gIHdvcmtlcjogdHJ1ZSxcbiAgbWltZVR5cGVzOiBbJ2FwcGxpY2F0aW9uL3guZW1wdHknXSxcbiAgZXh0ZW5zaW9uczogWydudWxsJ10sXG4gIHRlc3RzOiBbZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfV0sXG4gIG9wdGlvbnM6IHtcbiAgICBudWxsOiB7fVxuICB9XG59O1xuZXhwb3J0cy5OdWxsV29ya2VyTG9hZGVyID0gTnVsbFdvcmtlckxvYWRlcjtcbnZhciBOdWxsTG9hZGVyID0ge1xuICBuYW1lOiAnTnVsbCBsb2FkZXInLFxuICBpZDogJ251bGwnLFxuICBtb2R1bGU6ICdjb3JlJyxcbiAgdmVyc2lvbjogVkVSU0lPTixcbiAgbWltZVR5cGVzOiBbJ2FwcGxpY2F0aW9uL3guZW1wdHknXSxcbiAgZXh0ZW5zaW9uczogWydudWxsJ10sXG4gIHBhcnNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9wYXJzZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKGFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBhcnJheUJ1ZmZlcik7XG5cbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlKF94Mikge1xuICAgICAgcmV0dXJuIF9wYXJzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZTtcbiAgfSgpLFxuICBwYXJzZVN5bmM6IGZ1bmN0aW9uIHBhcnNlU3luYyhhcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBhcnJheUJ1ZmZlcjtcbiAgfSxcbiAgcGFyc2VJbkJhdGNoZXM6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2dlbmVyYXRvciA9ICgwLCBfd3JhcEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGFzeW5jSXRlcmF0b3IpIHtcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uLCBfZGlkSXRlcmF0b3JFcnJvciwgX2l0ZXJhdG9yRXJyb3IsIF9pdGVyYXRvciwgX3N0ZXAsIF92YWx1ZSwgYmF0Y2g7XG5cbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMjtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yID0gKDAsIF9hc3luY0l0ZXJhdG9yMi5kZWZhdWx0KShhc3luY0l0ZXJhdG9yKTtcblxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDY7XG4gICAgICAgICAgICAgIHJldHVybiAoMCwgX2F3YWl0QXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKF9pdGVyYXRvci5uZXh0KCkpO1xuXG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIF9zdGVwID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSBfc3RlcC5kb25lO1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEwO1xuICAgICAgICAgICAgICByZXR1cm4gKDAsIF9hd2FpdEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShfc3RlcC52YWx1ZSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIF92YWx1ZSA9IF9jb250ZXh0Mi5zZW50O1xuXG4gICAgICAgICAgICAgIGlmIChfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxODtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJhdGNoID0gX3ZhbHVlO1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE1O1xuICAgICAgICAgICAgICByZXR1cm4gYmF0Y2g7XG5cbiAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI0O1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAyMDtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gX2NvbnRleHQyW1wiY2F0Y2hcIl0oMik7XG4gICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBfY29udGV4dDIudDA7XG5cbiAgICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMjQ7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMjU7XG5cbiAgICAgICAgICAgICAgaWYgKCEoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI5O1xuICAgICAgICAgICAgICByZXR1cm4gKDAsIF9hd2FpdEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShfaXRlcmF0b3IucmV0dXJuKCkpO1xuXG4gICAgICAgICAgICBjYXNlIDI5OlxuICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDI5O1xuXG4gICAgICAgICAgICAgIGlmICghX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDMyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG5cbiAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuZmluaXNoKDI5KTtcblxuICAgICAgICAgICAgY2FzZSAzMzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5maW5pc2goMjQpO1xuXG4gICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUyLCBudWxsLCBbWzIsIDIwLCAyNCwgMzRdLCBbMjUsLCAyOSwgMzNdXSk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdG9yKF94KSB7XG4gICAgICByZXR1cm4gX2dlbmVyYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH0oKSxcbiAgdGVzdHM6IFtmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XSxcbiAgb3B0aW9uczoge1xuICAgIG51bGw6IHt9XG4gIH1cbn07XG5leHBvcnRzLk51bGxMb2FkZXIgPSBOdWxsTG9hZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVsbC1sb2FkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5fdHlwZWNoZWNrQ1NWTG9hZGVyID0gZXhwb3J0cy5DU1ZMb2FkZXIgPSB2b2lkIDA7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfdHlwZW9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfc2NoZW1hID0gcmVxdWlyZShcIkBsb2FkZXJzLmdsL3NjaGVtYVwiKTtcblxudmFyIF9wYXBhcGFyc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYnMvcGFwYXBhcnNlXCIpKTtcblxudmFyIF9hc3luY0l0ZXJhdG9yU3RyZWFtZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi9hc3luYy1pdGVyYXRvci1zdHJlYW1lclwiKSk7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgVkVSU0lPTiA9IHR5cGVvZiBcIjMuMC45XCIgIT09ICd1bmRlZmluZWQnID8gXCIzLjAuOVwiIDogJ2xhdGVzdCc7XG52YXIgREVGQVVMVF9DU1ZfTE9BREVSX09QVElPTlMgPSB7XG4gIGNzdjoge1xuICAgIHNoYXBlOiAnb2JqZWN0LXJvdy10YWJsZScsXG4gICAgb3B0aW1pemVNZW1vcnlVc2FnZTogZmFsc2UsXG4gICAgaGVhZGVyOiAnYXV0bycsXG4gICAgY29sdW1uUHJlZml4OiAnY29sdW1uJyxcbiAgICBxdW90ZUNoYXI6ICdcIicsXG4gICAgZXNjYXBlQ2hhcjogJ1wiJyxcbiAgICBkeW5hbWljVHlwaW5nOiB0cnVlLFxuICAgIGNvbW1lbnRzOiBmYWxzZSxcbiAgICBza2lwRW1wdHlMaW5lczogdHJ1ZSxcbiAgICBkZWxpbWl0ZXJzVG9HdWVzczogWycsJywgJ1xcdCcsICd8JywgJzsnXVxuICB9XG59O1xudmFyIENTVkxvYWRlciA9IHtcbiAgaWQ6ICdjc3YnLFxuICBtb2R1bGU6ICdjc3YnLFxuICBuYW1lOiAnQ1NWJyxcbiAgdmVyc2lvbjogVkVSU0lPTixcbiAgZXh0ZW5zaW9uczogWydjc3YnXSxcbiAgbWltZVR5cGVzOiBbJ3RleHQvY3N2J10sXG4gIGNhdGVnb3J5OiAndGFibGUnLFxuICBwYXJzZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcGFyc2UgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZShhcnJheUJ1ZmZlciwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgcGFyc2VDU1YobmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGFycmF5QnVmZmVyKSwgb3B0aW9ucykpO1xuXG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBwYXJzZShfeCwgX3gyKSB7XG4gICAgICByZXR1cm4gX3BhcnNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlO1xuICB9KCksXG4gIHBhcnNlVGV4dDogZnVuY3Rpb24gcGFyc2VUZXh0KHRleHQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcGFyc2VDU1YodGV4dCwgb3B0aW9ucyk7XG4gIH0sXG4gIHBhcnNlSW5CYXRjaGVzOiBwYXJzZUNTVkluQmF0Y2hlcyxcbiAgb3B0aW9uczogREVGQVVMVF9DU1ZfTE9BREVSX09QVElPTlNcbn07XG5leHBvcnRzLkNTVkxvYWRlciA9IENTVkxvYWRlcjtcblxuZnVuY3Rpb24gcGFyc2VDU1YoX3gzLCBfeDQpIHtcbiAgcmV0dXJuIF9wYXJzZUNTVi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfcGFyc2VDU1YoKSB7XG4gIF9wYXJzZUNTViA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMihjc3ZUZXh0LCBvcHRpb25zKSB7XG4gICAgdmFyIGNzdk9wdGlvbnMsIGZpcnN0Um93LCBoZWFkZXIsIHBhcnNlV2l0aEhlYWRlciwgcGFwYXBhcnNlQ29uZmlnLCByZXN1bHQsIHJvd3MsIGhlYWRlclJvdztcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjc3ZPcHRpb25zID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBERUZBVUxUX0NTVl9MT0FERVJfT1BUSU9OUy5jc3YpLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY3N2KTtcbiAgICAgICAgICAgIGZpcnN0Um93ID0gcmVhZEZpcnN0Um93KGNzdlRleHQpO1xuICAgICAgICAgICAgaGVhZGVyID0gY3N2T3B0aW9ucy5oZWFkZXIgPT09ICdhdXRvJyA/IGlzSGVhZGVyUm93KGZpcnN0Um93KSA6IEJvb2xlYW4oY3N2T3B0aW9ucy5oZWFkZXIpO1xuICAgICAgICAgICAgcGFyc2VXaXRoSGVhZGVyID0gaGVhZGVyO1xuICAgICAgICAgICAgcGFwYXBhcnNlQ29uZmlnID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjc3ZPcHRpb25zKSwge30sIHtcbiAgICAgICAgICAgICAgaGVhZGVyOiBwYXJzZVdpdGhIZWFkZXIsXG4gICAgICAgICAgICAgIGRvd25sb2FkOiBmYWxzZSxcbiAgICAgICAgICAgICAgdHJhbnNmb3JtSGVhZGVyOiBwYXJzZVdpdGhIZWFkZXIgPyBkdXBsaWNhdGVDb2x1bW5UcmFuc2Zvcm1lcigpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gZXJyb3IoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQgPSBfcGFwYXBhcnNlLmRlZmF1bHQucGFyc2UoY3N2VGV4dCwgcGFwYXBhcnNlQ29uZmlnKTtcbiAgICAgICAgICAgIHJvd3MgPSByZXN1bHQuZGF0YTtcbiAgICAgICAgICAgIGhlYWRlclJvdyA9IHJlc3VsdC5tZXRhLmZpZWxkcyB8fCBnZW5lcmF0ZUhlYWRlcihjc3ZPcHRpb25zLmNvbHVtblByZWZpeCwgZmlyc3RSb3cubGVuZ3RoKTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IGNzdk9wdGlvbnMuc2hhcGU7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IF9jb250ZXh0Mi50MCA9PT0gJ29iamVjdC1yb3ctdGFibGUnID8gMTEgOiBfY29udGV4dDIudDAgPT09ICdhcnJheS1yb3ctdGFibGUnID8gMTMgOiAxNTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIHJvd3MgPSByb3dzLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHJvdykgPyAoMCwgX3NjaGVtYS5jb252ZXJ0VG9PYmplY3RSb3cpKHJvdywgaGVhZGVyUm93KSA6IHJvdztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJicmVha1wiLCAxNSk7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgcm93cyA9IHJvd3MubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocm93KSA/IHJvdyA6ICgwLCBfc2NoZW1hLmNvbnZlcnRUb0FycmF5Um93KShyb3csIGhlYWRlclJvdyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwiYnJlYWtcIiwgMTUpO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHJvd3MpO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyKTtcbiAgfSkpO1xuICByZXR1cm4gX3BhcnNlQ1NWLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ1NWSW5CYXRjaGVzKGFzeW5jSXRlcmF0b3IsIG9wdGlvbnMpIHtcbiAgdmFyIF9vcHRpb25zO1xuXG4gIG9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucy5iYXRjaFNpemUgPT09ICdhdXRvJykge1xuICAgIG9wdGlvbnMuYmF0Y2hTaXplID0gNDAwMDtcbiAgfVxuXG4gIHZhciBjc3ZPcHRpb25zID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBERUZBVUxUX0NTVl9MT0FERVJfT1BUSU9OUy5jc3YpLCAoX29wdGlvbnMgPSBvcHRpb25zKSA9PT0gbnVsbCB8fCBfb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdGlvbnMuY3N2KTtcblxuICB2YXIgYXN5bmNRdWV1ZSA9IG5ldyBfc2NoZW1hLkFzeW5jUXVldWUoKTtcbiAgdmFyIGlzRmlyc3RSb3cgPSB0cnVlO1xuICB2YXIgaGVhZGVyUm93ID0gbnVsbDtcbiAgdmFyIHRhYmxlQmF0Y2hCdWlsZGVyID0gbnVsbDtcbiAgdmFyIHNjaGVtYSA9IG51bGw7XG5cbiAgdmFyIGNvbmZpZyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgY3N2T3B0aW9ucyksIHt9LCB7XG4gICAgaGVhZGVyOiBmYWxzZSxcbiAgICBkb3dubG9hZDogZmFsc2UsXG4gICAgY2h1bmtTaXplOiAxMDI0ICogMTAyNCAqIDUsXG4gICAgc2tpcEVtcHR5TGluZXM6IGZhbHNlLFxuICAgIHN0ZXA6IGZ1bmN0aW9uIHN0ZXAocmVzdWx0cykge1xuICAgICAgdmFyIHJvdyA9IHJlc3VsdHMuZGF0YTtcblxuICAgICAgaWYgKGNzdk9wdGlvbnMuc2tpcEVtcHR5TGluZXMpIHtcbiAgICAgICAgdmFyIGNvbGxhcHNlZFJvdyA9IHJvdy5mbGF0KCkuam9pbignJykudHJpbSgpO1xuXG4gICAgICAgIGlmIChjb2xsYXBzZWRSb3cgPT09ICcnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBieXRlc1VzZWQgPSByZXN1bHRzLm1ldGEuY3Vyc29yO1xuXG4gICAgICBpZiAoaXNGaXJzdFJvdyAmJiAhaGVhZGVyUm93KSB7XG4gICAgICAgIHZhciBoZWFkZXIgPSBjc3ZPcHRpb25zLmhlYWRlciA9PT0gJ2F1dG8nID8gaXNIZWFkZXJSb3cocm93KSA6IEJvb2xlYW4oY3N2T3B0aW9ucy5oZWFkZXIpO1xuXG4gICAgICAgIGlmIChoZWFkZXIpIHtcbiAgICAgICAgICBoZWFkZXJSb3cgPSByb3cubWFwKGR1cGxpY2F0ZUNvbHVtblRyYW5zZm9ybWVyKCkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNGaXJzdFJvdykge1xuICAgICAgICBpc0ZpcnN0Um93ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCFoZWFkZXJSb3cpIHtcbiAgICAgICAgICBoZWFkZXJSb3cgPSBnZW5lcmF0ZUhlYWRlcihjc3ZPcHRpb25zLmNvbHVtblByZWZpeCwgcm93Lmxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBzY2hlbWEgPSBkZWR1Y2VTY2hlbWEocm93LCBoZWFkZXJSb3cpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3N2T3B0aW9ucy5vcHRpbWl6ZU1lbW9yeVVzYWdlKSB7XG4gICAgICAgIHJvdyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocm93KSk7XG4gICAgICB9XG5cbiAgICAgIHRhYmxlQmF0Y2hCdWlsZGVyID0gdGFibGVCYXRjaEJ1aWxkZXIgfHwgbmV3IF9zY2hlbWEuVGFibGVCYXRjaEJ1aWxkZXIoc2NoZW1hLCBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgc2hhcGU6IGNzdk9wdGlvbnMuc2hhcGUgfHwgJ2FycmF5LXJvdy10YWJsZSdcbiAgICAgIH0sIG9wdGlvbnMpKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdGFibGVCYXRjaEJ1aWxkZXIuYWRkUm93KHJvdyk7XG4gICAgICAgIHZhciBiYXRjaCA9IHRhYmxlQmF0Y2hCdWlsZGVyICYmIHRhYmxlQmF0Y2hCdWlsZGVyLmdldEZ1bGxCYXRjaCh7XG4gICAgICAgICAgYnl0ZXNVc2VkOiBieXRlc1VzZWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGJhdGNoKSB7XG4gICAgICAgICAgYXN5bmNRdWV1ZS5lbnF1ZXVlKGJhdGNoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXN5bmNRdWV1ZS5lbnF1ZXVlKGVycm9yKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZShyZXN1bHRzKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgYnl0ZXNVc2VkID0gcmVzdWx0cy5tZXRhLmN1cnNvcjtcbiAgICAgICAgdmFyIGJhdGNoID0gdGFibGVCYXRjaEJ1aWxkZXIgJiYgdGFibGVCYXRjaEJ1aWxkZXIuZ2V0RmluYWxCYXRjaCh7XG4gICAgICAgICAgYnl0ZXNVc2VkOiBieXRlc1VzZWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGJhdGNoKSB7XG4gICAgICAgICAgYXN5bmNRdWV1ZS5lbnF1ZXVlKGJhdGNoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXN5bmNRdWV1ZS5lbnF1ZXVlKGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgYXN5bmNRdWV1ZS5jbG9zZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgX3BhcGFwYXJzZS5kZWZhdWx0LnBhcnNlKGFzeW5jSXRlcmF0b3IsIGNvbmZpZywgX2FzeW5jSXRlcmF0b3JTdHJlYW1lci5kZWZhdWx0KTtcblxuICByZXR1cm4gYXN5bmNRdWV1ZTtcbn1cblxuZnVuY3Rpb24gaXNIZWFkZXJSb3cocm93KSB7XG4gIHJldHVybiByb3cgJiYgcm93LmV2ZXJ5KGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVhZEZpcnN0Um93KGNzdlRleHQpIHtcbiAgdmFyIHJlc3VsdCA9IF9wYXBhcGFyc2UuZGVmYXVsdC5wYXJzZShjc3ZUZXh0LCB7XG4gICAgZG93bmxvYWQ6IGZhbHNlLFxuICAgIGR5bmFtaWNUeXBpbmc6IHRydWUsXG4gICAgcHJldmlldzogMVxuICB9KTtcblxuICByZXR1cm4gcmVzdWx0LmRhdGFbMF07XG59XG5cbmZ1bmN0aW9uIGR1cGxpY2F0ZUNvbHVtblRyYW5zZm9ybWVyKCkge1xuICB2YXIgb2JzZXJ2ZWRDb2x1bW5zID0gbmV3IFNldCgpO1xuICByZXR1cm4gZnVuY3Rpb24gKGNvbCkge1xuICAgIHZhciBjb2xOYW1lID0gY29sO1xuICAgIHZhciBjb3VudGVyID0gMTtcblxuICAgIHdoaWxlIChvYnNlcnZlZENvbHVtbnMuaGFzKGNvbE5hbWUpKSB7XG4gICAgICBjb2xOYW1lID0gXCJcIi5jb25jYXQoY29sLCBcIi5cIikuY29uY2F0KGNvdW50ZXIpO1xuICAgICAgY291bnRlcisrO1xuICAgIH1cblxuICAgIG9ic2VydmVkQ29sdW1ucy5hZGQoY29sTmFtZSk7XG4gICAgcmV0dXJuIGNvbE5hbWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlSGVhZGVyKGNvbHVtblByZWZpeCkge1xuICB2YXIgY291bnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gIHZhciBoZWFkZXJzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgaGVhZGVycy5wdXNoKFwiXCIuY29uY2F0KGNvbHVtblByZWZpeCkuY29uY2F0KGkgKyAxKSk7XG4gIH1cblxuICByZXR1cm4gaGVhZGVycztcbn1cblxuZnVuY3Rpb24gZGVkdWNlU2NoZW1hKHJvdywgaGVhZGVyUm93KSB7XG4gIHZhciBzY2hlbWEgPSBoZWFkZXJSb3cgPyB7fSA6IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvbHVtbk5hbWUgPSBoZWFkZXJSb3cgJiYgaGVhZGVyUm93W2ldIHx8IGk7XG4gICAgdmFyIHZhbHVlID0gcm93W2ldO1xuXG4gICAgc3dpdGNoICgoMCwgX3R5cGVvZjIuZGVmYXVsdCkodmFsdWUpKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHNjaGVtYVtjb2x1bW5OYW1lXSA9IHtcbiAgICAgICAgICBuYW1lOiBTdHJpbmcoY29sdW1uTmFtZSksXG4gICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgdHlwZTogRmxvYXQzMkFycmF5XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc2NoZW1hW2NvbHVtbk5hbWVdID0ge1xuICAgICAgICAgIG5hbWU6IFN0cmluZyhjb2x1bW5OYW1lKSxcbiAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICB0eXBlOiBBcnJheVxuICAgICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzY2hlbWE7XG59XG5cbnZhciBfdHlwZWNoZWNrQ1NWTG9hZGVyID0gQ1NWTG9hZGVyO1xuZXhwb3J0cy5fdHlwZWNoZWNrQ1NWTG9hZGVyID0gX3R5cGVjaGVja0NTVkxvYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNzdi1sb2FkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDU1ZMb2FkZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2NzdkxvYWRlci5DU1ZMb2FkZXI7XG4gIH1cbn0pO1xuXG52YXIgX2NzdkxvYWRlciA9IHJlcXVpcmUoXCIuL2Nzdi1sb2FkZXJcIik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBBc3luY0l0ZXJhdG9yU3RyZWFtZXI7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jSXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY0l0ZXJhdG9yXCIpKTtcblxudmFyIF9wYXBhcGFyc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9saWJzL3BhcGFwYXJzZVwiKSk7XG5cbnZhciBDaHVua1N0cmVhbWVyID0gX3BhcGFwYXJzZS5kZWZhdWx0LkNodW5rU3RyZWFtZXI7XG5cbmZ1bmN0aW9uIEFzeW5jSXRlcmF0b3JTdHJlYW1lcihjb25maWcpIHtcbiAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICBDaHVua1N0cmVhbWVyLmNhbGwodGhpcywgY29uZmlnKTtcbiAgdGhpcy50ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2Rlcih0aGlzLl9jb25maWcuZW5jb2RpbmcpO1xuXG4gIHRoaXMuc3RyZWFtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoYXN5bmNJdGVyYXRvcikge1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24sIF9kaWRJdGVyYXRvckVycm9yLCBfaXRlcmF0b3JFcnJvciwgX2l0ZXJhdG9yLCBfc3RlcCwgX3ZhbHVlLCBjaHVuaztcblxuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHRoaXMuX2lucHV0ID0gYXN5bmNJdGVyYXRvcjtcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDE7XG4gICAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gNDtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yID0gKDAsIF9hc3luY0l0ZXJhdG9yMi5kZWZhdWx0KShhc3luY0l0ZXJhdG9yKTtcblxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gODtcbiAgICAgICAgICAgICAgcmV0dXJuIF9pdGVyYXRvci5uZXh0KCk7XG5cbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgX3N0ZXAgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gX3N0ZXAuZG9uZTtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEyO1xuICAgICAgICAgICAgICByZXR1cm4gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgIF92YWx1ZSA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24pIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjaHVuayA9IF92YWx1ZTtcbiAgICAgICAgICAgICAgdGhpcy5wYXJzZUNodW5rKHRoaXMuZ2V0U3RyaW5nQ2h1bmsoY2h1bmspKTtcblxuICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2O1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI1O1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDIxO1xuICAgICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oNCk7XG4gICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBfY29udGV4dC50MDtcblxuICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDI1O1xuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjY7XG5cbiAgICAgICAgICAgICAgaWYgKCEoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzMDtcbiAgICAgICAgICAgICAgcmV0dXJuIF9pdGVyYXRvci5yZXR1cm4oKTtcblxuICAgICAgICAgICAgY2FzZSAzMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDMwO1xuXG4gICAgICAgICAgICAgIGlmICghX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMzM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcblxuICAgICAgICAgICAgY2FzZSAzMzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmZpbmlzaCgzMCk7XG5cbiAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5maW5pc2goMjUpO1xuXG4gICAgICAgICAgICBjYXNlIDM1OlxuICAgICAgICAgICAgICB0aGlzLl9maW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgIHRoaXMucGFyc2VDaHVuaygnJyk7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0MjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAzOTtcbiAgICAgICAgICAgICAgX2NvbnRleHQudDEgPSBfY29udGV4dFtcImNhdGNoXCJdKDEpO1xuXG4gICAgICAgICAgICAgIHRoaXMuX3NlbmRFcnJvcihfY29udGV4dC50MSk7XG5cbiAgICAgICAgICAgIGNhc2UgNDI6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlLCB0aGlzLCBbWzEsIDM5XSwgWzQsIDIxLCAyNSwgMzVdLCBbMjYsLCAzMCwgMzRdXSk7XG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChfeCkge1xuICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9KCk7XG5cbiAgdGhpcy5fbmV4dENodW5rID0gZnVuY3Rpb24gbmV4dENodW5rKCkge307XG5cbiAgdGhpcy5nZXRTdHJpbmdDaHVuayA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIHJldHVybiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnID8gY2h1bmsgOiB0aGlzLnRleHREZWNvZGVyLmRlY29kZShjaHVuaywge1xuICAgICAgc3RyZWFtOiB0cnVlXG4gICAgfSk7XG4gIH07XG59XG5cbkFzeW5jSXRlcmF0b3JTdHJlYW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENodW5rU3RyZWFtZXIucHJvdG90eXBlKTtcbkFzeW5jSXRlcmF0b3JTdHJlYW1lci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBc3luY0l0ZXJhdG9yU3RyZWFtZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3luYy1pdGVyYXRvci1zdHJlYW1lci5qcy5tYXAiLCIvLyBUaGlzIGlzIGEgZm9yayBvZiBwYXBhcGFyc2Vcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taG9sdC9QYXBhUGFyc2Vcbi8qIEBsaWNlbnNlXG5QYXBhIFBhcnNlXG52NS4wLjAtYmV0YS4wXG5odHRwczovL2dpdGh1Yi5jb20vbWhvbHQvUGFwYVBhcnNlXG5MaWNlbnNlOiBNSVRcbiovXG4vLyBGT1JLIFNVTU1BUlk6XG4vLyAtIEFkb3B0IEVTNiBleHBvcnRzXG4vLyAtIEltcGxlbWVudCBuZXcgQXN5bmNJdGVyYXRvclN0cmVhbWVyXG4vLyAtIFJlbW92ZSBub24gQXN5bmMgSXRlcmF0b3Igc3RyZWFtZXJzIChjYW4gYWxsIGJlIGhhbmRsZWQgYnkgbmV3IHN0cmVhbWVyKVxuLy8gLSBSZW1vdmUgdW51c2VkIFdvcmtlciBzdXBwb3J0IChsb2FkZXJzLmdsIHdvcmtlciBzeXN0ZW0gdXNlZCBpbnN0ZWFkKVxuLy8gLSBSZW1vdmUgdW51c2VkIGpRdWVyeSBwbHVnaW4gc3VwcG9ydFxuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLy8gQHRzLW5vY2hlY2tcbnZhciBnbG9iYWwgPSAoZnVuY3Rpb24oKSB7XG4gIC8vIGFsdGVybmF0aXZlIG1ldGhvZCwgc2ltaWxhciB0byBgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKWBcbiAgLy8gYnV0IHdpdGhvdXQgdXNpbmcgYGV2YWxgICh3aGljaCBpcyBkaXNhYmxlZCB3aGVuXG4gIC8vIHVzaW5nIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5KS5cblxuICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZ2xvYmFsO1xuICB9XG5cbiAgLy8gV2hlbiBydW5uaW5nIHRlc3RzIG5vbmUgb2YgdGhlIGFib3ZlIGhhdmUgYmVlbiBkZWZpbmVkXG4gIHJldHVybiB7fTtcbn0pKCk7XG5cbnZhciBJU19QQVBBX1dPUktFUiA9IGZhbHNlO1xuXG52YXIgUGFwYSA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBQYXBhO1xuUGFwYS5wYXJzZSA9IENzdlRvSnNvbjtcblBhcGEudW5wYXJzZSA9IEpzb25Ub0NzdjtcblxuUGFwYS5SRUNPUkRfU0VQID0gU3RyaW5nLmZyb21DaGFyQ29kZSgzMCk7XG5QYXBhLlVOSVRfU0VQID0gU3RyaW5nLmZyb21DaGFyQ29kZSgzMSk7XG5QYXBhLkJZVEVfT1JERVJfTUFSSyA9ICdcXHVmZWZmJztcblBhcGEuQkFEX0RFTElNSVRFUlMgPSBbJ1xccicsICdcXG4nLCAnXCInLCBQYXBhLkJZVEVfT1JERVJfTUFSS107XG5QYXBhLldPUktFUlNfU1VQUE9SVEVEID0gZmFsc2U7IC8vICFJU19XT1JLRVIgJiYgISFnbG9iYWwuV29ya2VyO1xuUGFwYS5OT0RFX1NUUkVBTV9JTlBVVCA9IDE7XG5cbi8vIENvbmZpZ3VyYWJsZSBjaHVuayBzaXplcyBmb3IgbG9jYWwgYW5kIHJlbW90ZSBmaWxlcywgcmVzcGVjdGl2ZWx5XG5QYXBhLkxvY2FsQ2h1bmtTaXplID0gMTAyNCAqIDEwMjQgKiAxMDsgLy8gMTAgTUJcblBhcGEuUmVtb3RlQ2h1bmtTaXplID0gMTAyNCAqIDEwMjQgKiA1OyAvLyA1IE1CXG5QYXBhLkRlZmF1bHREZWxpbWl0ZXIgPSAnLCc7IC8vIFVzZWQgaWYgbm90IHNwZWNpZmllZCBhbmQgZGV0ZWN0aW9uIGZhaWxzXG5cbi8vIEV4cG9zZWQgZm9yIHRlc3RpbmcgYW5kIGRldmVsb3BtZW50IG9ubHlcblBhcGEuUGFyc2VyID0gUGFyc2VyO1xuUGFwYS5QYXJzZXJIYW5kbGUgPSBQYXJzZXJIYW5kbGU7XG5cbi8vIEJFR0lOIEZPUktcblBhcGEuQ2h1bmtTdHJlYW1lciA9IENodW5rU3RyZWFtZXI7XG5QYXBhLlN0cmluZ1N0cmVhbWVyID0gU3RyaW5nU3RyZWFtZXI7XG4vKlxuUGFwYS5OZXR3b3JrU3RyZWFtZXIgPSBOZXR3b3JrU3RyZWFtZXI7XG5QYXBhLkZpbGVTdHJlYW1lciA9IEZpbGVTdHJlYW1lcjtcblBhcGEuUmVhZGFibGVTdHJlYW1TdHJlYW1lciA9IFJlYWRhYmxlU3RyZWFtU3RyZWFtZXI7XG5pZiAodHlwZW9mIFBBUEFfQlJPV1NFUl9DT05URVhUID09PSAndW5kZWZpbmVkJykge1xuICBQYXBhLkR1cGxleFN0cmVhbVN0cmVhbWVyID0gRHVwbGV4U3RyZWFtU3RyZWFtZXI7XG59XG4qL1xuLy8gRU5EIEZPUktcblxuLy8gQkVHSU4gRk9SS1xuLy8gQWRkcyBhbiBhcmd1bWVudCB0byBwYXBhLnBhcnNlXG4vLyBmdW5jdGlvbiBDc3ZUb0pzb24oX2lucHV0LCBfY29uZmlnKVxuZnVuY3Rpb24gQ3N2VG9Kc29uKFxuICBfaW5wdXQsXG4gIF9jb25maWcsXG4gIFVzZXJEZWZpbmVkU3RyZWFtZXIgLy8gQkVHSU4gRk9SS1xuKSB7XG4gIF9jb25maWcgPSBfY29uZmlnIHx8IHt9O1xuICB2YXIgZHluYW1pY1R5cGluZyA9IF9jb25maWcuZHluYW1pY1R5cGluZyB8fCBmYWxzZTtcbiAgaWYgKGlzRnVuY3Rpb24oZHluYW1pY1R5cGluZykpIHtcbiAgICBfY29uZmlnLmR5bmFtaWNUeXBpbmdGdW5jdGlvbiA9IGR5bmFtaWNUeXBpbmc7XG4gICAgLy8gV2lsbCBiZSBmaWxsZWQgb24gZmlyc3Qgcm93IGNhbGxcbiAgICBkeW5hbWljVHlwaW5nID0ge307XG4gIH1cbiAgX2NvbmZpZy5keW5hbWljVHlwaW5nID0gZHluYW1pY1R5cGluZztcblxuICBfY29uZmlnLnRyYW5zZm9ybSA9IGlzRnVuY3Rpb24oX2NvbmZpZy50cmFuc2Zvcm0pID8gX2NvbmZpZy50cmFuc2Zvcm0gOiBmYWxzZTtcblxuICBpZiAoX2NvbmZpZy53b3JrZXIgJiYgUGFwYS5XT1JLRVJTX1NVUFBPUlRFRCkge1xuICAgIHZhciB3ID0gbmV3V29ya2VyKCk7XG5cbiAgICB3LnVzZXJTdGVwID0gX2NvbmZpZy5zdGVwO1xuICAgIHcudXNlckNodW5rID0gX2NvbmZpZy5jaHVuaztcbiAgICB3LnVzZXJDb21wbGV0ZSA9IF9jb25maWcuY29tcGxldGU7XG4gICAgdy51c2VyRXJyb3IgPSBfY29uZmlnLmVycm9yO1xuXG4gICAgX2NvbmZpZy5zdGVwID0gaXNGdW5jdGlvbihfY29uZmlnLnN0ZXApO1xuICAgIF9jb25maWcuY2h1bmsgPSBpc0Z1bmN0aW9uKF9jb25maWcuY2h1bmspO1xuICAgIF9jb25maWcuY29tcGxldGUgPSBpc0Z1bmN0aW9uKF9jb25maWcuY29tcGxldGUpO1xuICAgIF9jb25maWcuZXJyb3IgPSBpc0Z1bmN0aW9uKF9jb25maWcuZXJyb3IpO1xuICAgIGRlbGV0ZSBfY29uZmlnLndvcmtlcjsgLy8gcHJldmVudCBpbmZpbml0ZSBsb29wXG5cbiAgICB3LnBvc3RNZXNzYWdlKHtcbiAgICAgIGlucHV0OiBfaW5wdXQsXG4gICAgICBjb25maWc6IF9jb25maWcsXG4gICAgICB3b3JrZXJJZDogdy5pZFxuICAgIH0pO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHN0cmVhbWVyID0gbnVsbDtcbiAgLypcbiAgaWYgKF9pbnB1dCA9PT0gUGFwYS5OT0RFX1NUUkVBTV9JTlBVVCAmJiB0eXBlb2YgUEFQQV9CUk9XU0VSX0NPTlRFWFQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gY3JlYXRlIGEgbm9kZSBEdXBsZXggc3RyZWFtIGZvciB1c2VcbiAgICAvLyB3aXRoIC5waXBlXG4gICAgc3RyZWFtZXIgPSBuZXcgRHVwbGV4U3RyZWFtU3RyZWFtZXIoX2NvbmZpZyk7XG4gICAgcmV0dXJuIHN0cmVhbWVyLmdldFN0cmVhbSgpO1xuICB9IGVsc2VcbiAgKi9cbiAgaWYgKHR5cGVvZiBfaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gaWYgKF9jb25maWcuZG93bmxvYWQpIHN0cmVhbWVyID0gbmV3IE5ldHdvcmtTdHJlYW1lcihfY29uZmlnKTtcbiAgICAvLyBlbHNlXG4gICAgc3RyZWFtZXIgPSBuZXcgU3RyaW5nU3RyZWFtZXIoX2NvbmZpZyk7XG4gIH1cbiAgLypcbiAgZWxzZSBpZiAoX2lucHV0LnJlYWRhYmxlID09PSB0cnVlICYmIGlzRnVuY3Rpb24oX2lucHV0LnJlYWQpICYmIGlzRnVuY3Rpb24oX2lucHV0Lm9uKSkge1xuICAgIHN0cmVhbWVyID0gbmV3IFJlYWRhYmxlU3RyZWFtU3RyZWFtZXIoX2NvbmZpZyk7XG4gIH0gZWxzZSBpZiAoKGdsb2JhbC5GaWxlICYmIF9pbnB1dCBpbnN0YW5jZW9mIEZpbGUpIHx8IF9pbnB1dCBpbnN0YW5jZW9mIE9iamVjdClcbiAgICAvLyAuLi5TYWZhcmkuIChzZWUgaXNzdWUgIzEwNilcbiAgICBzdHJlYW1lciA9IG5ldyBGaWxlU3RyZWFtZXIoX2NvbmZpZyk7XG4gICovXG5cbiAgLy8gQkVHSU4gRk9SS1xuICBpZiAoIXN0cmVhbWVyKSB7XG4gICAgc3RyZWFtZXIgPSBuZXcgVXNlckRlZmluZWRTdHJlYW1lcihfY29uZmlnKTtcbiAgfVxuICAvLyBFTkQgRk9SS1xuXG4gIHJldHVybiBzdHJlYW1lci5zdHJlYW0oX2lucHV0KTtcbn1cblxuZnVuY3Rpb24gSnNvblRvQ3N2KF9pbnB1dCwgX2NvbmZpZykge1xuICAvLyBEZWZhdWx0IGNvbmZpZ3VyYXRpb25cblxuICAvKiogd2hldGhlciB0byBzdXJyb3VuZCBldmVyeSBkYXR1bSB3aXRoIHF1b3RlcyAqL1xuICB2YXIgX3F1b3RlcyA9IGZhbHNlO1xuXG4gIC8qKiB3aGV0aGVyIHRvIHdyaXRlIGhlYWRlcnMgKi9cbiAgdmFyIF93cml0ZUhlYWRlciA9IHRydWU7XG5cbiAgLyoqIGRlbGltaXRpbmcgY2hhcmFjdGVyKHMpICovXG4gIHZhciBfZGVsaW1pdGVyID0gJywnO1xuXG4gIC8qKiBuZXdsaW5lIGNoYXJhY3RlcihzKSAqL1xuICB2YXIgX25ld2xpbmUgPSAnXFxyXFxuJztcblxuICAvKiogcXVvdGUgY2hhcmFjdGVyICovXG4gIHZhciBfcXVvdGVDaGFyID0gJ1wiJztcblxuICAvKiogZXNjYXBlZCBxdW90ZSBjaGFyYWN0ZXIsIGVpdGhlciBcIlwiIG9yIDxjb25maWcuZXNjYXBlQ2hhcj5cIiAqL1xuICB2YXIgX2VzY2FwZWRRdW90ZSA9IF9xdW90ZUNoYXIgKyBfcXVvdGVDaGFyO1xuXG4gIC8qKiB3aGV0aGVyIHRvIHNraXAgZW1wdHkgbGluZXMgKi9cbiAgdmFyIF9za2lwRW1wdHlMaW5lcyA9IGZhbHNlO1xuXG4gIC8qKiB0aGUgY29sdW1ucyAoa2V5cykgd2UgZXhwZWN0IHdoZW4gd2UgdW5wYXJzZSBvYmplY3RzICovXG4gIHZhciBfY29sdW1ucyA9IG51bGw7XG5cbiAgdW5wYWNrQ29uZmlnKCk7XG5cbiAgdmFyIHF1b3RlQ2hhclJlZ2V4ID0gbmV3IFJlZ0V4cChlc2NhcGVSZWdFeHAoX3F1b3RlQ2hhciksICdnJyk7XG5cbiAgaWYgKHR5cGVvZiBfaW5wdXQgPT09ICdzdHJpbmcnKSBfaW5wdXQgPSBKU09OLnBhcnNlKF9pbnB1dCk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoX2lucHV0KSkge1xuICAgIGlmICghX2lucHV0Lmxlbmd0aCB8fCBBcnJheS5pc0FycmF5KF9pbnB1dFswXSkpIHJldHVybiBzZXJpYWxpemUobnVsbCwgX2lucHV0LCBfc2tpcEVtcHR5TGluZXMpO1xuICAgIGVsc2UgaWYgKHR5cGVvZiBfaW5wdXRbMF0gPT09ICdvYmplY3QnKVxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZShfY29sdW1ucyB8fCBvYmplY3RLZXlzKF9pbnB1dFswXSksIF9pbnB1dCwgX3NraXBFbXB0eUxpbmVzKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgX2lucHV0ID09PSAnb2JqZWN0Jykge1xuICAgIGlmICh0eXBlb2YgX2lucHV0LmRhdGEgPT09ICdzdHJpbmcnKSBfaW5wdXQuZGF0YSA9IEpTT04ucGFyc2UoX2lucHV0LmRhdGEpO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoX2lucHV0LmRhdGEpKSB7XG4gICAgICBpZiAoIV9pbnB1dC5maWVsZHMpIF9pbnB1dC5maWVsZHMgPSBfaW5wdXQubWV0YSAmJiBfaW5wdXQubWV0YS5maWVsZHM7XG5cbiAgICAgIGlmICghX2lucHV0LmZpZWxkcylcbiAgICAgICAgX2lucHV0LmZpZWxkcyA9IEFycmF5LmlzQXJyYXkoX2lucHV0LmRhdGFbMF0pID8gX2lucHV0LmZpZWxkcyA6IG9iamVjdEtleXMoX2lucHV0LmRhdGFbMF0pO1xuXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoX2lucHV0LmRhdGFbMF0pICYmIHR5cGVvZiBfaW5wdXQuZGF0YVswXSAhPT0gJ29iamVjdCcpXG4gICAgICAgIF9pbnB1dC5kYXRhID0gW19pbnB1dC5kYXRhXTsgLy8gaGFuZGxlcyBpbnB1dCBsaWtlIFsxLDIsM10gb3IgWydhc2RmJ11cbiAgICB9XG5cbiAgICByZXR1cm4gc2VyaWFsaXplKF9pbnB1dC5maWVsZHMgfHwgW10sIF9pbnB1dC5kYXRhIHx8IFtdLCBfc2tpcEVtcHR5TGluZXMpO1xuICB9XG5cbiAgLy8gRGVmYXVsdCAoYW55IHZhbGlkIHBhdGhzIHNob3VsZCByZXR1cm4gYmVmb3JlIHRoaXMpXG4gIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHNlcmlhbGl6ZSB1bnJlY29nbml6ZWQgaW5wdXQnKTtcblxuICBmdW5jdGlvbiB1bnBhY2tDb25maWcoKSB7XG4gICAgaWYgKHR5cGVvZiBfY29uZmlnICE9PSAnb2JqZWN0JykgcmV0dXJuO1xuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIF9jb25maWcuZGVsaW1pdGVyID09PSAnc3RyaW5nJyAmJlxuICAgICAgIVBhcGEuQkFEX0RFTElNSVRFUlMuZmlsdGVyKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfY29uZmlnLmRlbGltaXRlci5pbmRleE9mKHZhbHVlKSAhPT0gLTE7XG4gICAgICB9KS5sZW5ndGhcbiAgICApIHtcbiAgICAgIF9kZWxpbWl0ZXIgPSBfY29uZmlnLmRlbGltaXRlcjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIF9jb25maWcucXVvdGVzID09PSAnYm9vbGVhbicgfHwgQXJyYXkuaXNBcnJheShfY29uZmlnLnF1b3RlcykpXG4gICAgICBfcXVvdGVzID0gX2NvbmZpZy5xdW90ZXM7XG5cbiAgICBpZiAodHlwZW9mIF9jb25maWcuc2tpcEVtcHR5TGluZXMgPT09ICdib29sZWFuJyB8fCB0eXBlb2YgX2NvbmZpZy5za2lwRW1wdHlMaW5lcyA9PT0gJ3N0cmluZycpXG4gICAgICBfc2tpcEVtcHR5TGluZXMgPSBfY29uZmlnLnNraXBFbXB0eUxpbmVzO1xuXG4gICAgaWYgKHR5cGVvZiBfY29uZmlnLm5ld2xpbmUgPT09ICdzdHJpbmcnKSBfbmV3bGluZSA9IF9jb25maWcubmV3bGluZTtcblxuICAgIGlmICh0eXBlb2YgX2NvbmZpZy5xdW90ZUNoYXIgPT09ICdzdHJpbmcnKSBfcXVvdGVDaGFyID0gX2NvbmZpZy5xdW90ZUNoYXI7XG5cbiAgICBpZiAodHlwZW9mIF9jb25maWcuaGVhZGVyID09PSAnYm9vbGVhbicpIF93cml0ZUhlYWRlciA9IF9jb25maWcuaGVhZGVyO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoX2NvbmZpZy5jb2x1bW5zKSkge1xuICAgICAgaWYgKF9jb25maWcuY29sdW1ucy5sZW5ndGggPT09IDApIHRocm93IG5ldyBFcnJvcignT3B0aW9uIGNvbHVtbnMgaXMgZW1wdHknKTtcblxuICAgICAgX2NvbHVtbnMgPSBfY29uZmlnLmNvbHVtbnM7XG4gICAgfVxuXG4gICAgaWYgKF9jb25maWcuZXNjYXBlQ2hhciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBfZXNjYXBlZFF1b3RlID0gX2NvbmZpZy5lc2NhcGVDaGFyICsgX3F1b3RlQ2hhcjtcbiAgICB9XG4gIH1cblxuICAvKiogVHVybnMgYW4gb2JqZWN0J3Mga2V5cyBpbnRvIGFuIGFycmF5ICovXG4gIGZ1bmN0aW9uIG9iamVjdEtleXMob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSByZXR1cm4gW107XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgICByZXR1cm4ga2V5cztcbiAgfVxuXG4gIC8qKiBUaGUgZG91YmxlIGZvciBsb29wIHRoYXQgaXRlcmF0ZXMgdGhlIGRhdGEgYW5kIHdyaXRlcyBvdXQgYSBDU1Ygc3RyaW5nIGluY2x1ZGluZyBoZWFkZXIgcm93ICovXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZShmaWVsZHMsIGRhdGEsIHNraXBFbXB0eUxpbmVzKSB7XG4gICAgdmFyIGNzdiA9ICcnO1xuXG4gICAgaWYgKHR5cGVvZiBmaWVsZHMgPT09ICdzdHJpbmcnKSBmaWVsZHMgPSBKU09OLnBhcnNlKGZpZWxkcyk7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG5cbiAgICB2YXIgaGFzSGVhZGVyID0gQXJyYXkuaXNBcnJheShmaWVsZHMpICYmIGZpZWxkcy5sZW5ndGggPiAwO1xuICAgIHZhciBkYXRhS2V5ZWRCeUZpZWxkID0gIUFycmF5LmlzQXJyYXkoZGF0YVswXSk7XG5cbiAgICAvLyBJZiB0aGVyZSBhIGhlYWRlciByb3csIHdyaXRlIGl0IGZpcnN0XG4gICAgaWYgKGhhc0hlYWRlciAmJiBfd3JpdGVIZWFkZXIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpID4gMCkgY3N2ICs9IF9kZWxpbWl0ZXI7XG4gICAgICAgIGNzdiArPSBzYWZlKGZpZWxkc1tpXSwgaSk7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSBjc3YgKz0gX25ld2xpbmU7XG4gICAgfVxuXG4gICAgLy8gVGhlbiB3cml0ZSBvdXQgdGhlIGRhdGFcbiAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBkYXRhLmxlbmd0aDsgcm93KyspIHtcbiAgICAgIHZhciBtYXhDb2wgPSBoYXNIZWFkZXIgPyBmaWVsZHMubGVuZ3RoIDogZGF0YVtyb3ddLmxlbmd0aDtcblxuICAgICAgdmFyIGVtcHR5TGluZSA9IGZhbHNlO1xuICAgICAgdmFyIG51bGxMaW5lID0gaGFzSGVhZGVyID8gT2JqZWN0LmtleXMoZGF0YVtyb3ddKS5sZW5ndGggPT09IDAgOiBkYXRhW3Jvd10ubGVuZ3RoID09PSAwO1xuICAgICAgaWYgKHNraXBFbXB0eUxpbmVzICYmICFoYXNIZWFkZXIpIHtcbiAgICAgICAgZW1wdHlMaW5lID1cbiAgICAgICAgICBza2lwRW1wdHlMaW5lcyA9PT0gJ2dyZWVkeSdcbiAgICAgICAgICAgID8gZGF0YVtyb3ddLmpvaW4oJycpLnRyaW0oKSA9PT0gJydcbiAgICAgICAgICAgIDogZGF0YVtyb3ddLmxlbmd0aCA9PT0gMSAmJiBkYXRhW3Jvd11bMF0ubGVuZ3RoID09PSAwO1xuICAgICAgfVxuICAgICAgaWYgKHNraXBFbXB0eUxpbmVzID09PSAnZ3JlZWR5JyAmJiBoYXNIZWFkZXIpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBtYXhDb2w7IGMrKykge1xuICAgICAgICAgIHZhciBjeCA9IGRhdGFLZXllZEJ5RmllbGQgPyBmaWVsZHNbY10gOiBjO1xuICAgICAgICAgIGxpbmUucHVzaChkYXRhW3Jvd11bY3hdKTtcbiAgICAgICAgfVxuICAgICAgICBlbXB0eUxpbmUgPSBsaW5lLmpvaW4oJycpLnRyaW0oKSA9PT0gJyc7XG4gICAgICB9XG4gICAgICBpZiAoIWVtcHR5TGluZSkge1xuICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtYXhDb2w7IGNvbCsrKSB7XG4gICAgICAgICAgaWYgKGNvbCA+IDAgJiYgIW51bGxMaW5lKSBjc3YgKz0gX2RlbGltaXRlcjtcbiAgICAgICAgICB2YXIgY29sSWR4ID0gaGFzSGVhZGVyICYmIGRhdGFLZXllZEJ5RmllbGQgPyBmaWVsZHNbY29sXSA6IGNvbDtcbiAgICAgICAgICBjc3YgKz0gc2FmZShkYXRhW3Jvd11bY29sSWR4XSwgY29sKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm93IDwgZGF0YS5sZW5ndGggLSAxICYmICghc2tpcEVtcHR5TGluZXMgfHwgKG1heENvbCA+IDAgJiYgIW51bGxMaW5lKSkpIHtcbiAgICAgICAgICBjc3YgKz0gX25ld2xpbmU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNzdjtcbiAgfVxuXG4gIC8qKiBFbmNsb3NlcyBhIHZhbHVlIGFyb3VuZCBxdW90ZXMgaWYgbmVlZGVkIChtYWtlcyBhIHZhbHVlIHNhZmUgZm9yIENTViBpbnNlcnRpb24pICovXG4gIGZ1bmN0aW9uIHNhZmUoc3RyLCBjb2wpIHtcbiAgICBpZiAodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcgfHwgc3RyID09PSBudWxsKSByZXR1cm4gJyc7XG5cbiAgICBpZiAoc3RyLmNvbnN0cnVjdG9yID09PSBEYXRlKSByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RyKS5zbGljZSgxLCAyNSk7XG5cbiAgICBzdHIgPSBzdHIudG9TdHJpbmcoKS5yZXBsYWNlKHF1b3RlQ2hhclJlZ2V4LCBfZXNjYXBlZFF1b3RlKTtcblxuICAgIHZhciBuZWVkc1F1b3RlcyA9XG4gICAgICAodHlwZW9mIF9xdW90ZXMgPT09ICdib29sZWFuJyAmJiBfcXVvdGVzKSB8fFxuICAgICAgKEFycmF5LmlzQXJyYXkoX3F1b3RlcykgJiYgX3F1b3Rlc1tjb2xdKSB8fFxuICAgICAgaGFzQW55KHN0ciwgUGFwYS5CQURfREVMSU1JVEVSUykgfHxcbiAgICAgIHN0ci5pbmRleE9mKF9kZWxpbWl0ZXIpID4gLTEgfHxcbiAgICAgIHN0ci5jaGFyQXQoMCkgPT09ICcgJyB8fFxuICAgICAgc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gMSkgPT09ICcgJztcblxuICAgIHJldHVybiBuZWVkc1F1b3RlcyA/IF9xdW90ZUNoYXIgKyBzdHIgKyBfcXVvdGVDaGFyIDogc3RyO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzQW55KHN0ciwgc3Vic3RyaW5ncykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic3RyaW5ncy5sZW5ndGg7IGkrKykgaWYgKHN0ci5pbmRleE9mKHN1YnN0cmluZ3NbaV0pID4gLTEpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKiogQ2h1bmtTdHJlYW1lciBpcyB0aGUgYmFzZSBwcm90b3R5cGUgZm9yIHZhcmlvdXMgc3RyZWFtZXIgaW1wbGVtZW50YXRpb25zLiAqL1xuZnVuY3Rpb24gQ2h1bmtTdHJlYW1lcihjb25maWcpIHtcbiAgdGhpcy5faGFuZGxlID0gbnVsbDtcbiAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZTtcbiAgdGhpcy5fY29tcGxldGVkID0gZmFsc2U7XG4gIHRoaXMuX2lucHV0ID0gbnVsbDtcbiAgdGhpcy5fYmFzZUluZGV4ID0gMDtcbiAgdGhpcy5fcGFydGlhbExpbmUgPSAnJztcbiAgdGhpcy5fcm93Q291bnQgPSAwO1xuICB0aGlzLl9zdGFydCA9IDA7XG4gIHRoaXMuX25leHRDaHVuayA9IG51bGw7XG4gIHRoaXMuaXNGaXJzdENodW5rID0gdHJ1ZTtcbiAgdGhpcy5fY29tcGxldGVSZXN1bHRzID0ge1xuICAgIGRhdGE6IFtdLFxuICAgIGVycm9yczogW10sXG4gICAgbWV0YToge31cbiAgfTtcbiAgcmVwbGFjZUNvbmZpZy5jYWxsKHRoaXMsIGNvbmZpZyk7XG5cbiAgdGhpcy5wYXJzZUNodW5rID0gZnVuY3Rpb24oY2h1bmssIGlzRmFrZUNodW5rKSB7XG4gICAgLy8gRmlyc3QgY2h1bmsgcHJlLXByb2Nlc3NpbmdcbiAgICBpZiAodGhpcy5pc0ZpcnN0Q2h1bmsgJiYgaXNGdW5jdGlvbih0aGlzLl9jb25maWcuYmVmb3JlRmlyc3RDaHVuaykpIHtcbiAgICAgIHZhciBtb2RpZmllZENodW5rID0gdGhpcy5fY29uZmlnLmJlZm9yZUZpcnN0Q2h1bmsoY2h1bmspO1xuICAgICAgaWYgKG1vZGlmaWVkQ2h1bmsgIT09IHVuZGVmaW5lZCkgY2h1bmsgPSBtb2RpZmllZENodW5rO1xuICAgIH1cbiAgICB0aGlzLmlzRmlyc3RDaHVuayA9IGZhbHNlO1xuXG4gICAgLy8gUmVqb2luIHRoZSBsaW5lIHdlIGxpa2VseSBqdXN0IHNwbGl0IGluIHR3byBieSBjaHVua2luZyB0aGUgZmlsZVxuICAgIHZhciBhZ2dyZWdhdGUgPSB0aGlzLl9wYXJ0aWFsTGluZSArIGNodW5rO1xuICAgIHRoaXMuX3BhcnRpYWxMaW5lID0gJyc7XG5cbiAgICB2YXIgcmVzdWx0cyA9IHRoaXMuX2hhbmRsZS5wYXJzZShhZ2dyZWdhdGUsIHRoaXMuX2Jhc2VJbmRleCwgIXRoaXMuX2ZpbmlzaGVkKTtcblxuICAgIGlmICh0aGlzLl9oYW5kbGUucGF1c2VkKCkgfHwgdGhpcy5faGFuZGxlLmFib3J0ZWQoKSkgcmV0dXJuO1xuXG4gICAgdmFyIGxhc3RJbmRleCA9IHJlc3VsdHMubWV0YS5jdXJzb3I7XG5cbiAgICBpZiAoIXRoaXMuX2ZpbmlzaGVkKSB7XG4gICAgICB0aGlzLl9wYXJ0aWFsTGluZSA9IGFnZ3JlZ2F0ZS5zdWJzdHJpbmcobGFzdEluZGV4IC0gdGhpcy5fYmFzZUluZGV4KTtcbiAgICAgIHRoaXMuX2Jhc2VJbmRleCA9IGxhc3RJbmRleDtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0cyAmJiByZXN1bHRzLmRhdGEpIHRoaXMuX3Jvd0NvdW50ICs9IHJlc3VsdHMuZGF0YS5sZW5ndGg7XG5cbiAgICB2YXIgZmluaXNoZWRJbmNsdWRpbmdQcmV2aWV3ID1cbiAgICAgIHRoaXMuX2ZpbmlzaGVkIHx8ICh0aGlzLl9jb25maWcucHJldmlldyAmJiB0aGlzLl9yb3dDb3VudCA+PSB0aGlzLl9jb25maWcucHJldmlldyk7XG5cbiAgICBpZiAoSVNfUEFQQV9XT1JLRVIpIHtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHJlc3VsdHM6IHJlc3VsdHMsXG4gICAgICAgIHdvcmtlcklkOiBQYXBhLldPUktFUl9JRCxcbiAgICAgICAgZmluaXNoZWQ6IGZpbmlzaGVkSW5jbHVkaW5nUHJldmlld1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2NvbmZpZy5jaHVuaykgJiYgIWlzRmFrZUNodW5rKSB7XG4gICAgICB0aGlzLl9jb25maWcuY2h1bmsocmVzdWx0cywgdGhpcy5faGFuZGxlKTtcbiAgICAgIGlmICh0aGlzLl9oYW5kbGUucGF1c2VkKCkgfHwgdGhpcy5faGFuZGxlLmFib3J0ZWQoKSkgcmV0dXJuO1xuICAgICAgcmVzdWx0cyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2NvbXBsZXRlUmVzdWx0cyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2NvbmZpZy5zdGVwICYmICF0aGlzLl9jb25maWcuY2h1bmspIHtcbiAgICAgIHRoaXMuX2NvbXBsZXRlUmVzdWx0cy5kYXRhID0gdGhpcy5fY29tcGxldGVSZXN1bHRzLmRhdGEuY29uY2F0KHJlc3VsdHMuZGF0YSk7XG4gICAgICB0aGlzLl9jb21wbGV0ZVJlc3VsdHMuZXJyb3JzID0gdGhpcy5fY29tcGxldGVSZXN1bHRzLmVycm9ycy5jb25jYXQocmVzdWx0cy5lcnJvcnMpO1xuICAgICAgdGhpcy5fY29tcGxldGVSZXN1bHRzLm1ldGEgPSByZXN1bHRzLm1ldGE7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgIXRoaXMuX2NvbXBsZXRlZCAmJlxuICAgICAgZmluaXNoZWRJbmNsdWRpbmdQcmV2aWV3ICYmXG4gICAgICBpc0Z1bmN0aW9uKHRoaXMuX2NvbmZpZy5jb21wbGV0ZSkgJiZcbiAgICAgICghcmVzdWx0cyB8fCAhcmVzdWx0cy5tZXRhLmFib3J0ZWQpXG4gICAgKSB7XG4gICAgICB0aGlzLl9jb25maWcuY29tcGxldGUodGhpcy5fY29tcGxldGVSZXN1bHRzLCB0aGlzLl9pbnB1dCk7XG4gICAgICB0aGlzLl9jb21wbGV0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghZmluaXNoZWRJbmNsdWRpbmdQcmV2aWV3ICYmICghcmVzdWx0cyB8fCAhcmVzdWx0cy5tZXRhLnBhdXNlZCkpIHRoaXMuX25leHRDaHVuaygpO1xuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgdGhpcy5fc2VuZEVycm9yID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgICBpZiAoaXNGdW5jdGlvbih0aGlzLl9jb25maWcuZXJyb3IpKSB0aGlzLl9jb25maWcuZXJyb3IoZXJyb3IpO1xuICAgIGVsc2UgaWYgKElTX1BBUEFfV09SS0VSICYmIHRoaXMuX2NvbmZpZy5lcnJvcikge1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgd29ya2VySWQ6IFBhcGEuV09SS0VSX0lELFxuICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgIGZpbmlzaGVkOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHJlcGxhY2VDb25maWcoY29uZmlnKSB7XG4gICAgLy8gRGVlcC1jb3B5IHRoZSBjb25maWcgc28gd2UgY2FuIGVkaXQgaXRcbiAgICB2YXIgY29uZmlnQ29weSA9IGNvcHkoY29uZmlnKTtcbiAgICBjb25maWdDb3B5LmNodW5rU2l6ZSA9IHBhcnNlSW50KGNvbmZpZ0NvcHkuY2h1bmtTaXplKTsgLy8gcGFyc2VJbnQgVkVSWSBpbXBvcnRhbnQgc28gd2UgZG9uJ3QgY29uY2F0ZW5hdGUgc3RyaW5ncyFcbiAgICBpZiAoIWNvbmZpZy5zdGVwICYmICFjb25maWcuY2h1bmspIGNvbmZpZ0NvcHkuY2h1bmtTaXplID0gbnVsbDsgLy8gZGlzYWJsZSBSYW5nZSBoZWFkZXIgaWYgbm90IHN0cmVhbWluZzsgYmFkIHZhbHVlcyBicmVhayBJSVMgLSBzZWUgaXNzdWUgIzE5NlxuICAgIHRoaXMuX2hhbmRsZSA9IG5ldyBQYXJzZXJIYW5kbGUoY29uZmlnQ29weSk7XG4gICAgdGhpcy5faGFuZGxlLnN0cmVhbWVyID0gdGhpcztcbiAgICB0aGlzLl9jb25maWcgPSBjb25maWdDb3B5OyAvLyBwZXJzaXN0IHRoZSBjb3B5IHRvIHRoZSBjYWxsZXJcbiAgfVxufVxuZnVuY3Rpb24gU3RyaW5nU3RyZWFtZXIoY29uZmlnKSB7XG4gIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgQ2h1bmtTdHJlYW1lci5jYWxsKHRoaXMsIGNvbmZpZyk7XG5cbiAgdmFyIHJlbWFpbmluZztcbiAgdGhpcy5zdHJlYW0gPSBmdW5jdGlvbihzKSB7XG4gICAgcmVtYWluaW5nID0gcztcbiAgICByZXR1cm4gdGhpcy5fbmV4dENodW5rKCk7XG4gIH07XG4gIHRoaXMuX25leHRDaHVuayA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9maW5pc2hlZCkgcmV0dXJuO1xuICAgIHZhciBzaXplID0gdGhpcy5fY29uZmlnLmNodW5rU2l6ZTtcbiAgICB2YXIgY2h1bmsgPSBzaXplID8gcmVtYWluaW5nLnN1YnN0cigwLCBzaXplKSA6IHJlbWFpbmluZztcbiAgICByZW1haW5pbmcgPSBzaXplID8gcmVtYWluaW5nLnN1YnN0cihzaXplKSA6ICcnO1xuICAgIHRoaXMuX2ZpbmlzaGVkID0gIXJlbWFpbmluZztcbiAgICByZXR1cm4gdGhpcy5wYXJzZUNodW5rKGNodW5rKTtcbiAgfTtcbn1cblN0cmluZ1N0cmVhbWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3RyaW5nU3RyZWFtZXIucHJvdG90eXBlKTtcblN0cmluZ1N0cmVhbWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN0cmluZ1N0cmVhbWVyO1xuXG4vLyBVc2Ugb25lIFBhcnNlckhhbmRsZSBwZXIgZW50aXJlIENTViBmaWxlIG9yIHN0cmluZ1xuZnVuY3Rpb24gUGFyc2VySGFuZGxlKF9jb25maWcpIHtcbiAgLy8gT25lIGdvYWwgaXMgdG8gbWluaW1pemUgdGhlIHVzZSBvZiByZWd1bGFyIGV4cHJlc3Npb25zLi4uXG4gIHZhciBGTE9BVCA9IC9eXFxzKi0/KFxcZCpcXC4/XFxkK3xcXGQrXFwuP1xcZCopKGVbLStdP1xcZCspP1xccyokL2k7XG4gIHZhciBJU09fREFURSA9IC8oXFxkezR9LVswMV1cXGQtWzAtM11cXGRUWzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGRcXC5cXGQrKFsrLV1bMC0yXVxcZDpbMC01XVxcZHxaKSl8KFxcZHs0fS1bMDFdXFxkLVswLTNdXFxkVFswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkKFsrLV1bMC0yXVxcZDpbMC01XVxcZHxaKSl8KFxcZHs0fS1bMDFdXFxkLVswLTNdXFxkVFswLTJdXFxkOlswLTVdXFxkKFsrLV1bMC0yXVxcZDpbMC01XVxcZHxaKSkvO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIF9zdGVwQ291bnRlciA9IDA7IC8vIE51bWJlciBvZiB0aW1lcyBzdGVwIHdhcyBjYWxsZWQgKG51bWJlciBvZiByb3dzIHBhcnNlZClcbiAgdmFyIF9yb3dDb3VudGVyID0gMDsgLy8gTnVtYmVyIG9mIHJvd3MgdGhhdCBoYXZlIGJlZW4gcGFyc2VkIHNvIGZhclxuICB2YXIgX2lucHV0OyAvLyBUaGUgaW5wdXQgYmVpbmcgcGFyc2VkXG4gIHZhciBfcGFyc2VyOyAvLyBUaGUgY29yZSBwYXJzZXIgYmVpbmcgdXNlZFxuICB2YXIgX3BhdXNlZCA9IGZhbHNlOyAvLyBXaGV0aGVyIHdlIGFyZSBwYXVzZWQgb3Igbm90XG4gIHZhciBfYWJvcnRlZCA9IGZhbHNlOyAvLyBXaGV0aGVyIHRoZSBwYXJzZXIgaGFzIGFib3J0ZWQgb3Igbm90XG4gIHZhciBfZGVsaW1pdGVyRXJyb3I7IC8vIFRlbXBvcmFyeSBzdGF0ZSBiZXR3ZWVuIGRlbGltaXRlciBkZXRlY3Rpb24gYW5kIHByb2Nlc3NpbmcgcmVzdWx0c1xuICB2YXIgX2ZpZWxkcyA9IFtdOyAvLyBGaWVsZHMgYXJlIGZyb20gdGhlIGhlYWRlciByb3cgb2YgdGhlIGlucHV0LCBpZiB0aGVyZSBpcyBvbmVcbiAgdmFyIF9yZXN1bHRzID0ge1xuICAgIC8vIFRoZSBsYXN0IHJlc3VsdHMgcmV0dXJuZWQgZnJvbSB0aGUgcGFyc2VyXG4gICAgZGF0YTogW10sXG4gICAgZXJyb3JzOiBbXSxcbiAgICBtZXRhOiB7fVxuICB9O1xuXG4gIGlmIChpc0Z1bmN0aW9uKF9jb25maWcuc3RlcCkpIHtcbiAgICB2YXIgdXNlclN0ZXAgPSBfY29uZmlnLnN0ZXA7XG4gICAgX2NvbmZpZy5zdGVwID0gZnVuY3Rpb24ocmVzdWx0cykge1xuICAgICAgX3Jlc3VsdHMgPSByZXN1bHRzO1xuXG4gICAgICBpZiAobmVlZHNIZWFkZXJSb3coKSkgcHJvY2Vzc1Jlc3VsdHMoKTtcbiAgICAgIC8vIG9ubHkgY2FsbCB1c2VyJ3Mgc3RlcCBmdW5jdGlvbiBhZnRlciBoZWFkZXIgcm93XG4gICAgICBlbHNlIHtcbiAgICAgICAgcHJvY2Vzc1Jlc3VsdHMoKTtcblxuICAgICAgICAvLyBJdCdzIHBvc3NiaWxlIHRoYXQgdGhpcyBsaW5lIHdhcyBlbXB0eSBhbmQgdGhlcmUncyBubyByb3cgaGVyZSBhZnRlciBhbGxcbiAgICAgICAgaWYgKCFfcmVzdWx0cy5kYXRhIHx8IF9yZXN1bHRzLmRhdGEubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAgICAgX3N0ZXBDb3VudGVyICs9IHJlc3VsdHMuZGF0YS5sZW5ndGg7XG4gICAgICAgIGlmIChfY29uZmlnLnByZXZpZXcgJiYgX3N0ZXBDb3VudGVyID4gX2NvbmZpZy5wcmV2aWV3KSBfcGFyc2VyLmFib3J0KCk7XG4gICAgICAgIGVsc2UgdXNlclN0ZXAoX3Jlc3VsdHMsIHNlbGYpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGlucHV0LiBNb3N0IHVzZXJzIHdvbid0IG5lZWQsIGFuZCBzaG91bGRuJ3QgbWVzcyB3aXRoLCB0aGUgYmFzZUluZGV4XG4gICAqIGFuZCBpZ25vcmVMYXN0Um93IHBhcmFtZXRlcnMuIFRoZXkgYXJlIHVzZWQgYnkgc3RyZWFtZXJzICh3cmFwcGVyIGZ1bmN0aW9ucylcbiAgICogd2hlbiBhbiBpbnB1dCBjb21lcyBpbiBtdWx0aXBsZSBjaHVua3MsIGxpa2UgZnJvbSBhIGZpbGUuXG4gICAqL1xuICB0aGlzLnBhcnNlID0gZnVuY3Rpb24oaW5wdXQsIGJhc2VJbmRleCwgaWdub3JlTGFzdFJvdykge1xuICAgIHZhciBxdW90ZUNoYXIgPSBfY29uZmlnLnF1b3RlQ2hhciB8fCAnXCInO1xuICAgIGlmICghX2NvbmZpZy5uZXdsaW5lKSBfY29uZmlnLm5ld2xpbmUgPSBndWVzc0xpbmVFbmRpbmdzKGlucHV0LCBxdW90ZUNoYXIpO1xuXG4gICAgX2RlbGltaXRlckVycm9yID0gZmFsc2U7XG4gICAgaWYgKCFfY29uZmlnLmRlbGltaXRlcikge1xuICAgICAgdmFyIGRlbGltR3Vlc3MgPSBndWVzc0RlbGltaXRlcihcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIF9jb25maWcubmV3bGluZSxcbiAgICAgICAgX2NvbmZpZy5za2lwRW1wdHlMaW5lcyxcbiAgICAgICAgX2NvbmZpZy5jb21tZW50cyxcbiAgICAgICAgX2NvbmZpZy5kZWxpbWl0ZXJzVG9HdWVzc1xuICAgICAgKTtcbiAgICAgIGlmIChkZWxpbUd1ZXNzLnN1Y2Nlc3NmdWwpIF9jb25maWcuZGVsaW1pdGVyID0gZGVsaW1HdWVzcy5iZXN0RGVsaW1pdGVyO1xuICAgICAgZWxzZSB7XG4gICAgICAgIF9kZWxpbWl0ZXJFcnJvciA9IHRydWU7IC8vIGFkZCBlcnJvciBhZnRlciBwYXJzaW5nIChvdGhlcndpc2UgaXQgd291bGQgYmUgb3ZlcndyaXR0ZW4pXG4gICAgICAgIF9jb25maWcuZGVsaW1pdGVyID0gUGFwYS5EZWZhdWx0RGVsaW1pdGVyO1xuICAgICAgfVxuICAgICAgX3Jlc3VsdHMubWV0YS5kZWxpbWl0ZXIgPSBfY29uZmlnLmRlbGltaXRlcjtcbiAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oX2NvbmZpZy5kZWxpbWl0ZXIpKSB7XG4gICAgICBfY29uZmlnLmRlbGltaXRlciA9IF9jb25maWcuZGVsaW1pdGVyKGlucHV0KTtcbiAgICAgIF9yZXN1bHRzLm1ldGEuZGVsaW1pdGVyID0gX2NvbmZpZy5kZWxpbWl0ZXI7XG4gICAgfVxuXG4gICAgdmFyIHBhcnNlckNvbmZpZyA9IGNvcHkoX2NvbmZpZyk7XG4gICAgaWYgKF9jb25maWcucHJldmlldyAmJiBfY29uZmlnLmhlYWRlcikgcGFyc2VyQ29uZmlnLnByZXZpZXcrKzsgLy8gdG8gY29tcGVuc2F0ZSBmb3IgaGVhZGVyIHJvd1xuXG4gICAgX2lucHV0ID0gaW5wdXQ7XG4gICAgX3BhcnNlciA9IG5ldyBQYXJzZXIocGFyc2VyQ29uZmlnKTtcbiAgICBfcmVzdWx0cyA9IF9wYXJzZXIucGFyc2UoX2lucHV0LCBiYXNlSW5kZXgsIGlnbm9yZUxhc3RSb3cpO1xuICAgIHByb2Nlc3NSZXN1bHRzKCk7XG4gICAgcmV0dXJuIF9wYXVzZWQgPyB7bWV0YToge3BhdXNlZDogdHJ1ZX19IDogX3Jlc3VsdHMgfHwge21ldGE6IHtwYXVzZWQ6IGZhbHNlfX07XG4gIH07XG5cbiAgdGhpcy5wYXVzZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gX3BhdXNlZDtcbiAgfTtcblxuICB0aGlzLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgX3BhdXNlZCA9IHRydWU7XG4gICAgX3BhcnNlci5hYm9ydCgpO1xuICAgIF9pbnB1dCA9IF9pbnB1dC5zdWJzdHIoX3BhcnNlci5nZXRDaGFySW5kZXgoKSk7XG4gIH07XG5cbiAgdGhpcy5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgICBfcGF1c2VkID0gZmFsc2U7XG4gICAgc2VsZi5zdHJlYW1lci5wYXJzZUNodW5rKF9pbnB1dCwgdHJ1ZSk7XG4gIH07XG5cbiAgdGhpcy5hYm9ydGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF9hYm9ydGVkO1xuICB9O1xuXG4gIHRoaXMuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICBfYWJvcnRlZCA9IHRydWU7XG4gICAgX3BhcnNlci5hYm9ydCgpO1xuICAgIF9yZXN1bHRzLm1ldGEuYWJvcnRlZCA9IHRydWU7XG4gICAgaWYgKGlzRnVuY3Rpb24oX2NvbmZpZy5jb21wbGV0ZSkpIF9jb25maWcuY29tcGxldGUoX3Jlc3VsdHMpO1xuICAgIF9pbnB1dCA9ICcnO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHRlc3RFbXB0eUxpbmUocykge1xuICAgIHJldHVybiBfY29uZmlnLnNraXBFbXB0eUxpbmVzID09PSAnZ3JlZWR5J1xuICAgICAgPyBzLmpvaW4oJycpLnRyaW0oKSA9PT0gJydcbiAgICAgIDogcy5sZW5ndGggPT09IDEgJiYgc1swXS5sZW5ndGggPT09IDA7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzUmVzdWx0cygpIHtcbiAgICBpZiAoX3Jlc3VsdHMgJiYgX2RlbGltaXRlckVycm9yKSB7XG4gICAgICBhZGRFcnJvcihcbiAgICAgICAgJ0RlbGltaXRlcicsXG4gICAgICAgICdVbmRldGVjdGFibGVEZWxpbWl0ZXInLFxuICAgICAgICBcIlVuYWJsZSB0byBhdXRvLWRldGVjdCBkZWxpbWl0aW5nIGNoYXJhY3RlcjsgZGVmYXVsdGVkIHRvICdcIiArIFBhcGEuRGVmYXVsdERlbGltaXRlciArIFwiJ1wiXG4gICAgICApO1xuICAgICAgX2RlbGltaXRlckVycm9yID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKF9jb25maWcuc2tpcEVtcHR5TGluZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3Jlc3VsdHMuZGF0YS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKHRlc3RFbXB0eUxpbmUoX3Jlc3VsdHMuZGF0YVtpXSkpIF9yZXN1bHRzLmRhdGEuc3BsaWNlKGktLSwgMSk7XG4gICAgfVxuXG4gICAgaWYgKG5lZWRzSGVhZGVyUm93KCkpIGZpbGxIZWFkZXJGaWVsZHMoKTtcblxuICAgIHJldHVybiBhcHBseUhlYWRlckFuZER5bmFtaWNUeXBpbmdBbmRUcmFuc2Zvcm1hdGlvbigpO1xuICB9XG5cbiAgZnVuY3Rpb24gbmVlZHNIZWFkZXJSb3coKSB7XG4gICAgcmV0dXJuIF9jb25maWcuaGVhZGVyICYmIF9maWVsZHMubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlsbEhlYWRlckZpZWxkcygpIHtcbiAgICBpZiAoIV9yZXN1bHRzKSByZXR1cm47XG5cbiAgICBmdW5jdGlvbiBhZGRIZWRlcihoZWFkZXIpIHtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKF9jb25maWcudHJhbnNmb3JtSGVhZGVyKSkgaGVhZGVyID0gX2NvbmZpZy50cmFuc2Zvcm1IZWFkZXIoaGVhZGVyKTtcblxuICAgICAgX2ZpZWxkcy5wdXNoKGhlYWRlcik7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoX3Jlc3VsdHMuZGF0YVswXSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBuZWVkc0hlYWRlclJvdygpICYmIGkgPCBfcmVzdWx0cy5kYXRhLmxlbmd0aDsgaSsrKVxuICAgICAgICBfcmVzdWx0cy5kYXRhW2ldLmZvckVhY2goYWRkSGVkZXIpO1xuXG4gICAgICBfcmVzdWx0cy5kYXRhLnNwbGljZSgwLCAxKTtcbiAgICB9XG4gICAgLy8gaWYgX3Jlc3VsdHMuZGF0YVswXSBpcyBub3QgYW4gYXJyYXksIHdlIGFyZSBpbiBhIHN0ZXAgd2hlcmUgX3Jlc3VsdHMuZGF0YSBpcyB0aGUgcm93LlxuICAgIGVsc2UgX3Jlc3VsdHMuZGF0YS5mb3JFYWNoKGFkZEhlZGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEFwcGx5RHluYW1pY1R5cGluZyhmaWVsZCkge1xuICAgIC8vIENhY2hlIGZ1bmN0aW9uIHZhbHVlcyB0byBhdm9pZCBjYWxsaW5nIGl0IGZvciBlYWNoIHJvd1xuICAgIGlmIChfY29uZmlnLmR5bmFtaWNUeXBpbmdGdW5jdGlvbiAmJiBfY29uZmlnLmR5bmFtaWNUeXBpbmdbZmllbGRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIF9jb25maWcuZHluYW1pY1R5cGluZ1tmaWVsZF0gPSBfY29uZmlnLmR5bmFtaWNUeXBpbmdGdW5jdGlvbihmaWVsZCk7XG4gICAgfVxuICAgIHJldHVybiAoX2NvbmZpZy5keW5hbWljVHlwaW5nW2ZpZWxkXSB8fCBfY29uZmlnLmR5bmFtaWNUeXBpbmcpID09PSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VEeW5hbWljKGZpZWxkLCB2YWx1ZSkge1xuICAgIGlmIChzaG91bGRBcHBseUR5bmFtaWNUeXBpbmcoZmllbGQpKSB7XG4gICAgICBpZiAodmFsdWUgPT09ICd0cnVlJyB8fCB2YWx1ZSA9PT0gJ1RSVUUnKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGVsc2UgaWYgKHZhbHVlID09PSAnZmFsc2UnIHx8IHZhbHVlID09PSAnRkFMU0UnKSByZXR1cm4gZmFsc2U7XG4gICAgICBlbHNlIGlmIChGTE9BVC50ZXN0KHZhbHVlKSkgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgZWxzZSBpZiAoSVNPX0RBVEUudGVzdCh2YWx1ZSkpIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICBlbHNlIHJldHVybiB2YWx1ZSA9PT0gJycgPyBudWxsIDogdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5SGVhZGVyQW5kRHluYW1pY1R5cGluZ0FuZFRyYW5zZm9ybWF0aW9uKCkge1xuICAgIGlmICghX3Jlc3VsdHMgfHwgIV9yZXN1bHRzLmRhdGEgfHwgKCFfY29uZmlnLmhlYWRlciAmJiAhX2NvbmZpZy5keW5hbWljVHlwaW5nICYmICFfY29uZmlnLnRyYW5zZm9ybSkpXG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzUm93KHJvd1NvdXJjZSwgaSkge1xuICAgICAgdmFyIHJvdyA9IF9jb25maWcuaGVhZGVyID8ge30gOiBbXTtcblxuICAgICAgdmFyIGo7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgcm93U291cmNlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IGo7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJvd1NvdXJjZVtqXTtcblxuICAgICAgICBpZiAoX2NvbmZpZy5oZWFkZXIpIGZpZWxkID0gaiA+PSBfZmllbGRzLmxlbmd0aCA/ICdfX3BhcnNlZF9leHRyYScgOiBfZmllbGRzW2pdO1xuXG4gICAgICAgIGlmIChfY29uZmlnLnRyYW5zZm9ybSkgdmFsdWUgPSBfY29uZmlnLnRyYW5zZm9ybSh2YWx1ZSwgZmllbGQpO1xuXG4gICAgICAgIHZhbHVlID0gcGFyc2VEeW5hbWljKGZpZWxkLCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKGZpZWxkID09PSAnX19wYXJzZWRfZXh0cmEnKSB7XG4gICAgICAgICAgcm93W2ZpZWxkXSA9IHJvd1tmaWVsZF0gfHwgW107XG4gICAgICAgICAgcm93W2ZpZWxkXS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHJvd1tmaWVsZF0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9jb25maWcuaGVhZGVyKSB7XG4gICAgICAgIGlmIChqID4gX2ZpZWxkcy5sZW5ndGgpXG4gICAgICAgICAgYWRkRXJyb3IoXG4gICAgICAgICAgICAnRmllbGRNaXNtYXRjaCcsXG4gICAgICAgICAgICAnVG9vTWFueUZpZWxkcycsXG4gICAgICAgICAgICAnVG9vIG1hbnkgZmllbGRzOiBleHBlY3RlZCAnICsgX2ZpZWxkcy5sZW5ndGggKyAnIGZpZWxkcyBidXQgcGFyc2VkICcgKyBqLFxuICAgICAgICAgICAgX3Jvd0NvdW50ZXIgKyBpXG4gICAgICAgICAgKTtcbiAgICAgICAgZWxzZSBpZiAoaiA8IF9maWVsZHMubGVuZ3RoKVxuICAgICAgICAgIGFkZEVycm9yKFxuICAgICAgICAgICAgJ0ZpZWxkTWlzbWF0Y2gnLFxuICAgICAgICAgICAgJ1Rvb0Zld0ZpZWxkcycsXG4gICAgICAgICAgICAnVG9vIGZldyBmaWVsZHM6IGV4cGVjdGVkICcgKyBfZmllbGRzLmxlbmd0aCArICcgZmllbGRzIGJ1dCBwYXJzZWQgJyArIGosXG4gICAgICAgICAgICBfcm93Q291bnRlciArIGlcbiAgICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcm93O1xuICAgIH1cblxuICAgIHZhciBpbmNyZW1lbnRCeSA9IDE7XG4gICAgaWYgKCFfcmVzdWx0cy5kYXRhWzBdIHx8IEFycmF5LmlzQXJyYXkoX3Jlc3VsdHMuZGF0YVswXSkpIHtcbiAgICAgIF9yZXN1bHRzLmRhdGEgPSBfcmVzdWx0cy5kYXRhLm1hcChwcm9jZXNzUm93KTtcbiAgICAgIGluY3JlbWVudEJ5ID0gX3Jlc3VsdHMuZGF0YS5sZW5ndGg7XG4gICAgfSBlbHNlIF9yZXN1bHRzLmRhdGEgPSBwcm9jZXNzUm93KF9yZXN1bHRzLmRhdGEsIDApO1xuXG4gICAgaWYgKF9jb25maWcuaGVhZGVyICYmIF9yZXN1bHRzLm1ldGEpIF9yZXN1bHRzLm1ldGEuZmllbGRzID0gX2ZpZWxkcztcblxuICAgIF9yb3dDb3VudGVyICs9IGluY3JlbWVudEJ5O1xuICAgIHJldHVybiBfcmVzdWx0cztcbiAgfVxuXG4gIGZ1bmN0aW9uIGd1ZXNzRGVsaW1pdGVyKGlucHV0LCBuZXdsaW5lLCBza2lwRW1wdHlMaW5lcywgY29tbWVudHMsIGRlbGltaXRlcnNUb0d1ZXNzKSB7XG4gICAgdmFyIGJlc3REZWxpbSwgYmVzdERlbHRhLCBmaWVsZENvdW50UHJldlJvdztcblxuICAgIGRlbGltaXRlcnNUb0d1ZXNzID0gZGVsaW1pdGVyc1RvR3Vlc3MgfHwgWycsJywgJ1xcdCcsICd8JywgJzsnLCBQYXBhLlJFQ09SRF9TRVAsIFBhcGEuVU5JVF9TRVBdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxpbWl0ZXJzVG9HdWVzcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlbGltID0gZGVsaW1pdGVyc1RvR3Vlc3NbaV07XG4gICAgICB2YXIgZGVsdGEgPSAwLFxuICAgICAgICBhdmdGaWVsZENvdW50ID0gMCxcbiAgICAgICAgZW1wdHlMaW5lc0NvdW50ID0gMDtcbiAgICAgIGZpZWxkQ291bnRQcmV2Um93ID0gdW5kZWZpbmVkO1xuXG4gICAgICB2YXIgcHJldmlldyA9IG5ldyBQYXJzZXIoe1xuICAgICAgICBjb21tZW50czogY29tbWVudHMsXG4gICAgICAgIGRlbGltaXRlcjogZGVsaW0sXG4gICAgICAgIG5ld2xpbmU6IG5ld2xpbmUsXG4gICAgICAgIHByZXZpZXc6IDEwXG4gICAgICB9KS5wYXJzZShpbnB1dCk7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJldmlldy5kYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChza2lwRW1wdHlMaW5lcyAmJiB0ZXN0RW1wdHlMaW5lKHByZXZpZXcuZGF0YVtqXSkpIHtcbiAgICAgICAgICBlbXB0eUxpbmVzQ291bnQrKztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmllbGRDb3VudCA9IHByZXZpZXcuZGF0YVtqXS5sZW5ndGg7XG4gICAgICAgIGF2Z0ZpZWxkQ291bnQgKz0gZmllbGRDb3VudDtcblxuICAgICAgICBpZiAodHlwZW9mIGZpZWxkQ291bnRQcmV2Um93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGZpZWxkQ291bnRQcmV2Um93ID0gMDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChmaWVsZENvdW50ID4gMSkge1xuICAgICAgICAgIGRlbHRhICs9IE1hdGguYWJzKGZpZWxkQ291bnQgLSBmaWVsZENvdW50UHJldlJvdyk7XG4gICAgICAgICAgZmllbGRDb3VudFByZXZSb3cgPSBmaWVsZENvdW50O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmV2aWV3LmRhdGEubGVuZ3RoID4gMCkgYXZnRmllbGRDb3VudCAvPSBwcmV2aWV3LmRhdGEubGVuZ3RoIC0gZW1wdHlMaW5lc0NvdW50O1xuXG4gICAgICBpZiAoKHR5cGVvZiBiZXN0RGVsdGEgPT09ICd1bmRlZmluZWQnIHx8IGRlbHRhID4gYmVzdERlbHRhKSAmJiBhdmdGaWVsZENvdW50ID4gMS45OSkge1xuICAgICAgICBiZXN0RGVsdGEgPSBkZWx0YTtcbiAgICAgICAgYmVzdERlbGltID0gZGVsaW07XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2NvbmZpZy5kZWxpbWl0ZXIgPSBiZXN0RGVsaW07XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2Vzc2Z1bDogISFiZXN0RGVsaW0sXG4gICAgICBiZXN0RGVsaW1pdGVyOiBiZXN0RGVsaW1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ3Vlc3NMaW5lRW5kaW5ncyhpbnB1dCwgcXVvdGVDaGFyKSB7XG4gICAgaW5wdXQgPSBpbnB1dC5zdWJzdHIoMCwgMTAyNCAqIDEwMjQpOyAvLyBtYXggbGVuZ3RoIDEgTUJcbiAgICAvLyBSZXBsYWNlIGFsbCB0aGUgdGV4dCBpbnNpZGUgcXVvdGVzXG4gICAgdmFyIHJlID0gbmV3IFJlZ0V4cChlc2NhcGVSZWdFeHAocXVvdGVDaGFyKSArICcoW15dKj8pJyArIGVzY2FwZVJlZ0V4cChxdW90ZUNoYXIpLCAnZ20nKTtcbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UocmUsICcnKTtcblxuICAgIHZhciByID0gaW5wdXQuc3BsaXQoJ1xccicpO1xuXG4gICAgdmFyIG4gPSBpbnB1dC5zcGxpdCgnXFxuJyk7XG5cbiAgICB2YXIgbkFwcGVhcnNGaXJzdCA9IG4ubGVuZ3RoID4gMSAmJiBuWzBdLmxlbmd0aCA8IHJbMF0ubGVuZ3RoO1xuXG4gICAgaWYgKHIubGVuZ3RoID09PSAxIHx8IG5BcHBlYXJzRmlyc3QpIHJldHVybiAnXFxuJztcblxuICAgIHZhciBudW1XaXRoTiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocltpXVswXSA9PT0gJ1xcbicpIG51bVdpdGhOKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bVdpdGhOID49IHIubGVuZ3RoIC8gMiA/ICdcXHJcXG4nIDogJ1xccic7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRFcnJvcih0eXBlLCBjb2RlLCBtc2csIHJvdykge1xuICAgIF9yZXN1bHRzLmVycm9ycy5wdXNoKHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBjb2RlOiBjb2RlLFxuICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgcm93OiByb3dcbiAgICB9KTtcbiAgfVxufVxuXG4vKiogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9HdWlkZS9SZWd1bGFyX0V4cHJlc3Npb25zICovXG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTsgLy8gJCYgbWVhbnMgdGhlIHdob2xlIG1hdGNoZWQgc3RyaW5nXG59XG5cbi8qKiBUaGUgY29yZSBwYXJzZXIgaW1wbGVtZW50cyBzcGVlZHkgYW5kIGNvcnJlY3QgQ1NWIHBhcnNpbmcgKi9cbmZ1bmN0aW9uIFBhcnNlcihjb25maWcpIHtcbiAgLy8gVW5wYWNrIHRoZSBjb25maWcgb2JqZWN0XG4gIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgdmFyIGRlbGltID0gY29uZmlnLmRlbGltaXRlcjtcbiAgdmFyIG5ld2xpbmUgPSBjb25maWcubmV3bGluZTtcbiAgdmFyIGNvbW1lbnRzID0gY29uZmlnLmNvbW1lbnRzO1xuICB2YXIgc3RlcCA9IGNvbmZpZy5zdGVwO1xuICB2YXIgcHJldmlldyA9IGNvbmZpZy5wcmV2aWV3O1xuICB2YXIgZmFzdE1vZGUgPSBjb25maWcuZmFzdE1vZGU7XG4gIHZhciBxdW90ZUNoYXI7XG4gIC8qKiBBbGxvd3MgZm9yIG5vIHF1b3RlQ2hhciBieSBzZXR0aW5nIHF1b3RlQ2hhciB0byB1bmRlZmluZWQgaW4gY29uZmlnICovXG4gIGlmIChjb25maWcucXVvdGVDaGFyID09PSB1bmRlZmluZWQpIHtcbiAgICBxdW90ZUNoYXIgPSAnXCInO1xuICB9IGVsc2Uge1xuICAgIHF1b3RlQ2hhciA9IGNvbmZpZy5xdW90ZUNoYXI7XG4gIH1cbiAgdmFyIGVzY2FwZUNoYXIgPSBxdW90ZUNoYXI7XG4gIGlmIChjb25maWcuZXNjYXBlQ2hhciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZXNjYXBlQ2hhciA9IGNvbmZpZy5lc2NhcGVDaGFyO1xuICB9XG5cbiAgLy8gRGVsaW1pdGVyIG11c3QgYmUgdmFsaWRcbiAgaWYgKHR5cGVvZiBkZWxpbSAhPT0gJ3N0cmluZycgfHwgUGFwYS5CQURfREVMSU1JVEVSUy5pbmRleE9mKGRlbGltKSA+IC0xKSBkZWxpbSA9ICcsJztcblxuICAvLyBDb21tZW50IGNoYXJhY3RlciBtdXN0IGJlIHZhbGlkXG4gIGlmIChjb21tZW50cyA9PT0gZGVsaW0pIHRocm93IG5ldyBFcnJvcignQ29tbWVudCBjaGFyYWN0ZXIgc2FtZSBhcyBkZWxpbWl0ZXInKTtcbiAgZWxzZSBpZiAoY29tbWVudHMgPT09IHRydWUpIGNvbW1lbnRzID0gJyMnO1xuICBlbHNlIGlmICh0eXBlb2YgY29tbWVudHMgIT09ICdzdHJpbmcnIHx8IFBhcGEuQkFEX0RFTElNSVRFUlMuaW5kZXhPZihjb21tZW50cykgPiAtMSlcbiAgICBjb21tZW50cyA9IGZhbHNlO1xuXG4gIC8vIE5ld2xpbmUgbXVzdCBiZSB2YWxpZDogXFxyLCBcXG4sIG9yIFxcclxcblxuICBpZiAobmV3bGluZSAhPT0gJ1xcbicgJiYgbmV3bGluZSAhPT0gJ1xccicgJiYgbmV3bGluZSAhPT0gJ1xcclxcbicpIG5ld2xpbmUgPSAnXFxuJztcblxuICAvLyBXZSdyZSBnb25uYSBuZWVkIHRoZXNlIGF0IHRoZSBQYXJzZXIgc2NvcGVcbiAgdmFyIGN1cnNvciA9IDA7XG4gIHZhciBhYm9ydGVkID0gZmFsc2U7XG5cbiAgdGhpcy5wYXJzZSA9IGZ1bmN0aW9uKGlucHV0LCBiYXNlSW5kZXgsIGlnbm9yZUxhc3RSb3cpIHtcbiAgICAvLyBGb3Igc29tZSByZWFzb24sIGluIENocm9tZSwgdGhpcyBzcGVlZHMgdGhpbmdzIHVwICghPylcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cbiAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGNvbXB1dGUgc29tZSBvZiB0aGVzZSBldmVyeSB0aW1lIHBhcnNlKCkgaXMgY2FsbGVkLFxuICAgIC8vIGJ1dCBoYXZpbmcgdGhlbSBpbiBhIG1vcmUgbG9jYWwgc2NvcGUgc2VlbXMgdG8gcGVyZm9ybSBiZXR0ZXJcbiAgICB2YXIgaW5wdXRMZW4gPSBpbnB1dC5sZW5ndGgsXG4gICAgICBkZWxpbUxlbiA9IGRlbGltLmxlbmd0aCxcbiAgICAgIG5ld2xpbmVMZW4gPSBuZXdsaW5lLmxlbmd0aCxcbiAgICAgIGNvbW1lbnRzTGVuID0gY29tbWVudHMubGVuZ3RoO1xuICAgIHZhciBzdGVwSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oc3RlcCk7XG5cbiAgICAvLyBFc3RhYmxpc2ggc3RhcnRpbmcgc3RhdGVcbiAgICBjdXJzb3IgPSAwO1xuICAgIHZhciBkYXRhID0gW10sXG4gICAgICBlcnJvcnMgPSBbXSxcbiAgICAgIHJvdyA9IFtdLFxuICAgICAgbGFzdEN1cnNvciA9IDA7XG5cbiAgICBpZiAoIWlucHV0KSByZXR1cm4gcmV0dXJuYWJsZSgpO1xuXG4gICAgaWYgKGZhc3RNb2RlIHx8IChmYXN0TW9kZSAhPT0gZmFsc2UgJiYgaW5wdXQuaW5kZXhPZihxdW90ZUNoYXIpID09PSAtMSkpIHtcbiAgICAgIHZhciByb3dzID0gaW5wdXQuc3BsaXQobmV3bGluZSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcm93ID0gcm93c1tpXTtcbiAgICAgICAgY3Vyc29yICs9IHJvdy5sZW5ndGg7XG4gICAgICAgIGlmIChpICE9PSByb3dzLmxlbmd0aCAtIDEpIGN1cnNvciArPSBuZXdsaW5lLmxlbmd0aDtcbiAgICAgICAgZWxzZSBpZiAoaWdub3JlTGFzdFJvdykgcmV0dXJuIHJldHVybmFibGUoKTtcbiAgICAgICAgaWYgKGNvbW1lbnRzICYmIHJvdy5zdWJzdHIoMCwgY29tbWVudHNMZW4pID09PSBjb21tZW50cykgY29udGludWU7XG4gICAgICAgIGlmIChzdGVwSXNGdW5jdGlvbikge1xuICAgICAgICAgIGRhdGEgPSBbXTtcbiAgICAgICAgICBwdXNoUm93KHJvdy5zcGxpdChkZWxpbSkpO1xuICAgICAgICAgIGRvU3RlcCgpO1xuICAgICAgICAgIGlmIChhYm9ydGVkKSByZXR1cm4gcmV0dXJuYWJsZSgpO1xuICAgICAgICB9IGVsc2UgcHVzaFJvdyhyb3cuc3BsaXQoZGVsaW0pKTtcbiAgICAgICAgaWYgKHByZXZpZXcgJiYgaSA+PSBwcmV2aWV3KSB7XG4gICAgICAgICAgZGF0YSA9IGRhdGEuc2xpY2UoMCwgcHJldmlldyk7XG4gICAgICAgICAgcmV0dXJuIHJldHVybmFibGUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXR1cm5hYmxlKCk7XG4gICAgfVxuXG4gICAgdmFyIG5leHREZWxpbSA9IGlucHV0LmluZGV4T2YoZGVsaW0sIGN1cnNvcik7XG4gICAgdmFyIG5leHROZXdsaW5lID0gaW5wdXQuaW5kZXhPZihuZXdsaW5lLCBjdXJzb3IpO1xuICAgIHZhciBxdW90ZUNoYXJSZWdleCA9IG5ldyBSZWdFeHAoZXNjYXBlUmVnRXhwKGVzY2FwZUNoYXIpICsgZXNjYXBlUmVnRXhwKHF1b3RlQ2hhciksICdnJyk7XG4gICAgdmFyIHF1b3RlU2VhcmNoO1xuXG4gICAgLy8gUGFyc2VyIGxvb3BcbiAgICBmb3IgKDs7KSB7XG4gICAgICAvLyBGaWVsZCBoYXMgb3BlbmluZyBxdW90ZVxuICAgICAgaWYgKGlucHV0W2N1cnNvcl0gPT09IHF1b3RlQ2hhcikge1xuICAgICAgICAvLyBTdGFydCBvdXIgc2VhcmNoIGZvciB0aGUgY2xvc2luZyBxdW90ZSB3aGVyZSB0aGUgY3Vyc29yIGlzXG4gICAgICAgIHF1b3RlU2VhcmNoID0gY3Vyc29yO1xuXG4gICAgICAgIC8vIFNraXAgdGhlIG9wZW5pbmcgcXVvdGVcbiAgICAgICAgY3Vyc29yKys7XG5cbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIC8vIEZpbmQgY2xvc2luZyBxdW90ZVxuICAgICAgICAgIHF1b3RlU2VhcmNoID0gaW5wdXQuaW5kZXhPZihxdW90ZUNoYXIsIHF1b3RlU2VhcmNoICsgMSk7XG5cbiAgICAgICAgICAvL05vIG90aGVyIHF1b3RlcyBhcmUgZm91bmQgLSBubyBvdGhlciBkZWxpbWl0ZXJzXG4gICAgICAgICAgaWYgKHF1b3RlU2VhcmNoID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKCFpZ25vcmVMYXN0Um93KSB7XG4gICAgICAgICAgICAgIC8vIE5vIGNsb3NpbmcgcXVvdGUuLi4gd2hhdCBhIHBpdHlcbiAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdRdW90ZXMnLFxuICAgICAgICAgICAgICAgIGNvZGU6ICdNaXNzaW5nUXVvdGVzJyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnUXVvdGVkIGZpZWxkIHVudGVybWluYXRlZCcsXG4gICAgICAgICAgICAgICAgcm93OiBkYXRhLmxlbmd0aCwgLy8gcm93IGhhcyB5ZXQgdG8gYmUgaW5zZXJ0ZWRcbiAgICAgICAgICAgICAgICBpbmRleDogY3Vyc29yXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpbmlzaCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENsb3NpbmcgcXVvdGUgYXQgRU9GXG4gICAgICAgICAgaWYgKHF1b3RlU2VhcmNoID09PSBpbnB1dExlbiAtIDEpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGlucHV0LnN1YnN0cmluZyhjdXJzb3IsIHF1b3RlU2VhcmNoKS5yZXBsYWNlKHF1b3RlQ2hhclJlZ2V4LCBxdW90ZUNoYXIpO1xuICAgICAgICAgICAgcmV0dXJuIGZpbmlzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhpcyBxdW90ZSBpcyBlc2NhcGVkLCBpdCdzIHBhcnQgb2YgdGhlIGRhdGE7IHNraXAgaXRcbiAgICAgICAgICAvLyBJZiB0aGUgcXVvdGUgY2hhcmFjdGVyIGlzIHRoZSBlc2NhcGUgY2hhcmFjdGVyLCB0aGVuIGNoZWNrIGlmIHRoZSBuZXh0IGNoYXJhY3RlciBpcyB0aGUgZXNjYXBlIGNoYXJhY3RlclxuICAgICAgICAgIGlmIChxdW90ZUNoYXIgPT09IGVzY2FwZUNoYXIgJiYgaW5wdXRbcXVvdGVTZWFyY2ggKyAxXSA9PT0gZXNjYXBlQ2hhcikge1xuICAgICAgICAgICAgcXVvdGVTZWFyY2grKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHRoZSBxdW90ZSBjaGFyYWN0ZXIgaXMgbm90IHRoZSBlc2NhcGUgY2hhcmFjdGVyLCB0aGVuIGNoZWNrIGlmIHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIgd2FzIHRoZSBlc2NhcGUgY2hhcmFjdGVyXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcXVvdGVDaGFyICE9PSBlc2NhcGVDaGFyICYmXG4gICAgICAgICAgICBxdW90ZVNlYXJjaCAhPT0gMCAmJlxuICAgICAgICAgICAgaW5wdXRbcXVvdGVTZWFyY2ggLSAxXSA9PT0gZXNjYXBlQ2hhclxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ2hlY2sgdXAgdG8gbmV4dERlbGltIG9yIG5leHROZXdsaW5lLCB3aGljaGV2ZXIgaXMgY2xvc2VzdFxuICAgICAgICAgIHZhciBjaGVja1VwVG8gPSBuZXh0TmV3bGluZSA9PT0gLTEgPyBuZXh0RGVsaW0gOiBNYXRoLm1pbihuZXh0RGVsaW0sIG5leHROZXdsaW5lKTtcbiAgICAgICAgICB2YXIgc3BhY2VzQmV0d2VlblF1b3RlQW5kRGVsaW1pdGVyID0gZXh0cmFTcGFjZXMoY2hlY2tVcFRvKTtcblxuICAgICAgICAgIC8vIENsb3NpbmcgcXVvdGUgZm9sbG93ZWQgYnkgZGVsaW1pdGVyIG9yICd1bm5lY2Vzc2FyeSBzcGFjZXMgKyBkZWxpbWl0ZXInXG4gICAgICAgICAgaWYgKGlucHV0W3F1b3RlU2VhcmNoICsgMSArIHNwYWNlc0JldHdlZW5RdW90ZUFuZERlbGltaXRlcl0gPT09IGRlbGltKSB7XG4gICAgICAgICAgICByb3cucHVzaChpbnB1dC5zdWJzdHJpbmcoY3Vyc29yLCBxdW90ZVNlYXJjaCkucmVwbGFjZShxdW90ZUNoYXJSZWdleCwgcXVvdGVDaGFyKSk7XG4gICAgICAgICAgICBjdXJzb3IgPSBxdW90ZVNlYXJjaCArIDEgKyBzcGFjZXNCZXR3ZWVuUXVvdGVBbmREZWxpbWl0ZXIgKyBkZWxpbUxlbjtcbiAgICAgICAgICAgIG5leHREZWxpbSA9IGlucHV0LmluZGV4T2YoZGVsaW0sIGN1cnNvcik7XG4gICAgICAgICAgICBuZXh0TmV3bGluZSA9IGlucHV0LmluZGV4T2YobmV3bGluZSwgY3Vyc29yKTtcblxuICAgICAgICAgICAgaWYgKHN0ZXBJc0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICAgIGRvU3RlcCgpO1xuICAgICAgICAgICAgICBpZiAoYWJvcnRlZCkgcmV0dXJuIHJldHVybmFibGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByZXZpZXcgJiYgZGF0YS5sZW5ndGggPj0gcHJldmlldykgcmV0dXJuIHJldHVybmFibGUodHJ1ZSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzcGFjZXNCZXR3ZWVuUXVvdGVBbmROZXdMaW5lID0gZXh0cmFTcGFjZXMobmV4dE5ld2xpbmUpO1xuXG4gICAgICAgICAgLy8gQ2xvc2luZyBxdW90ZSBmb2xsb3dlZCBieSBuZXdsaW5lIG9yICd1bm5lY2Vzc2FyeSBzcGFjZXMgKyBuZXdMaW5lJ1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGlucHV0LnN1YnN0cihxdW90ZVNlYXJjaCArIDEgKyBzcGFjZXNCZXR3ZWVuUXVvdGVBbmROZXdMaW5lLCBuZXdsaW5lTGVuKSA9PT0gbmV3bGluZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcm93LnB1c2goaW5wdXQuc3Vic3RyaW5nKGN1cnNvciwgcXVvdGVTZWFyY2gpLnJlcGxhY2UocXVvdGVDaGFyUmVnZXgsIHF1b3RlQ2hhcikpO1xuICAgICAgICAgICAgc2F2ZVJvdyhxdW90ZVNlYXJjaCArIDEgKyBzcGFjZXNCZXR3ZWVuUXVvdGVBbmROZXdMaW5lICsgbmV3bGluZUxlbik7XG4gICAgICAgICAgICBuZXh0RGVsaW0gPSBpbnB1dC5pbmRleE9mKGRlbGltLCBjdXJzb3IpOyAvLyBiZWNhdXNlIHdlIG1heSBoYXZlIHNraXBwZWQgdGhlIG5leHREZWxpbSBpbiB0aGUgcXVvdGVkIGZpZWxkXG5cbiAgICAgICAgICAgIGlmIChzdGVwSXNGdW5jdGlvbikge1xuICAgICAgICAgICAgICBkb1N0ZXAoKTtcbiAgICAgICAgICAgICAgaWYgKGFib3J0ZWQpIHJldHVybiByZXR1cm5hYmxlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcmV2aWV3ICYmIGRhdGEubGVuZ3RoID49IHByZXZpZXcpIHJldHVybiByZXR1cm5hYmxlKHRydWUpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDaGVja3MgZm9yIHZhbGlkIGNsb3NpbmcgcXVvdGVzIGFyZSBjb21wbGV0ZSAoZXNjYXBlZCBxdW90ZXMgb3IgcXVvdGUgZm9sbG93ZWQgYnkgRU9GL2RlbGltaXRlci9uZXdsaW5lKSAtLSBhc3N1bWUgdGhlc2UgcXVvdGVzIGFyZSBwYXJ0IG9mIGFuIGludmFsaWQgdGV4dCBzdHJpbmdcbiAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnUXVvdGVzJyxcbiAgICAgICAgICAgIGNvZGU6ICdJbnZhbGlkUXVvdGVzJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdUcmFpbGluZyBxdW90ZSBvbiBxdW90ZWQgZmllbGQgaXMgbWFsZm9ybWVkJyxcbiAgICAgICAgICAgIHJvdzogZGF0YS5sZW5ndGgsIC8vIHJvdyBoYXMgeWV0IHRvIGJlIGluc2VydGVkXG4gICAgICAgICAgICBpbmRleDogY3Vyc29yXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBxdW90ZVNlYXJjaCsrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0ZXBJc0Z1bmN0aW9uKSB7XG4gICAgICAgICAgZG9TdGVwKCk7XG4gICAgICAgICAgaWYgKGFib3J0ZWQpIHJldHVybiByZXR1cm5hYmxlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJldmlldyAmJiBkYXRhLmxlbmd0aCA+PSBwcmV2aWV3KSByZXR1cm4gcmV0dXJuYWJsZSh0cnVlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENvbW1lbnQgZm91bmQgYXQgc3RhcnQgb2YgbmV3IGxpbmVcbiAgICAgIGlmIChjb21tZW50cyAmJiByb3cubGVuZ3RoID09PSAwICYmIGlucHV0LnN1YnN0cihjdXJzb3IsIGNvbW1lbnRzTGVuKSA9PT0gY29tbWVudHMpIHtcbiAgICAgICAgaWYgKG5leHROZXdsaW5lID09PSAtMSlcbiAgICAgICAgICAvLyBDb21tZW50IGVuZHMgYXQgRU9GXG4gICAgICAgICAgcmV0dXJuIHJldHVybmFibGUoKTtcbiAgICAgICAgY3Vyc29yID0gbmV4dE5ld2xpbmUgKyBuZXdsaW5lTGVuO1xuICAgICAgICBuZXh0TmV3bGluZSA9IGlucHV0LmluZGV4T2YobmV3bGluZSwgY3Vyc29yKTtcbiAgICAgICAgbmV4dERlbGltID0gaW5wdXQuaW5kZXhPZihkZWxpbSwgY3Vyc29yKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIE5leHQgZGVsaW1pdGVyIGNvbWVzIGJlZm9yZSBuZXh0IG5ld2xpbmUsIHNvIHdlJ3ZlIHJlYWNoZWQgZW5kIG9mIGZpZWxkXG4gICAgICBpZiAobmV4dERlbGltICE9PSAtMSAmJiAobmV4dERlbGltIDwgbmV4dE5ld2xpbmUgfHwgbmV4dE5ld2xpbmUgPT09IC0xKSkge1xuICAgICAgICByb3cucHVzaChpbnB1dC5zdWJzdHJpbmcoY3Vyc29yLCBuZXh0RGVsaW0pKTtcbiAgICAgICAgY3Vyc29yID0gbmV4dERlbGltICsgZGVsaW1MZW47XG4gICAgICAgIG5leHREZWxpbSA9IGlucHV0LmluZGV4T2YoZGVsaW0sIGN1cnNvcik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBFbmQgb2Ygcm93XG4gICAgICBpZiAobmV4dE5ld2xpbmUgIT09IC0xKSB7XG4gICAgICAgIHJvdy5wdXNoKGlucHV0LnN1YnN0cmluZyhjdXJzb3IsIG5leHROZXdsaW5lKSk7XG4gICAgICAgIHNhdmVSb3cobmV4dE5ld2xpbmUgKyBuZXdsaW5lTGVuKTtcblxuICAgICAgICBpZiAoc3RlcElzRnVuY3Rpb24pIHtcbiAgICAgICAgICBkb1N0ZXAoKTtcbiAgICAgICAgICBpZiAoYWJvcnRlZCkgcmV0dXJuIHJldHVybmFibGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmV2aWV3ICYmIGRhdGEubGVuZ3RoID49IHByZXZpZXcpIHJldHVybiByZXR1cm5hYmxlKHRydWUpO1xuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gZmluaXNoKCk7XG5cbiAgICBmdW5jdGlvbiBwdXNoUm93KHJvdykge1xuICAgICAgZGF0YS5wdXNoKHJvdyk7XG4gICAgICBsYXN0Q3Vyc29yID0gY3Vyc29yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNoZWNrcyBpZiB0aGVyZSBhcmUgZXh0cmEgc3BhY2VzIGFmdGVyIGNsb3NpbmcgcXVvdGUgYW5kIGdpdmVuIGluZGV4IHdpdGhvdXQgYW55IHRleHRcbiAgICAgKiBpZiBZZXMsIHJldHVybnMgdGhlIG51bWJlciBvZiBzcGFjZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBleHRyYVNwYWNlcyhpbmRleCkge1xuICAgICAgdmFyIHNwYWNlTGVuZ3RoID0gMDtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdmFyIHRleHRCZXR3ZWVuQ2xvc2luZ1F1b3RlQW5kSW5kZXggPSBpbnB1dC5zdWJzdHJpbmcocXVvdGVTZWFyY2ggKyAxLCBpbmRleCk7XG4gICAgICAgIGlmICh0ZXh0QmV0d2VlbkNsb3NpbmdRdW90ZUFuZEluZGV4ICYmIHRleHRCZXR3ZWVuQ2xvc2luZ1F1b3RlQW5kSW5kZXgudHJpbSgpID09PSAnJykge1xuICAgICAgICAgIHNwYWNlTGVuZ3RoID0gdGV4dEJldHdlZW5DbG9zaW5nUXVvdGVBbmRJbmRleC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzcGFjZUxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIHRoZSByZW1haW5pbmcgaW5wdXQgZnJvbSBjdXJzb3IgdG8gdGhlIGVuZCBpbnRvXG4gICAgICogcm93LCBzYXZlcyB0aGUgcm93LCBjYWxscyBzdGVwLCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5pc2godmFsdWUpIHtcbiAgICAgIGlmIChpZ25vcmVMYXN0Um93KSByZXR1cm4gcmV0dXJuYWJsZSgpO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHZhbHVlID0gaW5wdXQuc3Vic3RyKGN1cnNvcik7XG4gICAgICByb3cucHVzaCh2YWx1ZSk7XG4gICAgICBjdXJzb3IgPSBpbnB1dExlbjsgLy8gaW1wb3J0YW50IGluIGNhc2UgcGFyc2luZyBpcyBwYXVzZWRcbiAgICAgIHB1c2hSb3cocm93KTtcbiAgICAgIGlmIChzdGVwSXNGdW5jdGlvbikgZG9TdGVwKCk7XG4gICAgICByZXR1cm4gcmV0dXJuYWJsZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgdGhlIGN1cnJlbnQgcm93IHRvIHRoZSByZXN1bHRzLiBJdCBzZXRzIHRoZSBjdXJzb3JcbiAgICAgKiB0byBuZXdDdXJzb3IgYW5kIGZpbmRzIHRoZSBuZXh0TmV3bGluZS4gVGhlIGNhbGxlciBzaG91bGRcbiAgICAgKiB0YWtlIGNhcmUgdG8gZXhlY3V0ZSB1c2VyJ3Mgc3RlcCBmdW5jdGlvbiBhbmQgY2hlY2sgZm9yXG4gICAgICogcHJldmlldyBhbmQgZW5kIHBhcnNpbmcgaWYgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhdmVSb3cobmV3Q3Vyc29yKSB7XG4gICAgICBjdXJzb3IgPSBuZXdDdXJzb3I7XG4gICAgICBwdXNoUm93KHJvdyk7XG4gICAgICByb3cgPSBbXTtcbiAgICAgIG5leHROZXdsaW5lID0gaW5wdXQuaW5kZXhPZihuZXdsaW5lLCBjdXJzb3IpO1xuICAgIH1cblxuICAgIC8qKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSByZXN1bHRzLCBlcnJvcnMsIGFuZCBtZXRhLiAqL1xuICAgIGZ1bmN0aW9uIHJldHVybmFibGUoc3RvcHBlZCwgc3RlcCkge1xuICAgICAgdmFyIGlzU3RlcCA9IHN0ZXAgfHwgZmFsc2U7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBpc1N0ZXAgPyBkYXRhWzBdIDogZGF0YSxcbiAgICAgICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgICAgIG1ldGE6IHtcbiAgICAgICAgICBkZWxpbWl0ZXI6IGRlbGltLFxuICAgICAgICAgIGxpbmVicmVhazogbmV3bGluZSxcbiAgICAgICAgICBhYm9ydGVkOiBhYm9ydGVkLFxuICAgICAgICAgIHRydW5jYXRlZDogISFzdG9wcGVkLFxuICAgICAgICAgIGN1cnNvcjogbGFzdEN1cnNvciArIChiYXNlSW5kZXggfHwgMClcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKiogRXhlY3V0ZXMgdGhlIHVzZXIncyBzdGVwIGZ1bmN0aW9uIGFuZCByZXNldHMgZGF0YSAmIGVycm9ycy4gKi9cbiAgICBmdW5jdGlvbiBkb1N0ZXAoKSB7XG4gICAgICBzdGVwKHJldHVybmFibGUodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgICBkYXRhID0gW107XG4gICAgICBlcnJvcnMgPSBbXTtcbiAgICB9XG4gIH07XG5cbiAgLyoqIFNldHMgdGhlIGFib3J0IGZsYWcgKi9cbiAgdGhpcy5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgIGFib3J0ZWQgPSB0cnVlO1xuICB9O1xuXG4gIC8qKiBHZXRzIHRoZSBjdXJzb3IgcG9zaXRpb24gKi9cbiAgdGhpcy5nZXRDaGFySW5kZXggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY3Vyc29yO1xuICB9O1xufVxuXG5mdW5jdGlvbiBub3RJbXBsZW1lbnRlZCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQuJyk7XG59XG5cbi8qKiBNYWtlcyBhIGRlZXAgY29weSBvZiBhbiBhcnJheSBvciBvYmplY3QgKG1vc3RseSkgKi9cbmZ1bmN0aW9uIGNvcHkob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHJldHVybiBvYmo7XG4gIHZhciBjcHkgPSBBcnJheS5pc0FycmF5KG9iaikgPyBbXSA6IHt9O1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSBjcHlba2V5XSA9IGNvcHkob2JqW2tleV0pO1xuICByZXR1cm4gY3B5O1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGZ1bmMpIHtcbiAgcmV0dXJuIHR5cGVvZiBmdW5jID09PSAnZnVuY3Rpb24nO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG52YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzc2VydFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYXNzZXJ0LmFzc2VydDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0Jyb3dzZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dsb2JhbHMuaXNCcm93c2VyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzV29ya2VyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxzLmlzV29ya2VyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5vZGVWZXJzaW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxzLm5vZGVWZXJzaW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNlbGZcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dsb2JhbHMuc2VsZjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ3aW5kb3dcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dsb2JhbHMud2luZG93O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdsb2JhbFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2xvYmFscy5nbG9iYWw7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZG9jdW1lbnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dsb2JhbHMuZG9jdW1lbnQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlTG9hZGVyV29ya2VyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVMb2FkZXJXb3JrZXIuY3JlYXRlTG9hZGVyV29ya2VyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlV2l0aFdvcmtlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfcGFyc2VXaXRoV29ya2VyLnBhcnNlV2l0aFdvcmtlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjYW5QYXJzZVdpdGhXb3JrZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3BhcnNlV2l0aFdvcmtlci5jYW5QYXJzZVdpdGhXb3JrZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VKU09OXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9wYXJzZUpzb24ucGFyc2VKU09OO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvQXJyYXlCdWZmZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2FycmF5QnVmZmVyVXRpbHMudG9BcnJheUJ1ZmZlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzbGljZUFycmF5QnVmZmVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hcnJheUJ1ZmZlclV0aWxzLnNsaWNlQXJyYXlCdWZmZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2FycmF5QnVmZmVyVXRpbHMuY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29uY2F0ZW5hdGVUeXBlZEFycmF5c1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYXJyYXlCdWZmZXJVdGlscy5jb25jYXRlbmF0ZVR5cGVkQXJyYXlzO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbXBhcmVBcnJheUJ1ZmZlcnNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2FycmF5QnVmZmVyVXRpbHMuY29tcGFyZUFycmF5QnVmZmVycztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYWRUb05CeXRlc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbWVtb3J5Q29weVV0aWxzLnBhZFRvTkJ5dGVzO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvcHlUb0FycmF5XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9tZW1vcnlDb3B5VXRpbHMuY29weVRvQXJyYXk7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29weUFycmF5QnVmZmVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9tZW1vcnlDb3B5VXRpbHMuY29weUFycmF5QnVmZmVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvcHlQYWRkZWRBcnJheUJ1ZmZlclRvRGF0YVZpZXdcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2JpbmFyeUNvcHlVdGlscy5jb3B5UGFkZGVkQXJyYXlCdWZmZXJUb0RhdGFWaWV3O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvcHlQYWRkZWRTdHJpbmdUb0RhdGFWaWV3XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9iaW5hcnlDb3B5VXRpbHMuY29weVBhZGRlZFN0cmluZ1RvRGF0YVZpZXc7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFkU3RyaW5nVG9CeXRlQWxpZ25tZW50XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9lbmNvZGVVdGlscy5wYWRTdHJpbmdUb0J5dGVBbGlnbm1lbnQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29weVN0cmluZ1RvRGF0YVZpZXdcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2VuY29kZVV0aWxzLmNvcHlTdHJpbmdUb0RhdGFWaWV3O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvcHlCaW5hcnlUb0RhdGFWaWV3XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9lbmNvZGVVdGlscy5jb3B5QmluYXJ5VG9EYXRhVmlldztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRGaXJzdENoYXJhY3RlcnNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dldEZpcnN0Q2hhcmFjdGVycy5nZXRGaXJzdENoYXJhY3RlcnM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0TWFnaWNTdHJpbmdcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dldEZpcnN0Q2hhcmFjdGVycy5nZXRNYWdpY1N0cmluZztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYWtlVGV4dEVuY29kZXJJdGVyYXRvclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdGV4dEl0ZXJhdG9ycy5tYWtlVGV4dEVuY29kZXJJdGVyYXRvcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYWtlVGV4dERlY29kZXJJdGVyYXRvclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdGV4dEl0ZXJhdG9ycy5tYWtlVGV4dERlY29kZXJJdGVyYXRvcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYWtlTGluZUl0ZXJhdG9yXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90ZXh0SXRlcmF0b3JzLm1ha2VMaW5lSXRlcmF0b3I7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWFrZU51bWJlcmVkTGluZUl0ZXJhdG9yXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90ZXh0SXRlcmF0b3JzLm1ha2VOdW1iZXJlZExpbmVJdGVyYXRvcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmb3JFYWNoXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hc3luY0l0ZXJhdGlvbi5mb3JFYWNoO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzQXN5bmNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2FzeW5jSXRlcmF0aW9uLmNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzQXN5bmM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFNjaGVkdWxlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfcmVxdWVzdFNjaGVkdWxlci5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNldFBhdGhQcmVmaXhcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ZpbGVBbGlhc2VzLnNldFBhdGhQcmVmaXg7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0UGF0aFByZWZpeFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZmlsZUFsaWFzZXMuZ2V0UGF0aFByZWZpeDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZXNvbHZlUGF0aFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZmlsZUFsaWFzZXMucmVzb2x2ZVBhdGg7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX2FkZEFsaWFzZXNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2ZpbGVBbGlhc2VzLmFkZEFsaWFzZXM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNCdWZmZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2J1ZmZlclV0aWxzLmlzQnVmZmVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvQnVmZmVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9idWZmZXJVdGlscy50b0J1ZmZlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJidWZmZXJUb0FycmF5QnVmZmVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9idWZmZXJVdGlscy5idWZmZXJUb0FycmF5QnVmZmVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkpTT05Mb2FkZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2pzb25Mb2FkZXIuSlNPTkxvYWRlcjtcbiAgfVxufSk7XG5leHBvcnRzLmZzID0gZXhwb3J0cy5wYXRoID0gdm9pZCAwO1xuXG52YXIgX2Fzc2VydCA9IHJlcXVpcmUoXCIuL2xpYi9lbnYtdXRpbHMvYXNzZXJ0XCIpO1xuXG52YXIgX2dsb2JhbHMgPSByZXF1aXJlKFwiLi9saWIvZW52LXV0aWxzL2dsb2JhbHNcIik7XG5cbnZhciBfY3JlYXRlTG9hZGVyV29ya2VyID0gcmVxdWlyZShcIi4vbGliL3dvcmtlci1sb2FkZXItdXRpbHMvY3JlYXRlLWxvYWRlci13b3JrZXJcIik7XG5cbnZhciBfcGFyc2VXaXRoV29ya2VyID0gcmVxdWlyZShcIi4vbGliL3dvcmtlci1sb2FkZXItdXRpbHMvcGFyc2Utd2l0aC13b3JrZXJcIik7XG5cbnZhciBfcGFyc2VKc29uID0gcmVxdWlyZShcIi4vbGliL3BhcnNlci11dGlscy9wYXJzZS1qc29uXCIpO1xuXG52YXIgX2FycmF5QnVmZmVyVXRpbHMgPSByZXF1aXJlKFwiLi9saWIvYmluYXJ5LXV0aWxzL2FycmF5LWJ1ZmZlci11dGlsc1wiKTtcblxudmFyIF9tZW1vcnlDb3B5VXRpbHMgPSByZXF1aXJlKFwiLi9saWIvYmluYXJ5LXV0aWxzL21lbW9yeS1jb3B5LXV0aWxzXCIpO1xuXG52YXIgX2JpbmFyeUNvcHlVdGlscyA9IHJlcXVpcmUoXCIuL2xpYi9iaW5hcnktdXRpbHMvYmluYXJ5LWNvcHktdXRpbHNcIik7XG5cbnZhciBfZW5jb2RlVXRpbHMgPSByZXF1aXJlKFwiLi9saWIvYmluYXJ5LXV0aWxzL2VuY29kZS11dGlsc1wiKTtcblxudmFyIF9nZXRGaXJzdENoYXJhY3RlcnMgPSByZXF1aXJlKFwiLi9saWIvYmluYXJ5LXV0aWxzL2dldC1maXJzdC1jaGFyYWN0ZXJzXCIpO1xuXG52YXIgX3RleHRJdGVyYXRvcnMgPSByZXF1aXJlKFwiLi9saWIvaXRlcmF0b3JzL3RleHQtaXRlcmF0b3JzXCIpO1xuXG52YXIgX2FzeW5jSXRlcmF0aW9uID0gcmVxdWlyZShcIi4vbGliL2l0ZXJhdG9ycy9hc3luYy1pdGVyYXRpb25cIik7XG5cbnZhciBfcmVxdWVzdFNjaGVkdWxlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL3JlcXVlc3QtdXRpbHMvcmVxdWVzdC1zY2hlZHVsZXJcIikpO1xuXG52YXIgcGF0aCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2xpYi9wYXRoLXV0aWxzL3BhdGhcIikpO1xuXG5leHBvcnRzLnBhdGggPSBwYXRoO1xuXG52YXIgX2ZpbGVBbGlhc2VzID0gcmVxdWlyZShcIi4vbGliL3BhdGgtdXRpbHMvZmlsZS1hbGlhc2VzXCIpO1xuXG52YXIgZnMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9saWIvbm9kZS9mc1wiKSk7XG5cbmV4cG9ydHMuZnMgPSBmcztcblxudmFyIF9idWZmZXJVdGlscyA9IHJlcXVpcmUoXCIuL2xpYi9iaW5hcnktdXRpbHMvYnVmZmVyLXV0aWxzXCIpO1xuXG52YXIgX2pzb25Mb2FkZXIgPSByZXF1aXJlKFwiLi9qc29uLWxvYWRlclwiKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7IH0pKG5vZGVJbnRlcm9wKTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7IGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5fdHlwZWNoZWNrSlNPTkxvYWRlciA9IGV4cG9ydHMuSlNPTkxvYWRlciA9IHZvaWQgMDtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBWRVJTSU9OID0gdHlwZW9mIFwiMy4wLjlcIiAhPT0gJ3VuZGVmaW5lZCcgPyBcIjMuMC45XCIgOiAnbGF0ZXN0JztcbnZhciBKU09OTG9hZGVyID0ge1xuICBuYW1lOiAnSlNPTicsXG4gIGlkOiAnanNvbicsXG4gIG1vZHVsZTogJ2pzb24nLFxuICB2ZXJzaW9uOiBWRVJTSU9OLFxuICBleHRlbnNpb25zOiBbJ2pzb24nLCAnZ2VvanNvbiddLFxuICBtaW1lVHlwZXM6IFsnYXBwbGljYXRpb24vanNvbiddLFxuICBjYXRlZ29yeTogJ2pzb24nLFxuICB0ZXh0OiB0cnVlLFxuICBwYXJzZVRleHRTeW5jOiBwYXJzZVRleHRTeW5jLFxuICBwYXJzZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcGFyc2UgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZShhcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgcGFyc2VUZXh0U3luYyhuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYXJyYXlCdWZmZXIpKSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlKF94KSB7XG4gICAgICByZXR1cm4gX3BhcnNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlO1xuICB9KCksXG4gIG9wdGlvbnM6IHt9XG59O1xuZXhwb3J0cy5KU09OTG9hZGVyID0gSlNPTkxvYWRlcjtcblxuZnVuY3Rpb24gcGFyc2VUZXh0U3luYyh0ZXh0KSB7XG4gIHJldHVybiBKU09OLnBhcnNlKHRleHQpO1xufVxuXG52YXIgX3R5cGVjaGVja0pTT05Mb2FkZXIgPSBKU09OTG9hZGVyO1xuZXhwb3J0cy5fdHlwZWNoZWNrSlNPTkxvYWRlciA9IF90eXBlY2hlY2tKU09OTG9hZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNvbi1sb2FkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG52YXIgX3R5cGVvZjMgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnRvQXJyYXlCdWZmZXIgPSB0b0FycmF5QnVmZmVyO1xuZXhwb3J0cy5jb21wYXJlQXJyYXlCdWZmZXJzID0gY29tcGFyZUFycmF5QnVmZmVycztcbmV4cG9ydHMuY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnMgPSBjb25jYXRlbmF0ZUFycmF5QnVmZmVycztcbmV4cG9ydHMuY29uY2F0ZW5hdGVUeXBlZEFycmF5cyA9IGNvbmNhdGVuYXRlVHlwZWRBcnJheXM7XG5leHBvcnRzLnNsaWNlQXJyYXlCdWZmZXIgPSBzbGljZUFycmF5QnVmZmVyO1xuXG52YXIgX3R5cGVvZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKSk7XG5cbnZhciBub2RlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4uL25vZGUvYnVmZmVyLXV0aWxzLm5vZGVcIikpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpOyB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDsgfSkobm9kZUludGVyb3ApOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHsgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2YzKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIoZGF0YSkge1xuICBpZiAobm9kZS50b0FycmF5QnVmZmVyKSB7XG4gICAgZGF0YSA9IG5vZGUudG9BcnJheUJ1ZmZlcihkYXRhKTtcbiAgfVxuXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICByZXR1cm4gZGF0YS5idWZmZXI7XG4gIH1cblxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHRleHQgPSBkYXRhO1xuICAgIHZhciB1aW50OEFycmF5ID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHRleHQpO1xuICAgIHJldHVybiB1aW50OEFycmF5LmJ1ZmZlcjtcbiAgfVxuXG4gIGlmIChkYXRhICYmICgwLCBfdHlwZW9mMi5kZWZhdWx0KShkYXRhKSA9PT0gJ29iamVjdCcgJiYgZGF0YS5fdG9BcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBkYXRhLl90b0FycmF5QnVmZmVyKCk7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ3RvQXJyYXlCdWZmZXInKTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZUFycmF5QnVmZmVycyhhcnJheUJ1ZmZlcjEsIGFycmF5QnVmZmVyMiwgYnl0ZUxlbmd0aCkge1xuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8fCBhcnJheUJ1ZmZlcjEuYnl0ZUxlbmd0aDtcblxuICBpZiAoYXJyYXlCdWZmZXIxLmJ5dGVMZW5ndGggPCBieXRlTGVuZ3RoIHx8IGFycmF5QnVmZmVyMi5ieXRlTGVuZ3RoIDwgYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBhcnJheTEgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcjEpO1xuICB2YXIgYXJyYXkyID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIyKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5MS5sZW5ndGg7ICsraSkge1xuICAgIGlmIChhcnJheTFbaV0gIT09IGFycmF5MltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25jYXRlbmF0ZUFycmF5QnVmZmVycygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNvdXJjZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgc291cmNlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHZhciBzb3VyY2VBcnJheXMgPSBzb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlMikge1xuICAgIHJldHVybiBzb3VyY2UyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBuZXcgVWludDhBcnJheShzb3VyY2UyKSA6IHNvdXJjZTI7XG4gIH0pO1xuICB2YXIgYnl0ZUxlbmd0aCA9IHNvdXJjZUFycmF5cy5yZWR1Y2UoZnVuY3Rpb24gKGxlbmd0aCwgdHlwZWRBcnJheSkge1xuICAgIHJldHVybiBsZW5ndGggKyB0eXBlZEFycmF5LmJ5dGVMZW5ndGg7XG4gIH0sIDApO1xuICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZUxlbmd0aCk7XG4gIHZhciBvZmZzZXQgPSAwO1xuXG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihzb3VyY2VBcnJheXMpLFxuICAgICAgX3N0ZXA7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgdmFyIHNvdXJjZUFycmF5ID0gX3N0ZXAudmFsdWU7XG4gICAgICByZXN1bHQuc2V0KHNvdXJjZUFycmF5LCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IHNvdXJjZUFycmF5LmJ5dGVMZW5ndGg7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvci5mKCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0LmJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gY29uY2F0ZW5hdGVUeXBlZEFycmF5cygpIHtcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCB0eXBlZEFycmF5cyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgIHR5cGVkQXJyYXlzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cblxuICB2YXIgYXJyYXlzID0gdHlwZWRBcnJheXM7XG4gIHZhciBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBhcnJheXMgJiYgYXJyYXlzLmxlbmd0aCA+IDEgJiYgYXJyYXlzWzBdLmNvbnN0cnVjdG9yIHx8IG51bGw7XG5cbiAgaWYgKCFUeXBlZEFycmF5Q29uc3RydWN0b3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiY29uY2F0ZW5hdGVUeXBlZEFycmF5c1wiIC0gaW5jb3JyZWN0IHF1YW50aXR5IG9mIGFyZ3VtZW50cyBvciBhcmd1bWVudHMgaGF2ZSBpbmNvbXBhdGlibGUgZGF0YSB0eXBlcycpO1xuICB9XG5cbiAgdmFyIHN1bUxlbmd0aCA9IGFycmF5cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdmFsdWUpIHtcbiAgICByZXR1cm4gYWNjICsgdmFsdWUubGVuZ3RoO1xuICB9LCAwKTtcbiAgdmFyIHJlc3VsdCA9IG5ldyBUeXBlZEFycmF5Q29uc3RydWN0b3Ioc3VtTGVuZ3RoKTtcbiAgdmFyIG9mZnNldCA9IDA7XG5cbiAgZm9yICh2YXIgX2kgPSAwLCBfYXJyYXlzID0gYXJyYXlzOyBfaSA8IF9hcnJheXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIGFycmF5ID0gX2FycmF5c1tfaV07XG4gICAgcmVzdWx0LnNldChhcnJheSwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gYXJyYXkubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gc2xpY2VBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICB2YXIgc3ViQXJyYXkgPSBieXRlTGVuZ3RoICE9PSB1bmRlZmluZWQgPyBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikuc3ViYXJyYXkoYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIGJ5dGVMZW5ndGgpIDogbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpLnN1YmFycmF5KGJ5dGVPZmZzZXQpO1xuICB2YXIgYXJyYXlDb3B5ID0gbmV3IFVpbnQ4QXJyYXkoc3ViQXJyYXkpO1xuICByZXR1cm4gYXJyYXlDb3B5LmJ1ZmZlcjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFycmF5LWJ1ZmZlci11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY29weVBhZGRlZEFycmF5QnVmZmVyVG9EYXRhVmlldyA9IGNvcHlQYWRkZWRBcnJheUJ1ZmZlclRvRGF0YVZpZXc7XG5leHBvcnRzLmNvcHlQYWRkZWRTdHJpbmdUb0RhdGFWaWV3ID0gY29weVBhZGRlZFN0cmluZ1RvRGF0YVZpZXc7XG5cbnZhciBfbWVtb3J5Q29weVV0aWxzID0gcmVxdWlyZShcIi4vbWVtb3J5LWNvcHktdXRpbHNcIik7XG5cbmZ1bmN0aW9uIGNvcHlQYWRkZWRBcnJheUJ1ZmZlclRvRGF0YVZpZXcoZGF0YVZpZXcsIGJ5dGVPZmZzZXQsIHNvdXJjZUJ1ZmZlciwgcGFkZGluZykge1xuICB2YXIgcGFkZGVkTGVuZ3RoID0gKDAsIF9tZW1vcnlDb3B5VXRpbHMucGFkVG9OQnl0ZXMpKHNvdXJjZUJ1ZmZlci5ieXRlTGVuZ3RoLCBwYWRkaW5nKTtcbiAgdmFyIHBhZExlbmd0aCA9IHBhZGRlZExlbmd0aCAtIHNvdXJjZUJ1ZmZlci5ieXRlTGVuZ3RoO1xuXG4gIGlmIChkYXRhVmlldykge1xuICAgIHZhciB0YXJnZXRBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGFWaWV3LmJ1ZmZlciwgZGF0YVZpZXcuYnl0ZU9mZnNldCArIGJ5dGVPZmZzZXQsIHNvdXJjZUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICB2YXIgc291cmNlQXJyYXkgPSBuZXcgVWludDhBcnJheShzb3VyY2VCdWZmZXIpO1xuICAgIHRhcmdldEFycmF5LnNldChzb3VyY2VBcnJheSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhZExlbmd0aDsgKytpKSB7XG4gICAgICBkYXRhVmlldy5zZXRVaW50OChieXRlT2Zmc2V0ICsgc291cmNlQnVmZmVyLmJ5dGVMZW5ndGggKyBpLCAweDIwKTtcbiAgICB9XG4gIH1cblxuICBieXRlT2Zmc2V0ICs9IHBhZGRlZExlbmd0aDtcbiAgcmV0dXJuIGJ5dGVPZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIGNvcHlQYWRkZWRTdHJpbmdUb0RhdGFWaWV3KGRhdGFWaWV3LCBieXRlT2Zmc2V0LCBzdHJpbmcsIHBhZGRpbmcpIHtcbiAgdmFyIHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIHZhciBzdHJpbmdCdWZmZXIgPSB0ZXh0RW5jb2Rlci5lbmNvZGUoc3RyaW5nKTtcbiAgYnl0ZU9mZnNldCA9IGNvcHlQYWRkZWRBcnJheUJ1ZmZlclRvRGF0YVZpZXcoZGF0YVZpZXcsIGJ5dGVPZmZzZXQsIHN0cmluZ0J1ZmZlciwgcGFkZGluZyk7XG4gIHJldHVybiBieXRlT2Zmc2V0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmluYXJ5LWNvcHktdXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG52YXIgX3R5cGVvZjMgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmlzQnVmZmVyID0gaXNCdWZmZXI7XG5leHBvcnRzLnRvQnVmZmVyID0gdG9CdWZmZXI7XG5leHBvcnRzLmJ1ZmZlclRvQXJyYXlCdWZmZXIgPSBidWZmZXJUb0FycmF5QnVmZmVyO1xuXG52YXIgX3R5cGVvZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKSk7XG5cbnZhciBub2RlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4uL25vZGUvYnVmZmVyLXV0aWxzLm5vZGVcIikpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpOyB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDsgfSkobm9kZUludGVyb3ApOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHsgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2YzKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5mdW5jdGlvbiBpc0J1ZmZlcih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJiYgKDAsIF90eXBlb2YyLmRlZmF1bHQpKHZhbHVlKSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuaXNCdWZmZXI7XG59XG5cbmZ1bmN0aW9uIHRvQnVmZmVyKGRhdGEpIHtcbiAgcmV0dXJuIG5vZGUudG9CdWZmZXIgPyBub2RlLnRvQnVmZmVyKGRhdGEpIDogZGF0YTtcbn1cblxuZnVuY3Rpb24gYnVmZmVyVG9BcnJheUJ1ZmZlcihkYXRhKSB7XG4gIGlmIChub2RlLnRvQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gbm9kZS50b0FycmF5QnVmZmVyKGRhdGEpO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWZmZXItdXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnBhZFN0cmluZ1RvQnl0ZUFsaWdubWVudCA9IHBhZFN0cmluZ1RvQnl0ZUFsaWdubWVudDtcbmV4cG9ydHMuY29weVN0cmluZ1RvRGF0YVZpZXcgPSBjb3B5U3RyaW5nVG9EYXRhVmlldztcbmV4cG9ydHMuY29weUJpbmFyeVRvRGF0YVZpZXcgPSBjb3B5QmluYXJ5VG9EYXRhVmlldztcblxuZnVuY3Rpb24gcGFkU3RyaW5nVG9CeXRlQWxpZ25tZW50KHN0cmluZywgYnl0ZUFsaWdubWVudCkge1xuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgdmFyIHBhZGRlZExlbmd0aCA9IE1hdGguY2VpbChsZW5ndGggLyBieXRlQWxpZ25tZW50KSAqIGJ5dGVBbGlnbm1lbnQ7XG4gIHZhciBwYWRkaW5nID0gcGFkZGVkTGVuZ3RoIC0gbGVuZ3RoO1xuICB2YXIgd2hpdGVzcGFjZSA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFkZGluZzsgKytpKSB7XG4gICAgd2hpdGVzcGFjZSArPSAnICc7XG4gIH1cblxuICByZXR1cm4gc3RyaW5nICsgd2hpdGVzcGFjZTtcbn1cblxuZnVuY3Rpb24gY29weVN0cmluZ1RvRGF0YVZpZXcoZGF0YVZpZXcsIGJ5dGVPZmZzZXQsIHN0cmluZywgYnl0ZUxlbmd0aCkge1xuICBpZiAoZGF0YVZpZXcpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVMZW5ndGg7IGkrKykge1xuICAgICAgZGF0YVZpZXcuc2V0VWludDgoYnl0ZU9mZnNldCArIGksIHN0cmluZy5jaGFyQ29kZUF0KGkpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZU9mZnNldCArIGJ5dGVMZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGNvcHlCaW5hcnlUb0RhdGFWaWV3KGRhdGFWaWV3LCBieXRlT2Zmc2V0LCBiaW5hcnksIGJ5dGVMZW5ndGgpIHtcbiAgaWYgKGRhdGFWaWV3KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlTGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGFWaWV3LnNldFVpbnQ4KGJ5dGVPZmZzZXQgKyBpLCBiaW5hcnlbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVuY29kZS11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0Rmlyc3RDaGFyYWN0ZXJzID0gZ2V0Rmlyc3RDaGFyYWN0ZXJzO1xuZXhwb3J0cy5nZXRNYWdpY1N0cmluZyA9IGdldE1hZ2ljU3RyaW5nO1xuXG5mdW5jdGlvbiBnZXRGaXJzdENoYXJhY3RlcnMoZGF0YSkge1xuICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiA1O1xuXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGF0YS5zbGljZSgwLCBsZW5ndGgpO1xuICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgIHJldHVybiBnZXRNYWdpY1N0cmluZyhkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHZhciBieXRlT2Zmc2V0ID0gMDtcbiAgICByZXR1cm4gZ2V0TWFnaWNTdHJpbmcoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0TWFnaWNTdHJpbmcoYXJyYXlCdWZmZXIsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCA8PSBieXRlT2Zmc2V0ICsgbGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgdmFyIGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKTtcbiAgdmFyIG1hZ2ljID0gJyc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIG1hZ2ljICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVZpZXcuZ2V0VWludDgoYnl0ZU9mZnNldCArIGkpKTtcbiAgfVxuXG4gIHJldHVybiBtYWdpYztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1maXJzdC1jaGFyYWN0ZXJzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5wYWRUb05CeXRlcyA9IHBhZFRvTkJ5dGVzO1xuZXhwb3J0cy5jb3B5QXJyYXlCdWZmZXIgPSBjb3B5QXJyYXlCdWZmZXI7XG5leHBvcnRzLmNvcHlUb0FycmF5ID0gY29weVRvQXJyYXk7XG5cbnZhciBfYXNzZXJ0ID0gcmVxdWlyZShcIi4uL2Vudi11dGlscy9hc3NlcnRcIik7XG5cbmZ1bmN0aW9uIHBhZFRvTkJ5dGVzKGJ5dGVMZW5ndGgsIHBhZGRpbmcpIHtcbiAgKDAsIF9hc3NlcnQuYXNzZXJ0KShieXRlTGVuZ3RoID49IDApO1xuICAoMCwgX2Fzc2VydC5hc3NlcnQpKHBhZGRpbmcgPiAwKTtcbiAgcmV0dXJuIGJ5dGVMZW5ndGggKyAocGFkZGluZyAtIDEpICYgfihwYWRkaW5nIC0gMSk7XG59XG5cbmZ1bmN0aW9uIGNvcHlBcnJheUJ1ZmZlcih0YXJnZXRCdWZmZXIsIHNvdXJjZUJ1ZmZlciwgYnl0ZU9mZnNldCkge1xuICB2YXIgYnl0ZUxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogc291cmNlQnVmZmVyLmJ5dGVMZW5ndGg7XG4gIHZhciB0YXJnZXRBcnJheSA9IG5ldyBVaW50OEFycmF5KHRhcmdldEJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gIHZhciBzb3VyY2VBcnJheSA9IG5ldyBVaW50OEFycmF5KHNvdXJjZUJ1ZmZlcik7XG4gIHRhcmdldEFycmF5LnNldChzb3VyY2VBcnJheSk7XG4gIHJldHVybiB0YXJnZXRCdWZmZXI7XG59XG5cbmZ1bmN0aW9uIGNvcHlUb0FycmF5KHNvdXJjZSwgdGFyZ2V0LCB0YXJnZXRPZmZzZXQpIHtcbiAgdmFyIHNvdXJjZUFycmF5O1xuXG4gIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHNvdXJjZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoc291cmNlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3JjQnl0ZU9mZnNldCA9IHNvdXJjZS5ieXRlT2Zmc2V0O1xuICAgIHZhciBzcmNCeXRlTGVuZ3RoID0gc291cmNlLmJ5dGVMZW5ndGg7XG4gICAgc291cmNlQXJyYXkgPSBuZXcgVWludDhBcnJheShzb3VyY2UuYnVmZmVyIHx8IHNvdXJjZS5hcnJheUJ1ZmZlciwgc3JjQnl0ZU9mZnNldCwgc3JjQnl0ZUxlbmd0aCk7XG4gIH1cblxuICB0YXJnZXQuc2V0KHNvdXJjZUFycmF5LCB0YXJnZXRPZmZzZXQpO1xuICByZXR1cm4gdGFyZ2V0T2Zmc2V0ICsgcGFkVG9OQnl0ZXMoc291cmNlQXJyYXkuYnl0ZUxlbmd0aCwgNCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZW1vcnktY29weS11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYXNzZXJ0ID0gYXNzZXJ0O1xuXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ2xvYWRlciBhc3NlcnRpb24gZmFpbGVkLicpO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NlcnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5ub2RlVmVyc2lvbiA9IGV4cG9ydHMuaXNXb3JrZXIgPSBleHBvcnRzLmlzQnJvd3NlciA9IGV4cG9ydHMuZG9jdW1lbnQgPSBleHBvcnRzLmdsb2JhbCA9IGV4cG9ydHMud2luZG93ID0gZXhwb3J0cy5zZWxmID0gdm9pZCAwO1xuXG52YXIgX3R5cGVvZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKSk7XG5cbnZhciBnbG9iYWxzID0ge1xuICBzZWxmOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZixcbiAgd2luZG93OiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3csXG4gIGdsb2JhbDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLFxuICBkb2N1bWVudDogdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudFxufTtcbnZhciBzZWxmXyA9IGdsb2JhbHMuc2VsZiB8fCBnbG9iYWxzLndpbmRvdyB8fCBnbG9iYWxzLmdsb2JhbCB8fCB7fTtcbmV4cG9ydHMuc2VsZiA9IHNlbGZfO1xudmFyIHdpbmRvd18gPSBnbG9iYWxzLndpbmRvdyB8fCBnbG9iYWxzLnNlbGYgfHwgZ2xvYmFscy5nbG9iYWwgfHwge307XG5leHBvcnRzLndpbmRvdyA9IHdpbmRvd187XG52YXIgZ2xvYmFsXyA9IGdsb2JhbHMuZ2xvYmFsIHx8IGdsb2JhbHMuc2VsZiB8fCBnbG9iYWxzLndpbmRvdyB8fCB7fTtcbmV4cG9ydHMuZ2xvYmFsID0gZ2xvYmFsXztcbnZhciBkb2N1bWVudF8gPSBnbG9iYWxzLmRvY3VtZW50IHx8IHt9O1xuZXhwb3J0cy5kb2N1bWVudCA9IGRvY3VtZW50XztcbnZhciBpc0Jyb3dzZXIgPSAodHlwZW9mIHByb2Nlc3MgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogKDAsIF90eXBlb2YyLmRlZmF1bHQpKHByb2Nlc3MpKSAhPT0gJ29iamVjdCcgfHwgU3RyaW5nKHByb2Nlc3MpICE9PSAnW29iamVjdCBwcm9jZXNzXScgfHwgcHJvY2Vzcy5icm93c2VyO1xuZXhwb3J0cy5pc0Jyb3dzZXIgPSBpc0Jyb3dzZXI7XG52YXIgaXNXb3JrZXIgPSB0eXBlb2YgaW1wb3J0U2NyaXB0cyA9PT0gJ2Z1bmN0aW9uJztcbmV4cG9ydHMuaXNXb3JrZXIgPSBpc1dvcmtlcjtcbnZhciBtYXRjaGVzID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MudmVyc2lvbiAmJiAvdihbMC05XSopLy5leGVjKHByb2Nlc3MudmVyc2lvbik7XG52YXIgbm9kZVZlcnNpb24gPSBtYXRjaGVzICYmIHBhcnNlRmxvYXQobWF0Y2hlc1sxXSkgfHwgMDtcbmV4cG9ydHMubm9kZVZlcnNpb24gPSBub2RlVmVyc2lvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsb2JhbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5mb3JFYWNoID0gZm9yRWFjaDtcbmV4cG9ydHMuY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnNBc3luYyA9IGNvbmNhdGVuYXRlQXJyYXlCdWZmZXJzQXN5bmM7XG5leHBvcnRzLmNvbmNhdGVuYXRlU3RyaW5nc0FzeW5jID0gY29uY2F0ZW5hdGVTdHJpbmdzQXN5bmM7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jSXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY0l0ZXJhdG9yXCIpKTtcblxudmFyIF9hcnJheUJ1ZmZlclV0aWxzID0gcmVxdWlyZShcIi4uL2JpbmFyeS11dGlscy9hcnJheS1idWZmZXItdXRpbHNcIik7XG5cbmZ1bmN0aW9uIGZvckVhY2goX3gsIF94Mikge1xuICByZXR1cm4gX2ZvckVhY2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2ZvckVhY2goKSB7XG4gIF9mb3JFYWNoID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoaXRlcmF0b3IsIHZpc2l0b3IpIHtcbiAgICB2YXIgX3lpZWxkJGl0ZXJhdG9yJG5leHQsIGRvbmUsIHZhbHVlLCBjYW5jZWw7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghdHJ1ZSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvci5uZXh0KCk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBfeWllbGQkaXRlcmF0b3IkbmV4dCA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICBkb25lID0gX3lpZWxkJGl0ZXJhdG9yJG5leHQuZG9uZTtcbiAgICAgICAgICAgIHZhbHVlID0gX3lpZWxkJGl0ZXJhdG9yJG5leHQudmFsdWU7XG5cbiAgICAgICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGNhbmNlbCA9IHZpc2l0b3IodmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAoIWNhbmNlbCkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlKTtcbiAgfSkpO1xuICByZXR1cm4gX2ZvckVhY2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnNBc3luYyhfeDMpIHtcbiAgcmV0dXJuIF9jb25jYXRlbmF0ZUFycmF5QnVmZmVyc0FzeW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9jb25jYXRlbmF0ZUFycmF5QnVmZmVyc0FzeW5jKCkge1xuICBfY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnNBc3luYyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMihhc3luY0l0ZXJhdG9yKSB7XG4gICAgdmFyIGFycmF5QnVmZmVycywgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiwgX2RpZEl0ZXJhdG9yRXJyb3IsIF9pdGVyYXRvckVycm9yLCBfaXRlcmF0b3IsIF9zdGVwLCBfdmFsdWUsIGNodW5rO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgYXJyYXlCdWZmZXJzID0gW107XG4gICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDM7XG4gICAgICAgICAgICBfaXRlcmF0b3IgPSAoMCwgX2FzeW5jSXRlcmF0b3IyLmRlZmF1bHQpKGFzeW5jSXRlcmF0b3IpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA3O1xuICAgICAgICAgICAgcmV0dXJuIF9pdGVyYXRvci5uZXh0KCk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBfc3RlcCA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IF9zdGVwLmRvbmU7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDExO1xuICAgICAgICAgICAgcmV0dXJuIF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIF92YWx1ZSA9IF9jb250ZXh0Mi5zZW50O1xuXG4gICAgICAgICAgICBpZiAoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbikge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2h1bmsgPSBfdmFsdWU7XG4gICAgICAgICAgICBhcnJheUJ1ZmZlcnMucHVzaChjaHVuayk7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI0O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAyMDtcbiAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IF9jb250ZXh0MltcImNhdGNoXCJdKDMpO1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBfY29udGV4dDIudDA7XG5cbiAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAyNDtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMjU7XG5cbiAgICAgICAgICAgIGlmICghKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjk7XG4gICAgICAgICAgICByZXR1cm4gX2l0ZXJhdG9yLnJldHVybigpO1xuXG4gICAgICAgICAgY2FzZSAyOTpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMjk7XG5cbiAgICAgICAgICAgIGlmICghX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAzMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuXG4gICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuZmluaXNoKDI5KTtcblxuICAgICAgICAgIGNhc2UgMzM6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmZpbmlzaCgyNCk7XG5cbiAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgX2FycmF5QnVmZmVyVXRpbHMuY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnMuYXBwbHkodm9pZCAwLCBhcnJheUJ1ZmZlcnMpKTtcblxuICAgICAgICAgIGNhc2UgMzU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMiwgbnVsbCwgW1szLCAyMCwgMjQsIDM0XSwgWzI1LCwgMjksIDMzXV0pO1xuICB9KSk7XG4gIHJldHVybiBfY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnNBc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBjb25jYXRlbmF0ZVN0cmluZ3NBc3luYyhfeDQpIHtcbiAgcmV0dXJuIF9jb25jYXRlbmF0ZVN0cmluZ3NBc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfY29uY2F0ZW5hdGVTdHJpbmdzQXN5bmMoKSB7XG4gIF9jb25jYXRlbmF0ZVN0cmluZ3NBc3luYyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhhc3luY0l0ZXJhdG9yKSB7XG4gICAgdmFyIHN0cmluZ3MsIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yLCBfZGlkSXRlcmF0b3JFcnJvcjIsIF9pdGVyYXRvckVycm9yMiwgX2l0ZXJhdG9yMiwgX3N0ZXAyLCBfdmFsdWUyLCBjaHVuaztcblxuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHN0cmluZ3MgPSBbXTtcbiAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlO1xuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAzO1xuICAgICAgICAgICAgX2l0ZXJhdG9yMiA9ICgwLCBfYXN5bmNJdGVyYXRvcjIuZGVmYXVsdCkoYXN5bmNJdGVyYXRvcik7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDc7XG4gICAgICAgICAgICByZXR1cm4gX2l0ZXJhdG9yMi5uZXh0KCk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBfc3RlcDIgPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gX3N0ZXAyLmRvbmU7XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDExO1xuICAgICAgICAgICAgcmV0dXJuIF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBfdmFsdWUyID0gX2NvbnRleHQzLnNlbnQ7XG5cbiAgICAgICAgICAgIGlmIChfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMikge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDE4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2h1bmsgPSBfdmFsdWUyO1xuICAgICAgICAgICAgc3RyaW5ncy5wdXNoKGNodW5rKTtcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDI0O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAyMDtcbiAgICAgICAgICAgIF9jb250ZXh0My50MCA9IF9jb250ZXh0M1tcImNhdGNoXCJdKDMpO1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICAgICAgICAgIF9pdGVyYXRvckVycm9yMiA9IF9jb250ZXh0My50MDtcblxuICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDI0O1xuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAyNTtcblxuICAgICAgICAgICAgaWYgKCEoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuICE9IG51bGwpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDI5O1xuICAgICAgICAgICAgcmV0dXJuIF9pdGVyYXRvcjIucmV0dXJuKCk7XG5cbiAgICAgICAgICBjYXNlIDI5OlxuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAyOTtcblxuICAgICAgICAgICAgaWYgKCFfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAzMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjtcblxuICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmZpbmlzaCgyOSk7XG5cbiAgICAgICAgICBjYXNlIDMzOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5maW5pc2goMjQpO1xuXG4gICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIHN0cmluZ3Muam9pbignJykpO1xuXG4gICAgICAgICAgY2FzZSAzNTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUzLCBudWxsLCBbWzMsIDIwLCAyNCwgMzRdLCBbMjUsLCAyOSwgMzNdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9jb25jYXRlbmF0ZVN0cmluZ3NBc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXN5bmMtaXRlcmF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubWFrZVRleHREZWNvZGVySXRlcmF0b3IgPSBtYWtlVGV4dERlY29kZXJJdGVyYXRvcjtcbmV4cG9ydHMubWFrZVRleHRFbmNvZGVySXRlcmF0b3IgPSBtYWtlVGV4dEVuY29kZXJJdGVyYXRvcjtcbmV4cG9ydHMubWFrZUxpbmVJdGVyYXRvciA9IG1ha2VMaW5lSXRlcmF0b3I7XG5leHBvcnRzLm1ha2VOdW1iZXJlZExpbmVJdGVyYXRvciA9IG1ha2VOdW1iZXJlZExpbmVJdGVyYXRvcjtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hd2FpdEFzeW5jR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXdhaXRBc3luY0dlbmVyYXRvclwiKSk7XG5cbnZhciBfd3JhcEFzeW5jR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvd3JhcEFzeW5jR2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY0l0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNJdGVyYXRvclwiKSk7XG5cbmZ1bmN0aW9uIG1ha2VUZXh0RGVjb2Rlckl0ZXJhdG9yKF94KSB7XG4gIHJldHVybiBfbWFrZVRleHREZWNvZGVySXRlcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX21ha2VUZXh0RGVjb2Rlckl0ZXJhdG9yKCkge1xuICBfbWFrZVRleHREZWNvZGVySXRlcmF0b3IgPSAoMCwgX3dyYXBBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKGFycmF5QnVmZmVySXRlcmF0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyxcbiAgICAgICAgdGV4dERlY29kZXIsXG4gICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24sXG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yLFxuICAgICAgICBfaXRlcmF0b3JFcnJvcixcbiAgICAgICAgX2l0ZXJhdG9yLFxuICAgICAgICBfc3RlcCxcbiAgICAgICAgX3ZhbHVlLFxuICAgICAgICBhcnJheUJ1ZmZlcixcbiAgICAgICAgX2FyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIG9wdGlvbnMgPSBfYXJncy5sZW5ndGggPiAxICYmIF9hcmdzWzFdICE9PSB1bmRlZmluZWQgPyBfYXJnc1sxXSA6IHt9O1xuICAgICAgICAgICAgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIodW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA0O1xuICAgICAgICAgICAgX2l0ZXJhdG9yID0gKDAsIF9hc3luY0l0ZXJhdG9yMi5kZWZhdWx0KShhcnJheUJ1ZmZlckl0ZXJhdG9yKTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA4O1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfYXdhaXRBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoX2l0ZXJhdG9yLm5leHQoKSk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBfc3RlcCA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gX3N0ZXAuZG9uZTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMjtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2F3YWl0QXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKF9zdGVwLnZhbHVlKTtcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBfdmFsdWUgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgICBpZiAoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbikge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhcnJheUJ1ZmZlciA9IF92YWx1ZTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNztcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYXJyYXlCdWZmZXIgPT09ICdzdHJpbmcnID8gYXJyYXlCdWZmZXIgOiB0ZXh0RGVjb2Rlci5kZWNvZGUoYXJyYXlCdWZmZXIsIHtcbiAgICAgICAgICAgICAgc3RyZWFtOiB0cnVlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI2O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDIyO1xuICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDQpO1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBfY29udGV4dC50MDtcblxuICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjY7XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjc7XG5cbiAgICAgICAgICAgIGlmICghKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDMxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDMxO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfYXdhaXRBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoX2l0ZXJhdG9yLnJldHVybigpKTtcblxuICAgICAgICAgIGNhc2UgMzE6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMzE7XG5cbiAgICAgICAgICAgIGlmICghX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG5cbiAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmZpbmlzaCgzMSk7XG5cbiAgICAgICAgICBjYXNlIDM1OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmZpbmlzaCgyNik7XG5cbiAgICAgICAgICBjYXNlIDM2OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlLCBudWxsLCBbWzQsIDIyLCAyNiwgMzZdLCBbMjcsLCAzMSwgMzVdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9tYWtlVGV4dERlY29kZXJJdGVyYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBtYWtlVGV4dEVuY29kZXJJdGVyYXRvcihfeDIpIHtcbiAgcmV0dXJuIF9tYWtlVGV4dEVuY29kZXJJdGVyYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfbWFrZVRleHRFbmNvZGVySXRlcmF0b3IoKSB7XG4gIF9tYWtlVGV4dEVuY29kZXJJdGVyYXRvciA9ICgwLCBfd3JhcEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKHRleHRJdGVyYXRvcikge1xuICAgIHZhciB0ZXh0RW5jb2RlciwgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIsIF9kaWRJdGVyYXRvckVycm9yMiwgX2l0ZXJhdG9yRXJyb3IyLCBfaXRlcmF0b3IyLCBfc3RlcDIsIF92YWx1ZTIsIHRleHQ7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDM7XG4gICAgICAgICAgICBfaXRlcmF0b3IyID0gKDAsIF9hc3luY0l0ZXJhdG9yMi5kZWZhdWx0KSh0ZXh0SXRlcmF0b3IpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA3O1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfYXdhaXRBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoX2l0ZXJhdG9yMi5uZXh0KCkpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgX3N0ZXAyID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IF9zdGVwMi5kb25lO1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2F3YWl0QXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKF9zdGVwMi52YWx1ZSk7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgX3ZhbHVlMiA9IF9jb250ZXh0Mi5zZW50O1xuXG4gICAgICAgICAgICBpZiAoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRleHQgPSBfdmFsdWUyO1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNjtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdGV4dCA9PT0gJ3N0cmluZycgPyB0ZXh0RW5jb2Rlci5lbmNvZGUodGV4dCkgOiB0ZXh0O1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDIxO1xuICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gX2NvbnRleHQyW1wiY2F0Y2hcIl0oMyk7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gX2NvbnRleHQyLnQwO1xuXG4gICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMjU7XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDI2O1xuXG4gICAgICAgICAgICBpZiAoISghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4gIT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAzMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMzA7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9hd2FpdEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShfaXRlcmF0b3IyLnJldHVybigpKTtcblxuICAgICAgICAgIGNhc2UgMzA6XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDMwO1xuXG4gICAgICAgICAgICBpZiAoIV9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDMzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuXG4gICAgICAgICAgY2FzZSAzMzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuZmluaXNoKDMwKTtcblxuICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmZpbmlzaCgyNSk7XG5cbiAgICAgICAgICBjYXNlIDM1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIsIG51bGwsIFtbMywgMjEsIDI1LCAzNV0sIFsyNiwsIDMwLCAzNF1dKTtcbiAgfSkpO1xuICByZXR1cm4gX21ha2VUZXh0RW5jb2Rlckl0ZXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIG1ha2VMaW5lSXRlcmF0b3IoX3gzKSB7XG4gIHJldHVybiBfbWFrZUxpbmVJdGVyYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfbWFrZUxpbmVJdGVyYXRvcigpIHtcbiAgX21ha2VMaW5lSXRlcmF0b3IgPSAoMCwgX3dyYXBBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMyh0ZXh0SXRlcmF0b3IpIHtcbiAgICB2YXIgcHJldmlvdXMsIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zLCBfZGlkSXRlcmF0b3JFcnJvcjMsIF9pdGVyYXRvckVycm9yMywgX2l0ZXJhdG9yMywgX3N0ZXAzLCBfdmFsdWUzLCB0ZXh0Q2h1bmssIGVvbEluZGV4LCBsaW5lO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcHJldmlvdXMgPSAnJztcbiAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlO1xuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAzO1xuICAgICAgICAgICAgX2l0ZXJhdG9yMyA9ICgwLCBfYXN5bmNJdGVyYXRvcjIuZGVmYXVsdCkodGV4dEl0ZXJhdG9yKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNztcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2F3YWl0QXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKF9pdGVyYXRvcjMubmV4dCgpKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIF9zdGVwMyA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSBfc3RlcDMuZG9uZTtcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTE7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9hd2FpdEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShfc3RlcDMudmFsdWUpO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIF92YWx1ZTMgPSBfY29udGV4dDMuc2VudDtcblxuICAgICAgICAgICAgaWYgKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0ZXh0Q2h1bmsgPSBfdmFsdWUzO1xuICAgICAgICAgICAgcHJldmlvdXMgKz0gdGV4dENodW5rO1xuICAgICAgICAgICAgZW9sSW5kZXggPSB2b2lkIDA7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgaWYgKCEoKGVvbEluZGV4ID0gcHJldmlvdXMuaW5kZXhPZignXFxuJykpID49IDApKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsaW5lID0gcHJldmlvdXMuc2xpY2UoMCwgZW9sSW5kZXggKyAxKTtcbiAgICAgICAgICAgIHByZXZpb3VzID0gcHJldmlvdXMuc2xpY2UoZW9sSW5kZXggKyAxKTtcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjE7XG4gICAgICAgICAgICByZXR1cm4gbGluZTtcblxuICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDE2O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlO1xuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA1O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAzMjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyODpcbiAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMjg7XG4gICAgICAgICAgICBfY29udGV4dDMudDAgPSBfY29udGV4dDNbXCJjYXRjaFwiXSgzKTtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMyA9IHRydWU7XG4gICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjMgPSBfY29udGV4dDMudDA7XG5cbiAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAzMjtcbiAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMzM7XG5cbiAgICAgICAgICAgIGlmICghKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyAmJiBfaXRlcmF0b3IzLnJldHVybiAhPSBudWxsKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDM3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAzNztcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2F3YWl0QXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKF9pdGVyYXRvcjMucmV0dXJuKCkpO1xuXG4gICAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMzc7XG5cbiAgICAgICAgICAgIGlmICghX2RpZEl0ZXJhdG9yRXJyb3IzKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjM7XG5cbiAgICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5maW5pc2goMzcpO1xuXG4gICAgICAgICAgY2FzZSA0MTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuZmluaXNoKDMyKTtcblxuICAgICAgICAgIGNhc2UgNDI6XG4gICAgICAgICAgICBpZiAoIShwcmV2aW91cy5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDQ1O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA0NTtcbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91cztcblxuICAgICAgICAgIGNhc2UgNDU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMywgbnVsbCwgW1szLCAyOCwgMzIsIDQyXSwgWzMzLCwgMzcsIDQxXV0pO1xuICB9KSk7XG4gIHJldHVybiBfbWFrZUxpbmVJdGVyYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBtYWtlTnVtYmVyZWRMaW5lSXRlcmF0b3IoX3g0KSB7XG4gIHJldHVybiBfbWFrZU51bWJlcmVkTGluZUl0ZXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9tYWtlTnVtYmVyZWRMaW5lSXRlcmF0b3IoKSB7XG4gIF9tYWtlTnVtYmVyZWRMaW5lSXRlcmF0b3IgPSAoMCwgX3dyYXBBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlNChsaW5lSXRlcmF0b3IpIHtcbiAgICB2YXIgY291bnRlciwgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQsIF9kaWRJdGVyYXRvckVycm9yNCwgX2l0ZXJhdG9yRXJyb3I0LCBfaXRlcmF0b3I0LCBfc3RlcDQsIF92YWx1ZTQsIGxpbmU7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjb3VudGVyID0gMTtcbiAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZTtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yNCA9IGZhbHNlO1xuICAgICAgICAgICAgX2NvbnRleHQ0LnByZXYgPSAzO1xuICAgICAgICAgICAgX2l0ZXJhdG9yNCA9ICgwLCBfYXN5bmNJdGVyYXRvcjIuZGVmYXVsdCkobGluZUl0ZXJhdG9yKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gNztcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2F3YWl0QXN5bmNHZW5lcmF0b3IyLmRlZmF1bHQpKF9pdGVyYXRvcjQubmV4dCgpKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIF9zdGVwNCA9IF9jb250ZXh0NC5zZW50O1xuICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjQgPSBfc3RlcDQuZG9uZTtcbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMTE7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9hd2FpdEFzeW5jR2VuZXJhdG9yMi5kZWZhdWx0KShfc3RlcDQudmFsdWUpO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIF92YWx1ZTQgPSBfY29udGV4dDQuc2VudDtcblxuICAgICAgICAgICAgaWYgKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240KSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMjA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsaW5lID0gX3ZhbHVlNDtcbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMTY7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBjb3VudGVyOiBjb3VudGVyLFxuICAgICAgICAgICAgICBsaW5lOiBsaW5lXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIGNvdW50ZXIrKztcblxuICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IHRydWU7XG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDI2O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgX2NvbnRleHQ0LnByZXYgPSAyMjtcbiAgICAgICAgICAgIF9jb250ZXh0NC50MCA9IF9jb250ZXh0NFtcImNhdGNoXCJdKDMpO1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I0ID0gdHJ1ZTtcbiAgICAgICAgICAgIF9pdGVyYXRvckVycm9yNCA9IF9jb250ZXh0NC50MDtcblxuICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICBfY29udGV4dDQucHJldiA9IDI2O1xuICAgICAgICAgICAgX2NvbnRleHQ0LnByZXYgPSAyNztcblxuICAgICAgICAgICAgaWYgKCEoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ICYmIF9pdGVyYXRvcjQucmV0dXJuICE9IG51bGwpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMzE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDMxO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBfYXdhaXRBc3luY0dlbmVyYXRvcjIuZGVmYXVsdCkoX2l0ZXJhdG9yNC5yZXR1cm4oKSk7XG5cbiAgICAgICAgICBjYXNlIDMxOlxuICAgICAgICAgICAgX2NvbnRleHQ0LnByZXYgPSAzMTtcblxuICAgICAgICAgICAgaWYgKCFfZGlkSXRlcmF0b3JFcnJvcjQpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAzNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNDtcblxuICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmZpbmlzaCgzMSk7XG5cbiAgICAgICAgICBjYXNlIDM1OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5maW5pc2goMjYpO1xuXG4gICAgICAgICAgY2FzZSAzNjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWU0LCBudWxsLCBbWzMsIDIyLCAyNiwgMzZdLCBbMjcsLCAzMSwgMzVdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9tYWtlTnVtYmVyZWRMaW5lSXRlcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRleHQtaXRlcmF0b3JzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5wYXJzZUpTT04gPSBwYXJzZUpTT047XG5cbnZhciBfZ2V0Rmlyc3RDaGFyYWN0ZXJzID0gcmVxdWlyZShcIi4uL2JpbmFyeS11dGlscy9nZXQtZmlyc3QtY2hhcmFjdGVyc1wiKTtcblxuZnVuY3Rpb24gcGFyc2VKU09OKHN0cmluZykge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHN0cmluZyk7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcGFyc2UgSlNPTiBmcm9tIGRhdGEgc3RhcnRpbmcgd2l0aCBcXFwiXCIuY29uY2F0KCgwLCBfZ2V0Rmlyc3RDaGFyYWN0ZXJzLmdldEZpcnN0Q2hhcmFjdGVycykoc3RyaW5nKSwgXCJcXFwiXCIpKTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2UtanNvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc2V0UGF0aFByZWZpeCA9IHNldFBhdGhQcmVmaXg7XG5leHBvcnRzLmdldFBhdGhQcmVmaXggPSBnZXRQYXRoUHJlZml4O1xuZXhwb3J0cy5hZGRBbGlhc2VzID0gYWRkQWxpYXNlcztcbmV4cG9ydHMucmVzb2x2ZVBhdGggPSByZXNvbHZlUGF0aDtcbnZhciBwYXRoUHJlZml4ID0gJyc7XG52YXIgZmlsZUFsaWFzZXMgPSB7fTtcblxuZnVuY3Rpb24gc2V0UGF0aFByZWZpeChwcmVmaXgpIHtcbiAgcGF0aFByZWZpeCA9IHByZWZpeDtcbn1cblxuZnVuY3Rpb24gZ2V0UGF0aFByZWZpeCgpIHtcbiAgcmV0dXJuIHBhdGhQcmVmaXg7XG59XG5cbmZ1bmN0aW9uIGFkZEFsaWFzZXMoYWxpYXNlcykge1xuICBPYmplY3QuYXNzaWduKGZpbGVBbGlhc2VzLCBhbGlhc2VzKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVBhdGgoZmlsZW5hbWUpIHtcbiAgZm9yICh2YXIgYWxpYXMgaW4gZmlsZUFsaWFzZXMpIHtcbiAgICBpZiAoZmlsZW5hbWUuc3RhcnRzV2l0aChhbGlhcykpIHtcbiAgICAgIHZhciByZXBsYWNlbWVudCA9IGZpbGVBbGlhc2VzW2FsaWFzXTtcbiAgICAgIGZpbGVuYW1lID0gZmlsZW5hbWUucmVwbGFjZShhbGlhcywgcmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghZmlsZW5hbWUuc3RhcnRzV2l0aCgnaHR0cDovLycpICYmICFmaWxlbmFtZS5zdGFydHNXaXRoKCdodHRwczovLycpKSB7XG4gICAgZmlsZW5hbWUgPSBcIlwiLmNvbmNhdChwYXRoUHJlZml4KS5jb25jYXQoZmlsZW5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIGZpbGVuYW1lO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsZS1hbGlhc2VzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kaXJuYW1lID0gZGlybmFtZTtcbmV4cG9ydHMuam9pbiA9IGpvaW47XG5cbmZ1bmN0aW9uIGRpcm5hbWUodXJsKSB7XG4gIHZhciBzbGFzaEluZGV4ID0gdXJsICYmIHVybC5sYXN0SW5kZXhPZignLycpO1xuICByZXR1cm4gc2xhc2hJbmRleCA+PSAwID8gdXJsLnN1YnN0cigwLCBzbGFzaEluZGV4KSA6ICcnO1xufVxuXG5mdW5jdGlvbiBqb2luKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGFydHMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgcGFydHNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB2YXIgc2VwYXJhdG9yID0gJy8nO1xuICBwYXJ0cyA9IHBhcnRzLm1hcChmdW5jdGlvbiAocGFydCwgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXgpIHtcbiAgICAgIHBhcnQgPSBwYXJ0LnJlcGxhY2UobmV3IFJlZ0V4cChcIl5cIi5jb25jYXQoc2VwYXJhdG9yKSksICcnKTtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggIT09IHBhcnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHBhcnQgPSBwYXJ0LnJlcGxhY2UobmV3IFJlZ0V4cChcIlwiLmNvbmNhdChzZXBhcmF0b3IsIFwiJFwiKSksICcnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFydDtcbiAgfSk7XG4gIHJldHVybiBwYXJ0cy5qb2luKHNlcGFyYXRvcik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXRoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9zdGF0cyA9IHJlcXVpcmUoXCJAcHJvYmUuZ2wvc3RhdHNcIik7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgU1RBVF9RVUVVRURfUkVRVUVTVFMgPSAnUXVldWVkIFJlcXVlc3RzJztcbnZhciBTVEFUX0FDVElWRV9SRVFVRVNUUyA9ICdBY3RpdmUgUmVxdWVzdHMnO1xudmFyIFNUQVRfQ0FOQ0VMTEVEX1JFUVVFU1RTID0gJ0NhbmNlbGxlZCBSZXF1ZXN0cyc7XG52YXIgU1RBVF9RVUVVRURfUkVRVUVTVFNfRVZFUiA9ICdRdWV1ZWQgUmVxdWVzdHMgRXZlcic7XG52YXIgU1RBVF9BQ1RJVkVfUkVRVUVTVFNfRVZFUiA9ICdBY3RpdmUgUmVxdWVzdHMgRXZlcic7XG52YXIgREVGQVVMVF9QUk9QUyA9IHtcbiAgaWQ6ICdyZXF1ZXN0LXNjaGVkdWxlcicsXG4gIHRocm90dGxlUmVxdWVzdHM6IHRydWUsXG4gIG1heFJlcXVlc3RzOiA2XG59O1xuXG52YXIgUmVxdWVzdFNjaGVkdWxlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVxdWVzdFNjaGVkdWxlcigpIHtcbiAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFJlcXVlc3RTY2hlZHVsZXIpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwicHJvcHNcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcInN0YXRzXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJhY3RpdmVSZXF1ZXN0Q291bnRcIiwgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJyZXF1ZXN0UXVldWVcIiwgW10pO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwicmVxdWVzdE1hcFwiLCBuZXcgTWFwKCkpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiZGVmZXJyZWRVcGRhdGVcIiwgbnVsbCk7XG4gICAgdGhpcy5wcm9wcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgREVGQVVMVF9QUk9QUyksIHByb3BzKTtcbiAgICB0aGlzLnN0YXRzID0gbmV3IF9zdGF0cy5TdGF0cyh7XG4gICAgICBpZDogdGhpcy5wcm9wcy5pZFxuICAgIH0pO1xuICAgIHRoaXMuc3RhdHMuZ2V0KFNUQVRfUVVFVUVEX1JFUVVFU1RTKTtcbiAgICB0aGlzLnN0YXRzLmdldChTVEFUX0FDVElWRV9SRVFVRVNUUyk7XG4gICAgdGhpcy5zdGF0cy5nZXQoU1RBVF9DQU5DRUxMRURfUkVRVUVTVFMpO1xuICAgIHRoaXMuc3RhdHMuZ2V0KFNUQVRfUVVFVUVEX1JFUVVFU1RTX0VWRVIpO1xuICAgIHRoaXMuc3RhdHMuZ2V0KFNUQVRfQUNUSVZFX1JFUVVFU1RTX0VWRVIpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoUmVxdWVzdFNjaGVkdWxlciwgW3tcbiAgICBrZXk6IFwic2NoZWR1bGVSZXF1ZXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjaGVkdWxlUmVxdWVzdChoYW5kbGUpIHtcbiAgICAgIHZhciBnZXRQcmlvcml0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH07XG5cbiAgICAgIGlmICghdGhpcy5wcm9wcy50aHJvdHRsZVJlcXVlc3RzKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgIGRvbmU6IGZ1bmN0aW9uIGRvbmUoKSB7fVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucmVxdWVzdE1hcC5oYXMoaGFuZGxlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0TWFwLmdldChoYW5kbGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVxdWVzdCA9IHtcbiAgICAgICAgaGFuZGxlOiBoYW5kbGUsXG4gICAgICAgIHByaW9yaXR5OiAwLFxuICAgICAgICBnZXRQcmlvcml0eTogZ2V0UHJpb3JpdHlcbiAgICAgIH07XG4gICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHJlcXVlc3QucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgICAgfSk7XG4gICAgICB0aGlzLnJlcXVlc3RRdWV1ZS5wdXNoKHJlcXVlc3QpO1xuICAgICAgdGhpcy5yZXF1ZXN0TWFwLnNldChoYW5kbGUsIHByb21pc2UpO1xuXG4gICAgICB0aGlzLl9pc3N1ZU5ld1JlcXVlc3RzKCk7XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaXNzdWVSZXF1ZXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pc3N1ZVJlcXVlc3QocmVxdWVzdCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGhhbmRsZSA9IHJlcXVlc3QuaGFuZGxlLFxuICAgICAgICAgIHJlc29sdmUgPSByZXF1ZXN0LnJlc29sdmU7XG4gICAgICB2YXIgaXNEb25lID0gZmFsc2U7XG5cbiAgICAgIHZhciBkb25lID0gZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgICAgaWYgKCFpc0RvbmUpIHtcbiAgICAgICAgICBpc0RvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgX3RoaXMucmVxdWVzdE1hcC5kZWxldGUoaGFuZGxlKTtcblxuICAgICAgICAgIF90aGlzLmFjdGl2ZVJlcXVlc3RDb3VudC0tO1xuXG4gICAgICAgICAgX3RoaXMuX2lzc3VlTmV3UmVxdWVzdHMoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5hY3RpdmVSZXF1ZXN0Q291bnQrKztcbiAgICAgIHJldHVybiByZXNvbHZlID8gcmVzb2x2ZSh7XG4gICAgICAgIGRvbmU6IGRvbmVcbiAgICAgIH0pIDogUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgZG9uZTogZG9uZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9pc3N1ZU5ld1JlcXVlc3RzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pc3N1ZU5ld1JlcXVlc3RzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5kZWZlcnJlZFVwZGF0ZSkge1xuICAgICAgICB0aGlzLmRlZmVycmVkVXBkYXRlID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5faXNzdWVOZXdSZXF1ZXN0c0FzeW5jKCk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaXNzdWVOZXdSZXF1ZXN0c0FzeW5jXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pc3N1ZU5ld1JlcXVlc3RzQXN5bmMoKSB7XG4gICAgICB0aGlzLmRlZmVycmVkVXBkYXRlID0gbnVsbDtcbiAgICAgIHZhciBmcmVlU2xvdHMgPSBNYXRoLm1heCh0aGlzLnByb3BzLm1heFJlcXVlc3RzIC0gdGhpcy5hY3RpdmVSZXF1ZXN0Q291bnQsIDApO1xuXG4gICAgICBpZiAoZnJlZVNsb3RzID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdXBkYXRlQWxsUmVxdWVzdHMoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmVlU2xvdHM7ICsraSkge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHRoaXMucmVxdWVzdFF1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICB0aGlzLl9pc3N1ZVJlcXVlc3QocmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZUFsbFJlcXVlc3RzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVBbGxSZXF1ZXN0cygpIHtcbiAgICAgIHZhciByZXF1ZXN0UXVldWUgPSB0aGlzLnJlcXVlc3RRdWV1ZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXF1ZXN0UXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSByZXF1ZXN0UXVldWVbaV07XG5cbiAgICAgICAgaWYgKCF0aGlzLl91cGRhdGVSZXF1ZXN0KHJlcXVlc3QpKSB7XG4gICAgICAgICAgcmVxdWVzdFF1ZXVlLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB0aGlzLnJlcXVlc3RNYXAuZGVsZXRlKHJlcXVlc3QuaGFuZGxlKTtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVxdWVzdFF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVSZXF1ZXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICAgIHJlcXVlc3QucHJpb3JpdHkgPSByZXF1ZXN0LmdldFByaW9yaXR5KHJlcXVlc3QuaGFuZGxlKTtcblxuICAgICAgaWYgKHJlcXVlc3QucHJpb3JpdHkgPCAwKSB7XG4gICAgICAgIHJlcXVlc3QucmVzb2x2ZShudWxsKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFJlcXVlc3RTY2hlZHVsZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJlcXVlc3RTY2hlZHVsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXF1ZXN0LXNjaGVkdWxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNyZWF0ZUxvYWRlcldvcmtlciA9IGNyZWF0ZUxvYWRlcldvcmtlcjtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfd29ya2VyVXRpbHMgPSByZXF1aXJlKFwiQGxvYWRlcnMuZ2wvd29ya2VyLXV0aWxzXCIpO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIHJlcXVlc3RJZCA9IDA7XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvYWRlcldvcmtlcihsb2FkZXIpIHtcbiAgaWYgKHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIF93b3JrZXJVdGlscy5Xb3JrZXJCb2R5Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKHR5cGUsIHBheWxvYWQpIHtcbiAgICAgIHZhciBpbnB1dCwgX3BheWxvYWQkb3B0aW9ucywgb3B0aW9ucywgcmVzdWx0LCBtZXNzYWdlO1xuXG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSB0eXBlO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gX2NvbnRleHQudDAgPT09ICdwcm9jZXNzJyA/IDMgOiAxNjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDM7XG4gICAgICAgICAgICAgIGlucHV0ID0gcGF5bG9hZC5pbnB1dCwgX3BheWxvYWQkb3B0aW9ucyA9IHBheWxvYWQub3B0aW9ucywgb3B0aW9ucyA9IF9wYXlsb2FkJG9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX3BheWxvYWQkb3B0aW9ucztcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZURhdGEoe1xuICAgICAgICAgICAgICAgIGxvYWRlcjogbG9hZGVyLFxuICAgICAgICAgICAgICAgIGFycmF5QnVmZmVyOiBpbnB1dCxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICAgIHBhcnNlOiBwYXJzZU9uTWFpblRocmVhZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgICBfd29ya2VyVXRpbHMuV29ya2VyQm9keS5wb3N0TWVzc2FnZSgnZG9uZScsIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTE7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnQxID0gX2NvbnRleHRbXCJjYXRjaFwiXSgzKTtcbiAgICAgICAgICAgICAgbWVzc2FnZSA9IF9jb250ZXh0LnQxIGluc3RhbmNlb2YgRXJyb3IgPyBfY29udGV4dC50MS5tZXNzYWdlIDogJyc7XG5cbiAgICAgICAgICAgICAgX3dvcmtlclV0aWxzLldvcmtlckJvZHkucG9zdE1lc3NhZ2UoJ2Vycm9yJywge1xuICAgICAgICAgICAgICAgIGVycm9yOiBtZXNzYWdlXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwiYnJlYWtcIiwgMTYpO1xuXG4gICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZSwgbnVsbCwgW1szLCAxMV1dKTtcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKF94LCBfeDIpIHtcbiAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSgpO1xufVxuXG5mdW5jdGlvbiBwYXJzZU9uTWFpblRocmVhZChhcnJheUJ1ZmZlciwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciBpZCA9IHJlcXVlc3RJZCsrO1xuXG4gICAgdmFyIG9uTWVzc2FnZSA9IGZ1bmN0aW9uIG9uTWVzc2FnZSh0eXBlLCBwYXlsb2FkKSB7XG4gICAgICBpZiAocGF5bG9hZC5pZCAhPT0gaWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnZG9uZSc6XG4gICAgICAgICAgX3dvcmtlclV0aWxzLldvcmtlckJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihvbk1lc3NhZ2UpO1xuXG4gICAgICAgICAgcmVzb2x2ZShwYXlsb2FkLnJlc3VsdCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgIF93b3JrZXJVdGlscy5Xb3JrZXJCb2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIob25NZXNzYWdlKTtcblxuICAgICAgICAgIHJlamVjdChwYXlsb2FkLmVycm9yKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgfVxuICAgIH07XG5cbiAgICBfd29ya2VyVXRpbHMuV29ya2VyQm9keS5hZGRFdmVudExpc3RlbmVyKG9uTWVzc2FnZSk7XG5cbiAgICB2YXIgcGF5bG9hZCA9IHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGlucHV0OiBhcnJheUJ1ZmZlcixcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICB9O1xuXG4gICAgX3dvcmtlclV0aWxzLldvcmtlckJvZHkucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MnLCBwYXlsb2FkKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRGF0YShfeDMpIHtcbiAgcmV0dXJuIF9wYXJzZURhdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3BhcnNlRGF0YSgpIHtcbiAgX3BhcnNlRGF0YSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMihfcmVmMikge1xuICAgIHZhciBsb2FkZXIsIGFycmF5QnVmZmVyLCBvcHRpb25zLCBjb250ZXh0LCBkYXRhLCBwYXJzZXIsIHRleHREZWNvZGVyO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGxvYWRlciA9IF9yZWYyLmxvYWRlciwgYXJyYXlCdWZmZXIgPSBfcmVmMi5hcnJheUJ1ZmZlciwgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnMsIGNvbnRleHQgPSBfcmVmMi5jb250ZXh0O1xuXG4gICAgICAgICAgICBpZiAoIShsb2FkZXIucGFyc2VTeW5jIHx8IGxvYWRlci5wYXJzZSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA2O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0YSA9IGFycmF5QnVmZmVyO1xuICAgICAgICAgICAgcGFyc2VyID0gbG9hZGVyLnBhcnNlU3luYyB8fCBsb2FkZXIucGFyc2U7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEzO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBpZiAoIWxvYWRlci5wYXJzZVRleHRTeW5jKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgICAgICAgICAgZGF0YSA9IHRleHREZWNvZGVyLmRlY29kZShhcnJheUJ1ZmZlcik7XG4gICAgICAgICAgICBwYXJzZXIgPSBsb2FkZXIucGFyc2VUZXh0U3luYztcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTM7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgbG9hZCBkYXRhIHdpdGggXCIuY29uY2F0KGxvYWRlci5uYW1lLCBcIiBsb2FkZXJcIikpO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIG9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgICAgICBtb2R1bGVzOiBsb2FkZXIgJiYgbG9hZGVyLm9wdGlvbnMgJiYgbG9hZGVyLm9wdGlvbnMubW9kdWxlcyB8fCB7fSxcbiAgICAgICAgICAgICAgd29ya2VyOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE2O1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlcihkYXRhLCBfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zKSwgY29udGV4dCwgbG9hZGVyKTtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDIuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIpO1xuICB9KSk7XG4gIHJldHVybiBfcGFyc2VEYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGUtbG9hZGVyLXdvcmtlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNhblBhcnNlV2l0aFdvcmtlciA9IGNhblBhcnNlV2l0aFdvcmtlcjtcbmV4cG9ydHMucGFyc2VXaXRoV29ya2VyID0gcGFyc2VXaXRoV29ya2VyO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF93b3JrZXJVdGlscyA9IHJlcXVpcmUoXCJAbG9hZGVycy5nbC93b3JrZXItdXRpbHNcIik7XG5cbmZ1bmN0aW9uIGNhblBhcnNlV2l0aFdvcmtlcihsb2FkZXIsIG9wdGlvbnMpIHtcbiAgaWYgKCFfd29ya2VyVXRpbHMuV29ya2VyRmFybS5pc1N1cHBvcnRlZCgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGxvYWRlci53b3JrZXIgJiYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy53b3JrZXIpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVdpdGhXb3JrZXIoX3gsIF94MiwgX3gzLCBfeDQsIF94NSkge1xuICByZXR1cm4gX3BhcnNlV2l0aFdvcmtlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfcGFyc2VXaXRoV29ya2VyKCkge1xuICBfcGFyc2VXaXRoV29ya2VyID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUobG9hZGVyLCBkYXRhLCBvcHRpb25zLCBjb250ZXh0LCBwYXJzZU9uTWFpblRocmVhZCkge1xuICAgIHZhciBuYW1lLCB1cmwsIHdvcmtlckZhcm0sIHdvcmtlclBvb2wsIGpvYiwgcmVzdWx0O1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgbmFtZSA9IGxvYWRlci5pZDtcbiAgICAgICAgICAgIHVybCA9ICgwLCBfd29ya2VyVXRpbHMuZ2V0V29ya2VyVVJMKShsb2FkZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgd29ya2VyRmFybSA9IF93b3JrZXJVdGlscy5Xb3JrZXJGYXJtLmdldFdvcmtlckZhcm0ob3B0aW9ucyk7XG4gICAgICAgICAgICB3b3JrZXJQb29sID0gd29ya2VyRmFybS5nZXRXb3JrZXJQb29sKHtcbiAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb3B0aW9ucyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob3B0aW9ucykpO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICByZXR1cm4gd29ya2VyUG9vbC5zdGFydEpvYigncHJvY2Vzcy1vbi13b3JrZXInLCBvbk1lc3NhZ2UuYmluZChudWxsLCBwYXJzZU9uTWFpblRocmVhZCkpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgam9iID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIGpvYi5wb3N0TWVzc2FnZSgncHJvY2VzcycsIHtcbiAgICAgICAgICAgICAgaW5wdXQ6IGRhdGEsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDExO1xuICAgICAgICAgICAgcmV0dXJuIGpvYi5yZXN1bHQ7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlKTtcbiAgfSkpO1xuICByZXR1cm4gX3BhcnNlV2l0aFdvcmtlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBvbk1lc3NhZ2UoX3g2LCBfeDcsIF94OCwgX3g5KSB7XG4gIHJldHVybiBfb25NZXNzYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9vbk1lc3NhZ2UoKSB7XG4gIF9vbk1lc3NhZ2UgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIocGFyc2VPbk1haW5UaHJlYWQsIGpvYiwgdHlwZSwgcGF5bG9hZCkge1xuICAgIHZhciBpZCwgaW5wdXQsIG9wdGlvbnMsIHJlc3VsdCwgbWVzc2FnZTtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDIudDAgPSB0eXBlO1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSBfY29udGV4dDIudDAgPT09ICdkb25lJyA/IDMgOiBfY29udGV4dDIudDAgPT09ICdlcnJvcicgPyA1IDogX2NvbnRleHQyLnQwID09PSAncHJvY2VzcycgPyA3IDogMjA7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGpvYi5kb25lKHBheWxvYWQpO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJicmVha1wiLCAyMSk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBqb2IuZXJyb3IocGF5bG9hZC5lcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcImJyZWFrXCIsIDIxKTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGlkID0gcGF5bG9hZC5pZCwgaW5wdXQgPSBwYXlsb2FkLmlucHV0LCBvcHRpb25zID0gcGF5bG9hZC5vcHRpb25zO1xuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSA4O1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU9uTWFpblRocmVhZChpbnB1dCwgb3B0aW9ucyk7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICBqb2IucG9zdE1lc3NhZ2UoJ2RvbmUnLCB7XG4gICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxOTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTU7XG4gICAgICAgICAgICBfY29udGV4dDIudDEgPSBfY29udGV4dDJbXCJjYXRjaFwiXSg4KTtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBfY29udGV4dDIudDEgaW5zdGFuY2VvZiBFcnJvciA/IF9jb250ZXh0Mi50MS5tZXNzYWdlIDogJ3Vua25vd24gZXJyb3InO1xuICAgICAgICAgICAgam9iLnBvc3RNZXNzYWdlKCdlcnJvcicsIHtcbiAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICBlcnJvcjogbWVzc2FnZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJicmVha1wiLCAyMSk7XG5cbiAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwicGFyc2Utd2l0aC13b3JrZXIgdW5rbm93biBtZXNzYWdlIFwiLmNvbmNhdCh0eXBlKSk7XG5cbiAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIsIG51bGwsIFtbOCwgMTVdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9vbk1lc3NhZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlLXdpdGgtd29ya2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXRNZXNoU2l6ZSA9IGdldE1lc2hTaXplO1xuZXhwb3J0cy5nZXRNZXNoQm91bmRpbmdCb3ggPSBnZXRNZXNoQm91bmRpbmdCb3g7XG5cbmZ1bmN0aW9uIGdldE1lc2hTaXplKGF0dHJpYnV0ZXMpIHtcbiAgdmFyIHNpemUgPSAwO1xuXG4gIGZvciAodmFyIGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuXG4gICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhhdHRyaWJ1dGUpKSB7XG4gICAgICBzaXplICs9IGF0dHJpYnV0ZS5ieXRlTGVuZ3RoICogYXR0cmlidXRlLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzaXplO1xufVxuXG5mdW5jdGlvbiBnZXRNZXNoQm91bmRpbmdCb3goYXR0cmlidXRlcykge1xuICB2YXIgbWluWCA9IEluZmluaXR5O1xuICB2YXIgbWluWSA9IEluZmluaXR5O1xuICB2YXIgbWluWiA9IEluZmluaXR5O1xuICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcbiAgdmFyIG1heFkgPSAtSW5maW5pdHk7XG4gIHZhciBtYXhaID0gLUluZmluaXR5O1xuICB2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5QT1NJVElPTiA/IGF0dHJpYnV0ZXMuUE9TSVRJT04udmFsdWUgOiBbXTtcbiAgdmFyIGxlbiA9IHBvc2l0aW9ucyAmJiBwb3NpdGlvbnMubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDMpIHtcbiAgICB2YXIgeCA9IHBvc2l0aW9uc1tpXTtcbiAgICB2YXIgeSA9IHBvc2l0aW9uc1tpICsgMV07XG4gICAgdmFyIHogPSBwb3NpdGlvbnNbaSArIDJdO1xuICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xuICAgIG1pblogPSB6IDwgbWluWiA/IHogOiBtaW5aO1xuICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xuICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xuICAgIG1heFogPSB6ID4gbWF4WiA/IHogOiBtYXhaO1xuICB9XG5cbiAgcmV0dXJuIFtbbWluWCwgbWluWSwgbWluWl0sIFttYXhYLCBtYXhZLCBtYXhaXV07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXNoLXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRhYmxlQmF0Y2hCdWlsZGVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90YWJsZUJhdGNoQnVpbGRlci5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJvd1RhYmxlQmF0Y2hBZ2dyZWdhdG9yXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9yb3dUYWJsZUJhdGNoQWdncmVnYXRvci5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbHVtbmFyVGFibGVCYXRjaEFnZ3JlZ2F0b3JcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2NvbHVtbmFyVGFibGVCYXRjaEFnZ3JlZ2F0b3IuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb252ZXJ0VG9PYmplY3RSb3dcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3Jvd1V0aWxzLmNvbnZlcnRUb09iamVjdFJvdztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb252ZXJ0VG9BcnJheVJvd1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfcm93VXRpbHMuY29udmVydFRvQXJyYXlSb3c7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0TWVzaFNpemVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX21lc2hVdGlscy5nZXRNZXNoU2l6ZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRNZXNoQm91bmRpbmdCb3hcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX21lc2hVdGlscy5nZXRNZXNoQm91bmRpbmdCb3g7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2NoZW1hXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuU2NoZW1hO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZpZWxkXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuRmllbGQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGF0YVR5cGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5EYXRhVHlwZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOdWxsXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuTnVsbDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCaW5hcnlcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5CaW5hcnk7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQm9vbFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLkJvb2w7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW50XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuSW50O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludDhcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5JbnQ4O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludDE2XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuSW50MTY7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW50MzJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5JbnQzMjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnQ2NFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLkludDY0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVpbnQ4XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuVWludDg7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVWludDE2XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuVWludDE2O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVpbnQzMlwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLlVpbnQzMjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVaW50NjRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5VaW50NjQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmxvYXRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5GbG9hdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGbG9hdDE2XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuRmxvYXQxNjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGbG9hdDMyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuRmxvYXQzMjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGbG9hdDY0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuRmxvYXQ2NDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVdGY4XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuVXRmODtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEYXRlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuRGF0ZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEYXRlRGF5XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuRGF0ZURheTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEYXRlTWlsbGlzZWNvbmRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5EYXRlTWlsbGlzZWNvbmQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGltZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLlRpbWU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGltZU1pbGxpc2Vjb25kXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuVGltZU1pbGxpc2Vjb25kO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRpbWVTZWNvbmRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5UaW1lU2Vjb25kO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRpbWVzdGFtcFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLlRpbWVzdGFtcDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUaW1lc3RhbXBTZWNvbmRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5UaW1lc3RhbXBTZWNvbmQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGltZXN0YW1wTWlsbGlzZWNvbmRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5UaW1lc3RhbXBNaWxsaXNlY29uZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUaW1lc3RhbXBNaWNyb3NlY29uZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLlRpbWVzdGFtcE1pY3Jvc2Vjb25kO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRpbWVzdGFtcE5hbm9zZWNvbmRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3NjaGVtYS5UaW1lc3RhbXBOYW5vc2Vjb25kO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludGVydmFsXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuSW50ZXJ2YWw7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW50ZXJ2YWxEYXlUaW1lXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuSW50ZXJ2YWxEYXlUaW1lO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludGVydmFsWWVhck1vbnRoXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuSW50ZXJ2YWxZZWFyTW9udGg7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRml4ZWRTaXplTGlzdFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc2NoZW1hLkZpeGVkU2l6ZUxpc3Q7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVkdWNlVGFibGVTY2hlbWFcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2RlZHVjZVRhYmxlU2NoZW1hLmRlZHVjZVRhYmxlU2NoZW1hO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFR5cGVJbmZvXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nZXRUeXBlSW5mby5nZXRUeXBlSW5mbztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRBcnJvd1R5cGVGcm9tVHlwZWRBcnJheVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZVV0aWxzLmdldEFycm93VHlwZUZyb21UeXBlZEFycmF5O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFzeW5jUXVldWVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2FzeW5jUXVldWUuZGVmYXVsdDtcbiAgfVxufSk7XG5cbnZhciBfdGFibGVCYXRjaEJ1aWxkZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi90YWJsZS90YWJsZS1iYXRjaC1idWlsZGVyXCIpKTtcblxudmFyIF9yb3dUYWJsZUJhdGNoQWdncmVnYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL3RhYmxlL3Jvdy10YWJsZS1iYXRjaC1hZ2dyZWdhdG9yXCIpKTtcblxudmFyIF9jb2x1bW5hclRhYmxlQmF0Y2hBZ2dyZWdhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvdGFibGUvY29sdW1uYXItdGFibGUtYmF0Y2gtYWdncmVnYXRvclwiKSk7XG5cbnZhciBfcm93VXRpbHMgPSByZXF1aXJlKFwiLi9saWIvdXRpbHMvcm93LXV0aWxzXCIpO1xuXG52YXIgX21lc2hVdGlscyA9IHJlcXVpcmUoXCIuL2NhdGVnb3J5L21lc2gvbWVzaC11dGlsc1wiKTtcblxudmFyIF9zY2hlbWEgPSByZXF1aXJlKFwiLi9saWIvc2NoZW1hXCIpO1xuXG52YXIgX2RlZHVjZVRhYmxlU2NoZW1hID0gcmVxdWlyZShcIi4vbGliL3NjaGVtYS11dGlscy9kZWR1Y2UtdGFibGUtc2NoZW1hXCIpO1xuXG52YXIgX2dldFR5cGVJbmZvID0gcmVxdWlyZShcIi4vbGliL3NjaGVtYS11dGlscy9nZXQtdHlwZS1pbmZvXCIpO1xuXG52YXIgX3R5cGVVdGlscyA9IHJlcXVpcmUoXCIuL2xpYi9zY2hlbWEtdXRpbHMvdHlwZS11dGlsc1wiKTtcblxudmFyIF9hc3luY1F1ZXVlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvdXRpbHMvYXN5bmMtcXVldWVcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZHVjZVRhYmxlU2NoZW1hID0gZGVkdWNlVGFibGVTY2hlbWE7XG5cbmZ1bmN0aW9uIGRlZHVjZVRhYmxlU2NoZW1hKHRhYmxlLCBzY2hlbWEpIHtcbiAgdmFyIGRlZHVjZWRTY2hlbWEgPSBBcnJheS5pc0FycmF5KHRhYmxlKSA/IGRlZHVjZVNjaGVtYUZvclJvd1RhYmxlKHRhYmxlKSA6IGRlZHVjZVNjaGVtYUZvckNvbHVtbmFyVGFibGUodGFibGUpO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihkZWR1Y2VkU2NoZW1hLCBzY2hlbWEpO1xufVxuXG5mdW5jdGlvbiBkZWR1Y2VTY2hlbWFGb3JDb2x1bW5hclRhYmxlKGNvbHVtbmFyVGFibGUpIHtcbiAgdmFyIHNjaGVtYSA9IHt9O1xuXG4gIGZvciAodmFyIGZpZWxkIGluIGNvbHVtbmFyVGFibGUpIHtcbiAgICB2YXIgY29sdW1uID0gY29sdW1uYXJUYWJsZVtmaWVsZF07XG5cbiAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGNvbHVtbikpIHtcbiAgICAgIHNjaGVtYVtmaWVsZF0gPSBjb2x1bW4uY29uc3RydWN0b3I7XG4gICAgfSBlbHNlIGlmIChjb2x1bW4ubGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBjb2x1bW5bMF07XG4gICAgICBzY2hlbWFbZmllbGRdID0gZGVkdWNlVHlwZUZyb21WYWx1ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgc2NoZW1hW2ZpZWxkXSA9IHNjaGVtYVtmaWVsZF0gfHwgbnVsbDtcbiAgfVxuXG4gIHJldHVybiBzY2hlbWE7XG59XG5cbmZ1bmN0aW9uIGRlZHVjZVNjaGVtYUZvclJvd1RhYmxlKHJvd1RhYmxlKSB7XG4gIHZhciBzY2hlbWEgPSB7fTtcblxuICBpZiAocm93VGFibGUubGVuZ3RoKSB7XG4gICAgdmFyIHJvdyA9IHJvd1RhYmxlWzBdO1xuXG4gICAgZm9yICh2YXIgZmllbGQgaW4gcm93KSB7XG4gICAgICB2YXIgdmFsdWUgPSByb3dbZmllbGRdO1xuICAgICAgc2NoZW1hW2ZpZWxkXSA9IGRlZHVjZVR5cGVGcm9tVmFsdWUodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzY2hlbWE7XG59XG5cbmZ1bmN0aW9uIGRlZHVjZVR5cGVGcm9tVmFsdWUodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBEYXRlO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgcmV0dXJuIEZsb2F0MzJBcnJheTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIFN0cmluZztcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVkdWNlLXRhYmxlLXNjaGVtYS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0VHlwZUluZm8gPSBnZXRUeXBlSW5mbztcblxudmFyIF9zY2hlbWEgPSByZXF1aXJlKFwiLi4vc2NoZW1hXCIpO1xuXG5mdW5jdGlvbiBnZXRUeXBlSW5mbyhhcnJvd1R5cGVMaWtlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZUlkOiBhcnJvd1R5cGVMaWtlLnR5cGVJZCxcbiAgICBBcnJheVR5cGU6IGFycm93VHlwZUxpa2UuQXJyYXlUeXBlLFxuICAgIHR5cGVOYW1lOiBhcnJvd1R5cGVMaWtlLnRvU3RyaW5nKCksXG4gICAgdHlwZUVudW1OYW1lOiBnZXRUeXBlS2V5KGFycm93VHlwZUxpa2UudHlwZUlkKSxcbiAgICBwcmVjaXNpb246IGFycm93VHlwZUxpa2UucHJlY2lzaW9uXG4gIH07XG59XG5cbnZhciBSZXZlcnNlVHlwZSA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldFR5cGVLZXkodHlwZUtleSkge1xuICBpZiAoIVJldmVyc2VUeXBlKSB7XG4gICAgUmV2ZXJzZVR5cGUgPSB7fTtcblxuICAgIGZvciAodmFyIF9rZXkgaW4gX3NjaGVtYS5UeXBlKSB7XG4gICAgICBSZXZlcnNlVHlwZVtfc2NoZW1hLlR5cGVbX2tleV1dID0gX2tleTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gUmV2ZXJzZVR5cGVbdHlwZUtleV07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtdHlwZS1pbmZvLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXRBcnJvd1R5cGVGcm9tVHlwZWRBcnJheSA9IGdldEFycm93VHlwZUZyb21UeXBlZEFycmF5O1xuXG52YXIgX3NjaGVtYSA9IHJlcXVpcmUoXCIuLi9zY2hlbWFcIik7XG5cbmZ1bmN0aW9uIGdldEFycm93VHlwZUZyb21UeXBlZEFycmF5KGFycmF5KSB7XG4gIHN3aXRjaCAoYXJyYXkuY29uc3RydWN0b3IpIHtcbiAgICBjYXNlIEludDhBcnJheTpcbiAgICAgIHJldHVybiBuZXcgX3NjaGVtYS5JbnQ4KCk7XG5cbiAgICBjYXNlIFVpbnQ4QXJyYXk6XG4gICAgICByZXR1cm4gbmV3IF9zY2hlbWEuVWludDgoKTtcblxuICAgIGNhc2UgSW50MTZBcnJheTpcbiAgICAgIHJldHVybiBuZXcgX3NjaGVtYS5JbnQxNigpO1xuXG4gICAgY2FzZSBVaW50MTZBcnJheTpcbiAgICAgIHJldHVybiBuZXcgX3NjaGVtYS5VaW50MTYoKTtcblxuICAgIGNhc2UgSW50MzJBcnJheTpcbiAgICAgIHJldHVybiBuZXcgX3NjaGVtYS5JbnQzMigpO1xuXG4gICAgY2FzZSBVaW50MzJBcnJheTpcbiAgICAgIHJldHVybiBuZXcgX3NjaGVtYS5VaW50MzIoKTtcblxuICAgIGNhc2UgRmxvYXQzMkFycmF5OlxuICAgICAgcmV0dXJuIG5ldyBfc2NoZW1hLkZsb2F0MzIoKTtcblxuICAgIGNhc2UgRmxvYXQ2NEFycmF5OlxuICAgICAgcmV0dXJuIG5ldyBfc2NoZW1hLkZsb2F0NjQoKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5IHR5cGUgbm90IHN1cHBvcnRlZCcpO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlLXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5UeXBlID0gdm9pZCAwO1xudmFyIFR5cGU7XG5leHBvcnRzLlR5cGUgPSBUeXBlO1xuXG4oZnVuY3Rpb24gKFR5cGUpIHtcbiAgVHlwZVtUeXBlW1wiTk9ORVwiXSA9IDBdID0gXCJOT05FXCI7XG4gIFR5cGVbVHlwZVtcIk51bGxcIl0gPSAxXSA9IFwiTnVsbFwiO1xuICBUeXBlW1R5cGVbXCJJbnRcIl0gPSAyXSA9IFwiSW50XCI7XG4gIFR5cGVbVHlwZVtcIkZsb2F0XCJdID0gM10gPSBcIkZsb2F0XCI7XG4gIFR5cGVbVHlwZVtcIkJpbmFyeVwiXSA9IDRdID0gXCJCaW5hcnlcIjtcbiAgVHlwZVtUeXBlW1wiVXRmOFwiXSA9IDVdID0gXCJVdGY4XCI7XG4gIFR5cGVbVHlwZVtcIkJvb2xcIl0gPSA2XSA9IFwiQm9vbFwiO1xuICBUeXBlW1R5cGVbXCJEZWNpbWFsXCJdID0gN10gPSBcIkRlY2ltYWxcIjtcbiAgVHlwZVtUeXBlW1wiRGF0ZVwiXSA9IDhdID0gXCJEYXRlXCI7XG4gIFR5cGVbVHlwZVtcIlRpbWVcIl0gPSA5XSA9IFwiVGltZVwiO1xuICBUeXBlW1R5cGVbXCJUaW1lc3RhbXBcIl0gPSAxMF0gPSBcIlRpbWVzdGFtcFwiO1xuICBUeXBlW1R5cGVbXCJJbnRlcnZhbFwiXSA9IDExXSA9IFwiSW50ZXJ2YWxcIjtcbiAgVHlwZVtUeXBlW1wiTGlzdFwiXSA9IDEyXSA9IFwiTGlzdFwiO1xuICBUeXBlW1R5cGVbXCJTdHJ1Y3RcIl0gPSAxM10gPSBcIlN0cnVjdFwiO1xuICBUeXBlW1R5cGVbXCJVbmlvblwiXSA9IDE0XSA9IFwiVW5pb25cIjtcbiAgVHlwZVtUeXBlW1wiRml4ZWRTaXplQmluYXJ5XCJdID0gMTVdID0gXCJGaXhlZFNpemVCaW5hcnlcIjtcbiAgVHlwZVtUeXBlW1wiRml4ZWRTaXplTGlzdFwiXSA9IDE2XSA9IFwiRml4ZWRTaXplTGlzdFwiO1xuICBUeXBlW1R5cGVbXCJNYXBcIl0gPSAxN10gPSBcIk1hcFwiO1xuICBUeXBlW1R5cGVbXCJEaWN0aW9uYXJ5XCJdID0gLTFdID0gXCJEaWN0aW9uYXJ5XCI7XG4gIFR5cGVbVHlwZVtcIkludDhcIl0gPSAtMl0gPSBcIkludDhcIjtcbiAgVHlwZVtUeXBlW1wiSW50MTZcIl0gPSAtM10gPSBcIkludDE2XCI7XG4gIFR5cGVbVHlwZVtcIkludDMyXCJdID0gLTRdID0gXCJJbnQzMlwiO1xuICBUeXBlW1R5cGVbXCJJbnQ2NFwiXSA9IC01XSA9IFwiSW50NjRcIjtcbiAgVHlwZVtUeXBlW1wiVWludDhcIl0gPSAtNl0gPSBcIlVpbnQ4XCI7XG4gIFR5cGVbVHlwZVtcIlVpbnQxNlwiXSA9IC03XSA9IFwiVWludDE2XCI7XG4gIFR5cGVbVHlwZVtcIlVpbnQzMlwiXSA9IC04XSA9IFwiVWludDMyXCI7XG4gIFR5cGVbVHlwZVtcIlVpbnQ2NFwiXSA9IC05XSA9IFwiVWludDY0XCI7XG4gIFR5cGVbVHlwZVtcIkZsb2F0MTZcIl0gPSAtMTBdID0gXCJGbG9hdDE2XCI7XG4gIFR5cGVbVHlwZVtcIkZsb2F0MzJcIl0gPSAtMTFdID0gXCJGbG9hdDMyXCI7XG4gIFR5cGVbVHlwZVtcIkZsb2F0NjRcIl0gPSAtMTJdID0gXCJGbG9hdDY0XCI7XG4gIFR5cGVbVHlwZVtcIkRhdGVEYXlcIl0gPSAtMTNdID0gXCJEYXRlRGF5XCI7XG4gIFR5cGVbVHlwZVtcIkRhdGVNaWxsaXNlY29uZFwiXSA9IC0xNF0gPSBcIkRhdGVNaWxsaXNlY29uZFwiO1xuICBUeXBlW1R5cGVbXCJUaW1lc3RhbXBTZWNvbmRcIl0gPSAtMTVdID0gXCJUaW1lc3RhbXBTZWNvbmRcIjtcbiAgVHlwZVtUeXBlW1wiVGltZXN0YW1wTWlsbGlzZWNvbmRcIl0gPSAtMTZdID0gXCJUaW1lc3RhbXBNaWxsaXNlY29uZFwiO1xuICBUeXBlW1R5cGVbXCJUaW1lc3RhbXBNaWNyb3NlY29uZFwiXSA9IC0xN10gPSBcIlRpbWVzdGFtcE1pY3Jvc2Vjb25kXCI7XG4gIFR5cGVbVHlwZVtcIlRpbWVzdGFtcE5hbm9zZWNvbmRcIl0gPSAtMThdID0gXCJUaW1lc3RhbXBOYW5vc2Vjb25kXCI7XG4gIFR5cGVbVHlwZVtcIlRpbWVTZWNvbmRcIl0gPSAtMTldID0gXCJUaW1lU2Vjb25kXCI7XG4gIFR5cGVbVHlwZVtcIlRpbWVNaWxsaXNlY29uZFwiXSA9IC0yMF0gPSBcIlRpbWVNaWxsaXNlY29uZFwiO1xuICBUeXBlW1R5cGVbXCJUaW1lTWljcm9zZWNvbmRcIl0gPSAtMjFdID0gXCJUaW1lTWljcm9zZWNvbmRcIjtcbiAgVHlwZVtUeXBlW1wiVGltZU5hbm9zZWNvbmRcIl0gPSAtMjJdID0gXCJUaW1lTmFub3NlY29uZFwiO1xuICBUeXBlW1R5cGVbXCJEZW5zZVVuaW9uXCJdID0gLTIzXSA9IFwiRGVuc2VVbmlvblwiO1xuICBUeXBlW1R5cGVbXCJTcGFyc2VVbmlvblwiXSA9IC0yNF0gPSBcIlNwYXJzZVVuaW9uXCI7XG4gIFR5cGVbVHlwZVtcIkludGVydmFsRGF5VGltZVwiXSA9IC0yNV0gPSBcIkludGVydmFsRGF5VGltZVwiO1xuICBUeXBlW1R5cGVbXCJJbnRlcnZhbFllYXJNb250aFwiXSA9IC0yNl0gPSBcIkludGVydmFsWWVhck1vbnRoXCI7XG59KShUeXBlIHx8IChleHBvcnRzLlR5cGUgPSBUeXBlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgRmllbGQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZpZWxkKG5hbWUsIHR5cGUpIHtcbiAgICB2YXIgbnVsbGFibGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgIHZhciBtZXRhZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbmV3IE1hcCgpO1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEZpZWxkKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcIm5hbWVcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcInR5cGVcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcIm51bGxhYmxlXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJtZXRhZGF0YVwiLCB2b2lkIDApO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLm51bGxhYmxlID0gbnVsbGFibGU7XG4gICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoRmllbGQsIFt7XG4gICAga2V5OiBcInR5cGVJZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZSAmJiB0aGlzLnR5cGUudHlwZUlkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHJldHVybiBuZXcgRmllbGQodGhpcy5uYW1lLCB0aGlzLnR5cGUsIHRoaXMubnVsbGFibGUsIHRoaXMubWV0YWRhdGEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wYXJlVG9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZVRvKG90aGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5uYW1lID09PSBvdGhlci5uYW1lICYmIHRoaXMudHlwZSA9PT0gb3RoZXIudHlwZSAmJiB0aGlzLm51bGxhYmxlID09PSBvdGhlci5udWxsYWJsZSAmJiB0aGlzLm1ldGFkYXRhID09PSBvdGhlci5tZXRhZGF0YTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy50eXBlKS5jb25jYXQodGhpcy5udWxsYWJsZSA/ICcsIG51bGxhYmxlJyA6ICcnKS5jb25jYXQodGhpcy5tZXRhZGF0YSA/IFwiLCBtZXRhZGF0YTogXCIuY29uY2F0KHRoaXMubWV0YWRhdGEpIDogJycpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRmllbGQ7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEZpZWxkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmllbGQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3RvQ29uc3VtYWJsZUFycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXlcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX2Fzc2VydCA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9hc3NlcnRcIik7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxudmFyIFNjaGVtYSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2NoZW1hKGZpZWxkcywgbWV0YWRhdGEpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBTY2hlbWEpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiZmllbGRzXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJtZXRhZGF0YVwiLCB2b2lkIDApO1xuICAgICgwLCBfYXNzZXJ0LmFzc2VydCkoQXJyYXkuaXNBcnJheShmaWVsZHMpKTtcbiAgICBjaGVja05hbWVzKGZpZWxkcyk7XG4gICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XG4gICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhIHx8IG5ldyBNYXAoKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKFNjaGVtYSwgW3tcbiAgICBrZXk6IFwiY29tcGFyZVRvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmVUbyhvdGhlcikge1xuICAgICAgaWYgKHRoaXMubWV0YWRhdGEgIT09IG90aGVyLm1ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZmllbGRzLmxlbmd0aCAhPT0gb3RoZXIuZmllbGRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5maWVsZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpZWxkc1tpXS5jb21wYXJlVG8ob3RoZXIuZmllbGRzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VsZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdCgpIHtcbiAgICAgIHZhciBuYW1lTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGNvbHVtbk5hbWVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBjb2x1bW5OYW1lc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2kgPSAwLCBfY29sdW1uTmFtZXMgPSBjb2x1bW5OYW1lczsgX2kgPCBfY29sdW1uTmFtZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBuYW1lID0gX2NvbHVtbk5hbWVzW19pXTtcbiAgICAgICAgbmFtZU1hcFtuYW1lXSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxlY3RlZEZpZWxkcyA9IHRoaXMuZmllbGRzLmZpbHRlcihmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVNYXBbZmllbGQubmFtZV07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgU2NoZW1hKHNlbGVjdGVkRmllbGRzLCB0aGlzLm1ldGFkYXRhKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VsZWN0QXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0QXQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGNvbHVtbkluZGljZXMgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgY29sdW1uSW5kaWNlc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VsZWN0ZWRGaWVsZHMgPSBjb2x1bW5JbmRpY2VzLm1hcChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmZpZWxkc1tpbmRleF07XG4gICAgICB9KS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICByZXR1cm4gbmV3IFNjaGVtYShzZWxlY3RlZEZpZWxkcywgdGhpcy5tZXRhZGF0YSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFzc2lnblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhc3NpZ24oc2NoZW1hT3JGaWVsZHMpIHtcbiAgICAgIHZhciBmaWVsZHM7XG4gICAgICB2YXIgbWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhO1xuXG4gICAgICBpZiAoc2NoZW1hT3JGaWVsZHMgaW5zdGFuY2VvZiBTY2hlbWEpIHtcbiAgICAgICAgdmFyIG90aGVyU2NoZW1hID0gc2NoZW1hT3JGaWVsZHM7XG4gICAgICAgIGZpZWxkcyA9IG90aGVyU2NoZW1hLmZpZWxkcztcbiAgICAgICAgbWV0YWRhdGEgPSBtZXJnZU1hcHMobWVyZ2VNYXBzKG5ldyBNYXAoKSwgdGhpcy5tZXRhZGF0YSksIG90aGVyU2NoZW1hLm1ldGFkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpZWxkcyA9IHNjaGVtYU9yRmllbGRzO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmllbGRNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5maWVsZHMpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBmaWVsZCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIGZpZWxkTWFwW2ZpZWxkLm5hbWVdID0gZmllbGQ7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihmaWVsZHMpLFxuICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX2ZpZWxkID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgIGZpZWxkTWFwW19maWVsZC5uYW1lXSA9IF9maWVsZDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtZXJnZWRGaWVsZHMgPSBPYmplY3QudmFsdWVzKGZpZWxkTWFwKTtcbiAgICAgIHJldHVybiBuZXcgU2NoZW1hKG1lcmdlZEZpZWxkcywgbWV0YWRhdGEpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU2NoZW1hO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTY2hlbWE7XG5cbmZ1bmN0aW9uIGNoZWNrTmFtZXMoZmllbGRzKSB7XG4gIHZhciB1c2VkTmFtZXMgPSB7fTtcblxuICB2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGZpZWxkcyksXG4gICAgICBfc3RlcDM7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgdmFyIGZpZWxkID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICBpZiAodXNlZE5hbWVzW2ZpZWxkLm5hbWVdKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignU2NoZW1hOiBkdXBsaWNhdGVkIGZpZWxkIG5hbWUnLCBmaWVsZC5uYW1lLCBmaWVsZCk7XG4gICAgICB9XG5cbiAgICAgIHVzZWROYW1lc1tmaWVsZC5uYW1lXSA9IHRydWU7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IzLmYoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZU1hcHMobTEsIG0yKSB7XG4gIHJldHVybiBuZXcgTWFwKFtdLmNvbmNhdCgoMCwgX3RvQ29uc3VtYWJsZUFycmF5Mi5kZWZhdWx0KShtMSB8fCBuZXcgTWFwKCkpLCAoMCwgX3RvQ29uc3VtYWJsZUFycmF5Mi5kZWZhdWx0KShtMiB8fCBuZXcgTWFwKCkpKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2hlbWEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHlwZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZW51bS5UeXBlO1xuICB9XG59KTtcbmV4cG9ydHMuRml4ZWRTaXplTGlzdCA9IGV4cG9ydHMuSW50ZXJ2YWxZZWFyTW9udGggPSBleHBvcnRzLkludGVydmFsRGF5VGltZSA9IGV4cG9ydHMuSW50ZXJ2YWwgPSBleHBvcnRzLlRpbWVzdGFtcE5hbm9zZWNvbmQgPSBleHBvcnRzLlRpbWVzdGFtcE1pY3Jvc2Vjb25kID0gZXhwb3J0cy5UaW1lc3RhbXBNaWxsaXNlY29uZCA9IGV4cG9ydHMuVGltZXN0YW1wU2Vjb25kID0gZXhwb3J0cy5UaW1lc3RhbXAgPSBleHBvcnRzLlRpbWVNaWxsaXNlY29uZCA9IGV4cG9ydHMuVGltZVNlY29uZCA9IGV4cG9ydHMuVGltZSA9IGV4cG9ydHMuRGF0ZU1pbGxpc2Vjb25kID0gZXhwb3J0cy5EYXRlRGF5ID0gZXhwb3J0cy5EYXRlID0gZXhwb3J0cy5VdGY4ID0gZXhwb3J0cy5CaW5hcnkgPSBleHBvcnRzLkZsb2F0NjQgPSBleHBvcnRzLkZsb2F0MzIgPSBleHBvcnRzLkZsb2F0MTYgPSBleHBvcnRzLkZsb2F0ID0gZXhwb3J0cy5VaW50NjQgPSBleHBvcnRzLlVpbnQzMiA9IGV4cG9ydHMuVWludDE2ID0gZXhwb3J0cy5VaW50OCA9IGV4cG9ydHMuSW50NjQgPSBleHBvcnRzLkludDMyID0gZXhwb3J0cy5JbnQxNiA9IGV4cG9ydHMuSW50OCA9IGV4cG9ydHMuSW50ID0gZXhwb3J0cy5Cb29sID0gZXhwb3J0cy5OdWxsID0gZXhwb3J0cy5EYXRhVHlwZSA9IHZvaWQgMDtcblxudmFyIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9lbnVtID0gcmVxdWlyZShcIi4vZW51bVwiKTtcblxudmFyIF9TeW1ib2wkdG9TdHJpbmdUYWcsIF9TeW1ib2wkdG9TdHJpbmdUYWcyLCBfU3ltYm9sJHRvU3RyaW5nVGFnMywgX1N5bWJvbCR0b1N0cmluZ1RhZzQsIF9TeW1ib2wkdG9TdHJpbmdUYWc1LCBfU3ltYm9sJHRvU3RyaW5nVGFnNiwgX1N5bWJvbCR0b1N0cmluZ1RhZzc7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgRGF0YVR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERhdGFUeXBlKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIERhdGFUeXBlKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKERhdGFUeXBlLCBbe1xuICAgIGtleTogXCJ0eXBlSWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfZW51bS5UeXBlLk5PTkU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBhcmVUb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzID09PSBvdGhlcjtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJpc051bGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNOdWxsKHgpIHtcbiAgICAgIHJldHVybiB4ICYmIHgudHlwZUlkID09PSBfZW51bS5UeXBlLk51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzSW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzSW50KHgpIHtcbiAgICAgIHJldHVybiB4ICYmIHgudHlwZUlkID09PSBfZW51bS5UeXBlLkludDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNGbG9hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0Zsb2F0KHgpIHtcbiAgICAgIHJldHVybiB4ICYmIHgudHlwZUlkID09PSBfZW51bS5UeXBlLkZsb2F0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0JpbmFyeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0JpbmFyeSh4KSB7XG4gICAgICByZXR1cm4geCAmJiB4LnR5cGVJZCA9PT0gX2VudW0uVHlwZS5CaW5hcnk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzVXRmOFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1V0ZjgoeCkge1xuICAgICAgcmV0dXJuIHggJiYgeC50eXBlSWQgPT09IF9lbnVtLlR5cGUuVXRmODtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNCb29sXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzQm9vbCh4KSB7XG4gICAgICByZXR1cm4geCAmJiB4LnR5cGVJZCA9PT0gX2VudW0uVHlwZS5Cb29sO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0RlY2ltYWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNEZWNpbWFsKHgpIHtcbiAgICAgIHJldHVybiB4ICYmIHgudHlwZUlkID09PSBfZW51bS5UeXBlLkRlY2ltYWw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzRGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0RhdGUoeCkge1xuICAgICAgcmV0dXJuIHggJiYgeC50eXBlSWQgPT09IF9lbnVtLlR5cGUuRGF0ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNUaW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzVGltZSh4KSB7XG4gICAgICByZXR1cm4geCAmJiB4LnR5cGVJZCA9PT0gX2VudW0uVHlwZS5UaW1lO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1RpbWVzdGFtcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1RpbWVzdGFtcCh4KSB7XG4gICAgICByZXR1cm4geCAmJiB4LnR5cGVJZCA9PT0gX2VudW0uVHlwZS5UaW1lc3RhbXA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzSW50ZXJ2YWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNJbnRlcnZhbCh4KSB7XG4gICAgICByZXR1cm4geCAmJiB4LnR5cGVJZCA9PT0gX2VudW0uVHlwZS5JbnRlcnZhbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNMaXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzTGlzdCh4KSB7XG4gICAgICByZXR1cm4geCAmJiB4LnR5cGVJZCA9PT0gX2VudW0uVHlwZS5MaXN0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1N0cnVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1N0cnVjdCh4KSB7XG4gICAgICByZXR1cm4geCAmJiB4LnR5cGVJZCA9PT0gX2VudW0uVHlwZS5TdHJ1Y3Q7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzVW5pb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNVbmlvbih4KSB7XG4gICAgICByZXR1cm4geCAmJiB4LnR5cGVJZCA9PT0gX2VudW0uVHlwZS5VbmlvbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNGaXhlZFNpemVCaW5hcnlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNGaXhlZFNpemVCaW5hcnkoeCkge1xuICAgICAgcmV0dXJuIHggJiYgeC50eXBlSWQgPT09IF9lbnVtLlR5cGUuRml4ZWRTaXplQmluYXJ5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0ZpeGVkU2l6ZUxpc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNGaXhlZFNpemVMaXN0KHgpIHtcbiAgICAgIHJldHVybiB4ICYmIHgudHlwZUlkID09PSBfZW51bS5UeXBlLkZpeGVkU2l6ZUxpc3Q7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzTWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzTWFwKHgpIHtcbiAgICAgIHJldHVybiB4ICYmIHgudHlwZUlkID09PSBfZW51bS5UeXBlLk1hcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNEaWN0aW9uYXJ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRGljdGlvbmFyeSh4KSB7XG4gICAgICByZXR1cm4geCAmJiB4LnR5cGVJZCA9PT0gX2VudW0uVHlwZS5EaWN0aW9uYXJ5O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRGF0YVR5cGU7XG59KCk7XG5cbmV4cG9ydHMuRGF0YVR5cGUgPSBEYXRhVHlwZTtcblxudmFyIE51bGwgPSBmdW5jdGlvbiAoX0RhdGFUeXBlKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKE51bGwsIF9EYXRhVHlwZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihOdWxsKTtcblxuICBmdW5jdGlvbiBOdWxsKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIE51bGwpO1xuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKE51bGwsIFt7XG4gICAga2V5OiBcInR5cGVJZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9lbnVtLlR5cGUuTnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFN5bWJvbC50b1N0cmluZ1RhZyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnTnVsbCc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICdOdWxsJztcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE51bGw7XG59KERhdGFUeXBlKTtcblxuZXhwb3J0cy5OdWxsID0gTnVsbDtcblxudmFyIEJvb2wgPSBmdW5jdGlvbiAoX0RhdGFUeXBlMikge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShCb29sLCBfRGF0YVR5cGUyKTtcblxuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlcihCb29sKTtcblxuICBmdW5jdGlvbiBCb29sKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEJvb2wpO1xuICAgIHJldHVybiBfc3VwZXIyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShCb29sLCBbe1xuICAgIGtleTogXCJ0eXBlSWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfZW51bS5UeXBlLkJvb2w7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBTeW1ib2wudG9TdHJpbmdUYWcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ0Jvb2wnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAnQm9vbCc7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCb29sO1xufShEYXRhVHlwZSk7XG5cbmV4cG9ydHMuQm9vbCA9IEJvb2w7XG5fU3ltYm9sJHRvU3RyaW5nVGFnID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xuXG52YXIgSW50ID0gZnVuY3Rpb24gKF9EYXRhVHlwZTMpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoSW50LCBfRGF0YVR5cGUzKTtcblxuICB2YXIgX3N1cGVyMyA9IF9jcmVhdGVTdXBlcihJbnQpO1xuXG4gIGZ1bmN0aW9uIEludChpc1NpZ25lZCwgYml0V2lkdGgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBJbnQpO1xuICAgIF90aGlzID0gX3N1cGVyMy5jYWxsKHRoaXMpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpcyksIFwiaXNTaWduZWRcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXMpLCBcImJpdFdpZHRoXCIsIHZvaWQgMCk7XG4gICAgX3RoaXMuaXNTaWduZWQgPSBpc1NpZ25lZDtcbiAgICBfdGhpcy5iaXRXaWR0aCA9IGJpdFdpZHRoO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEludCwgW3tcbiAgICBrZXk6IFwidHlwZUlkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2VudW0uVHlwZS5JbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBfU3ltYm9sJHRvU3RyaW5nVGFnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICdJbnQnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aGlzLmlzU2lnbmVkID8gJ0knIDogJ1VpJywgXCJudFwiKS5jb25jYXQodGhpcy5iaXRXaWR0aCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBJbnQ7XG59KERhdGFUeXBlKTtcblxuZXhwb3J0cy5JbnQgPSBJbnQ7XG5cbnZhciBJbnQ4ID0gZnVuY3Rpb24gKF9JbnQpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoSW50OCwgX0ludCk7XG5cbiAgdmFyIF9zdXBlcjQgPSBfY3JlYXRlU3VwZXIoSW50OCk7XG5cbiAgZnVuY3Rpb24gSW50OCgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBJbnQ4KTtcbiAgICByZXR1cm4gX3N1cGVyNC5jYWxsKHRoaXMsIHRydWUsIDgpO1xuICB9XG5cbiAgcmV0dXJuIEludDg7XG59KEludCk7XG5cbmV4cG9ydHMuSW50OCA9IEludDg7XG5cbnZhciBJbnQxNiA9IGZ1bmN0aW9uIChfSW50Mikge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShJbnQxNiwgX0ludDIpO1xuXG4gIHZhciBfc3VwZXI1ID0gX2NyZWF0ZVN1cGVyKEludDE2KTtcblxuICBmdW5jdGlvbiBJbnQxNigpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBJbnQxNik7XG4gICAgcmV0dXJuIF9zdXBlcjUuY2FsbCh0aGlzLCB0cnVlLCAxNik7XG4gIH1cblxuICByZXR1cm4gSW50MTY7XG59KEludCk7XG5cbmV4cG9ydHMuSW50MTYgPSBJbnQxNjtcblxudmFyIEludDMyID0gZnVuY3Rpb24gKF9JbnQzKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEludDMyLCBfSW50Myk7XG5cbiAgdmFyIF9zdXBlcjYgPSBfY3JlYXRlU3VwZXIoSW50MzIpO1xuXG4gIGZ1bmN0aW9uIEludDMyKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEludDMyKTtcbiAgICByZXR1cm4gX3N1cGVyNi5jYWxsKHRoaXMsIHRydWUsIDMyKTtcbiAgfVxuXG4gIHJldHVybiBJbnQzMjtcbn0oSW50KTtcblxuZXhwb3J0cy5JbnQzMiA9IEludDMyO1xuXG52YXIgSW50NjQgPSBmdW5jdGlvbiAoX0ludDQpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoSW50NjQsIF9JbnQ0KTtcblxuICB2YXIgX3N1cGVyNyA9IF9jcmVhdGVTdXBlcihJbnQ2NCk7XG5cbiAgZnVuY3Rpb24gSW50NjQoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgSW50NjQpO1xuICAgIHJldHVybiBfc3VwZXI3LmNhbGwodGhpcywgdHJ1ZSwgNjQpO1xuICB9XG5cbiAgcmV0dXJuIEludDY0O1xufShJbnQpO1xuXG5leHBvcnRzLkludDY0ID0gSW50NjQ7XG5cbnZhciBVaW50OCA9IGZ1bmN0aW9uIChfSW50NSkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShVaW50OCwgX0ludDUpO1xuXG4gIHZhciBfc3VwZXI4ID0gX2NyZWF0ZVN1cGVyKFVpbnQ4KTtcblxuICBmdW5jdGlvbiBVaW50OCgpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBVaW50OCk7XG4gICAgcmV0dXJuIF9zdXBlcjguY2FsbCh0aGlzLCBmYWxzZSwgOCk7XG4gIH1cblxuICByZXR1cm4gVWludDg7XG59KEludCk7XG5cbmV4cG9ydHMuVWludDggPSBVaW50ODtcblxudmFyIFVpbnQxNiA9IGZ1bmN0aW9uIChfSW50Nikge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShVaW50MTYsIF9JbnQ2KTtcblxuICB2YXIgX3N1cGVyOSA9IF9jcmVhdGVTdXBlcihVaW50MTYpO1xuXG4gIGZ1bmN0aW9uIFVpbnQxNigpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBVaW50MTYpO1xuICAgIHJldHVybiBfc3VwZXI5LmNhbGwodGhpcywgZmFsc2UsIDE2KTtcbiAgfVxuXG4gIHJldHVybiBVaW50MTY7XG59KEludCk7XG5cbmV4cG9ydHMuVWludDE2ID0gVWludDE2O1xuXG52YXIgVWludDMyID0gZnVuY3Rpb24gKF9JbnQ3KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKFVpbnQzMiwgX0ludDcpO1xuXG4gIHZhciBfc3VwZXIxMCA9IF9jcmVhdGVTdXBlcihVaW50MzIpO1xuXG4gIGZ1bmN0aW9uIFVpbnQzMigpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBVaW50MzIpO1xuICAgIHJldHVybiBfc3VwZXIxMC5jYWxsKHRoaXMsIGZhbHNlLCAzMik7XG4gIH1cblxuICByZXR1cm4gVWludDMyO1xufShJbnQpO1xuXG5leHBvcnRzLlVpbnQzMiA9IFVpbnQzMjtcblxudmFyIFVpbnQ2NCA9IGZ1bmN0aW9uIChfSW50OCkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShVaW50NjQsIF9JbnQ4KTtcblxuICB2YXIgX3N1cGVyMTEgPSBfY3JlYXRlU3VwZXIoVWludDY0KTtcblxuICBmdW5jdGlvbiBVaW50NjQoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgVWludDY0KTtcbiAgICByZXR1cm4gX3N1cGVyMTEuY2FsbCh0aGlzLCBmYWxzZSwgNjQpO1xuICB9XG5cbiAgcmV0dXJuIFVpbnQ2NDtcbn0oSW50KTtcblxuZXhwb3J0cy5VaW50NjQgPSBVaW50NjQ7XG52YXIgUHJlY2lzaW9uID0ge1xuICBIQUxGOiAxNixcbiAgU0lOR0xFOiAzMixcbiAgRE9VQkxFOiA2NFxufTtcbl9TeW1ib2wkdG9TdHJpbmdUYWcyID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xuXG52YXIgRmxvYXQgPSBmdW5jdGlvbiAoX0RhdGFUeXBlNCkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShGbG9hdCwgX0RhdGFUeXBlNCk7XG5cbiAgdmFyIF9zdXBlcjEyID0gX2NyZWF0ZVN1cGVyKEZsb2F0KTtcblxuICBmdW5jdGlvbiBGbG9hdChwcmVjaXNpb24pIHtcbiAgICB2YXIgX3RoaXMyO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgRmxvYXQpO1xuICAgIF90aGlzMiA9IF9zdXBlcjEyLmNhbGwodGhpcyk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzMiksIFwicHJlY2lzaW9uXCIsIHZvaWQgMCk7XG4gICAgX3RoaXMyLnByZWNpc2lvbiA9IHByZWNpc2lvbjtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoRmxvYXQsIFt7XG4gICAga2V5OiBcInR5cGVJZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9lbnVtLlR5cGUuRmxvYXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBfU3ltYm9sJHRvU3RyaW5nVGFnMixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnRmxvYXQnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcIkZsb2F0XCIuY29uY2F0KHRoaXMucHJlY2lzaW9uKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEZsb2F0O1xufShEYXRhVHlwZSk7XG5cbmV4cG9ydHMuRmxvYXQgPSBGbG9hdDtcblxudmFyIEZsb2F0MTYgPSBmdW5jdGlvbiAoX0Zsb2F0KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEZsb2F0MTYsIF9GbG9hdCk7XG5cbiAgdmFyIF9zdXBlcjEzID0gX2NyZWF0ZVN1cGVyKEZsb2F0MTYpO1xuXG4gIGZ1bmN0aW9uIEZsb2F0MTYoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgRmxvYXQxNik7XG4gICAgcmV0dXJuIF9zdXBlcjEzLmNhbGwodGhpcywgUHJlY2lzaW9uLkhBTEYpO1xuICB9XG5cbiAgcmV0dXJuIEZsb2F0MTY7XG59KEZsb2F0KTtcblxuZXhwb3J0cy5GbG9hdDE2ID0gRmxvYXQxNjtcblxudmFyIEZsb2F0MzIgPSBmdW5jdGlvbiAoX0Zsb2F0Mikge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShGbG9hdDMyLCBfRmxvYXQyKTtcblxuICB2YXIgX3N1cGVyMTQgPSBfY3JlYXRlU3VwZXIoRmxvYXQzMik7XG5cbiAgZnVuY3Rpb24gRmxvYXQzMigpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBGbG9hdDMyKTtcbiAgICByZXR1cm4gX3N1cGVyMTQuY2FsbCh0aGlzLCBQcmVjaXNpb24uU0lOR0xFKTtcbiAgfVxuXG4gIHJldHVybiBGbG9hdDMyO1xufShGbG9hdCk7XG5cbmV4cG9ydHMuRmxvYXQzMiA9IEZsb2F0MzI7XG5cbnZhciBGbG9hdDY0ID0gZnVuY3Rpb24gKF9GbG9hdDMpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoRmxvYXQ2NCwgX0Zsb2F0Myk7XG5cbiAgdmFyIF9zdXBlcjE1ID0gX2NyZWF0ZVN1cGVyKEZsb2F0NjQpO1xuXG4gIGZ1bmN0aW9uIEZsb2F0NjQoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgRmxvYXQ2NCk7XG4gICAgcmV0dXJuIF9zdXBlcjE1LmNhbGwodGhpcywgUHJlY2lzaW9uLkRPVUJMRSk7XG4gIH1cblxuICByZXR1cm4gRmxvYXQ2NDtcbn0oRmxvYXQpO1xuXG5leHBvcnRzLkZsb2F0NjQgPSBGbG9hdDY0O1xuXG52YXIgQmluYXJ5ID0gZnVuY3Rpb24gKF9EYXRhVHlwZTUpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoQmluYXJ5LCBfRGF0YVR5cGU1KTtcblxuICB2YXIgX3N1cGVyMTYgPSBfY3JlYXRlU3VwZXIoQmluYXJ5KTtcblxuICBmdW5jdGlvbiBCaW5hcnkoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgQmluYXJ5KTtcbiAgICByZXR1cm4gX3N1cGVyMTYuY2FsbCh0aGlzKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEJpbmFyeSwgW3tcbiAgICBrZXk6IFwidHlwZUlkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2VudW0uVHlwZS5CaW5hcnk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICdCaW5hcnknO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogU3ltYm9sLnRvU3RyaW5nVGFnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICdCaW5hcnknO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQmluYXJ5O1xufShEYXRhVHlwZSk7XG5cbmV4cG9ydHMuQmluYXJ5ID0gQmluYXJ5O1xuXG52YXIgVXRmOCA9IGZ1bmN0aW9uIChfRGF0YVR5cGU2KSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKFV0ZjgsIF9EYXRhVHlwZTYpO1xuXG4gIHZhciBfc3VwZXIxNyA9IF9jcmVhdGVTdXBlcihVdGY4KTtcblxuICBmdW5jdGlvbiBVdGY4KCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFV0ZjgpO1xuICAgIHJldHVybiBfc3VwZXIxNy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoVXRmOCwgW3tcbiAgICBrZXk6IFwidHlwZUlkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2VudW0uVHlwZS5VdGY4O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogU3ltYm9sLnRvU3RyaW5nVGFnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICdVdGY4JztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ1V0ZjgnO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVXRmODtcbn0oRGF0YVR5cGUpO1xuXG5leHBvcnRzLlV0ZjggPSBVdGY4O1xudmFyIERhdGVVbml0ID0ge1xuICBEQVk6IDAsXG4gIE1JTExJU0VDT05EOiAxXG59O1xuX1N5bWJvbCR0b1N0cmluZ1RhZzMgPSBTeW1ib2wudG9TdHJpbmdUYWc7XG5cbnZhciBEYXRlID0gZnVuY3Rpb24gKF9EYXRhVHlwZTcpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoRGF0ZSwgX0RhdGFUeXBlNyk7XG5cbiAgdmFyIF9zdXBlcjE4ID0gX2NyZWF0ZVN1cGVyKERhdGUpO1xuXG4gIGZ1bmN0aW9uIERhdGUodW5pdCkge1xuICAgIHZhciBfdGhpczM7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBEYXRlKTtcbiAgICBfdGhpczMgPSBfc3VwZXIxOC5jYWxsKHRoaXMpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczMpLCBcInVuaXRcIiwgdm9pZCAwKTtcbiAgICBfdGhpczMudW5pdCA9IHVuaXQ7XG4gICAgcmV0dXJuIF90aGlzMztcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKERhdGUsIFt7XG4gICAga2V5OiBcInR5cGVJZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9lbnVtLlR5cGUuRGF0ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IF9TeW1ib2wkdG9TdHJpbmdUYWczLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICdEYXRlJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCJEYXRlXCIuY29uY2F0KCh0aGlzLnVuaXQgKyAxKSAqIDMyLCBcIjxcIikuY29uY2F0KERhdGVVbml0W3RoaXMudW5pdF0sIFwiPlwiKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIERhdGU7XG59KERhdGFUeXBlKTtcblxuZXhwb3J0cy5EYXRlID0gRGF0ZTtcblxudmFyIERhdGVEYXkgPSBmdW5jdGlvbiAoX0RhdGUpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoRGF0ZURheSwgX0RhdGUpO1xuXG4gIHZhciBfc3VwZXIxOSA9IF9jcmVhdGVTdXBlcihEYXRlRGF5KTtcblxuICBmdW5jdGlvbiBEYXRlRGF5KCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIERhdGVEYXkpO1xuICAgIHJldHVybiBfc3VwZXIxOS5jYWxsKHRoaXMsIERhdGVVbml0LkRBWSk7XG4gIH1cblxuICByZXR1cm4gRGF0ZURheTtcbn0oRGF0ZSk7XG5cbmV4cG9ydHMuRGF0ZURheSA9IERhdGVEYXk7XG5cbnZhciBEYXRlTWlsbGlzZWNvbmQgPSBmdW5jdGlvbiAoX0RhdGUyKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKERhdGVNaWxsaXNlY29uZCwgX0RhdGUyKTtcblxuICB2YXIgX3N1cGVyMjAgPSBfY3JlYXRlU3VwZXIoRGF0ZU1pbGxpc2Vjb25kKTtcblxuICBmdW5jdGlvbiBEYXRlTWlsbGlzZWNvbmQoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgRGF0ZU1pbGxpc2Vjb25kKTtcbiAgICByZXR1cm4gX3N1cGVyMjAuY2FsbCh0aGlzLCBEYXRlVW5pdC5NSUxMSVNFQ09ORCk7XG4gIH1cblxuICByZXR1cm4gRGF0ZU1pbGxpc2Vjb25kO1xufShEYXRlKTtcblxuZXhwb3J0cy5EYXRlTWlsbGlzZWNvbmQgPSBEYXRlTWlsbGlzZWNvbmQ7XG52YXIgVGltZVVuaXQgPSB7XG4gIFNFQ09ORDogMSxcbiAgTUlMTElTRUNPTkQ6IDFlMyxcbiAgTUlDUk9TRUNPTkQ6IDFlNixcbiAgTkFOT1NFQ09ORDogMWU5XG59O1xuX1N5bWJvbCR0b1N0cmluZ1RhZzQgPSBTeW1ib2wudG9TdHJpbmdUYWc7XG5cbnZhciBUaW1lID0gZnVuY3Rpb24gKF9EYXRhVHlwZTgpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoVGltZSwgX0RhdGFUeXBlOCk7XG5cbiAgdmFyIF9zdXBlcjIxID0gX2NyZWF0ZVN1cGVyKFRpbWUpO1xuXG4gIGZ1bmN0aW9uIFRpbWUodW5pdCwgYml0V2lkdGgpIHtcbiAgICB2YXIgX3RoaXM0O1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgVGltZSk7XG4gICAgX3RoaXM0ID0gX3N1cGVyMjEuY2FsbCh0aGlzKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXM0KSwgXCJ1bml0XCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzNCksIFwiYml0V2lkdGhcIiwgdm9pZCAwKTtcbiAgICBfdGhpczQudW5pdCA9IHVuaXQ7XG4gICAgX3RoaXM0LmJpdFdpZHRoID0gYml0V2lkdGg7XG4gICAgcmV0dXJuIF90aGlzNDtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKFRpbWUsIFt7XG4gICAga2V5OiBcInR5cGVJZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9lbnVtLlR5cGUuVGltZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCJUaW1lXCIuY29uY2F0KHRoaXMuYml0V2lkdGgsIFwiPFwiKS5jb25jYXQoVGltZVVuaXRbdGhpcy51bml0XSwgXCI+XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogX1N5bWJvbCR0b1N0cmluZ1RhZzQsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ1RpbWUnO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVGltZTtcbn0oRGF0YVR5cGUpO1xuXG5leHBvcnRzLlRpbWUgPSBUaW1lO1xuXG52YXIgVGltZVNlY29uZCA9IGZ1bmN0aW9uIChfVGltZSkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShUaW1lU2Vjb25kLCBfVGltZSk7XG5cbiAgdmFyIF9zdXBlcjIyID0gX2NyZWF0ZVN1cGVyKFRpbWVTZWNvbmQpO1xuXG4gIGZ1bmN0aW9uIFRpbWVTZWNvbmQoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgVGltZVNlY29uZCk7XG4gICAgcmV0dXJuIF9zdXBlcjIyLmNhbGwodGhpcywgVGltZVVuaXQuU0VDT05ELCAzMik7XG4gIH1cblxuICByZXR1cm4gVGltZVNlY29uZDtcbn0oVGltZSk7XG5cbmV4cG9ydHMuVGltZVNlY29uZCA9IFRpbWVTZWNvbmQ7XG5cbnZhciBUaW1lTWlsbGlzZWNvbmQgPSBmdW5jdGlvbiAoX1RpbWUyKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKFRpbWVNaWxsaXNlY29uZCwgX1RpbWUyKTtcblxuICB2YXIgX3N1cGVyMjMgPSBfY3JlYXRlU3VwZXIoVGltZU1pbGxpc2Vjb25kKTtcblxuICBmdW5jdGlvbiBUaW1lTWlsbGlzZWNvbmQoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgVGltZU1pbGxpc2Vjb25kKTtcbiAgICByZXR1cm4gX3N1cGVyMjMuY2FsbCh0aGlzLCBUaW1lVW5pdC5NSUxMSVNFQ09ORCwgMzIpO1xuICB9XG5cbiAgcmV0dXJuIFRpbWVNaWxsaXNlY29uZDtcbn0oVGltZSk7XG5cbmV4cG9ydHMuVGltZU1pbGxpc2Vjb25kID0gVGltZU1pbGxpc2Vjb25kO1xuX1N5bWJvbCR0b1N0cmluZ1RhZzUgPSBTeW1ib2wudG9TdHJpbmdUYWc7XG5cbnZhciBUaW1lc3RhbXAgPSBmdW5jdGlvbiAoX0RhdGFUeXBlOSkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShUaW1lc3RhbXAsIF9EYXRhVHlwZTkpO1xuXG4gIHZhciBfc3VwZXIyNCA9IF9jcmVhdGVTdXBlcihUaW1lc3RhbXApO1xuXG4gIGZ1bmN0aW9uIFRpbWVzdGFtcCh1bml0KSB7XG4gICAgdmFyIF90aGlzNTtcblxuICAgIHZhciB0aW1lem9uZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBUaW1lc3RhbXApO1xuICAgIF90aGlzNSA9IF9zdXBlcjI0LmNhbGwodGhpcyk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzNSksIFwidW5pdFwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczUpLCBcInRpbWV6b25lXCIsIHZvaWQgMCk7XG4gICAgX3RoaXM1LnVuaXQgPSB1bml0O1xuICAgIF90aGlzNS50aW1lem9uZSA9IHRpbWV6b25lO1xuICAgIHJldHVybiBfdGhpczU7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShUaW1lc3RhbXAsIFt7XG4gICAga2V5OiBcInR5cGVJZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9lbnVtLlR5cGUuVGltZXN0YW1wO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogX1N5bWJvbCR0b1N0cmluZ1RhZzUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ1RpbWVzdGFtcCc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIFwiVGltZXN0YW1wPFwiLmNvbmNhdChUaW1lVW5pdFt0aGlzLnVuaXRdKS5jb25jYXQodGhpcy50aW1lem9uZSA/IFwiLCBcIi5jb25jYXQodGhpcy50aW1lem9uZSkgOiAnJywgXCI+XCIpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVGltZXN0YW1wO1xufShEYXRhVHlwZSk7XG5cbmV4cG9ydHMuVGltZXN0YW1wID0gVGltZXN0YW1wO1xuXG52YXIgVGltZXN0YW1wU2Vjb25kID0gZnVuY3Rpb24gKF9UaW1lc3RhbXApIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoVGltZXN0YW1wU2Vjb25kLCBfVGltZXN0YW1wKTtcblxuICB2YXIgX3N1cGVyMjUgPSBfY3JlYXRlU3VwZXIoVGltZXN0YW1wU2Vjb25kKTtcblxuICBmdW5jdGlvbiBUaW1lc3RhbXBTZWNvbmQoKSB7XG4gICAgdmFyIHRpbWV6b25lID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFRpbWVzdGFtcFNlY29uZCk7XG4gICAgcmV0dXJuIF9zdXBlcjI1LmNhbGwodGhpcywgVGltZVVuaXQuU0VDT05ELCB0aW1lem9uZSk7XG4gIH1cblxuICByZXR1cm4gVGltZXN0YW1wU2Vjb25kO1xufShUaW1lc3RhbXApO1xuXG5leHBvcnRzLlRpbWVzdGFtcFNlY29uZCA9IFRpbWVzdGFtcFNlY29uZDtcblxudmFyIFRpbWVzdGFtcE1pbGxpc2Vjb25kID0gZnVuY3Rpb24gKF9UaW1lc3RhbXAyKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKFRpbWVzdGFtcE1pbGxpc2Vjb25kLCBfVGltZXN0YW1wMik7XG5cbiAgdmFyIF9zdXBlcjI2ID0gX2NyZWF0ZVN1cGVyKFRpbWVzdGFtcE1pbGxpc2Vjb25kKTtcblxuICBmdW5jdGlvbiBUaW1lc3RhbXBNaWxsaXNlY29uZCgpIHtcbiAgICB2YXIgdGltZXpvbmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgVGltZXN0YW1wTWlsbGlzZWNvbmQpO1xuICAgIHJldHVybiBfc3VwZXIyNi5jYWxsKHRoaXMsIFRpbWVVbml0Lk1JTExJU0VDT05ELCB0aW1lem9uZSk7XG4gIH1cblxuICByZXR1cm4gVGltZXN0YW1wTWlsbGlzZWNvbmQ7XG59KFRpbWVzdGFtcCk7XG5cbmV4cG9ydHMuVGltZXN0YW1wTWlsbGlzZWNvbmQgPSBUaW1lc3RhbXBNaWxsaXNlY29uZDtcblxudmFyIFRpbWVzdGFtcE1pY3Jvc2Vjb25kID0gZnVuY3Rpb24gKF9UaW1lc3RhbXAzKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKFRpbWVzdGFtcE1pY3Jvc2Vjb25kLCBfVGltZXN0YW1wMyk7XG5cbiAgdmFyIF9zdXBlcjI3ID0gX2NyZWF0ZVN1cGVyKFRpbWVzdGFtcE1pY3Jvc2Vjb25kKTtcblxuICBmdW5jdGlvbiBUaW1lc3RhbXBNaWNyb3NlY29uZCgpIHtcbiAgICB2YXIgdGltZXpvbmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgVGltZXN0YW1wTWljcm9zZWNvbmQpO1xuICAgIHJldHVybiBfc3VwZXIyNy5jYWxsKHRoaXMsIFRpbWVVbml0Lk1JQ1JPU0VDT05ELCB0aW1lem9uZSk7XG4gIH1cblxuICByZXR1cm4gVGltZXN0YW1wTWljcm9zZWNvbmQ7XG59KFRpbWVzdGFtcCk7XG5cbmV4cG9ydHMuVGltZXN0YW1wTWljcm9zZWNvbmQgPSBUaW1lc3RhbXBNaWNyb3NlY29uZDtcblxudmFyIFRpbWVzdGFtcE5hbm9zZWNvbmQgPSBmdW5jdGlvbiAoX1RpbWVzdGFtcDQpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoVGltZXN0YW1wTmFub3NlY29uZCwgX1RpbWVzdGFtcDQpO1xuXG4gIHZhciBfc3VwZXIyOCA9IF9jcmVhdGVTdXBlcihUaW1lc3RhbXBOYW5vc2Vjb25kKTtcblxuICBmdW5jdGlvbiBUaW1lc3RhbXBOYW5vc2Vjb25kKCkge1xuICAgIHZhciB0aW1lem9uZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBUaW1lc3RhbXBOYW5vc2Vjb25kKTtcbiAgICByZXR1cm4gX3N1cGVyMjguY2FsbCh0aGlzLCBUaW1lVW5pdC5OQU5PU0VDT05ELCB0aW1lem9uZSk7XG4gIH1cblxuICByZXR1cm4gVGltZXN0YW1wTmFub3NlY29uZDtcbn0oVGltZXN0YW1wKTtcblxuZXhwb3J0cy5UaW1lc3RhbXBOYW5vc2Vjb25kID0gVGltZXN0YW1wTmFub3NlY29uZDtcbnZhciBJbnRlcnZhbFVuaXQgPSB7XG4gIERBWV9USU1FOiAwLFxuICBZRUFSX01PTlRIOiAxXG59O1xuX1N5bWJvbCR0b1N0cmluZ1RhZzYgPSBTeW1ib2wudG9TdHJpbmdUYWc7XG5cbnZhciBJbnRlcnZhbCA9IGZ1bmN0aW9uIChfRGF0YVR5cGUxMCkge1xuICAoMCwgX2luaGVyaXRzMi5kZWZhdWx0KShJbnRlcnZhbCwgX0RhdGFUeXBlMTApO1xuXG4gIHZhciBfc3VwZXIyOSA9IF9jcmVhdGVTdXBlcihJbnRlcnZhbCk7XG5cbiAgZnVuY3Rpb24gSW50ZXJ2YWwodW5pdCkge1xuICAgIHZhciBfdGhpczY7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBJbnRlcnZhbCk7XG4gICAgX3RoaXM2ID0gX3N1cGVyMjkuY2FsbCh0aGlzKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDIuZGVmYXVsdCkoX3RoaXM2KSwgXCJ1bml0XCIsIHZvaWQgMCk7XG4gICAgX3RoaXM2LnVuaXQgPSB1bml0O1xuICAgIHJldHVybiBfdGhpczY7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShJbnRlcnZhbCwgW3tcbiAgICBrZXk6IFwidHlwZUlkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2VudW0uVHlwZS5JbnRlcnZhbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IF9TeW1ib2wkdG9TdHJpbmdUYWc2LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICdJbnRlcnZhbCc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIFwiSW50ZXJ2YWw8XCIuY29uY2F0KEludGVydmFsVW5pdFt0aGlzLnVuaXRdLCBcIj5cIik7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBJbnRlcnZhbDtcbn0oRGF0YVR5cGUpO1xuXG5leHBvcnRzLkludGVydmFsID0gSW50ZXJ2YWw7XG5cbnZhciBJbnRlcnZhbERheVRpbWUgPSBmdW5jdGlvbiAoX0ludGVydmFsKSB7XG4gICgwLCBfaW5oZXJpdHMyLmRlZmF1bHQpKEludGVydmFsRGF5VGltZSwgX0ludGVydmFsKTtcblxuICB2YXIgX3N1cGVyMzAgPSBfY3JlYXRlU3VwZXIoSW50ZXJ2YWxEYXlUaW1lKTtcblxuICBmdW5jdGlvbiBJbnRlcnZhbERheVRpbWUoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgSW50ZXJ2YWxEYXlUaW1lKTtcbiAgICByZXR1cm4gX3N1cGVyMzAuY2FsbCh0aGlzLCBJbnRlcnZhbFVuaXQuREFZX1RJTUUpO1xuICB9XG5cbiAgcmV0dXJuIEludGVydmFsRGF5VGltZTtcbn0oSW50ZXJ2YWwpO1xuXG5leHBvcnRzLkludGVydmFsRGF5VGltZSA9IEludGVydmFsRGF5VGltZTtcblxudmFyIEludGVydmFsWWVhck1vbnRoID0gZnVuY3Rpb24gKF9JbnRlcnZhbDIpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoSW50ZXJ2YWxZZWFyTW9udGgsIF9JbnRlcnZhbDIpO1xuXG4gIHZhciBfc3VwZXIzMSA9IF9jcmVhdGVTdXBlcihJbnRlcnZhbFllYXJNb250aCk7XG5cbiAgZnVuY3Rpb24gSW50ZXJ2YWxZZWFyTW9udGgoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgSW50ZXJ2YWxZZWFyTW9udGgpO1xuICAgIHJldHVybiBfc3VwZXIzMS5jYWxsKHRoaXMsIEludGVydmFsVW5pdC5ZRUFSX01PTlRIKTtcbiAgfVxuXG4gIHJldHVybiBJbnRlcnZhbFllYXJNb250aDtcbn0oSW50ZXJ2YWwpO1xuXG5leHBvcnRzLkludGVydmFsWWVhck1vbnRoID0gSW50ZXJ2YWxZZWFyTW9udGg7XG5fU3ltYm9sJHRvU3RyaW5nVGFnNyA9IFN5bWJvbC50b1N0cmluZ1RhZztcblxudmFyIEZpeGVkU2l6ZUxpc3QgPSBmdW5jdGlvbiAoX0RhdGFUeXBlMTEpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoRml4ZWRTaXplTGlzdCwgX0RhdGFUeXBlMTEpO1xuXG4gIHZhciBfc3VwZXIzMiA9IF9jcmVhdGVTdXBlcihGaXhlZFNpemVMaXN0KTtcblxuICBmdW5jdGlvbiBGaXhlZFNpemVMaXN0KGxpc3RTaXplLCBjaGlsZCkge1xuICAgIHZhciBfdGhpczc7XG5cbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBGaXhlZFNpemVMaXN0KTtcbiAgICBfdGhpczcgPSBfc3VwZXIzMi5jYWxsKHRoaXMpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMi5kZWZhdWx0KShfdGhpczcpLCBcImxpc3RTaXplXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyLmRlZmF1bHQpKF90aGlzNyksIFwiY2hpbGRyZW5cIiwgdm9pZCAwKTtcbiAgICBfdGhpczcubGlzdFNpemUgPSBsaXN0U2l6ZTtcbiAgICBfdGhpczcuY2hpbGRyZW4gPSBbY2hpbGRdO1xuICAgIHJldHVybiBfdGhpczc7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShGaXhlZFNpemVMaXN0LCBbe1xuICAgIGtleTogXCJ0eXBlSWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfZW51bS5UeXBlLkZpeGVkU2l6ZUxpc3Q7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlVHlwZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bMF0udHlwZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmFsdWVGaWVsZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bMF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBfU3ltYm9sJHRvU3RyaW5nVGFnNyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnRml4ZWRTaXplTGlzdCc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIFwiRml4ZWRTaXplTGlzdFtcIi5jb25jYXQodGhpcy5saXN0U2l6ZSwgXCJdPFwiKS5jb25jYXQodGhpcy52YWx1ZVR5cGUsIFwiPlwiKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEZpeGVkU2l6ZUxpc3Q7XG59KERhdGFUeXBlKTtcblxuZXhwb3J0cy5GaXhlZFNpemVMaXN0ID0gRml4ZWRTaXplTGlzdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2NoZW1hXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zY2hlbWEuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGaWVsZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZmllbGQuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUeXBlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLlR5cGU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGF0YVR5cGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuRGF0YVR5cGU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTnVsbFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5OdWxsO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJvb2xcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuQm9vbDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuSW50O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludDhcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuSW50ODtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnQxNlwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5JbnQxNjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnQzMlwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5JbnQzMjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnQ2NFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5JbnQ2NDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVaW50OFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5VaW50ODtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVaW50MTZcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuVWludDE2O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVpbnQzMlwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5VaW50MzI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVWludDY0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLlVpbnQ2NDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGbG9hdFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5GbG9hdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGbG9hdDE2XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLkZsb2F0MTY7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmxvYXQzMlwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5GbG9hdDMyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZsb2F0NjRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuRmxvYXQ2NDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCaW5hcnlcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuQmluYXJ5O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlV0ZjhcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuVXRmODtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEYXRlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLkRhdGU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGF0ZURheVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5EYXRlRGF5O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRhdGVNaWxsaXNlY29uZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5EYXRlTWlsbGlzZWNvbmQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGltZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5UaW1lO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRpbWVTZWNvbmRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuVGltZVNlY29uZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUaW1lTWlsbGlzZWNvbmRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuVGltZU1pbGxpc2Vjb25kO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRpbWVzdGFtcFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5UaW1lc3RhbXA7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGltZXN0YW1wU2Vjb25kXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLlRpbWVzdGFtcFNlY29uZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUaW1lc3RhbXBNaWxsaXNlY29uZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5UaW1lc3RhbXBNaWxsaXNlY29uZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUaW1lc3RhbXBNaWNyb3NlY29uZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5UaW1lc3RhbXBNaWNyb3NlY29uZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUaW1lc3RhbXBOYW5vc2Vjb25kXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLlRpbWVzdGFtcE5hbm9zZWNvbmQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW50ZXJ2YWxcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3R5cGUuSW50ZXJ2YWw7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW50ZXJ2YWxEYXlUaW1lXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLkludGVydmFsRGF5VGltZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnRlcnZhbFllYXJNb250aFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdHlwZS5JbnRlcnZhbFllYXJNb250aDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGaXhlZFNpemVMaXN0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90eXBlLkZpeGVkU2l6ZUxpc3Q7XG4gIH1cbn0pO1xuXG52YXIgX3NjaGVtYSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaW1wbC9zY2hlbWFcIikpO1xuXG52YXIgX2ZpZWxkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pbXBsL2ZpZWxkXCIpKTtcblxudmFyIF90eXBlID0gcmVxdWlyZShcIi4vaW1wbC90eXBlXCIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgREVGQVVMVF9ST1dfQ09VTlQgPSAxMDA7XG5cbnZhciBSb3dUYWJsZUJhdGNoQWdncmVnYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUm93VGFibGVCYXRjaEFnZ3JlZ2F0b3Ioc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgUm93VGFibGVCYXRjaEFnZ3JlZ2F0b3IpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwic2NoZW1hXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJvcHRpb25zXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJsZW5ndGhcIiwgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJyb3dzXCIsIG51bGwpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiY3Vyc29yXCIsIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiX2hlYWRlcnNcIiwgW10pO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgICAgdGhpcy5faGVhZGVycyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgIHRoaXMuX2hlYWRlcnNbc2NoZW1hW2tleV0uaW5kZXhdID0gc2NoZW1hW2tleV0ubmFtZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShSb3dUYWJsZUJhdGNoQWdncmVnYXRvciwgW3tcbiAgICBrZXk6IFwicm93Q291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcm93Q291bnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZEFycmF5Um93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEFycmF5Um93KHJvdywgY3Vyc29yKSB7XG4gICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGN1cnNvcikpIHtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBjdXJzb3I7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucm93cyA9IHRoaXMucm93cyB8fCBuZXcgQXJyYXkoREVGQVVMVF9ST1dfQ09VTlQpO1xuICAgICAgdGhpcy5yb3dzW3RoaXMubGVuZ3RoXSA9IHJvdztcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZE9iamVjdFJvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRPYmplY3RSb3cocm93LCBjdXJzb3IpIHtcbiAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoY3Vyc29yKSkge1xuICAgICAgICB0aGlzLmN1cnNvciA9IGN1cnNvcjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yb3dzID0gdGhpcy5yb3dzIHx8IG5ldyBBcnJheShERUZBVUxUX1JPV19DT1VOVCk7XG4gICAgICB0aGlzLnJvd3NbdGhpcy5sZW5ndGhdID0gcm93O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QmF0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QmF0Y2goKSB7XG4gICAgICB2YXIgcm93cyA9IHRoaXMucm93cztcblxuICAgICAgaWYgKCFyb3dzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByb3dzID0gcm93cy5zbGljZSgwLCB0aGlzLmxlbmd0aCk7XG4gICAgICB0aGlzLnJvd3MgPSBudWxsO1xuICAgICAgdmFyIGJhdGNoID0ge1xuICAgICAgICBzaGFwZTogdGhpcy5vcHRpb25zLnNoYXBlLFxuICAgICAgICBiYXRjaFR5cGU6ICdkYXRhJyxcbiAgICAgICAgZGF0YTogcm93cyxcbiAgICAgICAgbGVuZ3RoOiB0aGlzLmxlbmd0aCxcbiAgICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgICAgY3Vyc29yOiB0aGlzLmN1cnNvclxuICAgICAgfTtcbiAgICAgIHJldHVybiBiYXRjaDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFJvd1RhYmxlQmF0Y2hBZ2dyZWdhdG9yO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSb3dUYWJsZUJhdGNoQWdncmVnYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2UtdGFibGUtYmF0Y2gtYWdncmVnYXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfc2xpY2VkVG9BcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXlcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgREVGQVVMVF9ST1dfQ09VTlQgPSAxMDA7XG5cbnZhciBDb2x1bW5hclRhYmxlQmF0Y2hBZ2dyZWdhdG9yID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb2x1bW5hclRhYmxlQmF0Y2hBZ2dyZWdhdG9yKHNjaGVtYSwgb3B0aW9ucykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIENvbHVtbmFyVGFibGVCYXRjaEFnZ3JlZ2F0b3IpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwic2NoZW1hXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJsZW5ndGhcIiwgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJhbGxvY2F0ZWRcIiwgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJjb2x1bW5zXCIsIHt9KTtcbiAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcblxuICAgIHRoaXMuX3JlYWxsb2NhdGVDb2x1bW5zKCk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShDb2x1bW5hclRhYmxlQmF0Y2hBZ2dyZWdhdG9yLCBbe1xuICAgIGtleTogXCJyb3dDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByb3dDb3VudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkQXJyYXlSb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQXJyYXlSb3cocm93KSB7XG4gICAgICB0aGlzLl9yZWFsbG9jYXRlQ29sdW1ucygpO1xuXG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIGZvciAodmFyIGZpZWxkTmFtZSBpbiB0aGlzLmNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy5jb2x1bW5zW2ZpZWxkTmFtZV1bdGhpcy5sZW5ndGhdID0gcm93W2krK107XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZE9iamVjdFJvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRPYmplY3RSb3cocm93KSB7XG4gICAgICB0aGlzLl9yZWFsbG9jYXRlQ29sdW1ucygpO1xuXG4gICAgICBmb3IgKHZhciBmaWVsZE5hbWUgaW4gcm93KSB7XG4gICAgICAgIHRoaXMuY29sdW1uc1tmaWVsZE5hbWVdW3RoaXMubGVuZ3RoXSA9IHJvd1tmaWVsZE5hbWVdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRCYXRjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCYXRjaCgpIHtcbiAgICAgIHRoaXMuX3BydW5lQ29sdW1ucygpO1xuXG4gICAgICB2YXIgY29sdW1ucyA9IEFycmF5LmlzQXJyYXkodGhpcy5zY2hlbWEpID8gdGhpcy5jb2x1bW5zIDoge307XG5cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLnNjaGVtYSkpIHtcbiAgICAgICAgZm9yICh2YXIgZmllbGROYW1lIGluIHRoaXMuc2NoZW1hKSB7XG4gICAgICAgICAgdmFyIGZpZWxkID0gdGhpcy5zY2hlbWFbZmllbGROYW1lXTtcbiAgICAgICAgICBjb2x1bW5zW2ZpZWxkLm5hbWVdID0gdGhpcy5jb2x1bW5zW2ZpZWxkLmluZGV4XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbHVtbnMgPSB7fTtcbiAgICAgIHZhciBiYXRjaCA9IHtcbiAgICAgICAgc2hhcGU6ICdjb2x1bW5hci10YWJsZScsXG4gICAgICAgIGJhdGNoVHlwZTogJ2RhdGEnLFxuICAgICAgICBkYXRhOiBjb2x1bW5zLFxuICAgICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgICBsZW5ndGg6IHRoaXMubGVuZ3RoXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGJhdGNoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmVhbGxvY2F0ZUNvbHVtbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlYWxsb2NhdGVDb2x1bW5zKCkge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoIDwgdGhpcy5hbGxvY2F0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFsbG9jYXRlZCA9IHRoaXMuYWxsb2NhdGVkID4gMCA/IHRoaXMuYWxsb2NhdGVkICo9IDIgOiBERUZBVUxUX1JPV19DT1VOVDtcbiAgICAgIHRoaXMuY29sdW1ucyA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBmaWVsZE5hbWUgaW4gdGhpcy5zY2hlbWEpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gdGhpcy5zY2hlbWFbZmllbGROYW1lXTtcbiAgICAgICAgdmFyIEFycmF5VHlwZSA9IGZpZWxkLnR5cGUgfHwgRmxvYXQzMkFycmF5O1xuICAgICAgICB2YXIgb2xkQ29sdW1uID0gdGhpcy5jb2x1bW5zW2ZpZWxkLmluZGV4XTtcblxuICAgICAgICBpZiAob2xkQ29sdW1uICYmIEFycmF5QnVmZmVyLmlzVmlldyhvbGRDb2x1bW4pKSB7XG4gICAgICAgICAgdmFyIHR5cGVkQXJyYXkgPSBuZXcgQXJyYXlUeXBlKHRoaXMuYWxsb2NhdGVkKTtcbiAgICAgICAgICB0eXBlZEFycmF5LnNldChvbGRDb2x1bW4pO1xuICAgICAgICAgIHRoaXMuY29sdW1uc1tmaWVsZC5pbmRleF0gPSB0eXBlZEFycmF5O1xuICAgICAgICB9IGVsc2UgaWYgKG9sZENvbHVtbikge1xuICAgICAgICAgIG9sZENvbHVtbi5sZW5ndGggPSB0aGlzLmFsbG9jYXRlZDtcbiAgICAgICAgICB0aGlzLmNvbHVtbnNbZmllbGQuaW5kZXhdID0gb2xkQ29sdW1uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY29sdW1uc1tmaWVsZC5pbmRleF0gPSBuZXcgQXJyYXlUeXBlKHRoaXMuYWxsb2NhdGVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcHJ1bmVDb2x1bW5zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wcnVuZUNvbHVtbnMoKSB7XG4gICAgICBmb3IgKHZhciBfaSA9IDAsIF9PYmplY3QkZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHRoaXMuY29sdW1ucyk7IF9pIDwgX09iamVjdCRlbnRyaWVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgX09iamVjdCRlbnRyaWVzJF9pID0gKDAsIF9zbGljZWRUb0FycmF5Mi5kZWZhdWx0KShfT2JqZWN0JGVudHJpZXNbX2ldLCAyKSxcbiAgICAgICAgICAgIF9jb2x1bW5OYW1lID0gX09iamVjdCRlbnRyaWVzJF9pWzBdLFxuICAgICAgICAgICAgY29sdW1uID0gX09iamVjdCRlbnRyaWVzJF9pWzFdO1xuXG4gICAgICAgIHRoaXMuY29sdW1uc1tfY29sdW1uTmFtZV0gPSBjb2x1bW4uc2xpY2UoMCwgdGhpcy5sZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ29sdW1uYXJUYWJsZUJhdGNoQWdncmVnYXRvcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQ29sdW1uYXJUYWJsZUJhdGNoQWdncmVnYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbHVtbmFyLXRhYmxlLWJhdGNoLWFnZ3JlZ2F0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX3Jvd1V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzL3Jvdy11dGlsc1wiKTtcblxudmFyIERFRkFVTFRfUk9XX0NPVU5UID0gMTAwO1xuXG52YXIgUm93VGFibGVCYXRjaEFnZ3JlZ2F0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJvd1RhYmxlQmF0Y2hBZ2dyZWdhdG9yKHNjaGVtYSwgb3B0aW9ucykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFJvd1RhYmxlQmF0Y2hBZ2dyZWdhdG9yKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcInNjaGVtYVwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwibGVuZ3RoXCIsIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwib2JqZWN0Um93c1wiLCBudWxsKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcImFycmF5Um93c1wiLCBudWxsKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcImN1cnNvclwiLCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcIl9oZWFkZXJzXCIsIFtdKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICAgIHRoaXMuX2hlYWRlcnMgPSBbXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNjaGVtYSkge1xuICAgICAgICB0aGlzLl9oZWFkZXJzW3NjaGVtYVtrZXldLmluZGV4XSA9IHNjaGVtYVtrZXldLm5hbWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoUm93VGFibGVCYXRjaEFnZ3JlZ2F0b3IsIFt7XG4gICAga2V5OiBcInJvd0NvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvd0NvdW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRBcnJheVJvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRBcnJheVJvdyhyb3csIGN1cnNvcikge1xuICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShjdXJzb3IpKSB7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gY3Vyc29yO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHRoaXMub3B0aW9ucy5zaGFwZSkge1xuICAgICAgICBjYXNlICdvYmplY3Qtcm93LXRhYmxlJzpcbiAgICAgICAgICB2YXIgcm93T2JqZWN0ID0gKDAsIF9yb3dVdGlscy5jb252ZXJ0VG9PYmplY3RSb3cpKHJvdywgdGhpcy5faGVhZGVycyk7XG4gICAgICAgICAgdGhpcy5hZGRPYmplY3RSb3cocm93T2JqZWN0LCBjdXJzb3IpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2FycmF5LXJvdy10YWJsZSc6XG4gICAgICAgICAgdGhpcy5hcnJheVJvd3MgPSB0aGlzLmFycmF5Um93cyB8fCBuZXcgQXJyYXkoREVGQVVMVF9ST1dfQ09VTlQpO1xuICAgICAgICAgIHRoaXMuYXJyYXlSb3dzW3RoaXMubGVuZ3RoXSA9IHJvdztcbiAgICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRPYmplY3RSb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkT2JqZWN0Um93KHJvdywgY3Vyc29yKSB7XG4gICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGN1cnNvcikpIHtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBjdXJzb3I7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAodGhpcy5vcHRpb25zLnNoYXBlKSB7XG4gICAgICAgIGNhc2UgJ2FycmF5LXJvdy10YWJsZSc6XG4gICAgICAgICAgdmFyIHJvd0FycmF5ID0gKDAsIF9yb3dVdGlscy5jb252ZXJ0VG9BcnJheVJvdykocm93LCB0aGlzLl9oZWFkZXJzKTtcbiAgICAgICAgICB0aGlzLmFkZEFycmF5Um93KHJvd0FycmF5LCBjdXJzb3IpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ29iamVjdC1yb3ctdGFibGUnOlxuICAgICAgICAgIHRoaXMub2JqZWN0Um93cyA9IHRoaXMub2JqZWN0Um93cyB8fCBuZXcgQXJyYXkoREVGQVVMVF9ST1dfQ09VTlQpO1xuICAgICAgICAgIHRoaXMub2JqZWN0Um93c1t0aGlzLmxlbmd0aF0gPSByb3c7XG4gICAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QmF0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QmF0Y2goKSB7XG4gICAgICB2YXIgcm93cyA9IHRoaXMuYXJyYXlSb3dzIHx8IHRoaXMub2JqZWN0Um93cztcblxuICAgICAgaWYgKCFyb3dzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByb3dzID0gcm93cy5zbGljZSgwLCB0aGlzLmxlbmd0aCk7XG4gICAgICB0aGlzLmFycmF5Um93cyA9IG51bGw7XG4gICAgICB0aGlzLm9iamVjdFJvd3MgPSBudWxsO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2hhcGU6IHRoaXMub3B0aW9ucy5zaGFwZSxcbiAgICAgICAgYmF0Y2hUeXBlOiAnZGF0YScsXG4gICAgICAgIGRhdGE6IHJvd3MsXG4gICAgICAgIGxlbmd0aDogdGhpcy5sZW5ndGgsXG4gICAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWEsXG4gICAgICAgIGN1cnNvcjogdGhpcy5jdXJzb3JcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBSb3dUYWJsZUJhdGNoQWdncmVnYXRvcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUm93VGFibGVCYXRjaEFnZ3JlZ2F0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3ctdGFibGUtYmF0Y2gtYWdncmVnYXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfYmFzZVRhYmxlQmF0Y2hBZ2dyZWdhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9iYXNlLXRhYmxlLWJhdGNoLWFnZ3JlZ2F0b3JcIikpO1xuXG52YXIgX3Jvd1RhYmxlQmF0Y2hBZ2dyZWdhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9yb3ctdGFibGUtYmF0Y2gtYWdncmVnYXRvclwiKSk7XG5cbnZhciBfY29sdW1uYXJUYWJsZUJhdGNoQWdncmVnYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29sdW1uYXItdGFibGUtYmF0Y2gtYWdncmVnYXRvclwiKSk7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICBzaGFwZTogJ2FycmF5LXJvdy10YWJsZScsXG4gIGJhdGNoU2l6ZTogJ2F1dG8nLFxuICBiYXRjaERlYm91bmNlTXM6IDAsXG4gIGxpbWl0OiAwLFxuICBfbGltaXRNQjogMFxufTtcbnZhciBFUlJfTUVTU0FHRSA9ICdUYWJsZUJhdGNoQnVpbGRlcic7XG5cbnZhciBUYWJsZUJhdGNoQnVpbGRlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGFibGVCYXRjaEJ1aWxkZXIoc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgVGFibGVCYXRjaEJ1aWxkZXIpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwic2NoZW1hXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJvcHRpb25zXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJhZ2dyZWdhdG9yXCIsIG51bGwpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiYmF0Y2hDb3VudFwiLCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcImJ5dGVzVXNlZFwiLCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcImlzQ2h1bmtDb21wbGV0ZVwiLCBmYWxzZSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJsYXN0QmF0Y2hFbWl0dGVkTXNcIiwgRGF0ZS5ub3coKSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJ0b3RhbExlbmd0aFwiLCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcInRvdGFsQnl0ZXNcIiwgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJyb3dCeXRlc1wiLCAwKTtcbiAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICB0aGlzLm9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIERFRkFVTFRfT1BUSU9OUyksIG9wdGlvbnMpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoVGFibGVCYXRjaEJ1aWxkZXIsIFt7XG4gICAga2V5OiBcImxpbWl0UmVhY2hlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaW1pdFJlYWNoZWQoKSB7XG4gICAgICB2YXIgX3RoaXMkb3B0aW9ucywgX3RoaXMkb3B0aW9uczI7XG5cbiAgICAgIGlmIChCb29sZWFuKChfdGhpcyRvcHRpb25zID0gdGhpcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfdGhpcyRvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zLmxpbWl0KSAmJiB0aGlzLnRvdGFsTGVuZ3RoID49IHRoaXMub3B0aW9ucy5saW1pdCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKEJvb2xlYW4oKF90aGlzJG9wdGlvbnMyID0gdGhpcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfdGhpcyRvcHRpb25zMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkb3B0aW9uczIuX2xpbWl0TUIpICYmIHRoaXMudG90YWxCeXRlcyAvIDFlNiA+PSB0aGlzLm9wdGlvbnMuX2xpbWl0TUIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkUm93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFJvdyhyb3cpIHtcbiAgICAgIGlmICh0aGlzLmxpbWl0UmVhY2hlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy50b3RhbExlbmd0aCsrO1xuICAgICAgdGhpcy5yb3dCeXRlcyA9IHRoaXMucm93Qnl0ZXMgfHwgdGhpcy5fZXN0aW1hdGVSb3dNQihyb3cpO1xuICAgICAgdGhpcy50b3RhbEJ5dGVzICs9IHRoaXMucm93Qnl0ZXM7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJvdykpIHtcbiAgICAgICAgdGhpcy5hZGRBcnJheVJvdyhyb3cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hZGRPYmplY3RSb3cocm93KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkQXJyYXlSb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQXJyYXlSb3cocm93KSB7XG4gICAgICBpZiAoIXRoaXMuYWdncmVnYXRvcikge1xuICAgICAgICB2YXIgVGFibGVCYXRjaFR5cGUgPSB0aGlzLl9nZXRUYWJsZUJhdGNoVHlwZSgpO1xuXG4gICAgICAgIHRoaXMuYWdncmVnYXRvciA9IG5ldyBUYWJsZUJhdGNoVHlwZSh0aGlzLnNjaGVtYSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hZ2dyZWdhdG9yLmFkZEFycmF5Um93KHJvdyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZE9iamVjdFJvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRPYmplY3RSb3cocm93KSB7XG4gICAgICBpZiAoIXRoaXMuYWdncmVnYXRvcikge1xuICAgICAgICB2YXIgVGFibGVCYXRjaFR5cGUgPSB0aGlzLl9nZXRUYWJsZUJhdGNoVHlwZSgpO1xuXG4gICAgICAgIHRoaXMuYWdncmVnYXRvciA9IG5ldyBUYWJsZUJhdGNoVHlwZSh0aGlzLnNjaGVtYSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hZ2dyZWdhdG9yLmFkZE9iamVjdFJvdyhyb3cpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjaHVua0NvbXBsZXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNodW5rQ29tcGxldGUoY2h1bmspIHtcbiAgICAgIGlmIChjaHVuayBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHRoaXMuYnl0ZXNVc2VkICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuYnl0ZXNVc2VkICs9IGNodW5rLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pc0NodW5rQ29tcGxldGUgPSB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRGdWxsQmF0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RnVsbEJhdGNoKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc0Z1bGwoKSA/IHRoaXMuX2dldEJhdGNoKG9wdGlvbnMpIDogbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RmluYWxCYXRjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGaW5hbEJhdGNoKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRCYXRjaChvcHRpb25zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2VzdGltYXRlUm93TUJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VzdGltYXRlUm93TUIocm93KSB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShyb3cpID8gcm93Lmxlbmd0aCAqIDggOiBPYmplY3Qua2V5cyhyb3cpLmxlbmd0aCAqIDg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9pc0Z1bGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzRnVsbCgpIHtcbiAgICAgIGlmICghdGhpcy5hZ2dyZWdhdG9yIHx8IHRoaXMuYWdncmVnYXRvci5yb3dDb3VudCgpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYXRjaFNpemUgPT09ICdhdXRvJykge1xuICAgICAgICBpZiAoIXRoaXMuaXNDaHVua0NvbXBsZXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5iYXRjaFNpemUgPiB0aGlzLmFnZ3JlZ2F0b3Iucm93Q291bnQoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmF0Y2hEZWJvdW5jZU1zID4gRGF0ZS5ub3coKSAtIHRoaXMubGFzdEJhdGNoRW1pdHRlZE1zKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pc0NodW5rQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgIHRoaXMubGFzdEJhdGNoRW1pdHRlZE1zID0gRGF0ZS5ub3coKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0QmF0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEJhdGNoKG9wdGlvbnMpIHtcbiAgICAgIGlmICghdGhpcy5hZ2dyZWdhdG9yKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgJiYgb3B0aW9ucy5ieXRlc1VzZWQpIHtcbiAgICAgICAgdGhpcy5ieXRlc1VzZWQgPSBvcHRpb25zLmJ5dGVzVXNlZDtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vcm1hbGl6ZWRCYXRjaCA9IHRoaXMuYWdncmVnYXRvci5nZXRCYXRjaCgpO1xuICAgICAgbm9ybWFsaXplZEJhdGNoLmNvdW50ID0gdGhpcy5iYXRjaENvdW50O1xuICAgICAgbm9ybWFsaXplZEJhdGNoLmJ5dGVzVXNlZCA9IHRoaXMuYnl0ZXNVc2VkO1xuICAgICAgT2JqZWN0LmFzc2lnbihub3JtYWxpemVkQmF0Y2gsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5iYXRjaENvdW50Kys7XG4gICAgICB0aGlzLmFnZ3JlZ2F0b3IgPSBudWxsO1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRCYXRjaDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFRhYmxlQmF0Y2hUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRUYWJsZUJhdGNoVHlwZSgpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5vcHRpb25zLnNoYXBlKSB7XG4gICAgICAgIGNhc2UgJ3Jvdy10YWJsZSc6XG4gICAgICAgICAgcmV0dXJuIF9iYXNlVGFibGVCYXRjaEFnZ3JlZ2F0b3IuZGVmYXVsdDtcblxuICAgICAgICBjYXNlICdhcnJheS1yb3ctdGFibGUnOlxuICAgICAgICBjYXNlICdvYmplY3Qtcm93LXRhYmxlJzpcbiAgICAgICAgICByZXR1cm4gX3Jvd1RhYmxlQmF0Y2hBZ2dyZWdhdG9yLmRlZmF1bHQ7XG5cbiAgICAgICAgY2FzZSAnY29sdW1uYXItdGFibGUnOlxuICAgICAgICAgIHJldHVybiBfY29sdW1uYXJUYWJsZUJhdGNoQWdncmVnYXRvci5kZWZhdWx0O1xuXG4gICAgICAgIGNhc2UgJ2Fycm93LXRhYmxlJzpcbiAgICAgICAgICBpZiAoIVRhYmxlQmF0Y2hCdWlsZGVyLkFycm93QmF0Y2gpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJfTUVTU0FHRSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIFRhYmxlQmF0Y2hCdWlsZGVyLkFycm93QmF0Y2g7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJSX01FU1NBR0UpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVGFibGVCYXRjaEJ1aWxkZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFRhYmxlQmF0Y2hCdWlsZGVyO1xuKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkoVGFibGVCYXRjaEJ1aWxkZXIsIFwiQXJyb3dCYXRjaFwiLCB2b2lkIDApO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFibGUtYmF0Y2gtYnVpbGRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnRha2VBc3luYyA9IHRha2VBc3luYztcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfaW5oZXJpdHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c1wiKSk7XG5cbnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIikpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2ZcIikpO1xuXG52YXIgX3dyYXBOYXRpdmVTdXBlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3dyYXBOYXRpdmVTdXBlclwiKSk7XG5cbnZhciBfU3ltYm9sJGFzeW5jSXRlcmF0b3I7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMi5kZWZhdWx0KSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgQXJyYXlRdWV1ZSA9IGZ1bmN0aW9uIChfQXJyYXkpIHtcbiAgKDAsIF9pbmhlcml0czIuZGVmYXVsdCkoQXJyYXlRdWV1ZSwgX0FycmF5KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEFycmF5UXVldWUpO1xuXG4gIGZ1bmN0aW9uIEFycmF5UXVldWUoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgQXJyYXlRdWV1ZSk7XG4gICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoQXJyYXlRdWV1ZSwgW3tcbiAgICBrZXk6IFwiZW5xdWV1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbnF1ZXVlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVxdWV1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXF1ZXVlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2hpZnQoKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEFycmF5UXVldWU7XG59KCgwLCBfd3JhcE5hdGl2ZVN1cGVyMi5kZWZhdWx0KShBcnJheSkpO1xuXG5fU3ltYm9sJGFzeW5jSXRlcmF0b3IgPSBTeW1ib2wuYXN5bmNJdGVyYXRvcjtcblxudmFyIEFzeW5jUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFzeW5jUXVldWUoKSB7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgQXN5bmNRdWV1ZSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJfdmFsdWVzXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJfc2V0dGxlcnNcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcIl9jbG9zZWRcIiwgdm9pZCAwKTtcbiAgICB0aGlzLl92YWx1ZXMgPSBuZXcgQXJyYXlRdWV1ZSgpO1xuICAgIHRoaXMuX3NldHRsZXJzID0gbmV3IEFycmF5UXVldWUoKTtcbiAgICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEFzeW5jUXVldWUsIFt7XG4gICAga2V5OiBcImNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgd2hpbGUgKHRoaXMuX3NldHRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5fc2V0dGxlcnMuZGVxdWV1ZSgpLnJlc29sdmUoe1xuICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBfU3ltYm9sJGFzeW5jSXRlcmF0b3IsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVucXVldWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5xdWV1ZSh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nsb3NlZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fc2V0dGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAodGhpcy5fdmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaW50ZXJuYWwgc3RhdGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZXR0bGVyID0gdGhpcy5fc2V0dGxlcnMuZGVxdWV1ZSgpO1xuXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgc2V0dGxlci5yZWplY3QodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldHRsZXIucmVzb2x2ZSh7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fdmFsdWVzLmVucXVldWUodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJuZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5fdmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fdmFsdWVzLmRlcXVldWUoKTtcblxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NldHRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaW50ZXJuYWwgc3RhdGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIF90aGlzLl9zZXR0bGVycy5lbnF1ZXVlKHtcbiAgICAgICAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgICAgICAgIHJlamVjdDogcmVqZWN0XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBBc3luY1F1ZXVlO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBBc3luY1F1ZXVlO1xuXG5mdW5jdGlvbiB0YWtlQXN5bmMoX3gpIHtcbiAgcmV0dXJuIF90YWtlQXN5bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3Rha2VBc3luYygpIHtcbiAgX3Rha2VBc3luYyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKGFzeW5jSXRlcmFibGUpIHtcbiAgICB2YXIgY291bnQsXG4gICAgICAgIHJlc3VsdCxcbiAgICAgICAgaXRlcmF0b3IsXG4gICAgICAgIF95aWVsZCRpdGVyYXRvciRuZXh0LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZG9uZSxcbiAgICAgICAgX2FyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNvdW50ID0gX2FyZ3MubGVuZ3RoID4gMSAmJiBfYXJnc1sxXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3NbMV0gOiBJbmZpbml0eTtcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgaXRlcmF0b3IgPSBhc3luY0l0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgaWYgKCEocmVzdWx0Lmxlbmd0aCA8IGNvdW50KSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvci5uZXh0KCk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBfeWllbGQkaXRlcmF0b3IkbmV4dCA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICB2YWx1ZSA9IF95aWVsZCRpdGVyYXRvciRuZXh0LnZhbHVlO1xuICAgICAgICAgICAgZG9uZSA9IF95aWVsZCRpdGVyYXRvciRuZXh0LmRvbmU7XG5cbiAgICAgICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwiYnJlYWtcIiwgMTQpO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCByZXN1bHQpO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSk7XG4gIH0pKTtcbiAgcmV0dXJuIF90YWtlQXN5bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzeW5jLXF1ZXVlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jb252ZXJ0VG9PYmplY3RSb3cgPSBjb252ZXJ0VG9PYmplY3RSb3c7XG5leHBvcnRzLmNvbnZlcnRUb0FycmF5Um93ID0gY29udmVydFRvQXJyYXlSb3c7XG5cbmZ1bmN0aW9uIGNvbnZlcnRUb09iamVjdFJvdyhhcnJheVJvdywgaGVhZGVycykge1xuICBpZiAoIWFycmF5Um93KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdudWxsIHJvdycpO1xuICB9XG5cbiAgaWYgKCFoZWFkZXJzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdubyBoZWFkZXJzJyk7XG4gIH1cblxuICB2YXIgb2JqZWN0Um93ID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgb2JqZWN0Um93W2hlYWRlcnNbaV1dID0gYXJyYXlSb3dbaV07XG4gIH1cblxuICByZXR1cm4gb2JqZWN0Um93O1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VG9BcnJheVJvdyhvYmplY3RSb3csIGhlYWRlcnMpIHtcbiAgaWYgKCFvYmplY3RSb3cpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ251bGwgcm93Jyk7XG4gIH1cblxuICBpZiAoIWhlYWRlcnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGhlYWRlcnMnKTtcbiAgfVxuXG4gIHZhciBhcnJheVJvdyA9IG5ldyBBcnJheShoZWFkZXJzLmxlbmd0aCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJyYXlSb3dbaV0gPSBvYmplY3RSb3dbaGVhZGVyc1tpXV07XG4gIH1cblxuICByZXR1cm4gYXJyYXlSb3c7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3ctdXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXNzZXJ0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hc3NlcnQuYXNzZXJ0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzQnJvd3NlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2xvYmFscy5pc0Jyb3dzZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNXb3JrZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dsb2JhbHMuaXNXb3JrZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29ya2VySm9iXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF93b3JrZXJKb2IuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXb3JrZXJUaHJlYWRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3dvcmtlclRocmVhZC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldvcmtlckZhcm1cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3dvcmtlckZhcm0uZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXb3JrZXJQb29sXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF93b3JrZXJQb29sLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29ya2VyQm9keVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfd29ya2VyQm9keS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInByb2Nlc3NPbldvcmtlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfcHJvY2Vzc09uV29ya2VyLnByb2Nlc3NPbldvcmtlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjYW5Qcm9jZXNzT25Xb3JrZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3Byb2Nlc3NPbldvcmtlci5jYW5Qcm9jZXNzT25Xb3JrZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlV29ya2VyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVXb3JrZXIuY3JlYXRlV29ya2VyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFdvcmtlclVSTFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2V0V29ya2VyVXJsLmdldFdvcmtlclVSTDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2YWxpZGF0ZVdvcmtlclZlcnNpb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3ZhbGlkYXRlV29ya2VyVmVyc2lvbi52YWxpZGF0ZVdvcmtlclZlcnNpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0VHJhbnNmZXJMaXN0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nZXRUcmFuc2Zlckxpc3QuZ2V0VHJhbnNmZXJMaXN0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldExpYnJhcnlVcmxcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2xpYnJhcnlVdGlscy5nZXRMaWJyYXJ5VXJsO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxvYWRMaWJyYXJ5XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9saWJyYXJ5VXRpbHMubG9hZExpYnJhcnk7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXN5bmNRdWV1ZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYXN5bmNRdWV1ZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNoaWxkUHJvY2Vzc1Byb3h5XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9jaGlsZFByb2Nlc3NQcm94eS5kZWZhdWx0O1xuICB9XG59KTtcbmV4cG9ydHMuTnVsbFdvcmtlciA9IHZvaWQgMDtcblxudmFyIF92ZXJzaW9uID0gcmVxdWlyZShcIi4vbGliL2Vudi11dGlscy92ZXJzaW9uXCIpO1xuXG52YXIgX2Fzc2VydCA9IHJlcXVpcmUoXCIuL2xpYi9lbnYtdXRpbHMvYXNzZXJ0XCIpO1xuXG52YXIgX2dsb2JhbHMgPSByZXF1aXJlKFwiLi9saWIvZW52LXV0aWxzL2dsb2JhbHNcIik7XG5cbnZhciBfd29ya2VySm9iID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvd29ya2VyLWZhcm0vd29ya2VyLWpvYlwiKSk7XG5cbnZhciBfd29ya2VyVGhyZWFkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvd29ya2VyLWZhcm0vd29ya2VyLXRocmVhZFwiKSk7XG5cbnZhciBfd29ya2VyRmFybSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL3dvcmtlci1mYXJtL3dvcmtlci1mYXJtXCIpKTtcblxudmFyIF93b3JrZXJQb29sID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvd29ya2VyLWZhcm0vd29ya2VyLXBvb2xcIikpO1xuXG52YXIgX3dvcmtlckJvZHkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpYi93b3JrZXItZmFybS93b3JrZXItYm9keVwiKSk7XG5cbnZhciBfcHJvY2Vzc09uV29ya2VyID0gcmVxdWlyZShcIi4vbGliL3dvcmtlci1hcGkvcHJvY2Vzcy1vbi13b3JrZXJcIik7XG5cbnZhciBfY3JlYXRlV29ya2VyID0gcmVxdWlyZShcIi4vbGliL3dvcmtlci1hcGkvY3JlYXRlLXdvcmtlclwiKTtcblxudmFyIF9nZXRXb3JrZXJVcmwgPSByZXF1aXJlKFwiLi9saWIvd29ya2VyLWFwaS9nZXQtd29ya2VyLXVybFwiKTtcblxudmFyIF92YWxpZGF0ZVdvcmtlclZlcnNpb24gPSByZXF1aXJlKFwiLi9saWIvd29ya2VyLWFwaS92YWxpZGF0ZS13b3JrZXItdmVyc2lvblwiKTtcblxudmFyIF9nZXRUcmFuc2Zlckxpc3QgPSByZXF1aXJlKFwiLi9saWIvd29ya2VyLXV0aWxzL2dldC10cmFuc2Zlci1saXN0XCIpO1xuXG52YXIgX2xpYnJhcnlVdGlscyA9IHJlcXVpcmUoXCIuL2xpYi9saWJyYXJ5LXV0aWxzL2xpYnJhcnktdXRpbHNcIik7XG5cbnZhciBfYXN5bmNRdWV1ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL2FzeW5jLXF1ZXVlL2FzeW5jLXF1ZXVlXCIpKTtcblxudmFyIF9jaGlsZFByb2Nlc3NQcm94eSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL3Byb2Nlc3MtdXRpbHMvY2hpbGQtcHJvY2Vzcy1wcm94eVwiKSk7XG5cbnZhciBOdWxsV29ya2VyID0ge1xuICBpZDogJ251bGwnLFxuICBuYW1lOiAnbnVsbCcsXG4gIG1vZHVsZTogJ3dvcmtlci11dGlscycsXG4gIHZlcnNpb246IF92ZXJzaW9uLlZFUlNJT04sXG4gIG9wdGlvbnM6IHtcbiAgICBudWxsOiB7fVxuICB9XG59O1xuZXhwb3J0cy5OdWxsV29ya2VyID0gTnVsbFdvcmtlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9TeW1ib2wkYXN5bmNJdGVyYXRvcjtcblxuX1N5bWJvbCRhc3luY0l0ZXJhdG9yID0gU3ltYm9sLmFzeW5jSXRlcmF0b3I7XG5cbnZhciBBc3luY1F1ZXVlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBc3luY1F1ZXVlKCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIEFzeW5jUXVldWUpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiX3ZhbHVlc1wiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiX3NldHRsZXJzXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJfY2xvc2VkXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5fdmFsdWVzID0gW107XG4gICAgdGhpcy5fc2V0dGxlcnMgPSBbXTtcbiAgICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKEFzeW5jUXVldWUsIFt7XG4gICAga2V5OiBfU3ltYm9sJGFzeW5jSXRlcmF0b3IsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInB1c2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVucXVldWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5xdWV1ZSh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nsb3NlZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fc2V0dGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAodGhpcy5fdmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaW50ZXJuYWwgc3RhdGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZXR0bGVyID0gdGhpcy5fc2V0dGxlcnMuc2hpZnQoKTtcblxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHNldHRsZXIucmVqZWN0KHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXR0bGVyLnJlc29sdmUoe1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICB3aGlsZSAodGhpcy5fc2V0dGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgc2V0dGxlciA9IHRoaXMuX3NldHRsZXJzLnNoaWZ0KCk7XG5cbiAgICAgICAgc2V0dGxlci5yZXNvbHZlKHtcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJuZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5fdmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fdmFsdWVzLnNoaWZ0KCk7XG5cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgIGlmICh0aGlzLl9zZXR0bGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGludGVybmFsIHN0YXRlJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIF90aGlzLl9zZXR0bGVycy5wdXNoKHtcbiAgICAgICAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgICAgICAgIHJlamVjdDogcmVqZWN0XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBBc3luY1F1ZXVlO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBBc3luY1F1ZXVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXN5bmMtcXVldWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcblxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdsb2FkZXJzLmdsIGFzc2VydGlvbiBmYWlsZWQuJyk7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc2VydC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm5vZGVWZXJzaW9uID0gZXhwb3J0cy5pc01vYmlsZSA9IGV4cG9ydHMuaXNXb3JrZXIgPSBleHBvcnRzLmlzQnJvd3NlciA9IGV4cG9ydHMuZG9jdW1lbnQgPSBleHBvcnRzLmdsb2JhbCA9IGV4cG9ydHMud2luZG93ID0gZXhwb3J0cy5zZWxmID0gdm9pZCAwO1xuXG52YXIgX3R5cGVvZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKSk7XG5cbnZhciBnbG9iYWxzID0ge1xuICBzZWxmOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZixcbiAgd2luZG93OiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3csXG4gIGdsb2JhbDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLFxuICBkb2N1bWVudDogdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudFxufTtcbnZhciBzZWxmXyA9IGdsb2JhbHMuc2VsZiB8fCBnbG9iYWxzLndpbmRvdyB8fCBnbG9iYWxzLmdsb2JhbCB8fCB7fTtcbmV4cG9ydHMuc2VsZiA9IHNlbGZfO1xudmFyIHdpbmRvd18gPSBnbG9iYWxzLndpbmRvdyB8fCBnbG9iYWxzLnNlbGYgfHwgZ2xvYmFscy5nbG9iYWwgfHwge307XG5leHBvcnRzLndpbmRvdyA9IHdpbmRvd187XG52YXIgZ2xvYmFsXyA9IGdsb2JhbHMuZ2xvYmFsIHx8IGdsb2JhbHMuc2VsZiB8fCBnbG9iYWxzLndpbmRvdyB8fCB7fTtcbmV4cG9ydHMuZ2xvYmFsID0gZ2xvYmFsXztcbnZhciBkb2N1bWVudF8gPSBnbG9iYWxzLmRvY3VtZW50IHx8IHt9O1xuZXhwb3J0cy5kb2N1bWVudCA9IGRvY3VtZW50XztcbnZhciBpc0Jyb3dzZXIgPSAodHlwZW9mIHByb2Nlc3MgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogKDAsIF90eXBlb2YyLmRlZmF1bHQpKHByb2Nlc3MpKSAhPT0gJ29iamVjdCcgfHwgU3RyaW5nKHByb2Nlc3MpICE9PSAnW29iamVjdCBwcm9jZXNzXScgfHwgcHJvY2Vzcy5icm93c2VyO1xuZXhwb3J0cy5pc0Jyb3dzZXIgPSBpc0Jyb3dzZXI7XG52YXIgaXNXb3JrZXIgPSB0eXBlb2YgaW1wb3J0U2NyaXB0cyA9PT0gJ2Z1bmN0aW9uJztcbmV4cG9ydHMuaXNXb3JrZXIgPSBpc1dvcmtlcjtcbnZhciBpc01vYmlsZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cub3JpZW50YXRpb24gIT09ICd1bmRlZmluZWQnO1xuZXhwb3J0cy5pc01vYmlsZSA9IGlzTW9iaWxlO1xudmFyIG1hdGNoZXMgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy52ZXJzaW9uICYmIC92KFswLTldKikvLmV4ZWMocHJvY2Vzcy52ZXJzaW9uKTtcbnZhciBub2RlVmVyc2lvbiA9IG1hdGNoZXMgJiYgcGFyc2VGbG9hdChtYXRjaGVzWzFdKSB8fCAwO1xuZXhwb3J0cy5ub2RlVmVyc2lvbiA9IG5vZGVWZXJzaW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2xvYmFscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuVkVSU0lPTiA9IHZvaWQgMDtcbnZhciBERUZBVUxUX1ZFUlNJT04gPSAnYmV0YSc7XG52YXIgVkVSU0lPTiA9IHR5cGVvZiBcIjMuMC45XCIgIT09ICd1bmRlZmluZWQnID8gXCIzLjAuOVwiIDogREVGQVVMVF9WRVJTSU9OO1xuZXhwb3J0cy5WRVJTSU9OID0gVkVSU0lPTjtcblxuaWYgKHR5cGVvZiBcIjMuMC45XCIgPT09ICd1bmRlZmluZWQnKSB7XG4gIGNvbnNvbGUuZXJyb3IoJ2xvYWRlcnMuZ2w6IFRoZSBfX1ZFUlNJT05fXyB2YXJpYWJsZSBpcyBub3QgaW5qZWN0ZWQgdXNpbmcgYmFiZWwgcGx1Z2luLiBMYXRlc3QgdW5zdGFibGUgd29ya2VycyB3b3VsZCBiZSBmZXRjaGVkIGZyb20gdGhlIENETi4nKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG52YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubG9hZExpYnJhcnkgPSBsb2FkTGlicmFyeTtcbmV4cG9ydHMuZ2V0TGlicmFyeVVybCA9IGdldExpYnJhcnlVcmw7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2dsb2JhbHMgPSByZXF1aXJlKFwiLi4vZW52LXV0aWxzL2dsb2JhbHNcIik7XG5cbnZhciBub2RlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4uL25vZGUvcmVxdWlyZS11dGlscy5ub2RlXCIpKTtcblxudmFyIF9hc3NlcnQgPSByZXF1aXJlKFwiLi4vZW52LXV0aWxzL2Fzc2VydFwiKTtcblxudmFyIF92ZXJzaW9uID0gcmVxdWlyZShcIi4uL2Vudi11dGlscy92ZXJzaW9uXCIpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpOyB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDsgfSkobm9kZUludGVyb3ApOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHsgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoa2V5ICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbnZhciBMQVRFU1QgPSAnYmV0YSc7XG52YXIgVkVSU0lPTiA9IHR5cGVvZiBcIjMuMC45XCIgIT09ICd1bmRlZmluZWQnID8gXCIzLjAuOVwiIDogTEFURVNUO1xudmFyIGxvYWRMaWJyYXJ5UHJvbWlzZXMgPSB7fTtcblxuZnVuY3Rpb24gbG9hZExpYnJhcnkoX3gpIHtcbiAgcmV0dXJuIF9sb2FkTGlicmFyeS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfbG9hZExpYnJhcnkoKSB7XG4gIF9sb2FkTGlicmFyeSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKGxpYnJhcnlVcmwpIHtcbiAgICB2YXIgbW9kdWxlTmFtZSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgX2FyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBtb2R1bGVOYW1lID0gX2FyZ3MubGVuZ3RoID4gMSAmJiBfYXJnc1sxXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3NbMV0gOiBudWxsO1xuICAgICAgICAgICAgb3B0aW9ucyA9IF9hcmdzLmxlbmd0aCA+IDIgJiYgX2FyZ3NbMl0gIT09IHVuZGVmaW5lZCA/IF9hcmdzWzJdIDoge307XG5cbiAgICAgICAgICAgIGlmIChtb2R1bGVOYW1lKSB7XG4gICAgICAgICAgICAgIGxpYnJhcnlVcmwgPSBnZXRMaWJyYXJ5VXJsKGxpYnJhcnlVcmwsIG1vZHVsZU5hbWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsb2FkTGlicmFyeVByb21pc2VzW2xpYnJhcnlVcmxdID0gbG9hZExpYnJhcnlQcm9taXNlc1tsaWJyYXJ5VXJsXSB8fCBsb2FkTGlicmFyeUZyb21GaWxlKGxpYnJhcnlVcmwpO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XG4gICAgICAgICAgICByZXR1cm4gbG9hZExpYnJhcnlQcm9taXNlc1tsaWJyYXJ5VXJsXTtcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUpO1xuICB9KSk7XG4gIHJldHVybiBfbG9hZExpYnJhcnkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0TGlicmFyeVVybChsaWJyYXJ5LCBtb2R1bGVOYW1lLCBvcHRpb25zKSB7XG4gIGlmIChsaWJyYXJ5LnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xuICAgIHJldHVybiBsaWJyYXJ5O1xuICB9XG5cbiAgdmFyIG1vZHVsZXMgPSBvcHRpb25zLm1vZHVsZXMgfHwge307XG5cbiAgaWYgKG1vZHVsZXNbbGlicmFyeV0pIHtcbiAgICByZXR1cm4gbW9kdWxlc1tsaWJyYXJ5XTtcbiAgfVxuXG4gIGlmICghX2dsb2JhbHMuaXNCcm93c2VyKSB7XG4gICAgcmV0dXJuIFwibW9kdWxlcy9cIi5jb25jYXQobW9kdWxlTmFtZSwgXCIvZGlzdC9saWJzL1wiKS5jb25jYXQobGlicmFyeSk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5DRE4pIHtcbiAgICAoMCwgX2Fzc2VydC5hc3NlcnQpKG9wdGlvbnMuQ0ROLnN0YXJ0c1dpdGgoJ2h0dHAnKSk7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KG9wdGlvbnMuQ0ROLCBcIi9cIikuY29uY2F0KG1vZHVsZU5hbWUsIFwiQFwiKS5jb25jYXQoVkVSU0lPTiwgXCIvZGlzdC9saWJzL1wiKS5jb25jYXQobGlicmFyeSk7XG4gIH1cblxuICBpZiAoX2dsb2JhbHMuaXNXb3JrZXIpIHtcbiAgICByZXR1cm4gXCIuLi9zcmMvbGlicy9cIi5jb25jYXQobGlicmFyeSk7XG4gIH1cblxuICByZXR1cm4gXCJtb2R1bGVzL1wiLmNvbmNhdChtb2R1bGVOYW1lLCBcIi9zcmMvbGlicy9cIikuY29uY2F0KGxpYnJhcnkpO1xufVxuXG5mdW5jdGlvbiBsb2FkTGlicmFyeUZyb21GaWxlKF94Mikge1xuICByZXR1cm4gX2xvYWRMaWJyYXJ5RnJvbUZpbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2xvYWRMaWJyYXJ5RnJvbUZpbGUoKSB7XG4gIF9sb2FkTGlicmFyeUZyb21GaWxlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGxpYnJhcnlVcmwpIHtcbiAgICB2YXIgX3Jlc3BvbnNlLCByZXNwb25zZSwgc2NyaXB0U291cmNlO1xuXG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvci5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCFsaWJyYXJ5VXJsLmVuZHNXaXRoKCd3YXNtJykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoKGxpYnJhcnlVcmwpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgX3Jlc3BvbnNlID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDY7XG4gICAgICAgICAgICByZXR1cm4gX3Jlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDIuc2VudCk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBpZiAoX2dsb2JhbHMuaXNCcm93c2VyKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dDIudDAgPSBub2RlLnJlcXVpcmVGcm9tRmlsZTtcblxuICAgICAgICAgICAgaWYgKCFfY29udGV4dDIudDApIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTI7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5yZXF1aXJlRnJvbUZpbGUobGlicmFyeVVybCk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gX2NvbnRleHQyLnNlbnQ7XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQyLnQwKTtcblxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICBpZiAoIV9nbG9iYWxzLmlzV29ya2VyKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBpbXBvcnRTY3JpcHRzKGxpYnJhcnlVcmwpKTtcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE4O1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoKGxpYnJhcnlVcmwpO1xuXG4gICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgIHJlc3BvbnNlID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDIxO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcblxuICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICBzY3JpcHRTb3VyY2UgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIGxvYWRMaWJyYXJ5RnJvbVN0cmluZyhzY3JpcHRTb3VyY2UsIGxpYnJhcnlVcmwpKTtcblxuICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMik7XG4gIH0pKTtcbiAgcmV0dXJuIF9sb2FkTGlicmFyeUZyb21GaWxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGxvYWRMaWJyYXJ5RnJvbVN0cmluZyhzY3JpcHRTb3VyY2UsIGlkKSB7XG4gIGlmICghX2dsb2JhbHMuaXNCcm93c2VyKSB7XG4gICAgcmV0dXJuIG5vZGUucmVxdWlyZUZyb21TdHJpbmcgJiYgbm9kZS5yZXF1aXJlRnJvbVN0cmluZyhzY3JpcHRTb3VyY2UsIGlkKTtcbiAgfVxuXG4gIGlmIChfZ2xvYmFscy5pc1dvcmtlcikge1xuICAgIGV2YWwuY2FsbChfZ2xvYmFscy5nbG9iYWwsIHNjcmlwdFNvdXJjZSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gIHNjcmlwdC5pZCA9IGlkO1xuXG4gIHRyeSB7XG4gICAgc2NyaXB0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHNjcmlwdFNvdXJjZSkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgc2NyaXB0LnRleHQgPSBzY3JpcHRTb3VyY2U7XG4gIH1cblxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gIHJldHVybiBudWxsO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGlicmFyeS11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNyZWF0ZVdvcmtlciA9IGNyZWF0ZVdvcmtlcjtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNJdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jSXRlcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jUXVldWUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9hc3luYy1xdWV1ZS9hc3luYy1xdWV1ZVwiKSk7XG5cbnZhciBfd29ya2VyQm9keSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3dvcmtlci1mYXJtL3dvcmtlci1ib2R5XCIpKTtcblxudmFyIHJlcXVlc3RJZCA9IDA7XG52YXIgaW5wdXRCYXRjaGVzO1xudmFyIG9wdGlvbnM7XG5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtlcihwcm9jZXNzLCBwcm9jZXNzSW5CYXRjaGVzKSB7XG4gIGlmICh0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY29udGV4dCA9IHtcbiAgICBwcm9jZXNzOiBwcm9jZXNzT25NYWluVGhyZWFkXG4gIH07XG5cbiAgX3dvcmtlckJvZHkuZGVmYXVsdC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyLmRlZmF1bHQpKF9yZWdlbmVyYXRvci5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZSh0eXBlLCBwYXlsb2FkKSB7XG4gICAgICB2YXIgcmVzdWx0LCByZXN1bHRJdGVyYXRvciwgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiwgX2RpZEl0ZXJhdG9yRXJyb3IsIF9pdGVyYXRvckVycm9yLCBfaXRlcmF0b3IsIF9zdGVwLCBfdmFsdWUsIGJhdGNoLCBtZXNzYWdlO1xuXG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDA7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gdHlwZTtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IF9jb250ZXh0LnQwID09PSAncHJvY2VzcycgPyA0IDogX2NvbnRleHQudDAgPT09ICdwcm9jZXNzLWluLWJhdGNoZXMnID8gMTEgOiBfY29udGV4dC50MCA9PT0gJ2lucHV0LWJhdGNoJyA/IDUxIDogX2NvbnRleHQudDAgPT09ICdpbnB1dC1kb25lJyA/IDUzIDogNTU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGlmIChwcm9jZXNzKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtlciBkb2VzIG5vdCBzdXBwb3J0IGF0b21pYyBwcm9jZXNzaW5nJyk7XG5cbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDg7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9jZXNzKHBheWxvYWQuaW5wdXQsIHBheWxvYWQub3B0aW9ucyB8fCB7fSwgY29udGV4dCk7XG5cbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgICBfd29ya2VyQm9keS5kZWZhdWx0LnBvc3RNZXNzYWdlKCdkb25lJywge1xuICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJicmVha1wiLCA1NSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIGlmIChwcm9jZXNzSW5CYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3JrZXIgZG9lcyBub3Qgc3VwcG9ydCBiYXRjaGVkIHByb2Nlc3NpbmcnKTtcblxuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgaW5wdXRCYXRjaGVzID0gbmV3IF9hc3luY1F1ZXVlLmRlZmF1bHQoKTtcbiAgICAgICAgICAgICAgb3B0aW9ucyA9IHBheWxvYWQub3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgICAgcmVzdWx0SXRlcmF0b3IgPSBwcm9jZXNzSW5CYXRjaGVzKGlucHV0QmF0Y2hlcywgb3B0aW9ucywgY29udGV4dCA9PT0gbnVsbCB8fCBjb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZXh0LnByb2Nlc3NJbkJhdGNoZXMpO1xuICAgICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDE4O1xuICAgICAgICAgICAgICBfaXRlcmF0b3IgPSAoMCwgX2FzeW5jSXRlcmF0b3IyLmRlZmF1bHQpKHJlc3VsdEl0ZXJhdG9yKTtcblxuICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIyO1xuICAgICAgICAgICAgICByZXR1cm4gX2l0ZXJhdG9yLm5leHQoKTtcblxuICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgICAgX3N0ZXAgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gX3N0ZXAuZG9uZTtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI2O1xuICAgICAgICAgICAgICByZXR1cm4gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICAgIF92YWx1ZSA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24pIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMzM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBiYXRjaCA9IF92YWx1ZTtcblxuICAgICAgICAgICAgICBfd29ya2VyQm9keS5kZWZhdWx0LnBvc3RNZXNzYWdlKCdvdXRwdXQtYmF0Y2gnLCB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OiBiYXRjaFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY2FzZSAzMDpcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMzM6XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMzU6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAzNTtcbiAgICAgICAgICAgICAgX2NvbnRleHQudDEgPSBfY29udGV4dFtcImNhdGNoXCJdKDE4KTtcbiAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IF9jb250ZXh0LnQxO1xuXG4gICAgICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMzk7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA0MDtcblxuICAgICAgICAgICAgICBpZiAoISghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ0O1xuICAgICAgICAgICAgICByZXR1cm4gX2l0ZXJhdG9yLnJldHVybigpO1xuXG4gICAgICAgICAgICBjYXNlIDQ0OlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gNDQ7XG5cbiAgICAgICAgICAgICAgaWYgKCFfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0NztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuXG4gICAgICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDQ0KTtcblxuICAgICAgICAgICAgY2FzZSA0ODpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmZpbmlzaCgzOSk7XG5cbiAgICAgICAgICAgIGNhc2UgNDk6XG4gICAgICAgICAgICAgIF93b3JrZXJCb2R5LmRlZmF1bHQucG9zdE1lc3NhZ2UoJ2RvbmUnLCB7fSk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcImJyZWFrXCIsIDU1KTtcblxuICAgICAgICAgICAgY2FzZSA1MTpcbiAgICAgICAgICAgICAgaW5wdXRCYXRjaGVzLnB1c2gocGF5bG9hZC5pbnB1dCk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJicmVha1wiLCA1NSk7XG5cbiAgICAgICAgICAgIGNhc2UgNTM6XG4gICAgICAgICAgICAgIGlucHV0QmF0Y2hlcy5jbG9zZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwiYnJlYWtcIiwgNTUpO1xuXG4gICAgICAgICAgICBjYXNlIDU1OlxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDU3OlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gNTc7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnQyID0gX2NvbnRleHRbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgICAgbWVzc2FnZSA9IF9jb250ZXh0LnQyIGluc3RhbmNlb2YgRXJyb3IgPyBfY29udGV4dC50Mi5tZXNzYWdlIDogJyc7XG5cbiAgICAgICAgICAgICAgX3dvcmtlckJvZHkuZGVmYXVsdC5wb3N0TWVzc2FnZSgnZXJyb3InLCB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IG1lc3NhZ2VcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNhc2UgNjE6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlLCBudWxsLCBbWzAsIDU3XSwgWzE4LCAzNSwgMzksIDQ5XSwgWzQwLCwgNDQsIDQ4XV0pO1xuICAgIH0pKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoX3gsIF94Mikge1xuICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9KCk7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NPbk1haW5UaHJlYWQoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciBpZCA9IHJlcXVlc3RJZCsrO1xuXG4gICAgdmFyIG9uTWVzc2FnZSA9IGZ1bmN0aW9uIG9uTWVzc2FnZSh0eXBlLCBwYXlsb2FkKSB7XG4gICAgICBpZiAocGF5bG9hZC5pZCAhPT0gaWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnZG9uZSc6XG4gICAgICAgICAgX3dvcmtlckJvZHkuZGVmYXVsdC5yZW1vdmVFdmVudExpc3RlbmVyKG9uTWVzc2FnZSk7XG5cbiAgICAgICAgICByZXNvbHZlKHBheWxvYWQucmVzdWx0KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgX3dvcmtlckJvZHkuZGVmYXVsdC5yZW1vdmVFdmVudExpc3RlbmVyKG9uTWVzc2FnZSk7XG5cbiAgICAgICAgICByZWplY3QocGF5bG9hZC5lcnJvcik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3dvcmtlckJvZHkuZGVmYXVsdC5hZGRFdmVudExpc3RlbmVyKG9uTWVzc2FnZSk7XG5cbiAgICB2YXIgcGF5bG9hZCA9IHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGlucHV0OiBhcnJheUJ1ZmZlcixcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICB9O1xuXG4gICAgX3dvcmtlckJvZHkuZGVmYXVsdC5wb3N0TWVzc2FnZSgncHJvY2VzcycsIHBheWxvYWQpO1xuICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZS13b3JrZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldFdvcmtlck5hbWUgPSBnZXRXb3JrZXJOYW1lO1xuZXhwb3J0cy5nZXRXb3JrZXJVUkwgPSBnZXRXb3JrZXJVUkw7XG5cbnZhciBfYXNzZXJ0ID0gcmVxdWlyZShcIi4uL2Vudi11dGlscy9hc3NlcnRcIik7XG5cbnZhciBfdmVyc2lvbiA9IHJlcXVpcmUoXCIuLi9lbnYtdXRpbHMvdmVyc2lvblwiKTtcblxudmFyIE5QTV9UQUcgPSAnbGF0ZXN0JztcbnZhciBWRVJTSU9OID0gdHlwZW9mIFwiMy4wLjlcIiAhPT0gJ3VuZGVmaW5lZCcgPyBcIjMuMC45XCIgOiBOUE1fVEFHO1xuXG5mdW5jdGlvbiBnZXRXb3JrZXJOYW1lKHdvcmtlcikge1xuICB2YXIgd2FybmluZyA9IHdvcmtlci52ZXJzaW9uICE9PSBWRVJTSU9OID8gXCIgKHdvcmtlci11dGlsc0BcIi5jb25jYXQoVkVSU0lPTiwgXCIpXCIpIDogJyc7XG4gIHJldHVybiBcIlwiLmNvbmNhdCh3b3JrZXIubmFtZSwgXCJAXCIpLmNvbmNhdCh3b3JrZXIudmVyc2lvbikuY29uY2F0KHdhcm5pbmcpO1xufVxuXG5mdW5jdGlvbiBnZXRXb3JrZXJVUkwod29ya2VyKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIHdvcmtlck9wdGlvbnMgPSBvcHRpb25zW3dvcmtlci5pZF0gfHwge307XG4gIHZhciB3b3JrZXJGaWxlID0gXCJcIi5jb25jYXQod29ya2VyLmlkLCBcIi13b3JrZXIuanNcIik7XG4gIHZhciB1cmwgPSB3b3JrZXJPcHRpb25zLndvcmtlclVybDtcblxuICBpZiAob3B0aW9ucy5fd29ya2VyVHlwZSA9PT0gJ3Rlc3QnKSB7XG4gICAgdXJsID0gXCJtb2R1bGVzL1wiLmNvbmNhdCh3b3JrZXIubW9kdWxlLCBcIi9kaXN0L1wiKS5jb25jYXQod29ya2VyRmlsZSk7XG4gIH1cblxuICBpZiAoIXVybCkge1xuICAgIHZhciB2ZXJzaW9uID0gd29ya2VyLnZlcnNpb247XG5cbiAgICBpZiAodmVyc2lvbiA9PT0gJ2xhdGVzdCcpIHtcbiAgICAgIHZlcnNpb24gPSBOUE1fVEFHO1xuICAgIH1cblxuICAgIHZhciB2ZXJzaW9uVGFnID0gdmVyc2lvbiA/IFwiQFwiLmNvbmNhdCh2ZXJzaW9uKSA6ICcnO1xuICAgIHVybCA9IFwiaHR0cHM6Ly91bnBrZy5jb20vQGxvYWRlcnMuZ2wvXCIuY29uY2F0KHdvcmtlci5tb2R1bGUpLmNvbmNhdCh2ZXJzaW9uVGFnLCBcIi9kaXN0L1wiKS5jb25jYXQod29ya2VyRmlsZSk7XG4gIH1cblxuICAoMCwgX2Fzc2VydC5hc3NlcnQpKHVybCk7XG4gIHJldHVybiB1cmw7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtd29ya2VyLXVybC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNhblByb2Nlc3NPbldvcmtlciA9IGNhblByb2Nlc3NPbldvcmtlcjtcbmV4cG9ydHMucHJvY2Vzc09uV29ya2VyID0gcHJvY2Vzc09uV29ya2VyO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF93b3JrZXJGYXJtID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vd29ya2VyLWZhcm0vd29ya2VyLWZhcm1cIikpO1xuXG52YXIgX3JlbW92ZU5vbnRyYW5zZmVyYWJsZU9wdGlvbnMgPSByZXF1aXJlKFwiLi4vd29ya2VyLXV0aWxzL3JlbW92ZS1ub250cmFuc2ZlcmFibGUtb3B0aW9uc1wiKTtcblxudmFyIF9nZXRXb3JrZXJVcmwgPSByZXF1aXJlKFwiLi9nZXQtd29ya2VyLXVybFwiKTtcblxuZnVuY3Rpb24gY2FuUHJvY2Vzc09uV29ya2VyKHdvcmtlciwgb3B0aW9ucykge1xuICBpZiAoIV93b3JrZXJGYXJtLmRlZmF1bHQuaXNTdXBwb3J0ZWQoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB3b3JrZXIud29ya2VyICYmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMud29ya2VyKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc09uV29ya2VyKF94LCBfeDIpIHtcbiAgcmV0dXJuIF9wcm9jZXNzT25Xb3JrZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3Byb2Nlc3NPbldvcmtlcigpIHtcbiAgX3Byb2Nlc3NPbldvcmtlciA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKHdvcmtlciwgZGF0YSkge1xuICAgIHZhciBvcHRpb25zLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBuYW1lLFxuICAgICAgICB1cmwsXG4gICAgICAgIHdvcmtlckZhcm0sXG4gICAgICAgIHdvcmtlclBvb2wsXG4gICAgICAgIGpvYk5hbWUsXG4gICAgICAgIGpvYixcbiAgICAgICAgdHJhbnNmZXJhYmxlT3B0aW9ucyxcbiAgICAgICAgcmVzdWx0LFxuICAgICAgICBfYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIG9wdGlvbnMgPSBfYXJncy5sZW5ndGggPiAyICYmIF9hcmdzWzJdICE9PSB1bmRlZmluZWQgPyBfYXJnc1syXSA6IHt9O1xuICAgICAgICAgICAgY29udGV4dCA9IF9hcmdzLmxlbmd0aCA+IDMgJiYgX2FyZ3NbM10gIT09IHVuZGVmaW5lZCA/IF9hcmdzWzNdIDoge307XG4gICAgICAgICAgICBuYW1lID0gKDAsIF9nZXRXb3JrZXJVcmwuZ2V0V29ya2VyTmFtZSkod29ya2VyKTtcbiAgICAgICAgICAgIHVybCA9ICgwLCBfZ2V0V29ya2VyVXJsLmdldFdvcmtlclVSTCkod29ya2VyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHdvcmtlckZhcm0gPSBfd29ya2VyRmFybS5kZWZhdWx0LmdldFdvcmtlckZhcm0ob3B0aW9ucyk7XG4gICAgICAgICAgICB3b3JrZXJQb29sID0gd29ya2VyRmFybS5nZXRXb3JrZXJQb29sKHtcbiAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgam9iTmFtZSA9IG9wdGlvbnMuam9iTmFtZSB8fCB3b3JrZXIubmFtZTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA5O1xuICAgICAgICAgICAgcmV0dXJuIHdvcmtlclBvb2wuc3RhcnRKb2Ioam9iTmFtZSwgb25NZXNzYWdlLmJpbmQobnVsbCwgY29udGV4dCkpO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgam9iID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIHRyYW5zZmVyYWJsZU9wdGlvbnMgPSAoMCwgX3JlbW92ZU5vbnRyYW5zZmVyYWJsZU9wdGlvbnMucmVtb3ZlTm9udHJhbnNmZXJhYmxlT3B0aW9ucykob3B0aW9ucyk7XG4gICAgICAgICAgICBqb2IucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MnLCB7XG4gICAgICAgICAgICAgIGlucHV0OiBkYXRhLFxuICAgICAgICAgICAgICBvcHRpb25zOiB0cmFuc2ZlcmFibGVPcHRpb25zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNDtcbiAgICAgICAgICAgIHJldHVybiBqb2IucmVzdWx0O1xuXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHJlc3VsdC5yZXN1bHQpO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9wcm9jZXNzT25Xb3JrZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gb25NZXNzYWdlKF94MywgX3g0LCBfeDUsIF94Nikge1xuICByZXR1cm4gX29uTWVzc2FnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfb25NZXNzYWdlKCkge1xuICBfb25NZXNzYWdlID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMi5kZWZhdWx0KShfcmVnZW5lcmF0b3IuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGNvbnRleHQsIGpvYiwgdHlwZSwgcGF5bG9hZCkge1xuICAgIHZhciBpZCwgaW5wdXQsIG9wdGlvbnMsIHJlc3VsdCwgbWVzc2FnZTtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dDIudDAgPSB0eXBlO1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSBfY29udGV4dDIudDAgPT09ICdkb25lJyA/IDMgOiBfY29udGV4dDIudDAgPT09ICdlcnJvcicgPyA1IDogX2NvbnRleHQyLnQwID09PSAncHJvY2VzcycgPyA3IDogMjM7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGpvYi5kb25lKHBheWxvYWQpO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJicmVha1wiLCAyNCk7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBqb2IuZXJyb3IocGF5bG9hZC5lcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcImJyZWFrXCIsIDI0KTtcblxuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGlkID0gcGF5bG9hZC5pZCwgaW5wdXQgPSBwYXlsb2FkLmlucHV0LCBvcHRpb25zID0gcGF5bG9hZC5vcHRpb25zO1xuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSA4O1xuXG4gICAgICAgICAgICBpZiAoY29udGV4dC5wcm9jZXNzKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBqb2IucG9zdE1lc3NhZ2UoJ2Vycm9yJywge1xuICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgIGVycm9yOiAnV29ya2VyIG5vdCBzZXQgdXAgdG8gcHJvY2VzcyBvbiBtYWluIHRocmVhZCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIik7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNDtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LnByb2Nlc3MoaW5wdXQsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgam9iLnBvc3RNZXNzYWdlKCdkb25lJywge1xuICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDE4O1xuICAgICAgICAgICAgX2NvbnRleHQyLnQxID0gX2NvbnRleHQyW1wiY2F0Y2hcIl0oOCk7XG4gICAgICAgICAgICBtZXNzYWdlID0gX2NvbnRleHQyLnQxIGluc3RhbmNlb2YgRXJyb3IgPyBfY29udGV4dDIudDEubWVzc2FnZSA6ICd1bmtub3duIGVycm9yJztcbiAgICAgICAgICAgIGpvYi5wb3N0TWVzc2FnZSgnZXJyb3InLCB7XG4gICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgZXJyb3I6IG1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwiYnJlYWtcIiwgMjQpO1xuXG4gICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcInByb2Nlc3Mtb24td29ya2VyOiB1bmtub3duIG1lc3NhZ2UgXCIuY29uY2F0KHR5cGUpKTtcblxuICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMiwgbnVsbCwgW1s4LCAxOF1dKTtcbiAgfSkpO1xuICByZXR1cm4gX29uTWVzc2FnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy1vbi13b3JrZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnZhbGlkYXRlV29ya2VyVmVyc2lvbiA9IHZhbGlkYXRlV29ya2VyVmVyc2lvbjtcblxudmFyIF9hc3NlcnQgPSByZXF1aXJlKFwiLi4vZW52LXV0aWxzL2Fzc2VydFwiKTtcblxudmFyIF92ZXJzaW9uID0gcmVxdWlyZShcIi4uL2Vudi11dGlscy92ZXJzaW9uXCIpO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVdvcmtlclZlcnNpb24od29ya2VyKSB7XG4gIHZhciBjb3JlVmVyc2lvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogX3ZlcnNpb24uVkVSU0lPTjtcbiAgKDAsIF9hc3NlcnQuYXNzZXJ0KSh3b3JrZXIsICdubyB3b3JrZXIgcHJvdmlkZWQnKTtcbiAgdmFyIHdvcmtlclZlcnNpb24gPSB3b3JrZXIudmVyc2lvbjtcblxuICBpZiAoIWNvcmVWZXJzaW9uIHx8ICF3b3JrZXJWZXJzaW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVmVyc2lvbih2ZXJzaW9uKSB7XG4gIHZhciBwYXJ0cyA9IHZlcnNpb24uc3BsaXQoJy4nKS5tYXAoTnVtYmVyKTtcbiAgcmV0dXJuIHtcbiAgICBtYWpvcjogcGFydHNbMF0sXG4gICAgbWlub3I6IHBhcnRzWzFdXG4gIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0ZS13b3JrZXItdmVyc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfZ2V0VHJhbnNmZXJMaXN0ID0gcmVxdWlyZShcIi4uL3dvcmtlci11dGlscy9nZXQtdHJhbnNmZXItbGlzdFwiKTtcblxudmFyIG9uTWVzc2FnZVdyYXBwZXJNYXAgPSBuZXcgTWFwKCk7XG5cbnZhciBXb3JrZXJCb2R5ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBXb3JrZXJCb2R5KCkge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFdvcmtlckJvZHkpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoV29ya2VyQm9keSwgbnVsbCwgW3tcbiAgICBrZXk6IFwib25tZXNzYWdlXCIsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQob25NZXNzYWdlKSB7XG4gICAgICBzZWxmLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIGlmICghaXNLbm93bk1lc3NhZ2UobWVzc2FnZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX21lc3NhZ2UkZGF0YSA9IG1lc3NhZ2UuZGF0YSxcbiAgICAgICAgICAgIHR5cGUgPSBfbWVzc2FnZSRkYXRhLnR5cGUsXG4gICAgICAgICAgICBwYXlsb2FkID0gX21lc3NhZ2UkZGF0YS5wYXlsb2FkO1xuICAgICAgICBvbk1lc3NhZ2UodHlwZSwgcGF5bG9hZCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRFdmVudExpc3RlbmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIob25NZXNzYWdlKSB7XG4gICAgICB2YXIgb25NZXNzYWdlV3JhcHBlciA9IG9uTWVzc2FnZVdyYXBwZXJNYXAuZ2V0KG9uTWVzc2FnZSk7XG5cbiAgICAgIGlmICghb25NZXNzYWdlV3JhcHBlcikge1xuICAgICAgICBvbk1lc3NhZ2VXcmFwcGVyID0gZnVuY3Rpb24gb25NZXNzYWdlV3JhcHBlcihtZXNzYWdlKSB7XG4gICAgICAgICAgaWYgKCFpc0tub3duTWVzc2FnZShtZXNzYWdlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfbWVzc2FnZSRkYXRhMiA9IG1lc3NhZ2UuZGF0YSxcbiAgICAgICAgICAgICAgdHlwZSA9IF9tZXNzYWdlJGRhdGEyLnR5cGUsXG4gICAgICAgICAgICAgIHBheWxvYWQgPSBfbWVzc2FnZSRkYXRhMi5wYXlsb2FkO1xuICAgICAgICAgIG9uTWVzc2FnZSh0eXBlLCBwYXlsb2FkKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25NZXNzYWdlV3JhcHBlcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihvbk1lc3NhZ2UpIHtcbiAgICAgIHZhciBvbk1lc3NhZ2VXcmFwcGVyID0gb25NZXNzYWdlV3JhcHBlck1hcC5nZXQob25NZXNzYWdlKTtcbiAgICAgIG9uTWVzc2FnZVdyYXBwZXJNYXAuZGVsZXRlKG9uTWVzc2FnZSk7XG4gICAgICBzZWxmLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbk1lc3NhZ2VXcmFwcGVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9zdE1lc3NhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zdE1lc3NhZ2UodHlwZSwgcGF5bG9hZCkge1xuICAgICAgaWYgKHNlbGYpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgc291cmNlOiAnbG9hZGVycy5nbCcsXG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkXG4gICAgICAgIH07XG4gICAgICAgIHZhciB0cmFuc2Zlckxpc3QgPSAoMCwgX2dldFRyYW5zZmVyTGlzdC5nZXRUcmFuc2Zlckxpc3QpKHBheWxvYWQpO1xuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKGRhdGEsIHRyYW5zZmVyTGlzdCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBXb3JrZXJCb2R5O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBXb3JrZXJCb2R5O1xuXG5mdW5jdGlvbiBpc0tub3duTWVzc2FnZShtZXNzYWdlKSB7XG4gIHZhciB0eXBlID0gbWVzc2FnZS50eXBlLFxuICAgICAgZGF0YSA9IG1lc3NhZ2UuZGF0YTtcbiAgcmV0dXJuIHR5cGUgPT09ICdtZXNzYWdlJyAmJiBkYXRhICYmIHR5cGVvZiBkYXRhLnNvdXJjZSA9PT0gJ3N0cmluZycgJiYgZGF0YS5zb3VyY2Uuc3RhcnRzV2l0aCgnbG9hZGVycy5nbCcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d29ya2VyLWJvZHkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX3dvcmtlclBvb2wgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3dvcmtlci1wb29sXCIpKTtcblxudmFyIF93b3JrZXJUaHJlYWQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3dvcmtlci10aHJlYWRcIikpO1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgREVGQVVMVF9QUk9QUyA9IHtcbiAgbWF4Q29uY3VycmVuY3k6IDMsXG4gIG1heE1vYmlsZUNvbmN1cnJlbmN5OiAxLFxuICBvbkRlYnVnOiBmdW5jdGlvbiBvbkRlYnVnKCkge30sXG4gIHJldXNlV29ya2VyczogdHJ1ZVxufTtcblxudmFyIFdvcmtlckZhcm0gPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFdvcmtlckZhcm0ocHJvcHMpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBXb3JrZXJGYXJtKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcInByb3BzXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJ3b3JrZXJQb29sc1wiLCBuZXcgTWFwKCkpO1xuICAgIHRoaXMucHJvcHMgPSBfb2JqZWN0U3ByZWFkKHt9LCBERUZBVUxUX1BST1BTKTtcbiAgICB0aGlzLnNldFByb3BzKHByb3BzKTtcbiAgICB0aGlzLndvcmtlclBvb2xzID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoV29ya2VyRmFybSwgW3tcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMud29ya2VyUG9vbHMudmFsdWVzKCkpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciB3b3JrZXJQb29sID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgd29ya2VyUG9vbC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UHJvcHMocHJvcHMpIHtcbiAgICAgIHRoaXMucHJvcHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMucHJvcHMpLCBwcm9wcyk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy53b3JrZXJQb29scy52YWx1ZXMoKSksXG4gICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciB3b3JrZXJQb29sID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgIHdvcmtlclBvb2wuc2V0UHJvcHModGhpcy5fZ2V0V29ya2VyUG9vbFByb3BzKCkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0V29ya2VyUG9vbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRXb3JrZXJQb29sKG9wdGlvbnMpIHtcbiAgICAgIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lLFxuICAgICAgICAgIHNvdXJjZSA9IG9wdGlvbnMuc291cmNlLFxuICAgICAgICAgIHVybCA9IG9wdGlvbnMudXJsO1xuICAgICAgdmFyIHdvcmtlclBvb2wgPSB0aGlzLndvcmtlclBvb2xzLmdldChuYW1lKTtcblxuICAgICAgaWYgKCF3b3JrZXJQb29sKSB7XG4gICAgICAgIHdvcmtlclBvb2wgPSBuZXcgX3dvcmtlclBvb2wuZGVmYXVsdCh7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICB1cmw6IHVybFxuICAgICAgICB9KTtcbiAgICAgICAgd29ya2VyUG9vbC5zZXRQcm9wcyh0aGlzLl9nZXRXb3JrZXJQb29sUHJvcHMoKSk7XG4gICAgICAgIHRoaXMud29ya2VyUG9vbHMuc2V0KG5hbWUsIHdvcmtlclBvb2wpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gd29ya2VyUG9vbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFdvcmtlclBvb2xQcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0V29ya2VyUG9vbFByb3BzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWF4Q29uY3VycmVuY3k6IHRoaXMucHJvcHMubWF4Q29uY3VycmVuY3ksXG4gICAgICAgIG1heE1vYmlsZUNvbmN1cnJlbmN5OiB0aGlzLnByb3BzLm1heE1vYmlsZUNvbmN1cnJlbmN5LFxuICAgICAgICByZXVzZVdvcmtlcnM6IHRoaXMucHJvcHMucmV1c2VXb3JrZXJzLFxuICAgICAgICBvbkRlYnVnOiB0aGlzLnByb3BzLm9uRGVidWdcbiAgICAgIH07XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiaXNTdXBwb3J0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XG4gICAgICByZXR1cm4gX3dvcmtlclRocmVhZC5kZWZhdWx0LmlzU3VwcG9ydGVkKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFdvcmtlckZhcm1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0V29ya2VyRmFybSgpIHtcbiAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICBXb3JrZXJGYXJtLl93b3JrZXJGYXJtID0gV29ya2VyRmFybS5fd29ya2VyRmFybSB8fCBuZXcgV29ya2VyRmFybSh7fSk7XG5cbiAgICAgIFdvcmtlckZhcm0uX3dvcmtlckZhcm0uc2V0UHJvcHMocHJvcHMpO1xuXG4gICAgICByZXR1cm4gV29ya2VyRmFybS5fd29ya2VyRmFybTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFdvcmtlckZhcm07XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFdvcmtlckZhcm07XG4oMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KShXb3JrZXJGYXJtLCBcIl93b3JrZXJGYXJtXCIsIHZvaWQgMCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JrZXItZmFybS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfYXNzZXJ0ID0gcmVxdWlyZShcIi4uL2Vudi11dGlscy9hc3NlcnRcIik7XG5cbnZhciBXb3JrZXJKb2IgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFdvcmtlckpvYihqb2JOYW1lLCB3b3JrZXJUaHJlYWQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgV29ya2VySm9iKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcIm5hbWVcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcIndvcmtlclRocmVhZFwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwiaXNSdW5uaW5nXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJyZXN1bHRcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcIl9yZXNvbHZlXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJfcmVqZWN0XCIsIHZvaWQgMCk7XG4gICAgdGhpcy5uYW1lID0gam9iTmFtZTtcbiAgICB0aGlzLndvcmtlclRocmVhZCA9IHdvcmtlclRocmVhZDtcbiAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG5cbiAgICB0aGlzLl9yZXNvbHZlID0gZnVuY3Rpb24gKCkge307XG5cbiAgICB0aGlzLl9yZWplY3QgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIHRoaXMucmVzdWx0ID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgX3RoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgX3RoaXMuX3JlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKFdvcmtlckpvYiwgW3tcbiAgICBrZXk6IFwicG9zdE1lc3NhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zdE1lc3NhZ2UodHlwZSwgcGF5bG9hZCkge1xuICAgICAgdGhpcy53b3JrZXJUaHJlYWQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBzb3VyY2U6ICdsb2FkZXJzLmdsJyxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgcGF5bG9hZDogcGF5bG9hZFxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRvbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG9uZSh2YWx1ZSkge1xuICAgICAgKDAsIF9hc3NlcnQuYXNzZXJ0KSh0aGlzLmlzUnVubmluZyk7XG4gICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuXG4gICAgICB0aGlzLl9yZXNvbHZlKHZhbHVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXJyb3IoX2Vycm9yKSB7XG4gICAgICAoMCwgX2Fzc2VydC5hc3NlcnQpKHRoaXMuaXNSdW5uaW5nKTtcbiAgICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuX3JlamVjdChfZXJyb3IpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gV29ya2VySm9iO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBXb3JrZXJKb2I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JrZXItam9iLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfZ2xvYmFscyA9IHJlcXVpcmUoXCIuLi9lbnYtdXRpbHMvZ2xvYmFsc1wiKTtcblxudmFyIF93b3JrZXJUaHJlYWQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3dvcmtlci10aHJlYWRcIikpO1xuXG52YXIgX3dvcmtlckpvYiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vd29ya2VyLWpvYlwiKSk7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgV29ya2VyUG9vbCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gV29ya2VyUG9vbChwcm9wcykge1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFdvcmtlclBvb2wpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwibmFtZVwiLCAndW5uYW1lZCcpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwic291cmNlXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJ1cmxcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcIm1heENvbmN1cnJlbmN5XCIsIDEpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwibWF4TW9iaWxlQ29uY3VycmVuY3lcIiwgMSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJvbkRlYnVnXCIsIGZ1bmN0aW9uICgpIHt9KTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcInJldXNlV29ya2Vyc1wiLCB0cnVlKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcInByb3BzXCIsIHt9KTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcImpvYlF1ZXVlXCIsIFtdKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcImlkbGVRdWV1ZVwiLCBbXSk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJjb3VudFwiLCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcImlzRGVzdHJveWVkXCIsIGZhbHNlKTtcbiAgICB0aGlzLnNvdXJjZSA9IHByb3BzLnNvdXJjZTtcbiAgICB0aGlzLnVybCA9IHByb3BzLnVybDtcbiAgICB0aGlzLnNldFByb3BzKHByb3BzKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKFdvcmtlclBvb2wsIFt7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuaWRsZVF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKHdvcmtlcikge1xuICAgICAgICByZXR1cm4gd29ya2VyLmRlc3Ryb3koKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFByb3BzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFByb3BzKHByb3BzKSB7XG4gICAgICB0aGlzLnByb3BzID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLnByb3BzKSwgcHJvcHMpO1xuXG4gICAgICBpZiAocHJvcHMubmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IHByb3BzLm5hbWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wcy5tYXhDb25jdXJyZW5jeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubWF4Q29uY3VycmVuY3kgPSBwcm9wcy5tYXhDb25jdXJyZW5jeTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3BzLm1heE1vYmlsZUNvbmN1cnJlbmN5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5tYXhNb2JpbGVDb25jdXJyZW5jeSA9IHByb3BzLm1heE1vYmlsZUNvbmN1cnJlbmN5O1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcHMucmV1c2VXb3JrZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5yZXVzZVdvcmtlcnMgPSBwcm9wcy5yZXVzZVdvcmtlcnM7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wcy5vbkRlYnVnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5vbkRlYnVnID0gcHJvcHMub25EZWJ1ZztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRKb2JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9zdGFydEpvYiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKG5hbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB2YXIgb25NZXNzYWdlLFxuICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgIHN0YXJ0UHJvbWlzZSxcbiAgICAgICAgICAgIF9hcmdzID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvbk1lc3NhZ2UgPSBfYXJncy5sZW5ndGggPiAxICYmIF9hcmdzWzFdICE9PSB1bmRlZmluZWQgPyBfYXJnc1sxXSA6IGZ1bmN0aW9uIChqb2IsIHR5cGUsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBqb2IuZG9uZShkYXRhKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG9uRXJyb3IgPSBfYXJncy5sZW5ndGggPiAyICYmIF9hcmdzWzJdICE9PSB1bmRlZmluZWQgPyBfYXJnc1syXSA6IGZ1bmN0aW9uIChqb2IsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gam9iLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHN0YXJ0UHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChvblN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5qb2JRdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgb25NZXNzYWdlOiBvbk1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IG9uRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIG9uU3RhcnQ6IG9uU3RhcnRcbiAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFF1ZXVlZEpvYigpO1xuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0UHJvbWlzZTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dC5zZW50KTtcblxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHN0YXJ0Sm9iKF94KSB7XG4gICAgICAgIHJldHVybiBfc3RhcnRKb2IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXJ0Sm9iO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIl9zdGFydFF1ZXVlZEpvYlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3N0YXJ0UXVldWVkSm9iMiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjIuZGVmYXVsdCkoX3JlZ2VuZXJhdG9yLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHtcbiAgICAgICAgdmFyIHdvcmtlclRocmVhZCwgcXVldWVkSm9iLCBfam9iO1xuXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5qb2JRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB3b3JrZXJUaHJlYWQgPSB0aGlzLl9nZXRBdmFpbGFibGVXb3JrZXIoKTtcblxuICAgICAgICAgICAgICAgIGlmICh3b3JrZXJUaHJlYWQpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBxdWV1ZWRKb2IgPSB0aGlzLmpvYlF1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXF1ZXVlZEpvYikge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxODtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMub25EZWJ1Zyh7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnU3RhcnRpbmcgam9iJyxcbiAgICAgICAgICAgICAgICAgIG5hbWU6IHF1ZXVlZEpvYi5uYW1lLFxuICAgICAgICAgICAgICAgICAgd29ya2VyVGhyZWFkOiB3b3JrZXJUaHJlYWQsXG4gICAgICAgICAgICAgICAgICBiYWNrbG9nOiB0aGlzLmpvYlF1ZXVlLmxlbmd0aFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIF9qb2IgPSBuZXcgX3dvcmtlckpvYi5kZWZhdWx0KHF1ZXVlZEpvYi5uYW1lLCB3b3JrZXJUaHJlYWQpO1xuXG4gICAgICAgICAgICAgICAgd29ya2VyVGhyZWFkLm9uTWVzc2FnZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcXVldWVkSm9iLm9uTWVzc2FnZShfam9iLCBkYXRhLnR5cGUsIGRhdGEucGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHdvcmtlclRocmVhZC5vbkVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcXVldWVkSm9iLm9uRXJyb3IoX2pvYiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBxdWV1ZWRKb2Iub25TdGFydChfam9iKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDEyO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9qb2IucmVzdWx0O1xuXG4gICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAxNTtcbiAgICAgICAgICAgICAgICB0aGlzLnJldHVybldvcmtlclRvUXVldWUod29ya2VyVGhyZWFkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmZpbmlzaCgxNSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMsIFtbMTIsLCAxNSwgMThdXSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIF9zdGFydFF1ZXVlZEpvYigpIHtcbiAgICAgICAgcmV0dXJuIF9zdGFydFF1ZXVlZEpvYjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9zdGFydFF1ZXVlZEpvYjtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJyZXR1cm5Xb3JrZXJUb1F1ZXVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJldHVybldvcmtlclRvUXVldWUod29ya2VyKSB7XG4gICAgICB2YXIgc2hvdWxkRGVzdHJveVdvcmtlciA9IHRoaXMuaXNEZXN0cm95ZWQgfHwgIXRoaXMucmV1c2VXb3JrZXJzIHx8IHRoaXMuY291bnQgPiB0aGlzLl9nZXRNYXhDb25jdXJyZW5jeSgpO1xuXG4gICAgICBpZiAoc2hvdWxkRGVzdHJveVdvcmtlcikge1xuICAgICAgICB3b3JrZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmNvdW50LS07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmlkbGVRdWV1ZS5wdXNoKHdvcmtlcik7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5pc0Rlc3Ryb3llZCkge1xuICAgICAgICB0aGlzLl9zdGFydFF1ZXVlZEpvYigpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0QXZhaWxhYmxlV29ya2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRBdmFpbGFibGVXb3JrZXIoKSB7XG4gICAgICBpZiAodGhpcy5pZGxlUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZGxlUXVldWUuc2hpZnQoKSB8fCBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jb3VudCA8IHRoaXMuX2dldE1heENvbmN1cnJlbmN5KCkpIHtcbiAgICAgICAgdGhpcy5jb3VudCsrO1xuICAgICAgICB2YXIgbmFtZSA9IFwiXCIuY29uY2F0KHRoaXMubmFtZS50b0xvd2VyQ2FzZSgpLCBcIiAoI1wiKS5jb25jYXQodGhpcy5jb3VudCwgXCIgb2YgXCIpLmNvbmNhdCh0aGlzLm1heENvbmN1cnJlbmN5LCBcIilcIik7XG4gICAgICAgIHJldHVybiBuZXcgX3dvcmtlclRocmVhZC5kZWZhdWx0KHtcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgICAgdXJsOiB0aGlzLnVybFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRNYXhDb25jdXJyZW5jeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0TWF4Q29uY3VycmVuY3koKSB7XG4gICAgICByZXR1cm4gX2dsb2JhbHMuaXNNb2JpbGUgPyB0aGlzLm1heE1vYmlsZUNvbmN1cnJlbmN5IDogdGhpcy5tYXhDb25jdXJyZW5jeTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFdvcmtlclBvb2w7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFdvcmtlclBvb2w7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JrZXItcG9vbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVja1wiKSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzc1wiKSk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfYXNzZXJ0ID0gcmVxdWlyZShcIi4uL2Vudi11dGlscy9hc3NlcnRcIik7XG5cbnZhciBfZ2V0TG9hZGFibGVXb3JrZXJVcmwgPSByZXF1aXJlKFwiLi4vd29ya2VyLXV0aWxzL2dldC1sb2FkYWJsZS13b3JrZXItdXJsXCIpO1xuXG52YXIgX2dldFRyYW5zZmVyTGlzdCA9IHJlcXVpcmUoXCIuLi93b3JrZXItdXRpbHMvZ2V0LXRyYW5zZmVyLWxpc3RcIik7XG5cbnZhciBOT09QID0gZnVuY3Rpb24gTk9PUCgpIHt9O1xuXG52YXIgV29ya2VyVGhyZWFkID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBXb3JrZXJUaHJlYWQocHJvcHMpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBXb3JrZXJUaHJlYWQpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwibmFtZVwiLCB2b2lkIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwic291cmNlXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJ1cmxcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcInRlcm1pbmF0ZWRcIiwgZmFsc2UpO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRoaXMsIFwid29ya2VyXCIsIHZvaWQgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGhpcywgXCJvbk1lc3NhZ2VcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcIm9uRXJyb3JcIiwgdm9pZCAwKTtcbiAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0aGlzLCBcIl9sb2FkYWJsZVVSTFwiLCAnJyk7XG4gICAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lLFxuICAgICAgICBzb3VyY2UgPSBwcm9wcy5zb3VyY2UsXG4gICAgICAgIHVybCA9IHByb3BzLnVybDtcbiAgICAoMCwgX2Fzc2VydC5hc3NlcnQpKHNvdXJjZSB8fCB1cmwpO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5vbk1lc3NhZ2UgPSBOT09QO1xuXG4gICAgdGhpcy5vbkVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5sb2coZXJyb3IpO1xuICAgIH07XG5cbiAgICB0aGlzLndvcmtlciA9IHRoaXMuX2NyZWF0ZUJyb3dzZXJXb3JrZXIoKTtcbiAgfVxuXG4gICgwLCBfY3JlYXRlQ2xhc3MyLmRlZmF1bHQpKFdvcmtlclRocmVhZCwgW3tcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5vbk1lc3NhZ2UgPSBOT09QO1xuICAgICAgdGhpcy5vbkVycm9yID0gTk9PUDtcbiAgICAgIHRoaXMud29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgdGhpcy50ZXJtaW5hdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNSdW5uaW5nXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gQm9vbGVhbih0aGlzLm9uTWVzc2FnZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvc3RNZXNzYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc3RNZXNzYWdlKGRhdGEsIHRyYW5zZmVyTGlzdCkge1xuICAgICAgdHJhbnNmZXJMaXN0ID0gdHJhbnNmZXJMaXN0IHx8ICgwLCBfZ2V0VHJhbnNmZXJMaXN0LmdldFRyYW5zZmVyTGlzdCkoZGF0YSk7XG4gICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShkYXRhLCB0cmFuc2Zlckxpc3QpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0RXJyb3JGcm9tRXJyb3JFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RXJyb3JGcm9tRXJyb3JFdmVudChldmVudCkge1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnRmFpbGVkIHRvIGxvYWQgJztcbiAgICAgIG1lc3NhZ2UgKz0gXCJ3b3JrZXIgXCIuY29uY2F0KHRoaXMubmFtZSwgXCIuIFwiKTtcblxuICAgICAgaWYgKGV2ZW50Lm1lc3NhZ2UpIHtcbiAgICAgICAgbWVzc2FnZSArPSBcIlwiLmNvbmNhdChldmVudC5tZXNzYWdlLCBcIiBpbiBcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC5saW5lbm8pIHtcbiAgICAgICAgbWVzc2FnZSArPSBcIjpcIi5jb25jYXQoZXZlbnQubGluZW5vLCBcIjpcIikuY29uY2F0KGV2ZW50LmNvbG5vKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZUJyb3dzZXJXb3JrZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUJyb3dzZXJXb3JrZXIoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLl9sb2FkYWJsZVVSTCA9ICgwLCBfZ2V0TG9hZGFibGVXb3JrZXJVcmwuZ2V0TG9hZGFibGVXb3JrZXJVUkwpKHtcbiAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZSxcbiAgICAgICAgdXJsOiB0aGlzLnVybFxuICAgICAgfSk7XG4gICAgICB2YXIgd29ya2VyID0gbmV3IFdvcmtlcih0aGlzLl9sb2FkYWJsZVVSTCwge1xuICAgICAgICBuYW1lOiB0aGlzLm5hbWVcbiAgICAgIH0pO1xuXG4gICAgICB3b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICghZXZlbnQuZGF0YSkge1xuICAgICAgICAgIF90aGlzLm9uRXJyb3IobmV3IEVycm9yKCdObyBkYXRhIHJlY2VpdmVkJykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzLm9uTWVzc2FnZShldmVudC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgd29ya2VyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgX3RoaXMub25FcnJvcihfdGhpcy5fZ2V0RXJyb3JGcm9tRXJyb3JFdmVudChlcnJvcikpO1xuXG4gICAgICAgIF90aGlzLnRlcm1pbmF0ZWQgPSB0cnVlO1xuICAgICAgfTtcblxuICAgICAgd29ya2VyLm9ubWVzc2FnZWVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKGV2ZW50KTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB3b3JrZXI7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiaXNTdXBwb3J0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIFdvcmtlciAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBXb3JrZXJUaHJlYWQ7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFdvcmtlclRocmVhZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmtlci10aHJlYWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldExvYWRhYmxlV29ya2VyVVJMID0gZ2V0TG9hZGFibGVXb3JrZXJVUkw7XG5cbnZhciBfYXNzZXJ0ID0gcmVxdWlyZShcIi4uL2Vudi11dGlscy9hc3NlcnRcIik7XG5cbnZhciB3b3JrZXJVUkxDYWNoZSA9IG5ldyBNYXAoKTtcblxuZnVuY3Rpb24gZ2V0TG9hZGFibGVXb3JrZXJVUkwocHJvcHMpIHtcbiAgKDAsIF9hc3NlcnQuYXNzZXJ0KShwcm9wcy5zb3VyY2UgJiYgIXByb3BzLnVybCB8fCAhcHJvcHMuc291cmNlICYmIHByb3BzLnVybCk7XG4gIHZhciB3b3JrZXJVUkwgPSB3b3JrZXJVUkxDYWNoZS5nZXQocHJvcHMuc291cmNlIHx8IHByb3BzLnVybCk7XG5cbiAgaWYgKCF3b3JrZXJVUkwpIHtcbiAgICBpZiAocHJvcHMudXJsKSB7XG4gICAgICB3b3JrZXJVUkwgPSBnZXRMb2FkYWJsZVdvcmtlclVSTEZyb21VUkwocHJvcHMudXJsKTtcbiAgICAgIHdvcmtlclVSTENhY2hlLnNldChwcm9wcy51cmwsIHdvcmtlclVSTCk7XG4gICAgfVxuXG4gICAgaWYgKHByb3BzLnNvdXJjZSkge1xuICAgICAgd29ya2VyVVJMID0gZ2V0TG9hZGFibGVXb3JrZXJVUkxGcm9tU291cmNlKHByb3BzLnNvdXJjZSk7XG4gICAgICB3b3JrZXJVUkxDYWNoZS5zZXQocHJvcHMuc291cmNlLCB3b3JrZXJVUkwpO1xuICAgIH1cbiAgfVxuXG4gICgwLCBfYXNzZXJ0LmFzc2VydCkod29ya2VyVVJMKTtcbiAgcmV0dXJuIHdvcmtlclVSTDtcbn1cblxuZnVuY3Rpb24gZ2V0TG9hZGFibGVXb3JrZXJVUkxGcm9tVVJMKHVybCkge1xuICBpZiAoIXVybC5zdGFydHNXaXRoKCdodHRwJykpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgdmFyIHdvcmtlclNvdXJjZSA9IGJ1aWxkU2NyaXB0U291cmNlKHVybCk7XG4gIHJldHVybiBnZXRMb2FkYWJsZVdvcmtlclVSTEZyb21Tb3VyY2Uod29ya2VyU291cmNlKTtcbn1cblxuZnVuY3Rpb24gZ2V0TG9hZGFibGVXb3JrZXJVUkxGcm9tU291cmNlKHdvcmtlclNvdXJjZSkge1xuICB2YXIgYmxvYiA9IG5ldyBCbG9iKFt3b3JrZXJTb3VyY2VdLCB7XG4gICAgdHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnXG4gIH0pO1xuICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbn1cblxuZnVuY3Rpb24gYnVpbGRTY3JpcHRTb3VyY2Uod29ya2VyVXJsKSB7XG4gIHJldHVybiBcInRyeSB7XFxuICBpbXBvcnRTY3JpcHRzKCdcIi5jb25jYXQod29ya2VyVXJsLCBcIicpO1xcbn0gY2F0Y2ggKGVycm9yKSB7XFxuICBjb25zb2xlLmVycm9yKGVycm9yKTtcXG4gIHRocm93IGVycm9yO1xcbn1cIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtbG9hZGFibGUtd29ya2VyLXVybC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldFRyYW5zZmVyTGlzdCA9IGdldFRyYW5zZmVyTGlzdDtcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2Zlckxpc3Qob2JqZWN0KSB7XG4gIHZhciByZWN1cnNpdmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gIHZhciB0cmFuc2ZlcnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIHRyYW5zZmVyc1NldCA9IHRyYW5zZmVycyB8fCBuZXcgU2V0KCk7XG5cbiAgaWYgKCFvYmplY3QpIHt9IGVsc2UgaWYgKGlzVHJhbnNmZXJhYmxlKG9iamVjdCkpIHtcbiAgICB0cmFuc2ZlcnNTZXQuYWRkKG9iamVjdCk7XG4gIH0gZWxzZSBpZiAoaXNUcmFuc2ZlcmFibGUob2JqZWN0LmJ1ZmZlcikpIHtcbiAgICB0cmFuc2ZlcnNTZXQuYWRkKG9iamVjdC5idWZmZXIpO1xuICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhvYmplY3QpKSB7fSBlbHNlIGlmIChyZWN1cnNpdmUgJiYgKDAsIF90eXBlb2YyLmRlZmF1bHQpKG9iamVjdCkgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgZ2V0VHJhbnNmZXJMaXN0KG9iamVjdFtrZXldLCByZWN1cnNpdmUsIHRyYW5zZmVyc1NldCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRyYW5zZmVycyA9PT0gdW5kZWZpbmVkID8gQXJyYXkuZnJvbSh0cmFuc2ZlcnNTZXQpIDogW107XG59XG5cbmZ1bmN0aW9uIGlzVHJhbnNmZXJhYmxlKG9iamVjdCkge1xuICBpZiAoIW9iamVjdCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChvYmplY3QgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBNZXNzYWdlUG9ydCAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqZWN0IGluc3RhbmNlb2YgTWVzc2FnZVBvcnQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgSW1hZ2VCaXRtYXAgIT09ICd1bmRlZmluZWQnICYmIG9iamVjdCBpbnN0YW5jZW9mIEltYWdlQml0bWFwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqZWN0IGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtdHJhbnNmZXItbGlzdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnJlbW92ZU5vbnRyYW5zZmVyYWJsZU9wdGlvbnMgPSByZW1vdmVOb250cmFuc2ZlcmFibGVPcHRpb25zO1xuXG52YXIgX3R5cGVvZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKSk7XG5cbmZ1bmN0aW9uIHJlbW92ZU5vbnRyYW5zZmVyYWJsZU9wdGlvbnMob2JqZWN0KSB7XG4gIHJldHVybiBKU09OLnBhcnNlKHN0cmluZ2lmeUpTT04ob2JqZWN0KSk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUpTT04odikge1xuICB2YXIgY2FjaGUgPSBuZXcgU2V0KCk7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh2LCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGlmICgoMCwgX3R5cGVvZjIuZGVmYXVsdCkodmFsdWUpID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNhY2hlLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNhY2hlLmFkZCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW92ZS1ub250cmFuc2ZlcmFibGUtb3B0aW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdGF0c1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc3RhdHMuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdGF0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9zdGF0LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX2dldEhpUmVzVGltZXN0YW1wXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9oaVJlc1RpbWVzdGFtcC5kZWZhdWx0O1xuICB9XG59KTtcblxudmFyIF9zdGF0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbGliL3N0YXRzXCIpKTtcblxudmFyIF9zdGF0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvc3RhdFwiKSk7XG5cbnZhciBfaGlSZXNUaW1lc3RhbXAgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWxzL2hpLXJlcy10aW1lc3RhbXBcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2hpUmVzVGltZXN0YW1wID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdXRpbHMvaGktcmVzLXRpbWVzdGFtcFwiKSk7XG5cbnZhciBTdGF0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdGF0KG5hbWUsIHR5cGUpIHtcbiAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMi5kZWZhdWx0KSh0aGlzLCBTdGF0KTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5zYW1wbGVTaXplID0gMTtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShTdGF0LCBbe1xuICAgIGtleTogXCJzZXRTYW1wbGVTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNhbXBsZVNpemUoc2FtcGxlcykge1xuICAgICAgdGhpcy5zYW1wbGVTaXplID0gc2FtcGxlcztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbmNyZW1lbnRDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmNyZW1lbnRDb3VudCgpIHtcbiAgICAgIHRoaXMuYWRkQ291bnQoMSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVjcmVtZW50Q291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjcmVtZW50Q291bnQoKSB7XG4gICAgICB0aGlzLnN1YnRyYWN0Q291bnQoMSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkQ291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQ291bnQodmFsdWUpIHtcbiAgICAgIHRoaXMuX2NvdW50ICs9IHZhbHVlO1xuICAgICAgdGhpcy5fc2FtcGxlcysrO1xuXG4gICAgICB0aGlzLl9jaGVja1NhbXBsaW5nKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdWJ0cmFjdENvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN1YnRyYWN0Q291bnQodmFsdWUpIHtcbiAgICAgIHRoaXMuX2NvdW50IC09IHZhbHVlO1xuICAgICAgdGhpcy5fc2FtcGxlcysrO1xuXG4gICAgICB0aGlzLl9jaGVja1NhbXBsaW5nKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRUaW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFRpbWUodGltZSkge1xuICAgICAgdGhpcy5fdGltZSArPSB0aW1lO1xuICAgICAgdGhpcy5sYXN0VGltaW5nID0gdGltZTtcbiAgICAgIHRoaXMuX3NhbXBsZXMrKztcblxuICAgICAgdGhpcy5fY2hlY2tTYW1wbGluZygpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGltZVN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRpbWVTdGFydCgpIHtcbiAgICAgIHRoaXMuX3N0YXJ0VGltZSA9ICgwLCBfaGlSZXNUaW1lc3RhbXAuZGVmYXVsdCkoKTtcbiAgICAgIHRoaXMuX3RpbWVyUGVuZGluZyA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGltZUVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aW1lRW5kKCkge1xuICAgICAgaWYgKCF0aGlzLl90aW1lclBlbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWRkVGltZSgoMCwgX2hpUmVzVGltZXN0YW1wLmRlZmF1bHQpKCkgLSB0aGlzLl9zdGFydFRpbWUpO1xuICAgICAgdGhpcy5fdGltZXJQZW5kaW5nID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuX2NoZWNrU2FtcGxpbmcoKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFNhbXBsZUF2ZXJhZ2VDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTYW1wbGVBdmVyYWdlQ291bnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zYW1wbGVTaXplID4gMCA/IHRoaXMubGFzdFNhbXBsZUNvdW50IC8gdGhpcy5zYW1wbGVTaXplIDogMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2FtcGxlQXZlcmFnZVRpbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2FtcGxlQXZlcmFnZVRpbWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zYW1wbGVTaXplID4gMCA/IHRoaXMubGFzdFNhbXBsZVRpbWUgLyB0aGlzLnNhbXBsZVNpemUgOiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTYW1wbGVIelwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTYW1wbGVIeigpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhc3RTYW1wbGVUaW1lID4gMCA/IHRoaXMuc2FtcGxlU2l6ZSAvICh0aGlzLmxhc3RTYW1wbGVUaW1lIC8gMTAwMCkgOiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRBdmVyYWdlQ291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXZlcmFnZUNvdW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2FtcGxlcyA+IDAgPyB0aGlzLmNvdW50IC8gdGhpcy5zYW1wbGVzIDogMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QXZlcmFnZVRpbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXZlcmFnZVRpbWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zYW1wbGVzID4gMCA/IHRoaXMudGltZSAvIHRoaXMuc2FtcGxlcyA6IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEh6XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEh6KCkge1xuICAgICAgcmV0dXJuIHRoaXMudGltZSA+IDAgPyB0aGlzLnNhbXBsZXMgLyAodGhpcy50aW1lIC8gMTAwMCkgOiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMudGltZSA9IDA7XG4gICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgIHRoaXMuc2FtcGxlcyA9IDA7XG4gICAgICB0aGlzLmxhc3RUaW1pbmcgPSAwO1xuICAgICAgdGhpcy5sYXN0U2FtcGxlVGltZSA9IDA7XG4gICAgICB0aGlzLmxhc3RTYW1wbGVDb3VudCA9IDA7XG4gICAgICB0aGlzLl9jb3VudCA9IDA7XG4gICAgICB0aGlzLl90aW1lID0gMDtcbiAgICAgIHRoaXMuX3NhbXBsZXMgPSAwO1xuICAgICAgdGhpcy5fc3RhcnRUaW1lID0gMDtcbiAgICAgIHRoaXMuX3RpbWVyUGVuZGluZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jaGVja1NhbXBsaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja1NhbXBsaW5nKCkge1xuICAgICAgaWYgKHRoaXMuX3NhbXBsZXMgPT09IHRoaXMuc2FtcGxlU2l6ZSkge1xuICAgICAgICB0aGlzLmxhc3RTYW1wbGVUaW1lID0gdGhpcy5fdGltZTtcbiAgICAgICAgdGhpcy5sYXN0U2FtcGxlQ291bnQgPSB0aGlzLl9jb3VudDtcbiAgICAgICAgdGhpcy5jb3VudCArPSB0aGlzLl9jb3VudDtcbiAgICAgICAgdGhpcy50aW1lICs9IHRoaXMuX3RpbWU7XG4gICAgICAgIHRoaXMuc2FtcGxlcyArPSB0aGlzLl9zYW1wbGVzO1xuICAgICAgICB0aGlzLl90aW1lID0gMDtcbiAgICAgICAgdGhpcy5fY291bnQgPSAwO1xuICAgICAgICB0aGlzLl9zYW1wbGVzID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFN0YXQ7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFN0YXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGF0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9zdGF0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zdGF0XCIpKTtcblxudmFyIFN0YXRzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdGF0cyhfcmVmKSB7XG4gICAgdmFyIGlkID0gX3JlZi5pZCxcbiAgICAgICAgc3RhdHMgPSBfcmVmLnN0YXRzO1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syLmRlZmF1bHQpKHRoaXMsIFN0YXRzKTtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5zdGF0cyA9IHt9O1xuXG4gICAgdGhpcy5faW5pdGlhbGl6ZVN0YXRzKHN0YXRzKTtcblxuICAgIE9iamVjdC5zZWFsKHRoaXMpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoU3RhdHMsIFt7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgICAgdmFyIHR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdjb3VudCc7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0T3JDcmVhdGUoe1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB0eXBlOiB0eXBlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2l6ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc3RhdHMpLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5zdGF0cykge1xuICAgICAgICB0aGlzLnN0YXRzW2tleV0ucmVzZXQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvckVhY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9yRWFjaChmbikge1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuc3RhdHMpIHtcbiAgICAgICAgZm4odGhpcy5zdGF0c1trZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VGFibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGFibGUoKSB7XG4gICAgICB2YXIgdGFibGUgPSB7fTtcbiAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoc3RhdCkge1xuICAgICAgICB0YWJsZVtzdGF0Lm5hbWVdID0ge1xuICAgICAgICAgIHRpbWU6IHN0YXQudGltZSB8fCAwLFxuICAgICAgICAgIGNvdW50OiBzdGF0LmNvdW50IHx8IDAsXG4gICAgICAgICAgYXZlcmFnZTogc3RhdC5nZXRBdmVyYWdlVGltZSgpIHx8IDAsXG4gICAgICAgICAgaHo6IHN0YXQuZ2V0SHooKSB8fCAwXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0YWJsZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRpYWxpemVTdGF0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdGlhbGl6ZVN0YXRzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHN0YXRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgICAgIHN0YXRzLmZvckVhY2goZnVuY3Rpb24gKHN0YXQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLl9nZXRPckNyZWF0ZShzdGF0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0T3JDcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldE9yQ3JlYXRlKHN0YXQpIHtcbiAgICAgIGlmICghc3RhdCB8fCAhc3RhdC5uYW1lKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmFtZSA9IHN0YXQubmFtZSxcbiAgICAgICAgICB0eXBlID0gc3RhdC50eXBlO1xuXG4gICAgICBpZiAoIXRoaXMuc3RhdHNbbmFtZV0pIHtcbiAgICAgICAgaWYgKHN0YXQgaW5zdGFuY2VvZiBfc3RhdC5kZWZhdWx0KSB7XG4gICAgICAgICAgdGhpcy5zdGF0c1tuYW1lXSA9IHN0YXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGF0c1tuYW1lXSA9IG5ldyBfc3RhdC5kZWZhdWx0KG5hbWUsIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnN0YXRzW25hbWVdO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU3RhdHM7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFN0YXRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBnZXRIaVJlc1RpbWVzdGFtcDtcblxuZnVuY3Rpb24gZ2V0SGlSZXNUaW1lc3RhbXAoKSB7XG4gIHZhciB0aW1lc3RhbXA7XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wZXJmb3JtYW5jZSkge1xuICAgIHRpbWVzdGFtcCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5ocnRpbWUpIHtcbiAgICB2YXIgdGltZVBhcnRzID0gcHJvY2Vzcy5ocnRpbWUoKTtcbiAgICB0aW1lc3RhbXAgPSB0aW1lUGFydHNbMF0gKiAxMDAwICsgdGltZVBhcnRzWzFdIC8gMWU2O1xuICB9IGVsc2Uge1xuICAgIHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gIH1cblxuICByZXR1cm4gdGltZXN0YW1wO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGktcmVzLXRpbWVzdGFtcC5qcy5tYXAiLCIiLCJtb2R1bGUuZXhwb3J0cyA9IGF0dHJpYnV0ZVRvUHJvcGVydHlcblxudmFyIHRyYW5zZm9ybSA9IHtcbiAgJ2NsYXNzJzogJ2NsYXNzTmFtZScsXG4gICdmb3InOiAnaHRtbEZvcicsXG4gICdodHRwLWVxdWl2JzogJ2h0dHBFcXVpdidcbn1cblxuZnVuY3Rpb24gYXR0cmlidXRlVG9Qcm9wZXJ0eSAoaCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHRhZ05hbWUsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgIGZvciAodmFyIGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgIGlmIChhdHRyIGluIHRyYW5zZm9ybSkge1xuICAgICAgICBhdHRyc1t0cmFuc2Zvcm1bYXR0cl1dID0gYXR0cnNbYXR0cl1cbiAgICAgICAgZGVsZXRlIGF0dHJzW2F0dHJdXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoKHRhZ05hbWUsIGF0dHJzLCBjaGlsZHJlbilcbiAgfVxufVxuIiwidmFyIGF0dHJUb1Byb3AgPSByZXF1aXJlKCdoeXBlcnNjcmlwdC1hdHRyaWJ1dGUtdG8tcHJvcGVydHknKVxuXG52YXIgVkFSID0gMCwgVEVYVCA9IDEsIE9QRU4gPSAyLCBDTE9TRSA9IDMsIEFUVFIgPSA0XG52YXIgQVRUUl9LRVkgPSA1LCBBVFRSX0tFWV9XID0gNlxudmFyIEFUVFJfVkFMVUVfVyA9IDcsIEFUVFJfVkFMVUUgPSA4XG52YXIgQVRUUl9WQUxVRV9TUSA9IDksIEFUVFJfVkFMVUVfRFEgPSAxMFxudmFyIEFUVFJfRVEgPSAxMSwgQVRUUl9CUkVBSyA9IDEyXG52YXIgQ09NTUVOVCA9IDEzXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGgsIG9wdHMpIHtcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cbiAgdmFyIGNvbmNhdCA9IG9wdHMuY29uY2F0IHx8IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIFN0cmluZyhhKSArIFN0cmluZyhiKVxuICB9XG4gIGlmIChvcHRzLmF0dHJUb1Byb3AgIT09IGZhbHNlKSB7XG4gICAgaCA9IGF0dHJUb1Byb3AoaClcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoc3RyaW5ncykge1xuICAgIHZhciBzdGF0ZSA9IFRFWFQsIHJlZyA9ICcnXG4gICAgdmFyIGFyZ2xlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICB2YXIgcGFydHMgPSBbXVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaSA8IGFyZ2xlbiAtIDEpIHtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ3VtZW50c1tpKzFdXG4gICAgICAgIHZhciBwID0gcGFyc2Uoc3RyaW5nc1tpXSlcbiAgICAgICAgdmFyIHhzdGF0ZSA9IHN0YXRlXG4gICAgICAgIGlmICh4c3RhdGUgPT09IEFUVFJfVkFMVUVfRFEpIHhzdGF0ZSA9IEFUVFJfVkFMVUVcbiAgICAgICAgaWYgKHhzdGF0ZSA9PT0gQVRUUl9WQUxVRV9TUSkgeHN0YXRlID0gQVRUUl9WQUxVRVxuICAgICAgICBpZiAoeHN0YXRlID09PSBBVFRSX1ZBTFVFX1cpIHhzdGF0ZSA9IEFUVFJfVkFMVUVcbiAgICAgICAgaWYgKHhzdGF0ZSA9PT0gQVRUUikgeHN0YXRlID0gQVRUUl9LRVlcbiAgICAgICAgaWYgKHhzdGF0ZSA9PT0gT1BFTikge1xuICAgICAgICAgIGlmIChyZWcgPT09ICcvJykge1xuICAgICAgICAgICAgcC5wdXNoKFsgT1BFTiwgJy8nLCBhcmcgXSlcbiAgICAgICAgICAgIHJlZyA9ICcnXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHAucHVzaChbIE9QRU4sIGFyZyBdKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh4c3RhdGUgPT09IENPTU1FTlQgJiYgb3B0cy5jb21tZW50cykge1xuICAgICAgICAgIHJlZyArPSBTdHJpbmcoYXJnKVxuICAgICAgICB9IGVsc2UgaWYgKHhzdGF0ZSAhPT0gQ09NTUVOVCkge1xuICAgICAgICAgIHAucHVzaChbIFZBUiwgeHN0YXRlLCBhcmcgXSlcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoLmFwcGx5KHBhcnRzLCBwKVxuICAgICAgfSBlbHNlIHBhcnRzLnB1c2guYXBwbHkocGFydHMsIHBhcnNlKHN0cmluZ3NbaV0pKVxuICAgIH1cblxuICAgIHZhciB0cmVlID0gW251bGwse30sW11dXG4gICAgdmFyIHN0YWNrID0gW1t0cmVlLC0xXV1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY3VyID0gc3RhY2tbc3RhY2subGVuZ3RoLTFdWzBdXG4gICAgICB2YXIgcCA9IHBhcnRzW2ldLCBzID0gcFswXVxuICAgICAgaWYgKHMgPT09IE9QRU4gJiYgL15cXC8vLnRlc3QocFsxXSkpIHtcbiAgICAgICAgdmFyIGl4ID0gc3RhY2tbc3RhY2subGVuZ3RoLTFdWzFdXG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgc3RhY2sucG9wKClcbiAgICAgICAgICBzdGFja1tzdGFjay5sZW5ndGgtMV1bMF1bMl1baXhdID0gaChcbiAgICAgICAgICAgIGN1clswXSwgY3VyWzFdLCBjdXJbMl0ubGVuZ3RoID8gY3VyWzJdIDogdW5kZWZpbmVkXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHMgPT09IE9QRU4pIHtcbiAgICAgICAgdmFyIGMgPSBbcFsxXSx7fSxbXV1cbiAgICAgICAgY3VyWzJdLnB1c2goYylcbiAgICAgICAgc3RhY2sucHVzaChbYyxjdXJbMl0ubGVuZ3RoLTFdKVxuICAgICAgfSBlbHNlIGlmIChzID09PSBBVFRSX0tFWSB8fCAocyA9PT0gVkFSICYmIHBbMV0gPT09IEFUVFJfS0VZKSkge1xuICAgICAgICB2YXIga2V5ID0gJydcbiAgICAgICAgdmFyIGNvcHlLZXlcbiAgICAgICAgZm9yICg7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChwYXJ0c1tpXVswXSA9PT0gQVRUUl9LRVkpIHtcbiAgICAgICAgICAgIGtleSA9IGNvbmNhdChrZXksIHBhcnRzW2ldWzFdKVxuICAgICAgICAgIH0gZWxzZSBpZiAocGFydHNbaV1bMF0gPT09IFZBUiAmJiBwYXJ0c1tpXVsxXSA9PT0gQVRUUl9LRVkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydHNbaV1bMl0gPT09ICdvYmplY3QnICYmICFrZXkpIHtcbiAgICAgICAgICAgICAgZm9yIChjb3B5S2V5IGluIHBhcnRzW2ldWzJdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzW2ldWzJdLmhhc093blByb3BlcnR5KGNvcHlLZXkpICYmICFjdXJbMV1bY29weUtleV0pIHtcbiAgICAgICAgICAgICAgICAgIGN1clsxXVtjb3B5S2V5XSA9IHBhcnRzW2ldWzJdW2NvcHlLZXldXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBrZXkgPSBjb25jYXQoa2V5LCBwYXJ0c1tpXVsyXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydHNbaV1bMF0gPT09IEFUVFJfRVEpIGkrK1xuICAgICAgICB2YXIgaiA9IGlcbiAgICAgICAgZm9yICg7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChwYXJ0c1tpXVswXSA9PT0gQVRUUl9WQUxVRSB8fCBwYXJ0c1tpXVswXSA9PT0gQVRUUl9LRVkpIHtcbiAgICAgICAgICAgIGlmICghY3VyWzFdW2tleV0pIGN1clsxXVtrZXldID0gc3RyZm4ocGFydHNbaV1bMV0pXG4gICAgICAgICAgICBlbHNlIHBhcnRzW2ldWzFdPT09XCJcIiB8fCAoY3VyWzFdW2tleV0gPSBjb25jYXQoY3VyWzFdW2tleV0sIHBhcnRzW2ldWzFdKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwYXJ0c1tpXVswXSA9PT0gVkFSXG4gICAgICAgICAgJiYgKHBhcnRzW2ldWzFdID09PSBBVFRSX1ZBTFVFIHx8IHBhcnRzW2ldWzFdID09PSBBVFRSX0tFWSkpIHtcbiAgICAgICAgICAgIGlmICghY3VyWzFdW2tleV0pIGN1clsxXVtrZXldID0gc3RyZm4ocGFydHNbaV1bMl0pXG4gICAgICAgICAgICBlbHNlIHBhcnRzW2ldWzJdPT09XCJcIiB8fCAoY3VyWzFdW2tleV0gPSBjb25jYXQoY3VyWzFdW2tleV0sIHBhcnRzW2ldWzJdKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChrZXkubGVuZ3RoICYmICFjdXJbMV1ba2V5XSAmJiBpID09PSBqXG4gICAgICAgICAgICAmJiAocGFydHNbaV1bMF0gPT09IENMT1NFIHx8IHBhcnRzW2ldWzBdID09PSBBVFRSX0JSRUFLKSkge1xuICAgICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmZyYXN0cnVjdHVyZS5odG1sI2Jvb2xlYW4tYXR0cmlidXRlc1xuICAgICAgICAgICAgICAvLyBlbXB0eSBzdHJpbmcgaXMgZmFsc3ksIG5vdCB3ZWxsIGJlaGF2ZWQgdmFsdWUgaW4gYnJvd3NlclxuICAgICAgICAgICAgICBjdXJbMV1ba2V5XSA9IGtleS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFydHNbaV1bMF0gPT09IENMT1NFKSB7XG4gICAgICAgICAgICAgIGktLVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocyA9PT0gQVRUUl9LRVkpIHtcbiAgICAgICAgY3VyWzFdW3BbMV1dID0gdHJ1ZVxuICAgICAgfSBlbHNlIGlmIChzID09PSBWQVIgJiYgcFsxXSA9PT0gQVRUUl9LRVkpIHtcbiAgICAgICAgY3VyWzFdW3BbMl1dID0gdHJ1ZVxuICAgICAgfSBlbHNlIGlmIChzID09PSBDTE9TRSkge1xuICAgICAgICBpZiAoc2VsZkNsb3NpbmcoY3VyWzBdKSAmJiBzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgaXggPSBzdGFja1tzdGFjay5sZW5ndGgtMV1bMV1cbiAgICAgICAgICBzdGFjay5wb3AoKVxuICAgICAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aC0xXVswXVsyXVtpeF0gPSBoKFxuICAgICAgICAgICAgY3VyWzBdLCBjdXJbMV0sIGN1clsyXS5sZW5ndGggPyBjdXJbMl0gOiB1bmRlZmluZWRcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocyA9PT0gVkFSICYmIHBbMV0gPT09IFRFWFQpIHtcbiAgICAgICAgaWYgKHBbMl0gPT09IHVuZGVmaW5lZCB8fCBwWzJdID09PSBudWxsKSBwWzJdID0gJydcbiAgICAgICAgZWxzZSBpZiAoIXBbMl0pIHBbMl0gPSBjb25jYXQoJycsIHBbMl0pXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBbMl1bMF0pKSB7XG4gICAgICAgICAgY3VyWzJdLnB1c2guYXBwbHkoY3VyWzJdLCBwWzJdKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1clsyXS5wdXNoKHBbMl0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocyA9PT0gVEVYVCkge1xuICAgICAgICBjdXJbMl0ucHVzaChwWzFdKVxuICAgICAgfSBlbHNlIGlmIChzID09PSBBVFRSX0VRIHx8IHMgPT09IEFUVFJfQlJFQUspIHtcbiAgICAgICAgLy8gbm8tb3BcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5oYW5kbGVkOiAnICsgcylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHJlZVsyXS5sZW5ndGggPiAxICYmIC9eXFxzKiQvLnRlc3QodHJlZVsyXVswXSkpIHtcbiAgICAgIHRyZWVbMl0uc2hpZnQoKVxuICAgIH1cblxuICAgIGlmICh0cmVlWzJdLmxlbmd0aCA+IDJcbiAgICB8fCAodHJlZVsyXS5sZW5ndGggPT09IDIgJiYgL1xcUy8udGVzdCh0cmVlWzJdWzFdKSkpIHtcbiAgICAgIGlmIChvcHRzLmNyZWF0ZUZyYWdtZW50KSByZXR1cm4gb3B0cy5jcmVhdGVGcmFnbWVudCh0cmVlWzJdKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnbXVsdGlwbGUgcm9vdCBlbGVtZW50cyBtdXN0IGJlIHdyYXBwZWQgaW4gYW4gZW5jbG9zaW5nIHRhZydcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHJlZVsyXVswXSkgJiYgdHlwZW9mIHRyZWVbMl1bMF1bMF0gPT09ICdzdHJpbmcnXG4gICAgJiYgQXJyYXkuaXNBcnJheSh0cmVlWzJdWzBdWzJdKSkge1xuICAgICAgdHJlZVsyXVswXSA9IGgodHJlZVsyXVswXVswXSwgdHJlZVsyXVswXVsxXSwgdHJlZVsyXVswXVsyXSlcbiAgICB9XG4gICAgcmV0dXJuIHRyZWVbMl1bMF1cblxuICAgIGZ1bmN0aW9uIHBhcnNlIChzdHIpIHtcbiAgICAgIHZhciByZXMgPSBbXVxuICAgICAgaWYgKHN0YXRlID09PSBBVFRSX1ZBTFVFX1cpIHN0YXRlID0gQVRUUlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gVEVYVCAmJiBjID09PSAnPCcpIHtcbiAgICAgICAgICBpZiAocmVnLmxlbmd0aCkgcmVzLnB1c2goW1RFWFQsIHJlZ10pXG4gICAgICAgICAgcmVnID0gJydcbiAgICAgICAgICBzdGF0ZSA9IE9QRU5cbiAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPicgJiYgIXF1b3Qoc3RhdGUpICYmIHN0YXRlICE9PSBDT01NRU5UKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBPUEVOICYmIHJlZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKFtPUEVOLHJlZ10pXG4gICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQVRUUl9LRVkpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKFtBVFRSX0tFWSxyZWddKVxuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IEFUVFJfVkFMVUUgJiYgcmVnLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzLnB1c2goW0FUVFJfVkFMVUUscmVnXSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzLnB1c2goW0NMT1NFXSlcbiAgICAgICAgICByZWcgPSAnJ1xuICAgICAgICAgIHN0YXRlID0gVEVYVFxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBDT01NRU5UICYmIC8tJC8udGVzdChyZWcpICYmIGMgPT09ICctJykge1xuICAgICAgICAgIGlmIChvcHRzLmNvbW1lbnRzKSB7XG4gICAgICAgICAgICByZXMucHVzaChbQVRUUl9WQUxVRSxyZWcuc3Vic3RyKDAsIHJlZy5sZW5ndGggLSAxKV0pXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlZyA9ICcnXG4gICAgICAgICAgc3RhdGUgPSBURVhUXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IE9QRU4gJiYgL14hLS0kLy50ZXN0KHJlZykpIHtcbiAgICAgICAgICBpZiAob3B0cy5jb21tZW50cykge1xuICAgICAgICAgICAgcmVzLnB1c2goW09QRU4sIHJlZ10sW0FUVFJfS0VZLCdjb21tZW50J10sW0FUVFJfRVFdKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZWcgPSBjXG4gICAgICAgICAgc3RhdGUgPSBDT01NRU5UXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IFRFWFQgfHwgc3RhdGUgPT09IENPTU1FTlQpIHtcbiAgICAgICAgICByZWcgKz0gY1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBPUEVOICYmIGMgPT09ICcvJyAmJiByZWcubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gbm8tb3AsIHNlbGYgY2xvc2luZyB0YWcgd2l0aG91dCBhIHNwYWNlIDxici8+XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IE9QRU4gJiYgL1xccy8udGVzdChjKSkge1xuICAgICAgICAgIGlmIChyZWcubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXMucHVzaChbT1BFTiwgcmVnXSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVnID0gJydcbiAgICAgICAgICBzdGF0ZSA9IEFUVFJcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gT1BFTikge1xuICAgICAgICAgIHJlZyArPSBjXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IEFUVFIgJiYgL1teXFxzXCInPS9dLy50ZXN0KGMpKSB7XG4gICAgICAgICAgc3RhdGUgPSBBVFRSX0tFWVxuICAgICAgICAgIHJlZyA9IGNcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQVRUUiAmJiAvXFxzLy50ZXN0KGMpKSB7XG4gICAgICAgICAgaWYgKHJlZy5sZW5ndGgpIHJlcy5wdXNoKFtBVFRSX0tFWSxyZWddKVxuICAgICAgICAgIHJlcy5wdXNoKFtBVFRSX0JSRUFLXSlcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQVRUUl9LRVkgJiYgL1xccy8udGVzdChjKSkge1xuICAgICAgICAgIHJlcy5wdXNoKFtBVFRSX0tFWSxyZWddKVxuICAgICAgICAgIHJlZyA9ICcnXG4gICAgICAgICAgc3RhdGUgPSBBVFRSX0tFWV9XXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IEFUVFJfS0VZICYmIGMgPT09ICc9Jykge1xuICAgICAgICAgIHJlcy5wdXNoKFtBVFRSX0tFWSxyZWddLFtBVFRSX0VRXSlcbiAgICAgICAgICByZWcgPSAnJ1xuICAgICAgICAgIHN0YXRlID0gQVRUUl9WQUxVRV9XXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IEFUVFJfS0VZKSB7XG4gICAgICAgICAgcmVnICs9IGNcbiAgICAgICAgfSBlbHNlIGlmICgoc3RhdGUgPT09IEFUVFJfS0VZX1cgfHwgc3RhdGUgPT09IEFUVFIpICYmIGMgPT09ICc9Jykge1xuICAgICAgICAgIHJlcy5wdXNoKFtBVFRSX0VRXSlcbiAgICAgICAgICBzdGF0ZSA9IEFUVFJfVkFMVUVfV1xuICAgICAgICB9IGVsc2UgaWYgKChzdGF0ZSA9PT0gQVRUUl9LRVlfVyB8fCBzdGF0ZSA9PT0gQVRUUikgJiYgIS9cXHMvLnRlc3QoYykpIHtcbiAgICAgICAgICByZXMucHVzaChbQVRUUl9CUkVBS10pXG4gICAgICAgICAgaWYgKC9bXFx3LV0vLnRlc3QoYykpIHtcbiAgICAgICAgICAgIHJlZyArPSBjXG4gICAgICAgICAgICBzdGF0ZSA9IEFUVFJfS0VZXG4gICAgICAgICAgfSBlbHNlIHN0YXRlID0gQVRUUlxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBBVFRSX1ZBTFVFX1cgJiYgYyA9PT0gJ1wiJykge1xuICAgICAgICAgIHN0YXRlID0gQVRUUl9WQUxVRV9EUVxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBBVFRSX1ZBTFVFX1cgJiYgYyA9PT0gXCInXCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEFUVFJfVkFMVUVfU1FcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQVRUUl9WQUxVRV9EUSAmJiBjID09PSAnXCInKSB7XG4gICAgICAgICAgcmVzLnB1c2goW0FUVFJfVkFMVUUscmVnXSxbQVRUUl9CUkVBS10pXG4gICAgICAgICAgcmVnID0gJydcbiAgICAgICAgICBzdGF0ZSA9IEFUVFJcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQVRUUl9WQUxVRV9TUSAmJiBjID09PSBcIidcIikge1xuICAgICAgICAgIHJlcy5wdXNoKFtBVFRSX1ZBTFVFLHJlZ10sW0FUVFJfQlJFQUtdKVxuICAgICAgICAgIHJlZyA9ICcnXG4gICAgICAgICAgc3RhdGUgPSBBVFRSXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IEFUVFJfVkFMVUVfVyAmJiAhL1xccy8udGVzdChjKSkge1xuICAgICAgICAgIHN0YXRlID0gQVRUUl9WQUxVRVxuICAgICAgICAgIGktLVxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBBVFRSX1ZBTFVFICYmIC9cXHMvLnRlc3QoYykpIHtcbiAgICAgICAgICByZXMucHVzaChbQVRUUl9WQUxVRSxyZWddLFtBVFRSX0JSRUFLXSlcbiAgICAgICAgICByZWcgPSAnJ1xuICAgICAgICAgIHN0YXRlID0gQVRUUlxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBBVFRSX1ZBTFVFIHx8IHN0YXRlID09PSBBVFRSX1ZBTFVFX1NRXG4gICAgICAgIHx8IHN0YXRlID09PSBBVFRSX1ZBTFVFX0RRKSB7XG4gICAgICAgICAgcmVnICs9IGNcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YXRlID09PSBURVhUICYmIHJlZy5sZW5ndGgpIHtcbiAgICAgICAgcmVzLnB1c2goW1RFWFQscmVnXSlcbiAgICAgICAgcmVnID0gJydcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IEFUVFJfVkFMVUUgJiYgcmVnLmxlbmd0aCkge1xuICAgICAgICByZXMucHVzaChbQVRUUl9WQUxVRSxyZWddKVxuICAgICAgICByZWcgPSAnJ1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQVRUUl9WQUxVRV9EUSAmJiByZWcubGVuZ3RoKSB7XG4gICAgICAgIHJlcy5wdXNoKFtBVFRSX1ZBTFVFLHJlZ10pXG4gICAgICAgIHJlZyA9ICcnXG4gICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBBVFRSX1ZBTFVFX1NRICYmIHJlZy5sZW5ndGgpIHtcbiAgICAgICAgcmVzLnB1c2goW0FUVFJfVkFMVUUscmVnXSlcbiAgICAgICAgcmVnID0gJydcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IEFUVFJfS0VZKSB7XG4gICAgICAgIHJlcy5wdXNoKFtBVFRSX0tFWSxyZWddKVxuICAgICAgICByZWcgPSAnJ1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmZuICh4KSB7XG4gICAgaWYgKHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nKSByZXR1cm4geFxuICAgIGVsc2UgaWYgKHR5cGVvZiB4ID09PSAnc3RyaW5nJykgcmV0dXJuIHhcbiAgICBlbHNlIGlmICh4ICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0JykgcmV0dXJuIHhcbiAgICBlbHNlIGlmICh4ID09PSBudWxsIHx8IHggPT09IHVuZGVmaW5lZCkgcmV0dXJuIHhcbiAgICBlbHNlIHJldHVybiBjb25jYXQoJycsIHgpXG4gIH1cbn1cblxuZnVuY3Rpb24gcXVvdCAoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlID09PSBBVFRSX1ZBTFVFX1NRIHx8IHN0YXRlID09PSBBVFRSX1ZBTFVFX0RRXG59XG5cbnZhciBjbG9zZVJFID0gUmVnRXhwKCdeKCcgKyBbXG4gICdhcmVhJywgJ2Jhc2UnLCAnYmFzZWZvbnQnLCAnYmdzb3VuZCcsICdicicsICdjb2wnLCAnY29tbWFuZCcsICdlbWJlZCcsXG4gICdmcmFtZScsICdocicsICdpbWcnLCAnaW5wdXQnLCAnaXNpbmRleCcsICdrZXlnZW4nLCAnbGluaycsICdtZXRhJywgJ3BhcmFtJyxcbiAgJ3NvdXJjZScsICd0cmFjaycsICd3YnInLCAnIS0tJyxcbiAgLy8gU1ZHIFRBR1NcbiAgJ2FuaW1hdGUnLCAnYW5pbWF0ZVRyYW5zZm9ybScsICdjaXJjbGUnLCAnY3Vyc29yJywgJ2Rlc2MnLCAnZWxsaXBzZScsXG4gICdmZUJsZW5kJywgJ2ZlQ29sb3JNYXRyaXgnLCAnZmVDb21wb3NpdGUnLFxuICAnZmVDb252b2x2ZU1hdHJpeCcsICdmZURpZmZ1c2VMaWdodGluZycsICdmZURpc3BsYWNlbWVudE1hcCcsXG4gICdmZURpc3RhbnRMaWdodCcsICdmZUZsb29kJywgJ2ZlRnVuY0EnLCAnZmVGdW5jQicsICdmZUZ1bmNHJywgJ2ZlRnVuY1InLFxuICAnZmVHYXVzc2lhbkJsdXInLCAnZmVJbWFnZScsICdmZU1lcmdlTm9kZScsICdmZU1vcnBob2xvZ3knLFxuICAnZmVPZmZzZXQnLCAnZmVQb2ludExpZ2h0JywgJ2ZlU3BlY3VsYXJMaWdodGluZycsICdmZVNwb3RMaWdodCcsICdmZVRpbGUnLFxuICAnZmVUdXJidWxlbmNlJywgJ2ZvbnQtZmFjZS1mb3JtYXQnLCAnZm9udC1mYWNlLW5hbWUnLCAnZm9udC1mYWNlLXVyaScsXG4gICdnbHlwaCcsICdnbHlwaFJlZicsICdoa2VybicsICdpbWFnZScsICdsaW5lJywgJ21pc3NpbmctZ2x5cGgnLCAnbXBhdGgnLFxuICAncGF0aCcsICdwb2x5Z29uJywgJ3BvbHlsaW5lJywgJ3JlY3QnLCAnc2V0JywgJ3N0b3AnLCAndHJlZicsICd1c2UnLCAndmlldycsXG4gICd2a2Vybidcbl0uam9pbignfCcpICsgJykoPzpbXFwuI11bYS16QS1aMC05XFx1MDA3Ri1cXHVGRkZGXzotXSspKiQnKVxuZnVuY3Rpb24gc2VsZkNsb3NpbmcgKHRhZykgeyByZXR1cm4gY2xvc2VSRS50ZXN0KHRhZykgfVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciB0cmFpbGluZ05ld2xpbmVSZWdleCA9IC9cXG5bXFxzXSskL1xudmFyIGxlYWRpbmdOZXdsaW5lUmVnZXggPSAvXlxcbltcXHNdKy9cbnZhciB0cmFpbGluZ1NwYWNlUmVnZXggPSAvW1xcc10rJC9cbnZhciBsZWFkaW5nU3BhY2VSZWdleCA9IC9eW1xcc10rL1xudmFyIG11bHRpU3BhY2VSZWdleCA9IC9bXFxuXFxzXSsvZ1xuXG52YXIgVEVYVF9UQUdTID0gW1xuICAnYScsICdhYmJyJywgJ2InLCAnYmRpJywgJ2JkbycsICdicicsICdjaXRlJywgJ2RhdGEnLCAnZGZuJywgJ2VtJywgJ2knLFxuICAna2JkJywgJ21hcmsnLCAncScsICdycCcsICdydCcsICdydGMnLCAncnVieScsICdzJywgJ2FtcCcsICdzbWFsbCcsICdzcGFuJyxcbiAgJ3N0cm9uZycsICdzdWInLCAnc3VwJywgJ3RpbWUnLCAndScsICd2YXInLCAnd2JyJ1xuXVxuXG52YXIgVkVSQkFUSU1fVEFHUyA9IFtcbiAgJ2NvZGUnLCAncHJlJywgJ3RleHRhcmVhJ1xuXVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFwcGVuZENoaWxkIChlbCwgY2hpbGRzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShjaGlsZHMpKSByZXR1cm5cblxuICB2YXIgbm9kZU5hbWUgPSBlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXG5cbiAgdmFyIGhhZFRleHQgPSBmYWxzZVxuICB2YXIgdmFsdWUsIGxlYWRlclxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaGlsZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IGNoaWxkc1tpXVxuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgICBhcHBlbmRDaGlsZChlbCwgbm9kZSlcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBub2RlID09PSAnbnVtYmVyJyB8fFxuICAgICAgdHlwZW9mIG5vZGUgPT09ICdib29sZWFuJyB8fFxuICAgICAgdHlwZW9mIG5vZGUgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIG5vZGUgaW5zdGFuY2VvZiBEYXRlIHx8XG4gICAgICBub2RlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICBub2RlID0gbm9kZS50b1N0cmluZygpXG4gICAgfVxuXG4gICAgdmFyIGxhc3RDaGlsZCA9IGVsLmNoaWxkTm9kZXNbZWwuY2hpbGROb2Rlcy5sZW5ndGggLSAxXVxuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRleHQgbm9kZXNcbiAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBoYWRUZXh0ID0gdHJ1ZVxuXG4gICAgICAvLyBJZiB3ZSBhbHJlYWR5IGhhZCB0ZXh0LCBhcHBlbmQgdG8gdGhlIGV4aXN0aW5nIHRleHRcbiAgICAgIGlmIChsYXN0Q2hpbGQgJiYgbGFzdENoaWxkLm5vZGVOYW1lID09PSAnI3RleHQnKSB7XG4gICAgICAgIGxhc3RDaGlsZC5ub2RlVmFsdWUgKz0gbm9kZVxuXG4gICAgICAvLyBXZSBkaWRuJ3QgaGF2ZSBhIHRleHQgbm9kZSB5ZXQsIGNyZWF0ZSBvbmVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBlbC5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGUpXG4gICAgICAgIGVsLmFwcGVuZENoaWxkKG5vZGUpXG4gICAgICAgIGxhc3RDaGlsZCA9IG5vZGVcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgbGFzdCBvZiB0aGUgY2hpbGQgbm9kZXMsIG1ha2Ugc3VyZSB3ZSBjbG9zZSBpdCBvdXRcbiAgICAgIC8vIHJpZ2h0XG4gICAgICBpZiAoaSA9PT0gbGVuIC0gMSkge1xuICAgICAgICBoYWRUZXh0ID0gZmFsc2VcbiAgICAgICAgLy8gVHJpbSB0aGUgY2hpbGQgdGV4dCBub2RlcyBpZiB0aGUgY3VycmVudCBub2RlIGlzbid0IGFcbiAgICAgICAgLy8gbm9kZSB3aGVyZSB3aGl0ZXNwYWNlIG1hdHRlcnMuXG4gICAgICAgIGlmIChURVhUX1RBR1MuaW5kZXhPZihub2RlTmFtZSkgPT09IC0xICYmXG4gICAgICAgICAgVkVSQkFUSU1fVEFHUy5pbmRleE9mKG5vZGVOYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICB2YWx1ZSA9IGxhc3RDaGlsZC5ub2RlVmFsdWVcbiAgICAgICAgICAgIC5yZXBsYWNlKGxlYWRpbmdOZXdsaW5lUmVnZXgsICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UodHJhaWxpbmdTcGFjZVJlZ2V4LCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKHRyYWlsaW5nTmV3bGluZVJlZ2V4LCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKG11bHRpU3BhY2VSZWdleCwgJyAnKVxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUNoaWxkKGxhc3RDaGlsZClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdENoaWxkLm5vZGVWYWx1ZSA9IHZhbHVlXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKFZFUkJBVElNX1RBR1MuaW5kZXhPZihub2RlTmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgLy8gVGhlIHZlcnkgZmlyc3Qgbm9kZSBpbiB0aGUgbGlzdCBzaG91bGQgbm90IGhhdmUgbGVhZGluZ1xuICAgICAgICAgIC8vIHdoaXRlc3BhY2UuIFNpYmxpbmcgdGV4dCBub2RlcyBzaG91bGQgaGF2ZSB3aGl0ZXNwYWNlIGlmIHRoZXJlXG4gICAgICAgICAgLy8gd2FzIGFueS5cbiAgICAgICAgICBsZWFkZXIgPSBpID09PSAwID8gJycgOiAnICdcbiAgICAgICAgICB2YWx1ZSA9IGxhc3RDaGlsZC5ub2RlVmFsdWVcbiAgICAgICAgICAgIC5yZXBsYWNlKGxlYWRpbmdOZXdsaW5lUmVnZXgsIGxlYWRlcilcbiAgICAgICAgICAgIC5yZXBsYWNlKGxlYWRpbmdTcGFjZVJlZ2V4LCAnICcpXG4gICAgICAgICAgICAucmVwbGFjZSh0cmFpbGluZ1NwYWNlUmVnZXgsICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UodHJhaWxpbmdOZXdsaW5lUmVnZXgsICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UobXVsdGlTcGFjZVJlZ2V4LCAnICcpXG4gICAgICAgICAgbGFzdENoaWxkLm5vZGVWYWx1ZSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIC8vIEl0ZXJhdGUgb3ZlciBET00gbm9kZXNcbiAgICB9IGVsc2UgaWYgKG5vZGUgJiYgbm9kZS5ub2RlVHlwZSkge1xuICAgICAgLy8gSWYgdGhlIGxhc3Qgbm9kZSB3YXMgYSB0ZXh0IG5vZGUsIG1ha2Ugc3VyZSBpdCBpcyBwcm9wZXJseSBjbG9zZWQgb3V0XG4gICAgICBpZiAoaGFkVGV4dCkge1xuICAgICAgICBoYWRUZXh0ID0gZmFsc2VcblxuICAgICAgICAvLyBUcmltIHRoZSBjaGlsZCB0ZXh0IG5vZGVzIGlmIHRoZSBjdXJyZW50IG5vZGUgaXNuJ3QgYVxuICAgICAgICAvLyB0ZXh0IG5vZGUgb3IgYSBjb2RlIG5vZGVcbiAgICAgICAgaWYgKFRFWFRfVEFHUy5pbmRleE9mKG5vZGVOYW1lKSA9PT0gLTEgJiZcbiAgICAgICAgICBWRVJCQVRJTV9UQUdTLmluZGV4T2Yobm9kZU5hbWUpID09PSAtMSkge1xuICAgICAgICAgIHZhbHVlID0gbGFzdENoaWxkLm5vZGVWYWx1ZVxuICAgICAgICAgICAgLnJlcGxhY2UobGVhZGluZ05ld2xpbmVSZWdleCwgJycpXG4gICAgICAgICAgICAucmVwbGFjZSh0cmFpbGluZ05ld2xpbmVSZWdleCwgJyAnKVxuICAgICAgICAgICAgLnJlcGxhY2UobXVsdGlTcGFjZVJlZ2V4LCAnICcpXG5cbiAgICAgICAgICAvLyBSZW1vdmUgZW1wdHkgdGV4dCBub2RlcywgYXBwZW5kIG90aGVyd2lzZVxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUNoaWxkKGxhc3RDaGlsZClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdENoaWxkLm5vZGVWYWx1ZSA9IHZhbHVlXG4gICAgICAgICAgfVxuICAgICAgICAvLyBUcmltIHRoZSBjaGlsZCBub2RlcyBidXQgcHJlc2VydmUgdGhlIGFwcHJvcHJpYXRlIHdoaXRlc3BhY2VcbiAgICAgICAgfSBlbHNlIGlmIChWRVJCQVRJTV9UQUdTLmluZGV4T2Yobm9kZU5hbWUpID09PSAtMSkge1xuICAgICAgICAgIHZhbHVlID0gbGFzdENoaWxkLm5vZGVWYWx1ZVxuICAgICAgICAgICAgLnJlcGxhY2UobGVhZGluZ1NwYWNlUmVnZXgsICcgJylcbiAgICAgICAgICAgIC5yZXBsYWNlKGxlYWRpbmdOZXdsaW5lUmVnZXgsICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UodHJhaWxpbmdOZXdsaW5lUmVnZXgsICcgJylcbiAgICAgICAgICAgIC5yZXBsYWNlKG11bHRpU3BhY2VSZWdleCwgJyAnKVxuICAgICAgICAgIGxhc3RDaGlsZC5ub2RlVmFsdWUgPSB2YWx1ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFN0b3JlIHRoZSBsYXN0IG5vZGVuYW1lXG4gICAgICB2YXIgX25vZGVOYW1lID0gbm9kZS5ub2RlTmFtZVxuICAgICAgaWYgKF9ub2RlTmFtZSkgbm9kZU5hbWUgPSBfbm9kZU5hbWUudG9Mb3dlckNhc2UoKVxuXG4gICAgICAvLyBBcHBlbmQgdGhlIG5vZGUgdG8gdGhlIERPTVxuICAgICAgZWwuYXBwZW5kQ2hpbGQobm9kZSlcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgJ2FzeW5jJywgJ2F1dG9mb2N1cycsICdhdXRvcGxheScsICdjaGVja2VkJywgJ2NvbnRyb2xzJywgJ2RlZmF1bHQnLFxuICAnZGVmYXVsdGNoZWNrZWQnLCAnZGVmZXInLCAnZGlzYWJsZWQnLCAnZm9ybW5vdmFsaWRhdGUnLCAnaGlkZGVuJyxcbiAgJ2lzbWFwJywgJ2xvb3AnLCAnbXVsdGlwbGUnLCAnbXV0ZWQnLCAnbm92YWxpZGF0ZScsICdvcGVuJywgJ3BsYXlzaW5saW5lJyxcbiAgJ3JlYWRvbmx5JywgJ3JlcXVpcmVkJywgJ3JldmVyc2VkJywgJ3NlbGVjdGVkJ1xuXVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RvbScpKGRvY3VtZW50KVxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gW1xuICAnaW5kZXRlcm1pbmF0ZSdcbl1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgaHlwZXJ4ID0gcmVxdWlyZSgnaHlwZXJ4JylcbnZhciBhcHBlbmRDaGlsZCA9IHJlcXVpcmUoJy4vYXBwZW5kLWNoaWxkJylcbnZhciBTVkdfVEFHUyA9IHJlcXVpcmUoJy4vc3ZnLXRhZ3MnKVxudmFyIEJPT0xfUFJPUFMgPSByZXF1aXJlKCcuL2Jvb2wtcHJvcHMnKVxuLy8gUHJvcHMgdGhhdCBuZWVkIHRvIGJlIHNldCBkaXJlY3RseSByYXRoZXIgdGhhbiB3aXRoIGVsLnNldEF0dHJpYnV0ZSgpXG52YXIgRElSRUNUX1BST1BTID0gcmVxdWlyZSgnLi9kaXJlY3QtcHJvcHMnKVxuXG52YXIgU1ZHTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnXG52YXIgWExJTktOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJ1xuXG52YXIgQ09NTUVOVF9UQUcgPSAnIS0tJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb2N1bWVudCkge1xuICBmdW5jdGlvbiBuYW5vSHRtbENyZWF0ZUVsZW1lbnQgKHRhZywgcHJvcHMsIGNoaWxkcmVuKSB7XG4gICAgdmFyIGVsXG5cbiAgICAvLyBJZiBhbiBzdmcgdGFnLCBpdCBuZWVkcyBhIG5hbWVzcGFjZVxuICAgIGlmIChTVkdfVEFHUy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBwcm9wcy5uYW1lc3BhY2UgPSBTVkdOU1xuICAgIH1cblxuICAgIC8vIElmIHdlIGFyZSB1c2luZyBhIG5hbWVzcGFjZVxuICAgIHZhciBucyA9IGZhbHNlXG4gICAgaWYgKHByb3BzLm5hbWVzcGFjZSkge1xuICAgICAgbnMgPSBwcm9wcy5uYW1lc3BhY2VcbiAgICAgIGRlbGV0ZSBwcm9wcy5uYW1lc3BhY2VcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBhcmUgZXh0ZW5kaW5nIGEgYnVpbHRpbiBlbGVtZW50XG4gICAgdmFyIGlzQ3VzdG9tRWxlbWVudCA9IGZhbHNlXG4gICAgaWYgKHByb3BzLmlzKSB7XG4gICAgICBpc0N1c3RvbUVsZW1lbnQgPSBwcm9wcy5pc1xuICAgICAgZGVsZXRlIHByb3BzLmlzXG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIHRoZSBlbGVtZW50XG4gICAgaWYgKG5zKSB7XG4gICAgICBpZiAoaXNDdXN0b21FbGVtZW50KSB7XG4gICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCB0YWcsIHsgaXM6IGlzQ3VzdG9tRWxlbWVudCB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsIHRhZylcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gQ09NTUVOVF9UQUcpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHByb3BzLmNvbW1lbnQpXG4gICAgfSBlbHNlIGlmIChpc0N1c3RvbUVsZW1lbnQpIHtcbiAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcsIHsgaXM6IGlzQ3VzdG9tRWxlbWVudCB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKVxuICAgIH1cblxuICAgIC8vIENyZWF0ZSB0aGUgcHJvcGVydGllc1xuICAgIGZvciAodmFyIHAgaW4gcHJvcHMpIHtcbiAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICB2YXIga2V5ID0gcC50b0xvd2VyQ2FzZSgpXG4gICAgICAgIHZhciB2YWwgPSBwcm9wc1twXVxuICAgICAgICAvLyBOb3JtYWxpemUgY2xhc3NOYW1lXG4gICAgICAgIGlmIChrZXkgPT09ICdjbGFzc25hbWUnKSB7XG4gICAgICAgICAga2V5ID0gJ2NsYXNzJ1xuICAgICAgICAgIHAgPSAnY2xhc3MnXG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGZvciBhdHRyaWJ1dGUgZ2V0cyB0cmFuc2Zvcm1lZCB0byBodG1sRm9yLCBidXQgd2UganVzdCBzZXQgYXMgZm9yXG4gICAgICAgIGlmIChwID09PSAnaHRtbEZvcicpIHtcbiAgICAgICAgICBwID0gJ2ZvcidcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhIHByb3BlcnR5IGlzIGJvb2xlYW4sIHNldCBpdHNlbGYgdG8gdGhlIGtleVxuICAgICAgICBpZiAoQk9PTF9QUk9QUy5pbmRleE9mKGtleSkgIT09IC0xKSB7XG4gICAgICAgICAgaWYgKFN0cmluZyh2YWwpID09PSAndHJ1ZScpIHZhbCA9IGtleVxuICAgICAgICAgIGVsc2UgaWYgKFN0cmluZyh2YWwpID09PSAnZmFsc2UnKSBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIGEgcHJvcGVydHkgcHJlZmVycyBiZWluZyBzZXQgZGlyZWN0bHkgdnMgc2V0QXR0cmlidXRlXG4gICAgICAgIGlmIChrZXkuc2xpY2UoMCwgMikgPT09ICdvbicgfHwgRElSRUNUX1BST1BTLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcbiAgICAgICAgICBlbFtwXSA9IHZhbFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChucykge1xuICAgICAgICAgICAgaWYgKHAgPT09ICd4bGluazpocmVmJykge1xuICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGVOUyhYTElOS05TLCBwLCB2YWwpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKC9eeG1sbnMoJHw6KS9pLnRlc3QocCkpIHtcbiAgICAgICAgICAgICAgLy8gc2tpcCB4bWxucyBkZWZpbml0aW9uc1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlTlMobnVsbCwgcCwgdmFsKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUocCwgdmFsKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGFwcGVuZENoaWxkKGVsLCBjaGlsZHJlbilcbiAgICByZXR1cm4gZWxcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50IChub2Rlcykge1xuICAgIHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChub2Rlc1tpXSA9PSBudWxsKSBjb250aW51ZVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZXNbaV0pKSB7XG4gICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGNyZWF0ZUZyYWdtZW50KG5vZGVzW2ldKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZXNbaV0gPT09ICdzdHJpbmcnKSBub2Rlc1tpXSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGVzW2ldKVxuICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChub2Rlc1tpXSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50XG4gIH1cblxuICB2YXIgZXhwb3J0cyA9IGh5cGVyeChuYW5vSHRtbENyZWF0ZUVsZW1lbnQsIHtcbiAgICBjb21tZW50czogdHJ1ZSxcbiAgICBjcmVhdGVGcmFnbWVudDogY3JlYXRlRnJhZ21lbnRcbiAgfSlcbiAgZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0c1xuICBleHBvcnRzLmNyZWF0ZUNvbW1lbnQgPSBuYW5vSHRtbENyZWF0ZUVsZW1lbnRcbiAgcmV0dXJuIGV4cG9ydHNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgJ3N2ZycsICdhbHRHbHlwaCcsICdhbHRHbHlwaERlZicsICdhbHRHbHlwaEl0ZW0nLCAnYW5pbWF0ZScsICdhbmltYXRlQ29sb3InLFxuICAnYW5pbWF0ZU1vdGlvbicsICdhbmltYXRlVHJhbnNmb3JtJywgJ2NpcmNsZScsICdjbGlwUGF0aCcsICdjb2xvci1wcm9maWxlJyxcbiAgJ2N1cnNvcicsICdkZWZzJywgJ2Rlc2MnLCAnZWxsaXBzZScsICdmZUJsZW5kJywgJ2ZlQ29sb3JNYXRyaXgnLFxuICAnZmVDb21wb25lbnRUcmFuc2ZlcicsICdmZUNvbXBvc2l0ZScsICdmZUNvbnZvbHZlTWF0cml4JyxcbiAgJ2ZlRGlmZnVzZUxpZ2h0aW5nJywgJ2ZlRGlzcGxhY2VtZW50TWFwJywgJ2ZlRGlzdGFudExpZ2h0JywgJ2ZlRmxvb2QnLFxuICAnZmVGdW5jQScsICdmZUZ1bmNCJywgJ2ZlRnVuY0cnLCAnZmVGdW5jUicsICdmZUdhdXNzaWFuQmx1cicsICdmZUltYWdlJyxcbiAgJ2ZlTWVyZ2UnLCAnZmVNZXJnZU5vZGUnLCAnZmVNb3JwaG9sb2d5JywgJ2ZlT2Zmc2V0JywgJ2ZlUG9pbnRMaWdodCcsXG4gICdmZVNwZWN1bGFyTGlnaHRpbmcnLCAnZmVTcG90TGlnaHQnLCAnZmVUaWxlJywgJ2ZlVHVyYnVsZW5jZScsICdmaWx0ZXInLFxuICAnZm9udCcsICdmb250LWZhY2UnLCAnZm9udC1mYWNlLWZvcm1hdCcsICdmb250LWZhY2UtbmFtZScsICdmb250LWZhY2Utc3JjJyxcbiAgJ2ZvbnQtZmFjZS11cmknLCAnZm9yZWlnbk9iamVjdCcsICdnJywgJ2dseXBoJywgJ2dseXBoUmVmJywgJ2hrZXJuJywgJ2ltYWdlJyxcbiAgJ2xpbmUnLCAnbGluZWFyR3JhZGllbnQnLCAnbWFya2VyJywgJ21hc2snLCAnbWV0YWRhdGEnLCAnbWlzc2luZy1nbHlwaCcsXG4gICdtcGF0aCcsICdwYXRoJywgJ3BhdHRlcm4nLCAncG9seWdvbicsICdwb2x5bGluZScsICdyYWRpYWxHcmFkaWVudCcsICdyZWN0JyxcbiAgJ3NldCcsICdzdG9wJywgJ3N3aXRjaCcsICdzeW1ib2wnLCAndGV4dCcsICd0ZXh0UGF0aCcsICd0aXRsZScsICd0cmVmJyxcbiAgJ3RzcGFuJywgJ3VzZScsICd2aWV3JywgJ3ZrZXJuJ1xuXVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5pc01vYmlsZSA9IGlzTW9iaWxlO1xuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0QnJvd3NlcjtcblxudmFyIF9nbG9iYWxzID0gcmVxdWlyZShcIi4vZ2xvYmFsc1wiKTtcblxudmFyIF9pc0Jyb3dzZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2lzLWJyb3dzZXJcIikpO1xuXG52YXIgX2lzRWxlY3Ryb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2lzLWVsZWN0cm9uXCIpKTtcblxuZnVuY3Rpb24gaXNNb2JpbGUoKSB7XG4gIHJldHVybiB0eXBlb2YgX2dsb2JhbHMud2luZG93Lm9yaWVudGF0aW9uICE9PSAndW5kZWZpbmVkJztcbn1cblxuZnVuY3Rpb24gZ2V0QnJvd3Nlcihtb2NrVXNlckFnZW50KSB7XG4gIGlmICghbW9ja1VzZXJBZ2VudCAmJiAhKDAsIF9pc0Jyb3dzZXIuZGVmYXVsdCkoKSkge1xuICAgIHJldHVybiAnTm9kZSc7XG4gIH1cblxuICBpZiAoKDAsIF9pc0VsZWN0cm9uLmRlZmF1bHQpKG1vY2tVc2VyQWdlbnQpKSB7XG4gICAgcmV0dXJuICdFbGVjdHJvbic7XG4gIH1cblxuICB2YXIgbmF2aWdhdG9yXyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnID8gbmF2aWdhdG9yIDoge307XG4gIHZhciB1c2VyQWdlbnQgPSBtb2NrVXNlckFnZW50IHx8IG5hdmlnYXRvcl8udXNlckFnZW50IHx8ICcnO1xuXG4gIGlmICh1c2VyQWdlbnQuaW5kZXhPZignRWRnZScpID4gLTEpIHtcbiAgICByZXR1cm4gJ0VkZ2UnO1xuICB9XG5cbiAgdmFyIGlzTVNJRSA9IHVzZXJBZ2VudC5pbmRleE9mKCdNU0lFICcpICE9PSAtMTtcbiAgdmFyIGlzVHJpZGVudCA9IHVzZXJBZ2VudC5pbmRleE9mKCdUcmlkZW50LycpICE9PSAtMTtcblxuICBpZiAoaXNNU0lFIHx8IGlzVHJpZGVudCkge1xuICAgIHJldHVybiAnSUUnO1xuICB9XG5cbiAgaWYgKF9nbG9iYWxzLndpbmRvdy5jaHJvbWUpIHtcbiAgICByZXR1cm4gJ0Nocm9tZSc7XG4gIH1cblxuICBpZiAoX2dsb2JhbHMud2luZG93LnNhZmFyaSkge1xuICAgIHJldHVybiAnU2FmYXJpJztcbiAgfVxuXG4gIGlmIChfZ2xvYmFscy53aW5kb3cubW96SW5uZXJTY3JlZW5YKSB7XG4gICAgcmV0dXJuICdGaXJlZm94JztcbiAgfVxuXG4gIHJldHVybiAnVW5rbm93bic7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtYnJvd3Nlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNvbnNvbGUgPSBleHBvcnRzLnByb2Nlc3MgPSBleHBvcnRzLmRvY3VtZW50ID0gZXhwb3J0cy5nbG9iYWwgPSBleHBvcnRzLndpbmRvdyA9IGV4cG9ydHMuc2VsZiA9IHZvaWQgMDtcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG52YXIgZ2xvYmFscyA9IHtcbiAgc2VsZjogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYsXG4gIHdpbmRvdzogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LFxuICBnbG9iYWw6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbCxcbiAgZG9jdW1lbnQ6IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQsXG4gIHByb2Nlc3M6ICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjIuZGVmYXVsdCkocHJvY2VzcykpID09PSAnb2JqZWN0JyAmJiBwcm9jZXNzXG59O1xudmFyIHNlbGZfID0gZ2xvYmFscy5zZWxmIHx8IGdsb2JhbHMud2luZG93IHx8IGdsb2JhbHMuZ2xvYmFsO1xuZXhwb3J0cy5zZWxmID0gc2VsZl87XG52YXIgd2luZG93XyA9IGdsb2JhbHMud2luZG93IHx8IGdsb2JhbHMuc2VsZiB8fCBnbG9iYWxzLmdsb2JhbDtcbmV4cG9ydHMud2luZG93ID0gd2luZG93XztcbnZhciBnbG9iYWxfID0gZ2xvYmFscy5nbG9iYWwgfHwgZ2xvYmFscy5zZWxmIHx8IGdsb2JhbHMud2luZG93O1xuZXhwb3J0cy5nbG9iYWwgPSBnbG9iYWxfO1xudmFyIGRvY3VtZW50XyA9IGdsb2JhbHMuZG9jdW1lbnQgfHwge307XG5leHBvcnRzLmRvY3VtZW50ID0gZG9jdW1lbnRfO1xudmFyIHByb2Nlc3NfID0gZ2xvYmFscy5wcm9jZXNzIHx8IHt9O1xuZXhwb3J0cy5wcm9jZXNzID0gcHJvY2Vzc187XG52YXIgY29uc29sZV8gPSBjb25zb2xlO1xuZXhwb3J0cy5jb25zb2xlID0gY29uc29sZV87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nbG9iYWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzQnJvd3NlcjtcbmV4cG9ydHMuaXNCcm93c2VyTWFpblRocmVhZCA9IGlzQnJvd3Nlck1haW5UaHJlYWQ7XG5cbnZhciBfdHlwZW9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpKTtcblxudmFyIF9pc0VsZWN0cm9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pcy1lbGVjdHJvblwiKSk7XG5cbmZ1bmN0aW9uIGlzQnJvd3NlcigpIHtcbiAgdmFyIGlzTm9kZSA9ICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjIuZGVmYXVsdCkocHJvY2VzcykpID09PSAnb2JqZWN0JyAmJiBTdHJpbmcocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJyAmJiAhcHJvY2Vzcy5icm93c2VyO1xuICByZXR1cm4gIWlzTm9kZSB8fCAoMCwgX2lzRWxlY3Ryb24uZGVmYXVsdCkoKTtcbn1cblxuZnVuY3Rpb24gaXNCcm93c2VyTWFpblRocmVhZCgpIHtcbiAgcmV0dXJuIGlzQnJvd3NlcigpICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1icm93c2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzRWxlY3Ryb247XG5cbnZhciBfdHlwZW9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpKTtcblxuZnVuY3Rpb24gaXNFbGVjdHJvbihtb2NrVXNlckFnZW50KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAoMCwgX3R5cGVvZjIuZGVmYXVsdCkod2luZG93LnByb2Nlc3MpID09PSAnb2JqZWN0JyAmJiB3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICgwLCBfdHlwZW9mMi5kZWZhdWx0KShwcm9jZXNzLnZlcnNpb25zKSA9PT0gJ29iamVjdCcgJiYgQm9vbGVhbihwcm9jZXNzLnZlcnNpb25zLmVsZWN0cm9uKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIHJlYWxVc2VyQWdlbnQgPSAodHlwZW9mIG5hdmlnYXRvciA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjIuZGVmYXVsdCkobmF2aWdhdG9yKSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBuYXZpZ2F0b3IudXNlckFnZW50ID09PSAnc3RyaW5nJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50O1xuICB2YXIgdXNlckFnZW50ID0gbW9ja1VzZXJBZ2VudCB8fCByZWFsVXNlckFnZW50O1xuXG4gIGlmICh1c2VyQWdlbnQgJiYgdXNlckFnZW50LmluZGV4T2YoJ0VsZWN0cm9uJykgPj0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtZWxlY3Ryb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG52YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxvZ1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfbG9nLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVkVSU0lPTlwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2xvYmFscy5WRVJTSU9OO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNlbGZcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dsb2JhbHMyLnNlbGY7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwid2luZG93XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxzMi53aW5kb3c7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2xvYmFsXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxzMi5nbG9iYWw7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZG9jdW1lbnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dsb2JhbHMyLmRvY3VtZW50O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInByb2Nlc3NcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dsb2JhbHMyLnByb2Nlc3M7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29uc29sZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2xvYmFsczIuY29uc29sZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0Jyb3dzZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2lzQnJvd3Nlci5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzQnJvd3Nlck1haW5UaHJlYWRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2lzQnJvd3Nlci5pc0Jyb3dzZXJNYWluVGhyZWFkO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEJyb3dzZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dldEJyb3dzZXIuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc01vYmlsZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2V0QnJvd3Nlci5pc01vYmlsZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0VsZWN0cm9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pc0VsZWN0cm9uLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXNzZXJ0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hc3NlcnQuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDT0xPUlwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfY29sb3IuQ09MT1I7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYWRkQ29sb3JcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2NvbG9yLmFkZENvbG9yO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxlZnRQYWRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2Zvcm1hdHRlcnMubGVmdFBhZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyaWdodFBhZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZm9ybWF0dGVycy5yaWdodFBhZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhdXRvYmluZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYXV0b2JpbmQuYXV0b2JpbmQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTG9jYWxTdG9yYWdlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9sb2NhbFN0b3JhZ2UuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRIaVJlc1RpbWVzdGFtcFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfaGlSZXNUaW1lc3RhbXAuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdGF0c1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc3RhdHMuU3RhdHM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3RhdFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfc3RhdHMuU3RhdDtcbiAgfVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnJlcXVpcmUoXCIuL2luaXRcIik7XG5cbnZhciBfbG9nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWIvbG9nXCIpKTtcblxudmFyIF9nbG9iYWxzID0gcmVxdWlyZShcIi4vdXRpbHMvZ2xvYmFsc1wiKTtcblxudmFyIF9nbG9iYWxzMiA9IHJlcXVpcmUoXCIuL2Vudi9nbG9iYWxzXCIpO1xuXG52YXIgX2lzQnJvd3NlciA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2Vudi9pcy1icm93c2VyXCIpKTtcblxudmFyIF9nZXRCcm93c2VyID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vZW52L2dldC1icm93c2VyXCIpKTtcblxudmFyIF9pc0VsZWN0cm9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9lbnYvaXMtZWxlY3Ryb25cIikpO1xuXG52YXIgX2Fzc2VydCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbHMvYXNzZXJ0XCIpKTtcblxudmFyIF9jb2xvciA9IHJlcXVpcmUoXCIuL3V0aWxzL2NvbG9yXCIpO1xuXG52YXIgX2Zvcm1hdHRlcnMgPSByZXF1aXJlKFwiLi91dGlscy9mb3JtYXR0ZXJzXCIpO1xuXG52YXIgX2F1dG9iaW5kID0gcmVxdWlyZShcIi4vdXRpbHMvYXV0b2JpbmRcIik7XG5cbnZhciBfbG9jYWxTdG9yYWdlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlscy9sb2NhbC1zdG9yYWdlXCIpKTtcblxudmFyIF9oaVJlc1RpbWVzdGFtcCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdXRpbHMvaGktcmVzLXRpbWVzdGFtcFwiKSk7XG5cbnZhciBfc3RhdHMgPSByZXF1aXJlKFwiQHByb2JlLmdsL3N0YXRzXCIpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpOyB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDsgfSkobm9kZUludGVyb3ApOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHsgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoa2V5ICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbnZhciBfZGVmYXVsdCA9IG5ldyBfbG9nLmRlZmF1bHQoe1xuICBpZDogJ3Byb2JlLmdsJ1xufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfZ2xvYmFscyA9IHJlcXVpcmUoXCIuL3V0aWxzL2dsb2JhbHNcIik7XG5cbl9nbG9iYWxzLmdsb2JhbC5wcm9iZSA9IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5pdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm5vcm1hbGl6ZUFyZ3VtZW50cyA9IG5vcm1hbGl6ZUFyZ3VtZW50cztcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG52YXIgX3RvQ29uc3VtYWJsZUFycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXlcIikpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2dsb2JhbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMvZ2xvYmFsc1wiKTtcblxudmFyIF9sb2NhbFN0b3JhZ2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlscy9sb2NhbC1zdG9yYWdlXCIpKTtcblxudmFyIF9mb3JtYXR0ZXJzID0gcmVxdWlyZShcIi4uL3V0aWxzL2Zvcm1hdHRlcnNcIik7XG5cbnZhciBfY29sb3IgPSByZXF1aXJlKFwiLi4vdXRpbHMvY29sb3JcIik7XG5cbnZhciBfYXV0b2JpbmQgPSByZXF1aXJlKFwiLi4vdXRpbHMvYXV0b2JpbmRcIik7XG5cbnZhciBfYXNzZXJ0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3V0aWxzL2Fzc2VydFwiKSk7XG5cbnZhciBfaGlSZXNUaW1lc3RhbXAgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlscy9oaS1yZXMtdGltZXN0YW1wXCIpKTtcblxudmFyIG9yaWdpbmFsQ29uc29sZSA9IHtcbiAgZGVidWc6IF9nbG9iYWxzLmlzQnJvd3NlciA/IGNvbnNvbGUuZGVidWcgfHwgY29uc29sZS5sb2cgOiBjb25zb2xlLmxvZyxcbiAgbG9nOiBjb25zb2xlLmxvZyxcbiAgaW5mbzogY29uc29sZS5pbmZvLFxuICB3YXJuOiBjb25zb2xlLndhcm4sXG4gIGVycm9yOiBjb25zb2xlLmVycm9yXG59O1xudmFyIERFRkFVTFRfU0VUVElOR1MgPSB7XG4gIGVuYWJsZWQ6IHRydWUsXG4gIGxldmVsOiAwXG59O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxudmFyIGNhY2hlID0ge307XG52YXIgT05DRSA9IHtcbiAgb25jZTogdHJ1ZVxufTtcblxuZnVuY3Rpb24gZ2V0VGFibGVIZWFkZXIodGFibGUpIHtcbiAgZm9yICh2YXIga2V5IGluIHRhYmxlKSB7XG4gICAgZm9yICh2YXIgdGl0bGUgaW4gdGFibGVba2V5XSkge1xuICAgICAgcmV0dXJuIHRpdGxlIHx8ICd1bnRpdGxlZCc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICdlbXB0eSc7XG59XG5cbnZhciBMb2cgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExvZygpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge1xuICAgICAgaWQ6ICcnXG4gICAgfSxcbiAgICAgICAgaWQgPSBfcmVmLmlkO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgTG9nKTtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5WRVJTSU9OID0gX2dsb2JhbHMuVkVSU0lPTjtcbiAgICB0aGlzLl9zdGFydFRzID0gKDAsIF9oaVJlc1RpbWVzdGFtcC5kZWZhdWx0KSgpO1xuICAgIHRoaXMuX2RlbHRhVHMgPSAoMCwgX2hpUmVzVGltZXN0YW1wLmRlZmF1bHQpKCk7XG4gICAgdGhpcy5MT0dfVEhST1RUTEVfVElNRU9VVCA9IDA7XG4gICAgdGhpcy5fc3RvcmFnZSA9IG5ldyBfbG9jYWxTdG9yYWdlLmRlZmF1bHQoXCJfX3Byb2JlLVwiLmNvbmNhdCh0aGlzLmlkLCBcIl9fXCIpLCBERUZBVUxUX1NFVFRJTkdTKTtcbiAgICB0aGlzLnVzZXJEYXRhID0ge307XG4gICAgdGhpcy50aW1lU3RhbXAoXCJcIi5jb25jYXQodGhpcy5pZCwgXCIgc3RhcnRlZFwiKSk7XG4gICAgKDAsIF9hdXRvYmluZC5hdXRvYmluZCkodGhpcyk7XG4gICAgT2JqZWN0LnNlYWwodGhpcyk7XG4gIH1cblxuICAoMCwgX2NyZWF0ZUNsYXNzMi5kZWZhdWx0KShMb2csIFt7XG4gICAga2V5OiBcImxldmVsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRMZXZlbCgpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3TGV2ZWwpIHtcbiAgICAgIHRoaXMuc2V0TGV2ZWwobmV3TGV2ZWwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0VuYWJsZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNFbmFibGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0b3JhZ2UuY29uZmlnLmVuYWJsZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldExldmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExldmVsKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0b3JhZ2UuY29uZmlnLmxldmVsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUb3RhbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUb3RhbCgpIHtcbiAgICAgIHJldHVybiBOdW1iZXIoKCgwLCBfaGlSZXNUaW1lc3RhbXAuZGVmYXVsdCkoKSAtIHRoaXMuX3N0YXJ0VHMpLnRvUHJlY2lzaW9uKDEwKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldERlbHRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlbHRhKCkge1xuICAgICAgcmV0dXJuIE51bWJlcigoKDAsIF9oaVJlc1RpbWVzdGFtcC5kZWZhdWx0KSgpIC0gdGhpcy5fZGVsdGFUcykudG9QcmVjaXNpb24oMTApKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJpb3JpdHlcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxldmVsO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3UHJpb3JpdHkpIHtcbiAgICAgIHRoaXMubGV2ZWwgPSBuZXdQcmlvcml0eTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UHJpb3JpdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHJpb3JpdHkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZXZlbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5hYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICAgIHZhciBlbmFibGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuXG4gICAgICB0aGlzLl9zdG9yYWdlLnVwZGF0ZUNvbmZpZ3VyYXRpb24oe1xuICAgICAgICBlbmFibGVkOiBlbmFibGVkXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldExldmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldExldmVsKGxldmVsKSB7XG4gICAgICB0aGlzLl9zdG9yYWdlLnVwZGF0ZUNvbmZpZ3VyYXRpb24oe1xuICAgICAgICBsZXZlbDogbGV2ZWxcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXNzZXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICAgICgwLCBfYXNzZXJ0Mi5kZWZhdWx0KShjb25kaXRpb24sIG1lc3NhZ2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3YXJuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdhcm4obWVzc2FnZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldExvZ0Z1bmN0aW9uKDAsIG1lc3NhZ2UsIG9yaWdpbmFsQ29uc29sZS53YXJuLCBhcmd1bWVudHMsIE9OQ0UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcnJvcihtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0TG9nRnVuY3Rpb24oMCwgbWVzc2FnZSwgb3JpZ2luYWxDb25zb2xlLmVycm9yLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXByZWNhdGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlcHJlY2F0ZWQob2xkVXNhZ2UsIG5ld1VzYWdlKSB7XG4gICAgICByZXR1cm4gdGhpcy53YXJuKFwiYFwiLmNvbmNhdChvbGRVc2FnZSwgXCJgIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGxhdGVyIHZlcnNpb24uIFVzZSBgXCIpLmNvbmNhdChuZXdVc2FnZSwgXCJgIGluc3RlYWRcIikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZWQob2xkVXNhZ2UsIG5ld1VzYWdlKSB7XG4gICAgICByZXR1cm4gdGhpcy5lcnJvcihcImBcIi5jb25jYXQob2xkVXNhZ2UsIFwiYCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgYFwiKS5jb25jYXQobmV3VXNhZ2UsIFwiYCBpbnN0ZWFkXCIpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJvYmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvYmUobG9nTGV2ZWwsIG1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRMb2dGdW5jdGlvbihsb2dMZXZlbCwgbWVzc2FnZSwgb3JpZ2luYWxDb25zb2xlLmxvZywgYXJndW1lbnRzLCB7XG4gICAgICAgIHRpbWU6IHRydWUsXG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsb2dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9nKGxvZ0xldmVsLCBtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0TG9nRnVuY3Rpb24obG9nTGV2ZWwsIG1lc3NhZ2UsIG9yaWdpbmFsQ29uc29sZS5kZWJ1ZywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5mb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmZvKGxvZ0xldmVsLCBtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0TG9nRnVuY3Rpb24obG9nTGV2ZWwsIG1lc3NhZ2UsIGNvbnNvbGUuaW5mbywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25jZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbmNlKGxvZ0xldmVsLCBtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0TG9nRnVuY3Rpb24obG9nTGV2ZWwsIG1lc3NhZ2UsIG9yaWdpbmFsQ29uc29sZS5kZWJ1ZyB8fCBvcmlnaW5hbENvbnNvbGUuaW5mbywgYXJndW1lbnRzLCBPTkNFKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGFibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGFibGUobG9nTGV2ZWwsIF90YWJsZSwgY29sdW1ucykge1xuICAgICAgaWYgKF90YWJsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TG9nRnVuY3Rpb24obG9nTGV2ZWwsIF90YWJsZSwgY29uc29sZS50YWJsZSB8fCBub29wLCBjb2x1bW5zICYmIFtjb2x1bW5zXSwge1xuICAgICAgICAgIHRhZzogZ2V0VGFibGVIZWFkZXIoX3RhYmxlKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImltYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGltYWdlKF9yZWYyKSB7XG4gICAgICB2YXIgbG9nTGV2ZWwgPSBfcmVmMi5sb2dMZXZlbCxcbiAgICAgICAgICBwcmlvcml0eSA9IF9yZWYyLnByaW9yaXR5LFxuICAgICAgICAgIF9pbWFnZSA9IF9yZWYyLmltYWdlLFxuICAgICAgICAgIF9yZWYyJG1lc3NhZ2UgPSBfcmVmMi5tZXNzYWdlLFxuICAgICAgICAgIG1lc3NhZ2UgPSBfcmVmMiRtZXNzYWdlID09PSB2b2lkIDAgPyAnJyA6IF9yZWYyJG1lc3NhZ2UsXG4gICAgICAgICAgX3JlZjIkc2NhbGUgPSBfcmVmMi5zY2FsZSxcbiAgICAgICAgICBzY2FsZSA9IF9yZWYyJHNjYWxlID09PSB2b2lkIDAgPyAxIDogX3JlZjIkc2NhbGU7XG5cbiAgICAgIGlmICghdGhpcy5fc2hvdWxkTG9nKGxvZ0xldmVsIHx8IHByaW9yaXR5KSkge1xuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9nbG9iYWxzLmlzQnJvd3NlciA/IGxvZ0ltYWdlSW5Ccm93c2VyKHtcbiAgICAgICAgaW1hZ2U6IF9pbWFnZSxcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgc2NhbGU6IHNjYWxlXG4gICAgICB9KSA6IGxvZ0ltYWdlSW5Ob2RlKHtcbiAgICAgICAgaW1hZ2U6IF9pbWFnZSxcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgc2NhbGU6IHNjYWxlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0dGluZ3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dGluZ3MoKSB7XG4gICAgICBpZiAoY29uc29sZS50YWJsZSkge1xuICAgICAgICBjb25zb2xlLnRhYmxlKHRoaXMuX3N0b3JhZ2UuY29uZmlnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuX3N0b3JhZ2UuY29uZmlnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChzZXR0aW5nKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RvcmFnZS5jb25maWdbc2V0dGluZ107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQoc2V0dGluZywgdmFsdWUpIHtcbiAgICAgIHRoaXMuX3N0b3JhZ2UudXBkYXRlQ29uZmlndXJhdGlvbigoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh7fSwgc2V0dGluZywgdmFsdWUpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGltZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aW1lKGxvZ0xldmVsLCBtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0TG9nRnVuY3Rpb24obG9nTGV2ZWwsIG1lc3NhZ2UsIGNvbnNvbGUudGltZSA/IGNvbnNvbGUudGltZSA6IGNvbnNvbGUuaW5mbyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRpbWVFbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGltZUVuZChsb2dMZXZlbCwgbWVzc2FnZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldExvZ0Z1bmN0aW9uKGxvZ0xldmVsLCBtZXNzYWdlLCBjb25zb2xlLnRpbWVFbmQgPyBjb25zb2xlLnRpbWVFbmQgOiBjb25zb2xlLmluZm8pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0aW1lU3RhbXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGltZVN0YW1wKGxvZ0xldmVsLCBtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0TG9nRnVuY3Rpb24obG9nTGV2ZWwsIG1lc3NhZ2UsIGNvbnNvbGUudGltZVN0YW1wIHx8IG5vb3ApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJncm91cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBncm91cChsb2dMZXZlbCwgbWVzc2FnZSkge1xuICAgICAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHtcbiAgICAgICAgY29sbGFwc2VkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIG9wdHMgPSBub3JtYWxpemVBcmd1bWVudHMoe1xuICAgICAgICBsb2dMZXZlbDogbG9nTGV2ZWwsXG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgIG9wdHM6IG9wdHNcbiAgICAgIH0pO1xuICAgICAgdmFyIF9vcHRzID0gb3B0cyxcbiAgICAgICAgICBjb2xsYXBzZWQgPSBfb3B0cy5jb2xsYXBzZWQ7XG4gICAgICBvcHRzLm1ldGhvZCA9IChjb2xsYXBzZWQgPyBjb25zb2xlLmdyb3VwQ29sbGFwc2VkIDogY29uc29sZS5ncm91cCkgfHwgY29uc29sZS5pbmZvO1xuICAgICAgcmV0dXJuIHRoaXMuX2dldExvZ0Z1bmN0aW9uKG9wdHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJncm91cENvbGxhcHNlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBncm91cENvbGxhcHNlZChsb2dMZXZlbCwgbWVzc2FnZSkge1xuICAgICAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgcmV0dXJuIHRoaXMuZ3JvdXAobG9nTGV2ZWwsIG1lc3NhZ2UsIE9iamVjdC5hc3NpZ24oe30sIG9wdHMsIHtcbiAgICAgICAgY29sbGFwc2VkOiB0cnVlXG4gICAgICB9KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdyb3VwRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdyb3VwRW5kKGxvZ0xldmVsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0TG9nRnVuY3Rpb24obG9nTGV2ZWwsICcnLCBjb25zb2xlLmdyb3VwRW5kIHx8IG5vb3ApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoR3JvdXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aEdyb3VwKGxvZ0xldmVsLCBtZXNzYWdlLCBmdW5jKSB7XG4gICAgICB0aGlzLmdyb3VwKGxvZ0xldmVsLCBtZXNzYWdlKSgpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmdW5jKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLmdyb3VwRW5kKGxvZ0xldmVsKSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0cmFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFjZSgpIHtcbiAgICAgIGlmIChjb25zb2xlLnRyYWNlKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3Nob3VsZExvZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2hvdWxkTG9nKGxvZ0xldmVsKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0VuYWJsZWQoKSAmJiB0aGlzLmdldExldmVsKCkgPj0gbm9ybWFsaXplTG9nTGV2ZWwobG9nTGV2ZWwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0TG9nRnVuY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldExvZ0Z1bmN0aW9uKGxvZ0xldmVsLCBtZXNzYWdlLCBtZXRob2QpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBbXTtcbiAgICAgIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgPyBhcmd1bWVudHNbNF0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh0aGlzLl9zaG91bGRMb2cobG9nTGV2ZWwpKSB7XG4gICAgICAgIHZhciBfbWV0aG9kO1xuXG4gICAgICAgIG9wdHMgPSBub3JtYWxpemVBcmd1bWVudHMoe1xuICAgICAgICAgIGxvZ0xldmVsOiBsb2dMZXZlbCxcbiAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICAgICAgb3B0czogb3B0c1xuICAgICAgICB9KTtcbiAgICAgICAgbWV0aG9kID0gbWV0aG9kIHx8IG9wdHMubWV0aG9kO1xuICAgICAgICAoMCwgX2Fzc2VydDIuZGVmYXVsdCkobWV0aG9kKTtcbiAgICAgICAgb3B0cy50b3RhbCA9IHRoaXMuZ2V0VG90YWwoKTtcbiAgICAgICAgb3B0cy5kZWx0YSA9IHRoaXMuZ2V0RGVsdGEoKTtcbiAgICAgICAgdGhpcy5fZGVsdGFUcyA9ICgwLCBfaGlSZXNUaW1lc3RhbXAuZGVmYXVsdCkoKTtcbiAgICAgICAgdmFyIHRhZyA9IG9wdHMudGFnIHx8IG9wdHMubWVzc2FnZTtcblxuICAgICAgICBpZiAob3B0cy5vbmNlKSB7XG4gICAgICAgICAgaWYgKCFjYWNoZVt0YWddKSB7XG4gICAgICAgICAgICBjYWNoZVt0YWddID0gKDAsIF9oaVJlc1RpbWVzdGFtcC5kZWZhdWx0KSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZXNzYWdlID0gZGVjb3JhdGVNZXNzYWdlKHRoaXMuaWQsIG9wdHMubWVzc2FnZSwgb3B0cyk7XG4gICAgICAgIHJldHVybiAoX21ldGhvZCA9IG1ldGhvZCkuYmluZC5hcHBseShfbWV0aG9kLCBbY29uc29sZSwgbWVzc2FnZV0uY29uY2F0KCgwLCBfdG9Db25zdW1hYmxlQXJyYXkyLmRlZmF1bHQpKG9wdHMuYXJncykpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBMb2c7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IExvZztcbkxvZy5WRVJTSU9OID0gX2dsb2JhbHMuVkVSU0lPTjtcblxuZnVuY3Rpb24gbm9ybWFsaXplTG9nTGV2ZWwobG9nTGV2ZWwpIHtcbiAgaWYgKCFsb2dMZXZlbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHJlc29sdmVkTGV2ZWw7XG5cbiAgc3dpdGNoICgoMCwgX3R5cGVvZjIuZGVmYXVsdCkobG9nTGV2ZWwpKSB7XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJlc29sdmVkTGV2ZWwgPSBsb2dMZXZlbDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHJlc29sdmVkTGV2ZWwgPSBsb2dMZXZlbC5sb2dMZXZlbCB8fCBsb2dMZXZlbC5wcmlvcml0eSB8fCAwO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIDA7XG4gIH1cblxuICAoMCwgX2Fzc2VydDIuZGVmYXVsdCkoTnVtYmVyLmlzRmluaXRlKHJlc29sdmVkTGV2ZWwpICYmIHJlc29sdmVkTGV2ZWwgPj0gMCk7XG4gIHJldHVybiByZXNvbHZlZExldmVsO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVBcmd1bWVudHMob3B0cykge1xuICB2YXIgbG9nTGV2ZWwgPSBvcHRzLmxvZ0xldmVsLFxuICAgICAgbWVzc2FnZSA9IG9wdHMubWVzc2FnZTtcbiAgb3B0cy5sb2dMZXZlbCA9IG5vcm1hbGl6ZUxvZ0xldmVsKGxvZ0xldmVsKTtcbiAgdmFyIGFyZ3MgPSBvcHRzLmFyZ3MgPyBBcnJheS5mcm9tKG9wdHMuYXJncykgOiBbXTtcblxuICB3aGlsZSAoYXJncy5sZW5ndGggJiYgYXJncy5zaGlmdCgpICE9PSBtZXNzYWdlKSB7fVxuXG4gIG9wdHMuYXJncyA9IGFyZ3M7XG5cbiAgc3dpdGNoICgoMCwgX3R5cGVvZjIuZGVmYXVsdCkobG9nTGV2ZWwpKSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICBpZiAobWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFyZ3MudW5zaGlmdChtZXNzYWdlKTtcbiAgICAgIH1cblxuICAgICAgb3B0cy5tZXNzYWdlID0gbG9nTGV2ZWw7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBPYmplY3QuYXNzaWduKG9wdHMsIGxvZ0xldmVsKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0cy5tZXNzYWdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0cy5tZXNzYWdlID0gb3B0cy5tZXNzYWdlKCk7XG4gIH1cblxuICB2YXIgbWVzc2FnZVR5cGUgPSAoMCwgX3R5cGVvZjIuZGVmYXVsdCkob3B0cy5tZXNzYWdlKTtcbiAgKDAsIF9hc3NlcnQyLmRlZmF1bHQpKG1lc3NhZ2VUeXBlID09PSAnc3RyaW5nJyB8fCBtZXNzYWdlVHlwZSA9PT0gJ29iamVjdCcpO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihvcHRzLCBvcHRzLm9wdHMpO1xufVxuXG5mdW5jdGlvbiBkZWNvcmF0ZU1lc3NhZ2UoaWQsIG1lc3NhZ2UsIG9wdHMpIHtcbiAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgIHZhciB0aW1lID0gb3B0cy50aW1lID8gKDAsIF9mb3JtYXR0ZXJzLmxlZnRQYWQpKCgwLCBfZm9ybWF0dGVycy5mb3JtYXRUaW1lKShvcHRzLnRvdGFsKSkgOiAnJztcbiAgICBtZXNzYWdlID0gb3B0cy50aW1lID8gXCJcIi5jb25jYXQoaWQsIFwiOiBcIikuY29uY2F0KHRpbWUsIFwiICBcIikuY29uY2F0KG1lc3NhZ2UpIDogXCJcIi5jb25jYXQoaWQsIFwiOiBcIikuY29uY2F0KG1lc3NhZ2UpO1xuICAgIG1lc3NhZ2UgPSAoMCwgX2NvbG9yLmFkZENvbG9yKShtZXNzYWdlLCBvcHRzLmNvbG9yLCBvcHRzLmJhY2tncm91bmQpO1xuICB9XG5cbiAgcmV0dXJuIG1lc3NhZ2U7XG59XG5cbmZ1bmN0aW9uIGxvZ0ltYWdlSW5Ob2RlKF9yZWYzKSB7XG4gIHZhciBpbWFnZSA9IF9yZWYzLmltYWdlLFxuICAgICAgX3JlZjMkbWVzc2FnZSA9IF9yZWYzLm1lc3NhZ2UsXG4gICAgICBtZXNzYWdlID0gX3JlZjMkbWVzc2FnZSA9PT0gdm9pZCAwID8gJycgOiBfcmVmMyRtZXNzYWdlLFxuICAgICAgX3JlZjMkc2NhbGUgPSBfcmVmMy5zY2FsZSxcbiAgICAgIHNjYWxlID0gX3JlZjMkc2NhbGUgPT09IHZvaWQgMCA/IDEgOiBfcmVmMyRzY2FsZTtcbiAgdmFyIGFzY2lpZnkgPSBudWxsO1xuXG4gIHRyeSB7XG4gICAgYXNjaWlmeSA9IG1vZHVsZS5yZXF1aXJlKCdhc2NpaWZ5LWltYWdlJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7fVxuXG4gIGlmIChhc2NpaWZ5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhc2NpaWZ5KGltYWdlLCB7XG4gICAgICAgIGZpdDogJ2JveCcsXG4gICAgICAgIHdpZHRoOiBcIlwiLmNvbmNhdChNYXRoLnJvdW5kKDgwICogc2NhbGUpLCBcIiVcIilcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBub29wO1xufVxuXG5mdW5jdGlvbiBsb2dJbWFnZUluQnJvd3NlcihfcmVmNCkge1xuICB2YXIgaW1hZ2UgPSBfcmVmNC5pbWFnZSxcbiAgICAgIF9yZWY0JG1lc3NhZ2UgPSBfcmVmNC5tZXNzYWdlLFxuICAgICAgbWVzc2FnZSA9IF9yZWY0JG1lc3NhZ2UgPT09IHZvaWQgMCA/ICcnIDogX3JlZjQkbWVzc2FnZSxcbiAgICAgIF9yZWY0JHNjYWxlID0gX3JlZjQuc2NhbGUsXG4gICAgICBzY2FsZSA9IF9yZWY0JHNjYWxlID09PSB2b2lkIDAgPyAxIDogX3JlZjQkc2NhbGU7XG5cbiAgaWYgKHR5cGVvZiBpbWFnZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG5cbiAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9jb25zb2xlO1xuXG4gICAgICB2YXIgYXJncyA9ICgwLCBfZm9ybWF0dGVycy5mb3JtYXRJbWFnZSkoaW1nLCBtZXNzYWdlLCBzY2FsZSk7XG5cbiAgICAgIChfY29uc29sZSA9IGNvbnNvbGUpLmxvZy5hcHBseShfY29uc29sZSwgKDAsIF90b0NvbnN1bWFibGVBcnJheTIuZGVmYXVsdCkoYXJncykpO1xuICAgIH07XG5cbiAgICBpbWcuc3JjID0gaW1hZ2U7XG4gICAgcmV0dXJuIG5vb3A7XG4gIH1cblxuICB2YXIgZWxlbWVudCA9IGltYWdlLm5vZGVOYW1lIHx8ICcnO1xuXG4gIGlmIChlbGVtZW50LnRvTG93ZXJDYXNlKCkgPT09ICdpbWcnKSB7XG4gICAgdmFyIF9jb25zb2xlMjtcblxuICAgIChfY29uc29sZTIgPSBjb25zb2xlKS5sb2cuYXBwbHkoX2NvbnNvbGUyLCAoMCwgX3RvQ29uc3VtYWJsZUFycmF5Mi5kZWZhdWx0KSgoMCwgX2Zvcm1hdHRlcnMuZm9ybWF0SW1hZ2UpKGltYWdlLCBtZXNzYWdlLCBzY2FsZSkpKTtcblxuICAgIHJldHVybiBub29wO1xuICB9XG5cbiAgaWYgKGVsZW1lbnQudG9Mb3dlckNhc2UoKSA9PT0gJ2NhbnZhcycpIHtcbiAgICB2YXIgX2ltZyA9IG5ldyBJbWFnZSgpO1xuXG4gICAgX2ltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2NvbnNvbGUzO1xuXG4gICAgICByZXR1cm4gKF9jb25zb2xlMyA9IGNvbnNvbGUpLmxvZy5hcHBseShfY29uc29sZTMsICgwLCBfdG9Db25zdW1hYmxlQXJyYXkyLmRlZmF1bHQpKCgwLCBfZm9ybWF0dGVycy5mb3JtYXRJbWFnZSkoX2ltZywgbWVzc2FnZSwgc2NhbGUpKSk7XG4gICAgfTtcblxuICAgIF9pbWcuc3JjID0gaW1hZ2UudG9EYXRhVVJMKCk7XG4gICAgcmV0dXJuIG5vb3A7XG4gIH1cblxuICByZXR1cm4gbm9vcDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGFzc2VydDtcblxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc2VydC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYXV0b2JpbmQgPSBhdXRvYmluZDtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBhdXRvYmluZChvYmopIHtcbiAgdmFyIHByZWRlZmluZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFsnY29uc3RydWN0b3InXTtcbiAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gIHZhciBwcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90byk7XG5cbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHByb3BOYW1lcyksXG4gICAgICBfc3RlcDtcblxuICB0cnkge1xuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgdmFyIGtleSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICBpZiAodHlwZW9mIG9ialtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmICghcHJlZGVmaW5lZC5maW5kKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIGtleSA9PT0gbmFtZTtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICBvYmpba2V5XSA9IG9ialtrZXldLmJpbmQob2JqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgX2xvb3AoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0b2JpbmQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmFkZENvbG9yID0gYWRkQ29sb3I7XG5leHBvcnRzLkNPTE9SID0gdm9pZCAwO1xuXG52YXIgX2dsb2JhbHMgPSByZXF1aXJlKFwiLi9nbG9iYWxzXCIpO1xuXG52YXIgQ09MT1IgPSB7XG4gIEJMQUNLOiAzMCxcbiAgUkVEOiAzMSxcbiAgR1JFRU46IDMyLFxuICBZRUxMT1c6IDMzLFxuICBCTFVFOiAzNCxcbiAgTUFHRU5UQTogMzUsXG4gIENZQU46IDM2LFxuICBXSElURTogMzcsXG4gIEJSSUdIVF9CTEFDSzogOTAsXG4gIEJSSUdIVF9SRUQ6IDkxLFxuICBCUklHSFRfR1JFRU46IDkyLFxuICBCUklHSFRfWUVMTE9XOiA5MyxcbiAgQlJJR0hUX0JMVUU6IDk0LFxuICBCUklHSFRfTUFHRU5UQTogOTUsXG4gIEJSSUdIVF9DWUFOOiA5NixcbiAgQlJJR0hUX1dISVRFOiA5N1xufTtcbmV4cG9ydHMuQ09MT1IgPSBDT0xPUjtcblxuZnVuY3Rpb24gZ2V0Q29sb3IoY29sb3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycgPyBDT0xPUltjb2xvci50b1VwcGVyQ2FzZSgpXSB8fCBDT0xPUi5XSElURSA6IGNvbG9yO1xufVxuXG5mdW5jdGlvbiBhZGRDb2xvcihzdHJpbmcsIGNvbG9yLCBiYWNrZ3JvdW5kKSB7XG4gIGlmICghX2dsb2JhbHMuaXNCcm93c2VyICYmIHR5cGVvZiBzdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICBjb2xvciA9IGdldENvbG9yKGNvbG9yKTtcbiAgICAgIHN0cmluZyA9IFwiXFx4MUJbXCIuY29uY2F0KGNvbG9yLCBcIm1cIikuY29uY2F0KHN0cmluZywgXCJcXHgxQlszOW1cIik7XG4gICAgfVxuXG4gICAgaWYgKGJhY2tncm91bmQpIHtcbiAgICAgIGNvbG9yID0gZ2V0Q29sb3IoYmFja2dyb3VuZCk7XG4gICAgICBzdHJpbmcgPSBcIlxceDFCW1wiLmNvbmNhdChiYWNrZ3JvdW5kICsgMTAsIFwibVwiKS5jb25jYXQoc3RyaW5nLCBcIlxceDFCWzQ5bVwiKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyaW5nO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29sb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmZvcm1hdFRpbWUgPSBmb3JtYXRUaW1lO1xuZXhwb3J0cy5sZWZ0UGFkID0gbGVmdFBhZDtcbmV4cG9ydHMucmlnaHRQYWQgPSByaWdodFBhZDtcbmV4cG9ydHMuZm9ybWF0VmFsdWUgPSBmb3JtYXRWYWx1ZTtcbmV4cG9ydHMuZm9ybWF0SW1hZ2UgPSBmb3JtYXRJbWFnZTtcblxuZnVuY3Rpb24gZm9ybWF0VGltZShtcykge1xuICB2YXIgZm9ybWF0dGVkO1xuXG4gIGlmIChtcyA8IDEwKSB7XG4gICAgZm9ybWF0dGVkID0gXCJcIi5jb25jYXQobXMudG9GaXhlZCgyKSwgXCJtc1wiKTtcbiAgfSBlbHNlIGlmIChtcyA8IDEwMCkge1xuICAgIGZvcm1hdHRlZCA9IFwiXCIuY29uY2F0KG1zLnRvRml4ZWQoMSksIFwibXNcIik7XG4gIH0gZWxzZSBpZiAobXMgPCAxMDAwKSB7XG4gICAgZm9ybWF0dGVkID0gXCJcIi5jb25jYXQobXMudG9GaXhlZCgwKSwgXCJtc1wiKTtcbiAgfSBlbHNlIHtcbiAgICBmb3JtYXR0ZWQgPSBcIlwiLmNvbmNhdCgobXMgLyAxMDAwKS50b0ZpeGVkKDIpLCBcInNcIik7XG4gIH1cblxuICByZXR1cm4gZm9ybWF0dGVkO1xufVxuXG5mdW5jdGlvbiBsZWZ0UGFkKHN0cmluZykge1xuICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiA4O1xuICB2YXIgcGFkTGVuZ3RoID0gTWF0aC5tYXgobGVuZ3RoIC0gc3RyaW5nLmxlbmd0aCwgMCk7XG4gIHJldHVybiBcIlwiLmNvbmNhdCgnICcucmVwZWF0KHBhZExlbmd0aCkpLmNvbmNhdChzdHJpbmcpO1xufVxuXG5mdW5jdGlvbiByaWdodFBhZChzdHJpbmcpIHtcbiAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogODtcbiAgdmFyIHBhZExlbmd0aCA9IE1hdGgubWF4KGxlbmd0aCAtIHN0cmluZy5sZW5ndGgsIDApO1xuICByZXR1cm4gXCJcIi5jb25jYXQoc3RyaW5nKS5jb25jYXQoJyAnLnJlcGVhdChwYWRMZW5ndGgpKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUodikge1xuICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBFUFNJTE9OID0gMWUtMTY7XG4gIHZhciBfb3B0cyRpc0ludGVnZXIgPSBvcHRzLmlzSW50ZWdlcixcbiAgICAgIGlzSW50ZWdlciA9IF9vcHRzJGlzSW50ZWdlciA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0cyRpc0ludGVnZXI7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodikgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHYpKSB7XG4gICAgcmV0dXJuIGZvcm1hdEFycmF5VmFsdWUodiwgb3B0cyk7XG4gIH1cblxuICBpZiAoIU51bWJlci5pc0Zpbml0ZSh2KSkge1xuICAgIHJldHVybiBTdHJpbmcodik7XG4gIH1cblxuICBpZiAoTWF0aC5hYnModikgPCBFUFNJTE9OKSB7XG4gICAgcmV0dXJuIGlzSW50ZWdlciA/ICcwJyA6ICcwLic7XG4gIH1cblxuICBpZiAoaXNJbnRlZ2VyKSB7XG4gICAgcmV0dXJuIHYudG9GaXhlZCgwKTtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyh2KSA+IDEwMCAmJiBNYXRoLmFicyh2KSA8IDEwMDAwKSB7XG4gICAgcmV0dXJuIHYudG9GaXhlZCgwKTtcbiAgfVxuXG4gIHZhciBzdHJpbmcgPSB2LnRvUHJlY2lzaW9uKDIpO1xuICB2YXIgZGVjaW1hbCA9IHN0cmluZy5pbmRleE9mKCcuMCcpO1xuICByZXR1cm4gZGVjaW1hbCA9PT0gc3RyaW5nLmxlbmd0aCAtIDIgPyBzdHJpbmcuc2xpY2UoMCwgLTEpIDogc3RyaW5nO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheVZhbHVlKHYsIG9wdHMpIHtcbiAgdmFyIF9vcHRzJG1heEVsdHMgPSBvcHRzLm1heEVsdHMsXG4gICAgICBtYXhFbHRzID0gX29wdHMkbWF4RWx0cyA9PT0gdm9pZCAwID8gMTYgOiBfb3B0cyRtYXhFbHRzLFxuICAgICAgX29wdHMkc2l6ZSA9IG9wdHMuc2l6ZSxcbiAgICAgIHNpemUgPSBfb3B0cyRzaXplID09PSB2b2lkIDAgPyAxIDogX29wdHMkc2l6ZTtcbiAgdmFyIHN0cmluZyA9ICdbJztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoICYmIGkgPCBtYXhFbHRzOyArK2kpIHtcbiAgICBpZiAoaSA+IDApIHtcbiAgICAgIHN0cmluZyArPSBcIixcIi5jb25jYXQoaSAlIHNpemUgPT09IDAgPyAnICcgOiAnJyk7XG4gICAgfVxuXG4gICAgc3RyaW5nICs9IGZvcm1hdFZhbHVlKHZbaV0sIG9wdHMpO1xuICB9XG5cbiAgdmFyIHRlcm1pbmF0b3IgPSB2Lmxlbmd0aCA+IG1heEVsdHMgPyAnLi4uJyA6ICddJztcbiAgcmV0dXJuIFwiXCIuY29uY2F0KHN0cmluZykuY29uY2F0KHRlcm1pbmF0b3IpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRJbWFnZShpbWFnZSwgbWVzc2FnZSwgc2NhbGUpIHtcbiAgdmFyIG1heFdpZHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiA2MDA7XG4gIHZhciBpbWFnZVVybCA9IGltYWdlLnNyYy5yZXBsYWNlKC9cXCgvZywgJyUyOCcpLnJlcGxhY2UoL1xcKS9nLCAnJTI5Jyk7XG5cbiAgaWYgKGltYWdlLndpZHRoID4gbWF4V2lkdGgpIHtcbiAgICBzY2FsZSA9IE1hdGgubWluKHNjYWxlLCBtYXhXaWR0aCAvIGltYWdlLndpZHRoKTtcbiAgfVxuXG4gIHZhciB3aWR0aCA9IGltYWdlLndpZHRoICogc2NhbGU7XG4gIHZhciBoZWlnaHQgPSBpbWFnZS5oZWlnaHQgKiBzY2FsZTtcbiAgdmFyIHN0eWxlID0gWydmb250LXNpemU6MXB4OycsIFwicGFkZGluZzpcIi5jb25jYXQoTWF0aC5mbG9vcihoZWlnaHQgLyAyKSwgXCJweCBcIikuY29uY2F0KE1hdGguZmxvb3Iod2lkdGggLyAyKSwgXCJweDtcIiksIFwibGluZS1oZWlnaHQ6XCIuY29uY2F0KGhlaWdodCwgXCJweDtcIiksIFwiYmFja2dyb3VuZDp1cmwoXCIuY29uY2F0KGltYWdlVXJsLCBcIik7XCIpLCBcImJhY2tncm91bmQtc2l6ZTpcIi5jb25jYXQod2lkdGgsIFwicHggXCIpLmNvbmNhdChoZWlnaHQsIFwicHg7XCIpLCAnY29sb3I6dHJhbnNwYXJlbnQ7J10uam9pbignJyk7XG4gIHJldHVybiBbXCJcIi5jb25jYXQobWVzc2FnZSwgXCIgJWMrXCIpLCBzdHlsZV07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXR0ZXJzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNlbGZcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dsb2JhbHMuc2VsZjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ3aW5kb3dcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dsb2JhbHMud2luZG93O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdsb2JhbFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2xvYmFscy5nbG9iYWw7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZG9jdW1lbnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dsb2JhbHMuZG9jdW1lbnQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicHJvY2Vzc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2xvYmFscy5wcm9jZXNzO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbnNvbGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dsb2JhbHMuY29uc29sZTtcbiAgfVxufSk7XG5leHBvcnRzLmlzQnJvd3NlciA9IGV4cG9ydHMuVkVSU0lPTiA9IHZvaWQgMDtcblxudmFyIF9pc0Jyb3dzZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9lbnYvaXMtYnJvd3NlclwiKSk7XG5cbnZhciBfZ2xvYmFscyA9IHJlcXVpcmUoXCIuLi9lbnYvZ2xvYmFsc1wiKTtcblxudmFyIFZFUlNJT04gPSB0eXBlb2YgX19WRVJTSU9OX18gIT09ICd1bmRlZmluZWQnID8gX19WRVJTSU9OX18gOiAndW50cmFuc3BpbGVkIHNvdXJjZSc7XG5leHBvcnRzLlZFUlNJT04gPSBWRVJTSU9OO1xudmFyIGlzQnJvd3NlciA9ICgwLCBfaXNCcm93c2VyLmRlZmF1bHQpKCk7XG5leHBvcnRzLmlzQnJvd3NlciA9IGlzQnJvd3Nlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsb2JhbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBnZXRIaVJlc1RpbWVzdGFtcDtcblxudmFyIF9nbG9iYWxzID0gcmVxdWlyZShcIi4vZ2xvYmFsc1wiKTtcblxuZnVuY3Rpb24gZ2V0SGlSZXNUaW1lc3RhbXAoKSB7XG4gIHZhciB0aW1lc3RhbXA7XG5cbiAgaWYgKF9nbG9iYWxzLmlzQnJvd3NlciAmJiBfZ2xvYmFscy53aW5kb3cucGVyZm9ybWFuY2UpIHtcbiAgICB0aW1lc3RhbXAgPSBfZ2xvYmFscy53aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gIH0gZWxzZSBpZiAoX2dsb2JhbHMucHJvY2Vzcy5ocnRpbWUpIHtcbiAgICB2YXIgdGltZVBhcnRzID0gX2dsb2JhbHMucHJvY2Vzcy5ocnRpbWUoKTtcblxuICAgIHRpbWVzdGFtcCA9IHRpbWVQYXJ0c1swXSAqIDEwMDAgKyB0aW1lUGFydHNbMV0gLyAxZTY7XG4gIH0gZWxzZSB7XG4gICAgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgfVxuXG4gIHJldHVybiB0aW1lc3RhbXA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oaS1yZXMtdGltZXN0YW1wLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxuZnVuY3Rpb24gZ2V0U3RvcmFnZSh0eXBlKSB7XG4gIHRyeSB7XG4gICAgdmFyIHN0b3JhZ2UgPSB3aW5kb3dbdHlwZV07XG4gICAgdmFyIHggPSAnX19zdG9yYWdlX3Rlc3RfXyc7XG4gICAgc3RvcmFnZS5zZXRJdGVtKHgsIHgpO1xuICAgIHN0b3JhZ2UucmVtb3ZlSXRlbSh4KTtcbiAgICByZXR1cm4gc3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbnZhciBMb2NhbFN0b3JhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExvY2FsU3RvcmFnZShpZCwgZGVmYXVsdFNldHRpbmdzKSB7XG4gICAgdmFyIHR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICdzZXNzaW9uU3RvcmFnZSc7XG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazIuZGVmYXVsdCkodGhpcywgTG9jYWxTdG9yYWdlKTtcbiAgICB0aGlzLnN0b3JhZ2UgPSBnZXRTdG9yYWdlKHR5cGUpO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmNvbmZpZyA9IHt9O1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5jb25maWcsIGRlZmF1bHRTZXR0aW5ncyk7XG5cbiAgICB0aGlzLl9sb2FkQ29uZmlndXJhdGlvbigpO1xuICB9XG5cbiAgKDAsIF9jcmVhdGVDbGFzczIuZGVmYXVsdCkoTG9jYWxTdG9yYWdlLCBbe1xuICAgIGtleTogXCJnZXRDb25maWd1cmF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbmZpZ3VyYXRpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25maWc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldENvbmZpZ3VyYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uKSB7XG4gICAgICB0aGlzLmNvbmZpZyA9IHt9O1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlQ29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlQ29uZmlndXJhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5jb25maWcsIGNvbmZpZ3VyYXRpb24pO1xuXG4gICAgICBpZiAodGhpcy5zdG9yYWdlKSB7XG4gICAgICAgIHZhciBzZXJpYWxpemVkID0gSlNPTi5zdHJpbmdpZnkodGhpcy5jb25maWcpO1xuICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0SXRlbSh0aGlzLmlkLCBzZXJpYWxpemVkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9sb2FkQ29uZmlndXJhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9hZENvbmZpZ3VyYXRpb24oKSB7XG4gICAgICB2YXIgY29uZmlndXJhdGlvbiA9IHt9O1xuXG4gICAgICBpZiAodGhpcy5zdG9yYWdlKSB7XG4gICAgICAgIHZhciBzZXJpYWxpemVkQ29uZmlndXJhdGlvbiA9IHRoaXMuc3RvcmFnZS5nZXRJdGVtKHRoaXMuaWQpO1xuICAgICAgICBjb25maWd1cmF0aW9uID0gc2VyaWFsaXplZENvbmZpZ3VyYXRpb24gPyBKU09OLnBhcnNlKHNlcmlhbGl6ZWRDb25maWd1cmF0aW9uKSA6IHt9O1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMuY29uZmlnLCBjb25maWd1cmF0aW9uKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTG9jYWxTdG9yYWdlO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBMb2NhbFN0b3JhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbC1zdG9yYWdlLmpzLm1hcCIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBydW50aW1lID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIG9ialtrZXldO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gSUUgOCBoYXMgYSBicm9rZW4gT2JqZWN0LmRlZmluZVByb3BlcnR5IHRoYXQgb25seSB3b3JrcyBvbiBET00gb2JqZWN0cy5cbiAgICBkZWZpbmUoe30sIFwiXCIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZWZpbmUgPSBmdW5jdGlvbihvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBkZWZpbmUoSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIGRlZmluZShHcCwgXCJjb25zdHJ1Y3RvclwiLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gIGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCBHZW5lcmF0b3JGdW5jdGlvbik7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKFxuICAgIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLFxuICAgIHRvU3RyaW5nVGFnU3ltYm9sLFxuICAgIFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICApO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIGRlZmluZShwcm90b3R5cGUsIG1ldGhvZCwgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGRlZmluZShnZW5GdW4sIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgZGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlLCBhc3luY0l0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7XG4gICAgaWYgKFByb21pc2VJbXBsID09PSB2b2lkIDApIFByb21pc2VJbXBsID0gUHJvbWlzZTtcblxuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSxcbiAgICAgIFByb21pc2VJbXBsXG4gICAgKTtcblxuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAvLyBOb3RlOiBbXCJyZXR1cm5cIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKTtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIGRlZmluZShHcCwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KTtcblxuICBkZWZpbmUoR3AsIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9XG4pKTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIGluIG1vZGVybiBlbmdpbmVzXG4gIC8vIHdlIGNhbiBleHBsaWNpdGx5IGFjY2VzcyBnbG9iYWxUaGlzLiBJbiBvbGRlciBlbmdpbmVzIHdlIGNhbiBlc2NhcGVcbiAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJvYmplY3RcIikge1xuICAgIGdsb2JhbFRoaXMucmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbiAgfSBlbHNlIHtcbiAgICBGdW5jdGlvbihcInJcIiwgXCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByXCIpKHJ1bnRpbWUpO1xuICB9XG59XG4iXX0=
